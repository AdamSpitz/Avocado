if (! window.hasOwnProperty('avocado')) { window.avocado = {}; }
avocado.isLoadingStatically = true;

window.bootstrapTheModuleSystem = function () {

// The bootstrap module is kind of a mess. Try to minimize it.

if (! window.hasOwnProperty('avocado')) { window.avocado = {}; }

Object.basicCreate = function(parent) {
  var constr = function BasicConstructor() {};
  constr.prototype = parent;
  return new constr();
};

Object.create = function(parent) {
  var anno = annotator.annotationOf(parent);
  var constr = anno.constructorForMakingChildrenOf(parent);
  return new constr();
};

if (typeof Object.newChildOf !== 'function') {
  Object.newChildOf = function(parent) {
    var child = Object.create(parent);
    if (child.initialize) {
      var args;
      if (typeof($A) !== 'undefined') {
        args = $A(arguments);
        args.shift();
      } else {
        args = [];
        for (var i = 1, n = arguments.length; i < n; ++i) { args.push(arguments[i]); }
      }
      child.initialize.apply(child, args);
    }
    return child;
  };
}

if (typeof Object.shallowCopy !== 'function') {
  Object.shallowCopy = function(o) {
    var c = Object.create(o['__proto__']);
    if (typeof(o.hasOwnProperty) !== 'function') { throw new Error("Cannot shallowCopy this object because it has no hasOwnProperty function."); }
    for (var property in o) {
      if (o.hasOwnProperty(property) && property !== '__annotation__') {
        c[property] = o[property];
      }
    }
    return c;
  };
}

Object.inheritsFrom = function(ancestor, child) {
  // Does JS have a built-in way to check this? Similar to instanceof, but for checking the
  // prototype chain directly rather than assuming we have access to the constructor object?
  var p = child;
  while (p) {
    if (p === ancestor) { return true; }
    p = p['__proto__'];
  }
  return false;
};


// Gotta overwrite Prototype's Object.extend, or bad things happen with annotations.
Object.extend = function extend(destination, source) {
  for (var property in source) {
    if (property !== '__annotation__') {
      destination[property] = source[property];
    }
  }
  return destination;
};


Object.extendWithJustDirectPropertiesOf = function extendWithJustDirectPropertiesOf(destination, source) {
  if (typeof(source.hasOwnProperty) !== 'function') { throw new Error("extendWithJustDirectPropertiesOf: source has no hasOwnProperty function"); }
  for (var property in source) {
    if (source.hasOwnProperty(property) && property !== '__annotation__') {
      destination[property] = source[property];
    }
  }
  return destination;
};


var annotator = {
  objectAnnotationPrototype: {
    _slotAnnoPrefix: 'anno_',
    
    annotationNameForSlotNamed: function(name) {
      // can't just use the name because it leads to conflicts with stuff inherited from Object.prototype
      return this._slotAnnoPrefix + name;
    },

    asSlotAnnotation: function(slotAnno, slotName) {
      if (slotAnno['__proto__'] !== avocado.annotator.slotAnnotationPrototype) {
        slotAnno = Object.extendWithJustDirectPropertiesOf(Object.create(avocado.annotator.slotAnnotationPrototype), slotAnno);

        var catParts = slotAnno.category;
        if (catParts) {
          delete slotAnno.category;
          this.setCategoryPartsForSlotNamed(slotName, catParts, slotAnno);
        }
      }

      return slotAnno;
    },

    existingSlotAnnotation: function(name) {
      return this[this.annotationNameForSlotNamed(name)];
    },
    
    eachSlotAnnotation: function(f) {
      var prefixLength = this._slotAnnoPrefix.length;
      for (var n in this) {
        if (this.hasOwnProperty(n)) {
          var slotName = n.substr(prefixLength);
          if (n.substr(0, prefixLength) === this._slotAnnoPrefix) {
            f(n.substr(prefixLength), this[n]);
          }
        }
      }
    },

    setSlotAnnotation: function(name, slotAnno) {
      if (slotAnno) {
        var realSlotAnno = this.asSlotAnnotation(slotAnno, name);
        this[this.annotationNameForSlotNamed(name)] = realSlotAnno;
        return realSlotAnno;
      } else {
        this.removeSlotAnnotation(name);
        return undefined;
      }
    },

    slotAnnotation: function(name) {
      return this.existingSlotAnnotation(name) || this.setSlotAnnotation(name, {});
    },

    removeSlotAnnotation: function(name) {
      delete this[this.annotationNameForSlotNamed(name)];
    },
    
    getComment: function() {
      return this.comment;
    },
    
    setComment: function(c) {
      this.comment = c;
    },

    constructorTemplate: "(function() { return function CONSTRUCTOR_FUNCTION() {}; })()",

    constructorForMakingChildrenOf: function(parent, explicitlySpecifiedName) {
      return this.constructorForMakingChildrenOfMyObject || this.createConstructorForMakingChildrenOf(parent, explicitlySpecifiedName);
    },

    createConstructorForMakingChildrenOf: function(parent, explicitlySpecifiedName) {
      var name;
      if (explicitlySpecifiedName) {
        name = explicitlySpecifiedName;
      } else {
        var cs = this.explicitlySpecifiedCreatorSlot();
        if (cs) { name = cs.name; }
        if (!name || name === '__proto__') { name = 'something'; }
      }
      var constr = eval(this.constructorTemplate.replace(/CONSTRUCTOR_FUNCTION/g, name));
      constr.prototype = parent;
      this.constructorForMakingChildrenOfMyObject = constr;
      return constr;
    },
    
    isRedundant: function (objectThatIAnnotate) {
      for (var p in this) {
        if (this.hasOwnProperty(p)){
          if (p !== 'creatorSlot') { return false; }
          var cs = this.creatorSlot;
          var implicitCS = avocado.annotator.creatorSlotDeterminableFromTheObjectItself(objectThatIAnnotate);
          if (! implicitCS) { return false; }
          if (cs.name !== implicitCS.name || cs.holder !== implicitCS.holder) { return false; }
        }
      }
      return true;
    },
    
    deleteIfRedundant: function (objectThatIAnnotate) {
      if (objectThatIAnnotate.__annotation__ === this && this.isRedundant(objectThatIAnnotate)) {
        delete objectThatIAnnotate.__annotation__;
      }
    },
    
    explicitlySpecifiedCreatorSlot: function () {
      return this.hasOwnProperty('creatorSlot') ? this.creatorSlot : null;
    },
    
    setCreatorSlot: function(name, holder) {
      if (name !== undefined && holder !== undefined) {
        this.creatorSlot = Object.newChildOf(avocado.annotator.slotSpecifierPrototype, name, holder);
      } else {
        delete this.creatorSlot;
      }
      
      delete this.constructorForMakingChildrenOfMyObject; // name has changed, so make a new constructor
      
      // delete this.possibleCreatorSlots; // don't need these anymore // aaa - no, I disagree now, leave them there so people can easily change it back -- Adam, Oct. 2010
    },

    addPossibleCreatorSlot: function(name, holder) {
      // if (this.explicitlySpecifiedCreatorSlot()) { return; } // no point // aaa - no, I disagree now, leave them there so people can easily change it back -- Adam, Oct. 2010
      
      var cs = Object.newChildOf(avocado.annotator.slotSpecifierPrototype, name, holder);
      
      // optimization: don't bother creating an array until we have more than one
      if (! this.possibleCreatorSlots) {
        this.possibleCreatorSlots = cs;
      } else {
        var slots = this.possibleCreatorSlots = this.arrayOfPossibleCreatorSlots();

        // Don't add duplicates.
        // aaa - Quadratic, blecch. Use a hash table? but hash_table.js isn't loaded yet. Oh, well - might not matter if I keep the list small.
        for (var i = 0, n = slots.length; i < n; ++i) {
          var s = slots[i];
          if (name === s.name && holder === s.holder) { return; }
        }

        slots.push(cs);
      }
    },

    numberOfPossibleCreatorSlots: function () {
      var ss = this.possibleCreatorSlots;
      if (!ss) { return 0; }
      if (! (ss instanceof Array)) { return 1; }
      return ss.length;
    },
  
    onlyPossibleCreatorSlot: function () {
      var ss = this.possibleCreatorSlots;
      if (!ss) { return null; }
      if (! (ss instanceof Array)) { return ss; }
      return ss && ss.length === 1 ? ss[0] : null;
    },

    theCreatorSlot: function () {
      // aaa - I think I should just make this call probableCreatorSlot
      return this.explicitlySpecifiedCreatorSlot() || this.onlyPossibleCreatorSlot();
    },

    probableCreatorSlot: function () {
      var cs = this.explicitlySpecifiedCreatorSlot();
      if (cs) { return cs; }
      var count = this.numberOfPossibleCreatorSlots();
      if (count === 0) { return null;     }
      if (count === 1) { return this.onlyPossibleCreatorSlot(); }
      var slots = this.arrayOfPossibleCreatorSlots();
      var shortest = null;
      var shortestLength;
      for (var i = 0, n = slots.length; i < n; ++i) {
        var s = slots[i];
        var sLength = avocado.annotator.creatorChainLength(s.holder);
        if (typeof(sLength) === 'number') {
          if (!shortest || sLength < shortestLength) {
            // This one's shorter, so probably better; use it instead.
            shortest = s;
            shortestLength = sLength;
          }
        }
      }
      return shortest;
    },
    
    arrayOfPossibleCreatorSlots: function () {
      var ss = this.possibleCreatorSlots;
      if (!ss) { return []; }
      if (! (ss instanceof Array)) { return [ss]; }
      return ss;
    },
    
    copyDownSlotsFromAllCopyDownParents: function(obj) {
      if (this.copyDownParents) {
        for (var i = 0, n = this.copyDownParents.length; i < n; i += 1) {
          var cdp = this.copyDownParents[i];
          if (typeof(cdp.parent) === 'undefined') {
            throw new Error("Each element of the array must contain a 'parent' slot pointing to the desired copy-down parent; e.g. [{parent: Enumerable}]");
          }
          this.copyDownSlots(obj, cdp.parent, cdp.slotsToOmit);
        }
      }
    },
    
    copyDownSlots: function(dst, src, rawSlotsToOmit) {
      var slotsToOmit = annotator.adjustSlotsToOmit(rawSlotsToOmit);
      for (var name in src) {
        if (src.hasOwnProperty(name)) {
          if (! slotsToOmit.include(name)) {
            dst[name] = src[name];
            
            // Copy down the category (and maybe other stuff?).
            var srcAnno = avocado.annotator.existingAnnotationOf(src);
            if (srcAnno) {
              var srcSlotAnno = srcAnno.existingSlotAnnotation(name);
              if (srcSlotAnno && srcSlotAnno.categoryParts()) {
                var dstSlotAnno = this.setSlotAnnotation(name, {});
                this.setCategoryPartsForSlotNamed(name, srcSlotAnno.categoryParts(), dstSlotAnno);
        	      // aaa - Make sure the JSQuiche server gets updated?
        	      // Do we store each slot's category separately, or store
        	      // the fact that there's a copy-down parent?
              }
            }
          }
        }
      }
    },
    
    getCategoryCache: function(catParts) {
      var c = this.categoryCache;
      if (!c) { c = this.categoryCache = Object.newChildOf(avocado.annotator.categoryCachePrototype); }
      if (catParts) {
        for (var i = 0, n = catParts.length; i < n; ++i) {
          c = c.getOrCreateSubcategory(catParts[i]);
        }
      }
      return c;
    },
    
    setCategoryPartsForSlotNamed: function(slotName, catParts, alreadyGotTheSlotAnno) {
      var slotAnno = alreadyGotTheSlotAnno || this.slotAnnotation(slotName); // just an optimization, allow it to be passed in if the caller already has it
      
      var oldCatCache = slotAnno.category;
      if (oldCatCache) { oldCatCache.removeSlotName(slotName); }
      
      if (catParts) {
        // Sometimes we screw up when hacking on the text files and accidentally write a category as
        // a string instead of an array of strings.
        if (! (catParts instanceof Array)) { catParts = [catParts]; }
        
        var c = this.getCategoryCache(catParts);
        slotAnno.category = c;
        c.addSlotName(slotName);
      } else {
        delete slotAnno.category;
      }
    },

    categorize: function(catParts, slotNames) {
      // Just a shortcut to let us categorize a bunch of slots at a time.
      for (var i = 0, n = slotNames.length; i < n; ++i) {
	      var slotName = slotNames[i];
	      this.setCategoryPartsForSlotNamed(slotName, catParts);
      }
    },
  
    asRawDataObject: function () {
      var raw = {};
      if (this.comment        ) { raw.comment         = this.comment;         }
      if (this.copyDownParents) { raw.copyDownParents = this.copyDownParents; }
      return raw;
    },

    copy: function () {
      var c = avocado.annotator.asObjectAnnotation(this.asRawDataObject());
      this.eachSlotAnnotation(function(slotName, slotAnno) {
        c.setSlotAnnotation(slotName, slotAnno.asRawDataObject());
      });
      return c;
    }
  },

  slotSpecifierPrototype: {
    initialize: function(name, holder) {
      this.name = name;
      this.holder = holder;
    },
    
    contentsObject: function() {
      return this.holder[this.name];
    }
  },

  slotAnnotationPrototype: {
    categoryParts: function() {
      var c = this.category;
      if (!c) { return null; }
      return c.parts();
    },
    
    getModuleAssignedToMeExplicitly: function() {
      return this.module;
    },
    
    setModule: function(m) {
      this.module = m;
    },
    
    forgetModule: function() {
      delete this.module;
    },
    
    getComment: function() {
      return this.comment;
    },
    
    setComment: function(c) {
      this.comment = c;
    },
    
    initializationExpression: function() {
      return this.initializeTo;
    },
    
    setInitializationExpression: function(e) {
      this.initializeTo = e;
    },
    
    equals: function(other) {
      for (var n in this) {
        if (this.hasOwnProperty(n)) {
          if (this[n] !== other[n]) { return false; }
        }
      }
      return true;
    },
    
    hashCode: function () {
      var catParts = this.categoryParts();
      return catParts ? catParts.join(',') : 'no category';
    },

    asRawDataObject: function () {
      var raw = {};
      var catParts = this.categoryParts();
      if (catParts          && catParts.length > 0) { raw.category     = catParts;                        }
      if (this.comment                            ) { raw.comment      = this.getComment();               }
      if (this.initializeTo                       ) { raw.initializeTo = this.initializationExpression(); }
      return raw;
    }
  },
  
  categoryCachePrototype: {
    initialize: function(n, supercat) {
      
      // The OLD way of doing categories was that they were just in each slot annotation. This
      // had two problems:
      //   - A category didn't really "exist" until it had at least one slot in it. Which was
      //     annoying, because the natural way of creating categories in the UI is for the user
      //     to say "add category" and *then* add slots to it, so the category would kinda be
      //     in this weird limbo until the slot was actually added. It was awkward to hack the
      //     UI to make it remember to keep the newly-created category around.
      //   - It was slow for really big objects (like "window"), because to find the contents
      //     of a category, the UI would have to search through every slot in the object.
      //
      // So now, an object annotation keeps these "category cache" objects around (in addition
      // to having them in the slot annotations). The category's cache remembers which slots
      // are in the category.
      // 
      // Unfortunately, there's no way to catch the creation of new slots by code like "obj.x = 3",
      // so we can't guarantee that this data structure will be up to date. That's why we think
      // of it as a cache rather than a guaranteed-up-to-date parallel data structure. And I
      // think that when doing an update, we just replace the whole structure, which means that
      // we can't have the slots keep pointers to their category caches... which is fine, this
      // isn't meant to solve that problem.
      //
      // For now, I think the mirror morph's refreshContent method refreshes this cache
      // whenever it runs (so once every 8 seconds, or whatever it is). But maybe it'd make
      // sense to keep a timestamp and check it whenever someone accesses the cache, so that
      // it'll still keep getting updated even if there's no mirror morph on the screen.
      
      
      this._lastPart = n;
      this._supercategory = supercat;
    },
    
    parts: function() {
      var ps = [];
      var c = this;
      while (c && typeof(c._lastPart) !== 'undefined') {
        ps.unshift(c._lastPart);
        c = c._supercategory;
      }
      return ps;
    },
    
    subcategories: function() {
      if (! this._subcategories) { this._subcategories = {}; }
      return this._subcategories;
    },
    
    getOrCreateSubcategory: function(name) {
      var subcats = this.subcategories();
      var c = subcats[name];
      if (!c) {
        c = subcats[name] = Object.newChildOf(avocado.annotator.categoryCachePrototype, name, this);
      }
      return c;
    },
    
    removeSubcategory: function(name) {
      if (! this._subcategories) { return; }
      delete this._subcategories[name];
    },
    
    removeMe: function() {
      if (! this._supercategory) { return; }
      this._supercategory.removeSubcategory(this._lastPart);
    },
    
    eachSubcategoryName: function(f) {
      for (var name in this._subcategories) {
        if (this._subcategories.hasOwnProperty(name)) {
          f(name);
        }
      }
    },
    
    addSlotName: function(name) {
      if (! this._slotNames) { this._slotNames = {}; }
      this._slotNames[name] = true;
    },
    
    removeSlotName: function(name) {
      if (! this._slotNames) { return; }
      delete this._slotNames[name];
    },
    
    eachSlotName: function(f) {
      for (var name in this._slotNames) {
        if (this._slotNames.hasOwnProperty(name)) {
          f(name);
        }
      }
    }
  },

  _nextOID: 0,

  oidOf: function(o) {
    // aaa - We're not gonna be able to transport identityDictionaries (because we're not
    // actually saving the OID, we're recreating it each time we load the object into the image).
    // Not a problem for now, but keep it in mind.
    var a = this.annotationOf(o);
    if (a.hasOwnProperty('oid')) { return a.oid; }
    return a.oid = this._nextOID++;
  },

  annotationOf: function(o) {
    var a = this.existingAnnotationOf(o);
    if (a !== null) { return a; }
    a = this.newObjectAnnotation(o);
    o.__annotation__ = a;
    return a;
  },

  existingAnnotationOf: function(o) {
    var a = this.actualExistingAnnotationOf(o);
    if (a) { return a; }
    
    // If there's an implicit creator slot, gotta treat the annotation as if it already exists.
    // aaa - Though we should optimize that in the mirror code that asks for a creator slot - can
    // just return the creator slot straight, without creating this annotation object. Though
    // with decent GC this might not matter. Don't worry about it yet.
    var cs = this.creatorSlotDeterminableFromTheObjectItself(o);
    if (cs) {
      return o.__annotation__ = this.newObjectAnnotation(o);
    }
    
    return null;
  },

  actualExistingAnnotationOf: function(o) {
    if (typeof(o.hasOwnProperty) === 'function' && o.hasOwnProperty('__annotation__')) { return o.__annotation__; }
    
    // HACK: In JavaScript, adding attributes to Object.prototype and stuff like that
    // is a bad idea, because people use for..in loops to enumerate their attributes.
    // So we'll keep a special array to hold their annotations.
    if (o === Object.prototype || o === Array.prototype) { return this.specialAnnotationOf(o); }
    
    return null;
  },

  _annotationsForObjectsThatShouldNotHaveAttributesAddedToThem: [],

  specialAnnotationOf: function(o) {
    var specialAnnoRecords = this._annotationsForObjectsThatShouldNotHaveAttributesAddedToThem;
    for (var i = 0, n = specialAnnoRecords.length; i < n; ++i) {
      var r = specialAnnoRecords[i];
      if (r.object === o) { return r.annotation; }
    }
    
    var a = this.newObjectAnnotation(o);
    specialAnnoRecords.push({object: o, annotation: a});
    return a;
  },

  newObjectAnnotation: function(o) {
    var a = Object.create(this.objectAnnotationPrototype);
    
    // Small hack to enable an optimization.
    var cs = this.creatorSlotDeterminableFromTheObjectItself(o);
    if (cs) { a.creatorSlot = cs; }
    
    return a;
  },

  asObjectAnnotation: function(anno) {
    // aaa - In browsers that don't allow you to set __proto__, create a new
    // object and copy over the slots.
    // aaa - OK, try it that way, not just for browsers that can't set __proto__,
    // but because using Object.create makes Chrome memory profiles show up nicer.
    // anno['__proto__'] = this.objectAnnotationPrototype;
    // return anno;
    if (anno['__proto__'] === this.objectAnnotationPrototype) { return anno; }
    return Object.extendWithJustDirectPropertiesOf(Object.create(this.objectAnnotationPrototype), anno);
  },

  loadObjectAnnotation: function(o, rawAnno, creatorSlotName, creatorSlotHolder) {
    var a;
    
    if (creatorSlotName && creatorSlotHolder) {
      var implicitCS = this.creatorSlotDeterminableFromTheObjectItself(o);
      if (!a && implicitCS && implicitCS.name === creatorSlotName && implicitCS.holder === creatorSlotHolder) {
        // no need to create the annotation just for this
      } else {
        a = a || annotator.annotationOf(o);
        a.setCreatorSlot(creatorSlotName, creatorSlotHolder);
      }
    }
    
    if (rawAnno) {
      for (var property in rawAnno) {
        if (rawAnno.hasOwnProperty(property) && property !== '__annotation__') {
          a = a || annotator.annotationOf(o);
          a[property] = rawAnno[property];
        }
      }

      a = a || annotator.actualExistingAnnotationOf(o);
      if (a) {
        a.copyDownSlotsFromAllCopyDownParents(o);
      }
    }
    
    return a;
  },

  existingSlotAnnotation: function(holder, name) {
    var anno = this.existingAnnotationOf(holder);
    if (!anno) { return null; }
    return anno.existingSlotAnnotation(name);
  },
  
  moduleOfAnyCreatorInChainFor: function(o) {
    var p = o;
    while (true) {
      var cs = this.theCreatorSlotOf(p);
      if (!cs) { return null; }
      var slotAnno = this.existingSlotAnnotation(cs.holder, cs.name);
      if (slotAnno) {
        var m = slotAnno.getModuleAssignedToMeExplicitly();
        if (m) { return m; }
      }
      p = cs.holder;
    }
  },
  
  getModuleAssignedExplicitlyOrImplicitlyTo: function(slotAnno, holder) {
    return (slotAnno && slotAnno.getModuleAssignedToMeExplicitly()) || this.moduleOfAnyCreatorInChainFor(holder);
  },
  
  setModuleIfNecessary: function(holder, slotName, desiredModule) {
    var implicitModule = this.moduleOfAnyCreatorInChainFor(holder);
    if ((implicitModule || null) === (desiredModule || null)) {
      // Optimization: Avoid creating the slot annotation if it's not necessary.
      var holderAnno = this.existingAnnotationOf(holder);
      var slotAnno = holderAnno && holderAnno.existingSlotAnnotation(slotName);
      if (slotAnno) { slotAnno.forgetModule(); }
    } else {
      this.annotationOf(holder).slotAnnotation(slotName).setModule(desiredModule);
      if (desiredModule) { desiredModule.slotCollection().add(holder, slotName); }
      
      var shouldLogModules = false;
      if (shouldLogModules) {
        var chain = this.creatorSlotChainOf(holder);
        chain.push(slotName);
        console.log("Setting module of " + chain.join(".") + " to " + desiredModule._name);
      }
    }
  },
  
  isEmptyObject: function(o) {
    if (typeof(o) !== 'object') { return false; }
    try { // workaround for Firefox problem
      if (o['__proto__'] !== Object.prototype) { return false; }
    } catch (ex) {
      return false;
    }
    if (typeof(o.hasOwnProperty) !== 'function') { return false; }
    for (var n in o) {
      if (o.hasOwnProperty(n)) {
        return false;
      }
    }
    return true;
  },

  LK_slotNamesAttachedToMethods: ['declaredClass', 'methodName', 'displayName', '_creatorSlotHolder'],
  LK_slotNamesUsedForMakingSuperWork: ['valueOf', 'toString', 'originalFunction'],
  
  isSimpleMethod: function(o) {
    if (typeof(o) !== 'function') { return false; }

    var hasSuper = o.argumentNames && o.argumentNames()[0] === '$super';

    if (typeof(o.hasOwnProperty) !== 'function') { return false; }
    for (var n in o) {
      if (o.hasOwnProperty(n) && n !== '__annotation__') {
        if (            this.LK_slotNamesAttachedToMethods.include(n)) { continue; }
        if (hasSuper && this.LK_slotNamesUsedForMakingSuperWork .include(n)) { continue; }
        if (n === 'prototype' && this.isEmptyObject(o[n])) { continue; }
        return false;
      }
    }
    return true;
  },
  
  isMagicSlotNameOnFunction: function(o, n) {
    if (typeof(o) !== 'function') { return false; }
    if (this.LK_slotNamesAttachedToMethods.include(n)) { return true; }
    var hasSuper = o.argumentNames && o.argumentNames().first() === '$super';
    if (hasSuper && this.LK_slotNamesUsedForMakingSuperWork.include(n)) { return true; }
    return false;
  },
  
  creatorSlotDeterminableFromTheObjectItself: function(o) {
    // Some very common kinds of objects have enough information in them to let us know the creator
    // slot without being explicitly told.
    
    // Functions already have a displayName (or should), and we can set _creatorSlotHolder ourselves.
    if (typeof(o) === 'function' && typeof(o.displayName) === 'string' && o._creatorSlotHolder) {
      return Object.newChildOf(avocado.annotator.slotSpecifierPrototype, o.displayName, o._creatorSlotHolder);
    }
    
    // Function (constructor) prototypes.
    if (this.isEmptyObject(o)) {
      var c = o.constructor;
      if (c && o === c.prototype) {
        return Object.newChildOf(avocado.annotator.slotSpecifierPrototype, 'prototype', c);
      }
    }
    
    return null;
  },

  theCreatorSlotOf: function(o) {
    if (!o) { return null; }
    var cs = this.creatorSlotDeterminableFromTheObjectItself(o);
    if (cs) { return cs; }
    var a = this.existingAnnotationOf(o);
    if (!a) { return null; }
    return a.probableCreatorSlot();
  },
  
  creatorSlotChainOf: function(o) {
    var chain = [];
    var h = o;
    while (true) {
      var cs = this.theCreatorSlotOf(h);
      if (! cs) { break; }
      chain.unshift(cs.name);
      h = cs.holder;
    }
    return chain;
  },

  creatorChainLength: function (o) {
    var len = 0;
    while (o !== window) {
      var anno = this.existingAnnotationOf(o);
      if (!anno) { return null; }
      var cs = anno.theCreatorSlot(); // aaa wrong - should be probableCreatorSlot, I think, but gotta avoid infinite loop
      if (!cs) { return null; }
      len += 1;
      o = cs.holder;
    }
    return len;
  },
  
  canonicalCategoryParts: [],
  
  canonicalizeCategoryParts: function(nonCanonical) {
    var len = nonCanonical.length;
    for (var i = 0, n = this.canonicalCategoryParts.length; i < n; ++i) {
      var canonical = this.canonicalCategoryParts[i];
      if (this.areCategoryPartsEqual(canonical, nonCanonical)) { return canonical; }
    }
    this.canonicalCategoryParts.push(nonCanonical);
    return nonCanonical;
  },
  
  areCategoryPartsEqual: function(catParts1, catParts2) {
    var len = catParts1.length;
    if (catParts2.length !== len) { return false; }
    for (var i = 0; i < len; ++i) {
      var p1 = catParts1[i];
      var p2 = catParts2[i];
      if (p1 !== p2) { return false; }
    }
    return true;
  },
  
  adjustSlotsToOmit: function(rawSlotsToOmit) {
    var slotsToOmit = rawSlotsToOmit || [];
    if (typeof slotsToOmit === 'string') {
      slotsToOmit = slotsToOmit.split(" ");
    }
    if (! slotsToOmit.include('__annotation__')) {
      slotsToOmit.push('__annotation__');
    }
    return slotsToOmit;
  }
};

avocado.annotator = annotator;

// Need to use basicCreate to create the annotations for the annotation prototypes; otherwise we get an infinite recursion.
annotator.objectAnnotationPrototype.__annotation__ = Object.basicCreate(annotator.objectAnnotationPrototype);

annotator.annotationOf(avocado).setCreatorSlot('avocado', window);
annotator.annotationOf(window).setSlotAnnotation('avocado', {category: ['avocado']});

annotator.annotationOf(avocado.annotator).setCreatorSlot('annotator', avocado);
annotator.annotationOf(avocado).setSlotAnnotation('annotator', {category: ['annotations']});
annotator.annotationOf(annotator.objectAnnotationPrototype).setCreatorSlot('objectAnnotationPrototype', annotator);
annotator.annotationOf(annotator.slotAnnotationPrototype).setCreatorSlot('slotAnnotationPrototype', annotator);
annotator.annotationOf(annotator.slotSpecifierPrototype).setCreatorSlot('slotSpecifierPrototype', annotator);
annotator.annotationOf(annotator.categoryCachePrototype).setCreatorSlot('categoryCachePrototype', annotator);

avocado.javascript = {};
annotator.annotationOf(avocado.javascript).setCreatorSlot('javascript', avocado);
annotator.annotationOf(avocado).setSlotAnnotation('javascript', {category: ['javascript']});

avocado.javascript.reservedWords = {'abstract': true, 'boolean': true, 'break': true, 'byte': true, 'case': true, 'catch': true, 'char': true, 'class': true, 'const': true, 'continue': true, 'debugger': true, 'default': true, 'delete': true, 'do': true, 'double': true, 'else': true, 'enum': true, 'export': true, 'extends': true, 'false': true, 'final': true, 'finally': true, 'float': true, 'for': true, 'function': true, 'goto': true, 'if': true, 'implements': true, 'import': true, 'in': true, 'instanceof': true, 'int': true, 'interface': true, 'long': true, 'native': true, 'new': true, 'null': true, 'package': true, 'private': true, 'protected': true, 'public': true, 'return': true, 'short': true, 'static': true, 'super': true, 'switch': true, 'synchronized': true, 'this': true, 'throw': true, 'throws': true, 'transient': true, 'true': true, 'try': true, 'typeof': true, 'var': true, 'volatile': true, 'void': true, 'while': true, 'with': true};

// aaa - Copied from Base.js. Just a hack to make $super work. Not really sure
// what the right solution is in the long run - how do we make this work with
// both prototype-style inheritance and class-style inheritance?
avocado.makeSuperWork = function(holder, property, contents) {
  var value = contents;
  var hasSuperArgument = typeof(value) === 'function' && value.argumentNames && value.argumentNames()[0] === "$super";
  if (hasSuperArgument) {
    var superclass = holder.constructor && this === holder.constructor.prototype && holder.constructor.superclass;
    var ancestor = superclass ? superclass.prototype : holder['__proto__']; // using [] to fool JSLint
    if (ancestor) {
      (function() { // wrapped in a method to save the value of 'method' for advice
        var method = value;
        var advice = (function(m) {
          return function callSuper() {
            return ancestor[m].apply(this, arguments);
          };
        })(property);
        advice.methodName = "$super:" + (superclass ? superclass.type + "." : "") + property;

        value = advice.wrap(method);
        value.valueOf = function() { return method; };
        value.toString = function() { return method.toString(); };
        value.originalFunction = method;
      })();
    } else {
      throw new Error("cannot makeSuperWork, there is no ancestor");
    }
  } else {
    // fine, nothing to do
  }
  return value;
};
annotator.annotationOf(avocado.makeSuperWork).setCreatorSlot('makeSuperWork', avocado);
annotator.annotationOf(avocado).setSlotAnnotation('makeSuperWork', {category: ['inheritance']});

// Seems like Chrome doesn't actually enumerate the "prototype" slot.
// This is just a simple test to see.
(function() {
  function SomeConstructor() {}
  SomeConstructor.prototype.someAttribute = 42;
  avocado.javascript.prototypeAttributeIsEnumerable = false;
  for (var name in SomeConstructor) {
    if (SomeConstructor.hasOwnProperty(name)) {
      if (name === 'prototype') {
        avocado.javascript.prototypeAttributeIsEnumerable = true;
      }
    }
  }
})();


avocado.callbackWaiter = {
  on: function(functionThatYieldsCallbacks, functionToRunWhenDone, name) {
    return Object.newChildOf(this, functionToRunWhenDone, name).yieldCallbacks(functionThatYieldsCallbacks);
  },
  
  initialize: function(functionToRunWhenDone, name) {
    this._name = name;
    this._functionToRunWhenDone = functionToRunWhenDone;
    this._callbacks = [];
    this._numberOfCallsExpected = 0;
    this._numberCalledSoFar = 0;
    this._doneYieldingCallbacks = false;
    this._alreadyDone = false;
  },
  
  yieldCallbacks: function(functionThatYieldsCallbacks) {
    var thisWaiter = this;
    functionThatYieldsCallbacks(function() { return thisWaiter.createCallback(); });
    this._doneYieldingCallbacks = true;
    if (! this._alreadyDone) { this.checkWhetherDone(); }
  },
  
  checkWhetherDone: function() {
    if (this._alreadyDone) {
      throw "Called a callback again after we're already done.";
    }

    if (! this._doneYieldingCallbacks) { return; }

    if (this._numberCalledSoFar >= this._numberOfCallsExpected) {
      this._alreadyDone = true;
      if (this._functionToRunWhenDone) { this._functionToRunWhenDone(); }
    }
  },
  
  createCallback: function() {
    this._numberOfCallsExpected += 1;
    var thisWaiter = this;
    var callback = function() {
      if (callback.alreadyCalled) { throw new Error("Wait a minute, this one was already called!"); }
      callback.alreadyCalled = true;
      thisWaiter._numberCalledSoFar += 1;
      thisWaiter.checkWhetherDone();
    };
    this._callbacks.push(callback);
    return callback;
  }
};
annotator.annotationOf(avocado.callbackWaiter).setCreatorSlot('callbackWaiter', avocado);
annotator.annotationOf(avocado).setSlotAnnotation('callbackWaiter', {category: ['callbacks']});

window.modules = {};
annotator.annotationOf(modules).setCreatorSlot('modules', window);
annotator.annotationOf(window).setSlotAnnotation('modules', {category: ['avocado']});

if (! avocado.hasOwnProperty('transporter')) { avocado.transporter = {}; }
annotator.annotationOf(avocado.transporter).setCreatorSlot('transporter', avocado);
annotator.annotationOf(avocado).setSlotAnnotation('transporter', {category: ['transporter']});

avocado.transporter.loadedURLs = {};
annotator.annotationOf(avocado.transporter).slotAnnotation('loadedURLs').setInitializationExpression("{}");

avocado.transporter.loadOrder = [];

avocado.transporter.shouldLog = false;

avocado.transporter.module = {};
annotator.annotationOf(avocado.transporter.module).setCreatorSlot('module', avocado.transporter);

avocado.transporter.module.version = {};
annotator.annotationOf(avocado.transporter.module.version).setCreatorSlot('version', avocado.transporter.module);

avocado.transporter.module.cache = {};
annotator.annotationOf(avocado.transporter.module).slotAnnotation('cache').setInitializationExpression("{}");

avocado.transporter.module.onLoadCallbacks = {};
annotator.annotationOf(avocado.transporter.module).slotAnnotation('onLoadCallbacks').setInitializationExpression("{}");

avocado.transporter.slotCollection = {};
annotator.annotationOf(avocado.transporter.slotCollection).setCreatorSlot('slotCollection', avocado.transporter);

avocado.transporter.slotCollection.initialize = function(shouldIncludeSubObjectsOfCreatorSlot) {
  this._explicitlyIncluded = [];
};

avocado.transporter.slotCollection.add = function(holder, name) {
  this._explicitlyIncluded.push(Object.newChildOf(avocado.annotator.slotSpecifierPrototype, name, holder));
};

avocado.transporter.module.named = function(n) {
  var m = modules[n];
  if (m) {return m;}
  if (avocado.transporter.shouldLog) { console.log("Creating module named " + n); }
  m = modules[n] = Object.create(this);
  m._name = n;
  annotator.annotationOf(m).setCreatorSlot(n, modules);
  avocado.transporter.module.cache[n] = Object.newChildOf(avocado.transporter.slotCollection, function(s) {
    var sm = s.getModuleAssignedToMeExplicitlyOrImplicitly();
    return m === sm || !sm;
  });
  return m;
};

avocado.transporter.module.create = function(n, reqBlock, contentsBlock, versionInfo) {
  if (modules[n]) { throw 'The ' + n + ' module is already loaded.'; }
  var newModule = this.named(n);

  if (versionInfo) {
    newModule.setCurrentVersion(Object.newChildOf(avocado.transporter.module.version, newModule, versionInfo.versionID, 'unknown'));
  }
  
  avocado.callbackWaiter.on(function(finalCallback) {
    reqBlock(function(reqName) {
      newModule.requires(reqName, finalCallback());
    });
  }, function() {
    avocado.transporter.loadOrder.push({module: n});
    contentsBlock(newModule);
    if (avocado.transporter.shouldLog) { console.log("Finished loading module: " + n); }
    if (newModule.objectsWithAPostFileInMethod) {
      newModule.objectsWithAPostFileInMethod.each(function(o) {
        o.postFileIn();
      });
      delete newModule.objectsWithAPostFileInMethod;
    }
    avocado.transporter.module.doneLoadingModuleNamed(n);
  }, n);
};

avocado.transporter.module.setCurrentVersion = function (v) {
  this._currentVersion = v;
};

avocado.transporter.module.version.initialize = function (module, id, parentVersions) {
  this._module = module;
  this._id = id || "";
  this._parentVersions = parentVersions || [];
};

avocado.transporter.module.callWhenDoneLoadingModuleNamed = function(n, callback) {
  callback = callback || function() {};

  if (typeof(callback) !== 'function') { throw "What kind of callback is that? " + callback; }
  
  var existingOnLoadCallback = avocado.transporter.module.onLoadCallbacks[n];
  if (!existingOnLoadCallback) {
    avocado.transporter.module.onLoadCallbacks[n] = callback;
  } else if (typeof(existingOnLoadCallback) === 'function') {
    avocado.transporter.module.onLoadCallbacks[n] = function() {
      existingOnLoadCallback();
      callback();
    };
  } else if (existingOnLoadCallback === 'done') {
    // Already done; just call it right now.
    callback();
    return true;
  } else {
    throw "What's wrong with the on-load callback? " + typeof(existingOnLoadCallback);
  }
  return false;
};

avocado.transporter.module.doneLoadingModuleNamed = function(n) {
  var onLoadCallback = avocado.transporter.module.onLoadCallbacks[n];
  if (typeof(onLoadCallback) === 'function') {
    avocado.transporter.module.onLoadCallbacks[n] = 'done';
    onLoadCallback();
  } else if (onLoadCallback === 'done') {
    // Fine, I think.
  } else if (typeof(onLoadCallback) === 'undefined') {
    // aaa - I think this is OK too. Really, this whole callback system is a mess - needs to be cleaned up. -- Adam, Feb. 2011
    avocado.transporter.module.onLoadCallbacks[n] = 'done';
  } else {
    throw "What's wrong with the on-load callback for " + n + "? " + typeof(onLoadCallback);
  }
};

avocado.transporter.module.slotCollection = function() {
  return avocado.transporter.module.cache[this._name];
};

avocado.transporter.module.slotAdder = {
  data: function(name, contents, slotAnnotation, contentsAnnotation) {
    var holderAnno = annotator.annotationOf(this.holder);
    if (! slotAnnotation) { slotAnnotation = Object.create(annotator.slotAnnotationPrototype); }
    slotAnnotation = holderAnno.asSlotAnnotation(slotAnnotation, name);
    holderAnno.setSlotAnnotation(name, slotAnnotation);
    this.holder[name] = contents;
    annotator.setModuleIfNecessary(this.holder, name, this.module);
    if (contentsAnnotation) { // used for creator slots
      annotator.loadObjectAnnotation(contents, contentsAnnotation, name, this.holder);
    }
    
    if (name === 'postFileIn') {
      this.module.objectsWithAPostFileInMethod = this.module.objectsWithAPostFileInMethod || [];
      this.module.objectsWithAPostFileInMethod.push(this.holder);
    }
  },
  
  creator: function(name, contents, slotAnnotation, objectAnnotation) {
    this.data(name, contents, slotAnnotation, objectAnnotation || {});

    if (typeof(contents.postFileIn) === 'function') {
      this.module.objectsWithAPostFileInMethod = this.module.objectsWithAPostFileInMethod || [];
      this.module.objectsWithAPostFileInMethod.push(contents);
    }
    
    // aaa - Where's the right place to put this? How do we make sure that the stuff filed in before the
    // senders code still has its senders indexed?
    if (!window.shouldNotInitializeReflectiveSystem && avocado.senders && avocado.senders.rememberIdentifiersUsedBy) {
      if (typeof(contents) === 'function') {
        avocado.senders.rememberIdentifiersUsedBy(contents);
      }
    }
  },

  method: function(name, contents, slotAnnotation) {
    contents.displayName = name; // this'll show up in the Safari debugger
    contents._creatorSlotHolder = this.holder; // to allow implicit creator slots
    this.creator(name, avocado.makeSuperWork(this.holder, name, contents), slotAnnotation);
  },
  
  domChildNode: function(name, contents, slotAnnotation, contentsAnnotation) {
    this.holder.appendChild(contents);
  }
};

avocado.transporter.module.addSlots = function(holder, block) {
  var holderType = typeof(holder);
  if (holder === null || (holderType !== 'object' && holderType !== 'function')) { throw new Error("Cannot addSlots to " + holder); }
  var slotAdder = Object.create(this.slotAdder);
  slotAdder.module = this;
  slotAdder.holder = holder;
  block(slotAdder);
};

annotator.annotationOf(window).categorize(['avocado', 'bootstrap'], ['__annotation__', 'bootstrapTheModuleSystem', 'modules', 'currentUser', 'jsQuicheBaseURL', 'kernelModuleSavingScriptURL', 'logoutURL', 'startAvocadoGoogleApp', 'urlForKernelModuleName', 'isInCodeOrganizingMode']);

avocado.transporter.module.callWhenDoneLoadingModuleNamed('bootstrap',       function() {});
avocado.transporter.module.callWhenDoneLoadingModuleNamed('bootstrap_lk',    function() {}); // aaa lk-specific
avocado.transporter.module.callWhenDoneLoadingModuleNamed('bootstrap_three', function() {}); // aaa threejs-specific;
};
bootstrapTheModuleSystem();



avocado.transporter.module.create('bootstrap', function(requires) {

}, function(thisModule) {


thisModule.addSlots(window, function(add) {
  
  add.data('isInProgrammingEnvironmentMode', false, {category: ['avocado', 'config'], initializeTo: 'false'});
  
  add.data('isInCodeOrganizingMode', false, {category: ['avocado', 'config'], initializeTo: 'false'});
  
  add.data('isInRunMode', false, {category: ['avocado', 'config'], initializeTo: 'false'});
  
});


thisModule.addSlots(modules.bootstrap, function(add) {

  add.data('preFileInFunctionName', 'bootstrapTheModuleSystem');

});


thisModule.addSlots(avocado.transporter, function(add) {

  add.creator('repositories', {});

  add.data('availableRepositories', [], {initializeTo: '[]'});

  add.method('repositoryContainingModuleNamed', function (name) {
    // aaa fix once I want to allow multiple repositories
    return this.availableRepositories[0];
  }, {category: ['loading']});

  add.method('fileIn', function (name, moduleLoadedCallback) {
    var repo = this.repositoryContainingModuleNamed(name);
    if (!repo) {
      throw new Error("There is no repository containing a module named '" + name + "'; available repositories are: [" + this.availableRepositories.join(", ") + "]");
    }
    repo.fileIn(name, moduleLoadedCallback);
  }, {category: ['loading']});

  add.method('fileInIfWanted', function (name, callWhenDone) {
    if (this.shouldLoadModule(name)) {
      this.repositoryContainingModuleNamed(name).fileIn(name, callWhenDone);
    } else {
      if (callWhenDone) { callWhenDone(); }
    }
  }, {category: ['loading']});

  add.method('shouldLoadModule', function (name) {
    return true;
  }, {category: ['bootstrapping']});

  add.method('loadExternal', function (names, callWhenDone) {
    if (names.length === 0) { return callWhenDone(); }
    var name = names.shift();
    avocado.transporter.fileIn(name, function() {
      avocado.transporter.loadExternal(names, callWhenDone);
    });
  }, {category: ['bootstrapping']});

  add.method('loadJSFileFromURL', function (url, callWhenDone) {
    var i = url.lastIndexOf("/");
    var repoURL = url.substring(0, i) + '/';
    var fileName = url.substring(i + 1);
    var repo = Object.newChildOf(avocado.transporter.repositories.http, repoURL);
    repo.fileIn(fileName, function () {
      console.log("Loaded " + url);
      if (callWhenDone) { callWhenDone(); }
    });
  }, {category: ['bootstrapping']});

  add.method('initializeRepositories', function () {
    var baseURL = avocado.transporter.avocadoBaseURL;
    if (baseURL === undefined) { baseURL = document.documentURI; }
    baseURL = baseURL.substring(0, baseURL.lastIndexOf("/")) + '/';
    var repoURL = baseURL + "javascripts/";
    
    // aaa - hack because I want saving to keep working on my local machine
    if (repoURL.indexOf("http://localhost") === 0) { avocado.kernelModuleSupportsWebDAV = true; }
    
    // aaa - hack because I haven't managed to get WebDAV working on the real server yet
    if (repoURL.indexOf("coolfridgesoftware.com") >= 0) { window.kernelModuleSavingScriptURL = "http://coolfridgesoftware.com/cgi-bin/savefile.cgi"; }
    
    var kernelRepo;
    if (window.kernelModuleSavingScriptURL) {
      var savingScriptURL = window.kernelModuleSavingScriptURL;
      kernelRepo = Object.newChildOf(avocado.transporter.repositories.httpWithSavingScript, repoURL, savingScriptURL);
    } else if (avocado.kernelModuleSupportsWebDAV) {
      kernelRepo = Object.newChildOf(avocado.transporter.repositories.httpWithWebDAV, repoURL);
    } else {
      kernelRepo = Object.newChildOf(avocado.transporter.repositories.http, repoURL);
    }
    
    if (window.urlForKernelModuleName) {
      kernelRepo.urlForModuleName = window.urlForKernelModuleName;
    }
    
    avocado.transporter.availableRepositories.push(kernelRepo);
    
    modules.bootstrap.setRepository(kernelRepo);
    
    // aaa - This is not really the right place for this. I think. Maybe. Where's the
    // place where we really know where the emailing script is? -- Adam
    avocado.transporter.emailingScriptURL = "http://" + document.domain + "/cgi-bin/emailSource.cgi";
  }, {category: ['bootstrapping']});

  add.method('initializeCallbackWaiters', function () {
    avocado.callbackWaiter.on(function(callback) {
      avocado.transporter.callWhenWorldIsCreated = callback();
      avocado.transporter.callWhenAllAvocadoCodeIsLoaded = callback();
    }, function () {
      avocado.transporter.doneLoadingAllOfAvocado();
    });
  }, {category: ['bootstrapping']});

  add.method('putUnownedSlotsInInitModule', function () {
    var initModule = avocado.transporter.module.named('init');
    // aaa - HACK! necessary because the phone runs out of memory while doing this, I think.
    // The right solution in the long run, I think, is to have some clear way of specifying
    // whether the programming-environment stuff should be loaded. -- Adam
    if (!window.shouldNotInitializeReflectiveSystem && (!window.UserAgent || !UserAgent.isIPhone)) {
      var annotator = avocado.objectGraphWalker.visitors.objectGraphAnnotator.create();
      annotator.alsoMakeCreatorSlots();
      annotator.alsoBuildListsOfUsedIdentifiers();
      annotator.alsoAssignUnownedSlotsToModule(initModule);
      annotator.createWalker().alsoWalkSpecialUnreachableObjects().go();
    }
  }, {category: ['bootstrapping']});

  add.method('printLoadOrder', function () {
    console.log("# This code was produced by calling avocado.transporter.printLoadOrder()\n\n" + avocado.transporter.loadOrder.map(function(itemToLoad) {
      if (itemToLoad.externalScript) {
        return "externalScript(" + itemToLoad.externalScript.inspect() + ");";
      } else if (itemToLoad.module) {
        return "newModule(" + itemToLoad.module.inspect() + ");";
      } else if (itemToLoad.doIt) {
        return "doIt(" + itemToLoad.doIt.inspect() + ");";
      } else {
        throw "What's this weird thing in the loadOrder?"
      }
    }).join("\n"));
  }, {category: ['bootstrapping']});

  add.data('whatHasAlreadyBeenLoaded', {}, {category: ['bootstrapping'], initializeTo: '{}'});

  add.method('createAvocadoWorld', function () {
    Event.prepareEventSystem();
    var world = avocado.transporter.userInterfaceInitializer.createAvocadoWorld();
    if (this.callWhenDoneCreatingAvocadoWorld) {
      this.callWhenDoneCreatingAvocadoWorld(world);
      delete this.callWhenDoneCreatingAvocadoWorld;
    }
    return world;
  }, {category: ['bootstrapping']});

  add.method('createAvocadoWorldIfBothTheCodeAndTheWindowAreLoaded', function () {
    if (avocado.transporter.whatHasAlreadyBeenLoaded.isDoneLoadingAvocadoLib && avocado.transporter.whatHasAlreadyBeenLoaded.isDoneLoadingWindow) {
      avocado.world = avocado.transporter.createAvocadoWorld();
      avocado.transporter.callWhenWorldIsCreated();
      delete avocado.transporter.callWhenWorldIsCreated;
    }
  }, {category: ['bootstrapping']});

  add.method('doneLoadingWindow', function () {
    avocado.transporter.whatHasAlreadyBeenLoaded.isDoneLoadingWindow = true;
    if (avocado.transporter.userInterfaceInitializer) { avocado.transporter.userInterfaceInitializer.doneLoadingWindow(); }
    avocado.transporter.createAvocadoWorldIfBothTheCodeAndTheWindowAreLoaded();
  }, {category: ['bootstrapping']});

  add.method('doneLoadingAvocadoLib', function () {
    avocado.transporter.whatHasAlreadyBeenLoaded.isDoneLoadingAvocadoLib = true;
    avocado.transporter.createAvocadoWorldIfBothTheCodeAndTheWindowAreLoaded();
  }, {category: ['bootstrapping']});

  add.method('doneLoadingAllAvocadoCode', function () {
    avocado.transporter.userInterfaceInitializer.doneLoadingAllAvocadoCode();
    avocado.morphMixins.installAll();
    
    avocado.transporter.callWhenAllAvocadoCodeIsLoaded();
    delete avocado.transporter.callWhenAllAvocadoCodeIsLoaded;
  }, {category: ['bootstrapping']});

  add.method('doneLoadingAllOfAvocado', function () {
    if (window.callWhenDoneLoadingAvocado) {
      window.callWhenDoneLoadingAvocado(avocado.world);
      delete window.callWhenDoneLoadingAvocado;
    }
  }, {category: ['bootstrapping']});

  add.method('doBootstrappingStep', function (name) {
    avocado.transporter.loadOrder.push({doIt: 'avocado.transporter.' + name + '();'});
    //console.log("Doing bootstrapping step: " + name);
    return this[name].call(this);
  }, {category: ['bootstrapping']});

  add.method('startAvocado', function (callWhenDone) {
    if (typeof(callWhenDone) !== 'undefined') { window.callWhenDoneLoadingAvocado = callWhenDone; }
    
    this.doBootstrappingStep('initializeCallbackWaiters');
    this.doBootstrappingStep('initializeRepositories');

    avocado.transporter.userInterfaceInitializer.loadUserInterface(function() {

      avocado.transporter.fileInIfWanted("transporter/object_graph_walker", function() {
        avocado.transporter.doBootstrappingStep('putUnownedSlotsInInitModule');
        
        avocado.transporter.fileInIfWanted("avocado_lib", function() {
          avocado.transporter.doBootstrappingStep('doneLoadingAvocadoLib');
          avocado.transporter.userInterfaceInitializer.loadTopLevelEnvironment(function() {
            avocado.transporter.doBootstrappingStep('doneLoadingAllAvocadoCode');
          });
        });
      });
    });
  }, {category: ['bootstrapping']});
  
  add.method('canUseStoreStringToTransportObject', function (o) {
    if (o === null || typeof(o) === 'undefined') { return false; }
    if (typeof(o.storeString) !== 'function') { return false; }
    
    var storeStringFunctionAnno = avocado.annotator.existingAnnotationOf(o.storeString);
    var storeStringFunctionCreatorSlot = storeStringFunctionAnno && storeStringFunctionAnno.probableCreatorSlot();
    var storeStringFunctionIsOnThisObject = !!(storeStringFunctionCreatorSlot && o === storeStringFunctionCreatorSlot.holder);
    
    var storeStringNeedsThisObject = typeof(o.storeStringNeeds) === 'function' && o === o.storeStringNeeds();
    
    return !storeStringNeedsThisObject && !storeStringFunctionIsOnThisObject;
  }, {category: ['bootstrapping']});

});


thisModule.addSlots(avocado, function(add) {

  add.data('version', '0.15', {category: ['version']});

  add.creator('http', {}, {category: ['HTTP']});

  add.creator('generalUI', {}, {category: ['user interface'], comment: 'An extra layer of indirection, so that we can switch between LK and ThreeJS and various other UI systems.'});

});


thisModule.addSlots(avocado.http, function(add) {

  add.method('paramsStringFrom', function (paramsStringOrObject) {
    if (!paramsStringOrObject) { return ""; }
    if (typeof(paramsStringOrObject) === 'string') { return paramsStringOrObject; }
    var params = [];
    for (var n in paramsStringOrObject) {
      if (paramsStringOrObject.hasOwnProperty(n)) {
        params.push(encodeURIComponent(n) + "=" + encodeURIComponent(paramsStringOrObject[n]));
      }
    }
    return params.join("&");
  }, {category: ['requests']});

  add.creator('request', {}, {category: ['XHR']});

  add.creator('scriptTagRequest', {}, {category: ['script tags']});

});


thisModule.addSlots(avocado.http.request, function(add) {

  add.method('initialize', function (path) {
    this._path = path;
  }, {category: ['creating']});

  add.method('httpMethod', function () {
    return this._httpMethod || "GET";
  }, {category: ['accessing']});

  add.method('params', function () {
    return this._params || {};
  }, {category: ['accessing']});

  add.method('paramsString', function () {
    return avocado.http.paramsStringFrom(this.params());
  }, {category: ['accessing']});

  add.method('headers', function () {
    return this._headers || {};
  }, {category: ['accessing']});

  add.method('eachHeader', function (f) {
    var headers =  this.headers()
  	for (var headerName in headers) {
  	  if (headers.hasOwnProperty(headerName)) {
  	    f(headerName, headers[headerName]);
  	  }
  	}
  	if (this.httpMethod() === "POST") {
    	f("Content-type", "application/x-www-form-urlencoded");
  	}
  }, {category: ['accessing']});

  add.method('url', function () {
    if (this.httpMethod() === "GET") {
      return this._path + "?" + this.paramsString();
    } else {
      return this._path;
    }
  }, {category: ['accessing']});

  add.method('body', function () {
    var method = this.httpMethod();
    if (method === "POST" || method === "PUT") {
      if (this._postBody) {
        return this._postBody;
      } else {
        return this.paramsString();
      }
    } else {
      return undefined;
    }
  }, {category: ['accessing']});

  add.method('send', function (callback, errback, partback) {
  	var req = new XMLHttpRequest();
  	var httpMethod = this.httpMethod();
  	var url = this.url();
  	var debugMode = this._debugMode;
  	
  	req.open(httpMethod, url, ! this._isSynchronous);
  	this.eachHeader(function(name, value) { req.setRequestHeader(name, value); });

    var index = 0;
    req.onreadystatechange = function () {
      if (partback && req.readyState === 3) {
        if (req.status == 200) {
          var rtlen = req.responseText.length;
          if (index < rtlen) {
            var nextPartOfResponseText = req.responseText.substring(index);
            partback(nextPartOfResponseText);
            index = rtlen;
          }
        }
      } else if (req.readyState === 4) {
        if (req.status >= 200 && req.status < 300) {
          var responseText = req.responseText;
          if (debugMode) {
            console.log("Received response from " + url);
            if (responseText) { console.log(responseText); }
          }
          callback(responseText);
        } else {
          errback("HTTP status: " + req.status);
        }
      }
    }
    
    var body = this.body();
  	if (debugMode) {
  	  console.log("Sending HTTP " + httpMethod + " to " + url);
      if (body) { console.log(body); }
  	}
    req.send(body);
  }, {category: ['sending']});

});


thisModule.addSlots(avocado.http.scriptTagRequest, function(add) {

  add.method('initialize', function (path) {
    this._path = path;
  }, {category: ['creating']});

  add.method('fullPath', function () {
    var p = this._path;
    // aaa - might want to have caching in production?
    if (p.indexOf('?') >= 0) { p += "&t=" + new Date().getTime(); } else { p += "?t=" + new Date().getTime(); } // to avoid caching;
    return p;
  }, {category: ['sending']});

  add.method('send', function (callback) {
    var script = document.createElement('script');
    script.type = 'text/javascript';
    script.src = this.fullPath();
    script.onload = callback;
    var head = document.getElementsByTagName('head')[0];
    head.appendChild(script);
  }, {category: ['sending']});

});


thisModule.addSlots(avocado.transporter.module, function(add) {

  add.data('_repository', null, {initializeTo: 'null'});

  add.method('setRepository', function (r) {
    this._repository = r;
    return this;
  }, {category: ['accessing']});

  add.method('existingOneNamed', function (n) {
    return modules[n];
  }, {category: ['accessing']});

  add.method('requirements', function () {
    if (! this._requirements) { this._requirements = []; }
    return this._requirements;
  }, {category: ['requirements']});

  add.method('addRequirement', function (nameOfRequiredModule) {
    if (this.requirements().include(nameOfRequiredModule)) { return; }
    this.requirements().push(nameOfRequiredModule);
    this.markAsChanged();
  }, {category: ['requirements']});

  add.method('requires', function (moduleName, reqLoadedCallback) {
    this.requirements().push(moduleName);

    reqLoadedCallback = reqLoadedCallback || function() {};

    var module = avocado.transporter.module.existingOneNamed(moduleName);
    if (module) {
      avocado.transporter.module.callWhenDoneLoadingModuleNamed(moduleName, reqLoadedCallback);
    } else {
      avocado.transporter.fileIn(moduleName, reqLoadedCallback);
    }
  }, {category: ['requirements']});

});


thisModule.addSlots(avocado.transporter.repositories, function(add) {

  add.creator('abstract', {});

});


thisModule.addSlots(avocado.transporter.repositories['abstract'], function(add) {

  add.method('fileIn', function (name, moduleLoadedCallback) {
    if (avocado.transporter.module.callWhenDoneLoadingModuleNamed(name, moduleLoadedCallback)) { return; }
    
    var thisRepository = this;
    this.loadModuleNamed(name, function() {
      var module = modules[name];
      if (module) {
        module.setRepository(thisRepository);
      } else {
        // Must just be some external Javascript library - not one of our
        // modules. So we consider the module to be loaded now, since the
        // file is loaded.
        avocado.transporter.loadOrder.push({externalScript: name});
        if (avocado.transporter.shouldLog) { console.log("Finished loading external script: " + name); }
        avocado.transporter.module.doneLoadingModuleNamed(name);
      }
    });
  }, {category: ['loading']});

});


thisModule.addSlots(avocado.transporter.repositories, function(add) {

  add.creator('console', Object.create(avocado.transporter.repositories['abstract']));

  add.creator('http', Object.create(avocado.transporter.repositories['abstract']));

});


thisModule.addSlots(avocado.transporter.repositories.http, function(add) {

  add.method('initialize', function (url) {
    this._url = url;
  }, {category: ['creating']});

  add.method('url', function () {
    return this._url;
  }, {category: ['printing']});

  add.method('toString', function () {
    return this.url();
  }, {category: ['printing']});

  add.method('urlForModuleName', function (name) {
    return this.urlForFileName((name.substring(name.length - 3) !== '.js') ? name + ".js" : name);
  }, {category: ['saving to WebDAV']});

  add.method('urlForFileName', function (name) {
    return this.url() + name;
  }, {category: ['saving to WebDAV']});

  add.method('loadModuleNamed', function (name, callWhenDone) {
    var url = this.urlForModuleName(name);
    if (avocado.transporter.shouldLog) { console.log("About to try to loadModuleNamed " + name + " at URL " + url); }
    this.loadURL(url, callWhenDone);
  }, {category: ['loading']});

  add.method('loadURL', function (url, scriptLoadedCallback) {
    scriptLoadedCallback = scriptLoadedCallback || function() {};

    // Don't load the same JS file more than once.
    var loadingStatus = avocado.transporter.loadedURLs[url];
    if (typeof loadingStatus === 'function') {
      avocado.transporter.loadedURLs[url] = function() {
        loadingStatus();
        scriptLoadedCallback();
      };
      return;
    } else if (loadingStatus === 'done') {
      return scriptLoadedCallback();
    } else if (loadingStatus) {
      throw "Wait, it's not a callback function and it's not 'done'; what is it?"
    }

    // aaa - don't use this global loadedURLs thing, use something repo-specific.
    avocado.transporter.loadedURLs[url] = scriptLoadedCallback;

    var loadingFunction = avocado.transporter._functionToLoadAURL;
    if (!loadingFunction) {
      var thisRepo = this;
      var shouldUseXMLHttpRequest = false; // aaa - not sure which way is better; seems to be a tradeoff
      if (shouldUseXMLHttpRequest) {
        loadingFunction = function(url, callback) { thisRepo.loadURLUsingXHR(url, callback); };
      } else {
        loadingFunction = function(url, callback) { thisRepo.loadURLUsingScriptTag(url, callback); };
      }
    }
    loadingFunction(url, function() {
      avocado.transporter.loadedURLs[url]();
      avocado.transporter.loadedURLs[url] = 'done';
    });
  }, {category: ['loading']});

  add.method('loadURLUsingXHR', function (url, callback) {
    var req = Object.newChildOf(avocado.http.request, url);
    req.send(function(_fileContents) {
      // I really hope "with" is the right thing to do here. We seem to need
      // it in order to make globally-defined things work.
      with (window) { eval("//@ sourceURL=" + url + "\n" + _fileContents); } // sourceURL will show up in the debugger
      callback();
    }, function(err) {
      throw err;
    });
  }, {category: ['loading']});

  add.method('loadURLUsingScriptTag', function (url, callback) {
    var req = Object.newChildOf(avocado.http.scriptTagRequest, url);
    req.send(callback);
  }, {category: ['loading']});

  add.method('canFileOutIndividualModules', function () {
    return typeof(this.fileOutModuleVersion) === 'function';
  }, {category: ['saving']});

});


thisModule.addSlots(avocado.transporter.repositories, function(add) {

  add.creator('httpWithWebDAV', Object.create(avocado.transporter.repositories.http));

  add.creator('httpWithSavingScript', Object.create(avocado.transporter.repositories.http));

});


thisModule.addSlots(avocado.transporter.repositories.httpWithSavingScript, function(add) {

  add.method('initialize', function (url, savingScriptURL) {
    this._url = url;
    this._savingScriptURL = savingScriptURL;
  }, {category: ['creating']});

});


});

avocado.transporter.module.onLoadCallbacks["bootstrap_lk"] = function() {};
avocado.transporter.module.create('bootstrap_lk', function(requires) {}, function(thisModule) {


thisModule.addSlots(avocado.transporter, function(add) {
  
  add.creator('livelyKernelInitializer', {}, {category: ['user interface', 'lively kernel']});
  
  add.data('userInterfaceInitializer', avocado.transporter.livelyKernelInitializer, {category: ['user interface']});

});


thisModule.addSlots(avocado.transporter.livelyKernelInitializer, function(add) {

  add.method('loadUserInterface', function (callWhenDone) {
    avocado.transporter.callWhenDoneLoadingLivelyKernelCode = callWhenDone;
    if (document.body) {
      this.createCanvasIfNone();
      this.loadLivelyKernelCodeIfReadyAndTheWindowIsLoaded();
    } else {
      if (this._debugmode) {
        console.log("document.body doesn't exist yet; setting window.onload."); // aaa - I have a feeling that this doesn't work, though, at least in some browsers. -- Adam, Nov. 2010
      }
      var that = this;
      window.onload = function() { that.createCanvasIfNone(); };
      this.loadLivelyKernelCodeIfReadyAndTheWindowIsLoaded();
    }
  }, {category: ['bootstrapping']});
  
  add.method('doneLoadingWindow', function () {
    this.loadLivelyKernelCodeIfReadyAndTheWindowIsLoaded();
  }, {category: ['bootstrapping']});
  
  add.method('loadTopLevelEnvironment', function (callWhenDone) {
    
    var whichOne;
    if (window.isInCodeOrganizingMode) { whichOne = "lk_programming_environment/code_organizer";          }
    else if (window.isInRunMode)       { whichOne = "lk_programming_environment/runtime_environment";     }
    else                               { whichOne = "lk_programming_environment/programming_environment"; window.isInProgrammingEnvironmentMode = true; }
    
    avocado.transporter.fileInIfWanted(whichOne, function() {
      var topLevelEnvironment;
      if (window.isInCodeOrganizingMode) { topLevelEnvironment = jsQuiche; }
      else if (window.isInRunMode)       { topLevelEnvironment = avocado.runtime; }
      else                               { topLevelEnvironment = avocado.livelyKernelUI.programmingEnvironment; }

      topLevelEnvironment.loadAsTopLevelEnvironment();
      
      if (callWhenDone) { callWhenDone(); }
    });
  }, {category: ['bootstrapping']});

  add.method('doneLoadingAllAvocadoCode', function () {
    avocado.ui = avocado.livelyKernelUI;
  }, {category: ['bootstrapping']});
    
  add.method('createCanvasIfNone', function () {
    var canvas = document.getElementById("canvas");
    if (! canvas) {
      // Put the canvas inside a div, because for some reason FireFox isn't calculating
      // offsetLeft and offsetTop for the canvas itself. Also, allow people to specify
      // an 'avocadoDiv' element so they can control where Avocado goes on the page.
      var avocadoDiv = document.getElementById('avocadoDiv');
      if (! avocadoDiv) {
        avocadoDiv = document.createElement('div');
        document.body.appendChild(avocadoDiv);
      }
      
      canvas = document.createElementNS("http://www.w3.org/2000/svg", 'svg');
      canvas.setAttribute('id', 'canvas');
      canvas.setAttribute('width',  avocadoDiv.offsetWidth  || window.document.documentElement.clientWidth || '800'); // aaa used to say 100% but that caused some weird bug that I don't understand -- Adam, June 2011
      canvas.setAttribute('height', avocadoDiv.offsetHeight || window.document.documentElement.clientHeight * 0.99 || '620'); // 0.99 to avoid scroll bars
      canvas.setAttribute('xmlns', "http://www.w3.org/2000/svg");
      canvas.setAttribute('xmlns:lively', "http://www.experimentalstuff.com/Lively");
      canvas.setAttribute('xmlns:xlink', "http://www.w3.org/1999/xlink");
      canvas.setAttribute('xmlns:xhtml', "http://www.w3.org/1999/xhtml");
      canvas.setAttribute('xml:space', "preserve");
      canvas.setAttribute('zoomAndPan', "disable");

      var title = document.createElement('title');
      title.appendChild(document.createTextNode('Lively canvas'));
      canvas.appendChild(title);
      
      avocadoDiv.appendChild(canvas);
    }
    return canvas;
  }, {category: ['bootstrapping']});

  add.method('loadLivelyKernelCodeIfReadyAndTheWindowIsLoaded', function () {
    if (avocado.transporter.callWhenDoneLoadingLivelyKernelCode && (document.body || avocado.transporter.whatHasAlreadyBeenLoaded.isDoneLoadingWindow)) {
      this.loadLivelyKernelCode(avocado.transporter.callWhenDoneLoadingLivelyKernelCode);
    }
  }, {category: ['bootstrapping']});

  add.method('loadLivelyKernelCode', function (callWhenDone) {
    this.createCanvasIfNone();
    
    // Loading LK modules dynamically, in the same order that they are loaded in the xhtml file.   
    avocado.transporter.loadExternal(
      ["prototype/prototype",
       "lk/JSON",
       "lk/defaultconfig",
       "local-LK-config",
       "lk/Base",
       "lk/scene",
       "lk/Core",
       "lk/Text",
       "lk/Widgets",
       "lk/Network",
       "lk/Data",
       "lk/Storage",
       "lk/bindings",
       "lk/Tools",
       "jslint"
      ], callWhenDone
    );
  }, {category: ['bootstrapping']});

  add.method('createAvocadoWorld', function () {
    Morph.prototype.suppressBalloonHelp = true; // balloons keep staying up when they shouldn't. Suppress until fixed.
    //Morph.suppressAllHandlesForever();  //disable handles if not doing much UI construction; probably annoying.
    
    var canvas = this.createCanvasIfNone();
    
  	DisplayThemes['lively'].world.fill = Color.white;
  	
    var world = new WorldMorph(canvas);
    world.displayOnCanvas(canvas);
    modules.init.markAsUnchanged(); // because displayOnCanvas sets the creator slot of the world
    if (navigator.appName == 'Opera') { window.onresize(); }
    if (avocado.transporter.shouldLog) { console.log("The world should be visible now."); }
    // this.initializeGestures(world); // aaa disable loading of mootools for now, since we're not using moosture
    return world;
  }, {category: ['bootstrapping']});

  add.method('initializeGestures', function (world) {
    //Moosture gesture experiments
    var gstr = new Moousture.ReducedLevenMatcher({reduceConsistency: 1});
    var probe = new (UserAgent.isTouch ? Moousture.iPhoneProbe : Moousture.MouseProbe)(world); //$(document));
    var recorder = new Moousture.Recorder({maxSteps: 20, minSteps: 8, matcher: gstr});
    var monitor = new Moousture.Monitor(20, 1);
    //CCW circle motion vectors
    //gstr.addGesture([3,2,1,0,7,6,5,4], ccwCircle);
    //Make a triangle
    function triMov(error){
      if (error * 10 >= 8) { return; }
      world.showContextMenu(Event.createFake());
    }

    gstr.addGesture([7, 1, 7, 1], triMov);
    //Zig zag swipe vectors
    //gstr.addGesture([4, 0, 4, 0], swipeMouse);
    
    //var swipeProbe = new Moousture.iPhoneProbe(world.rawNode);
    //var swipeMonitor = new Moousture.Monitor(20, 1);
    //var swipeMatcher = new Moousture.ReducedLevenMatcher({reduceConsistency: 4});
    //var swipeRecorder = new Moousture.Recorder({maxSteps: 50, minSteps: 2, matcher: swipeMatcher});
    
    //swipeMatcher.addGesture([0], rightSwipe);
    //swipeMatcher.addGesture([4], leftSwipe);
    
    monitor.start(probe, recorder);
    //swipeMonitor.start(swipeProbe, swipeRecorder);
  }, {category: ['bootstrapping']});
  
});


});

avocado.transporter.initializeCallbackWaiters();
avocado.transporter.initializeRepositories();
avocado.transporter.module.onLoadCallbacks["prototype/prototype"] = function() {};
/*  Prototype JavaScript framework, version 1.6.1
 *  (c) 2005-2009 Sam Stephenson
 *
 *  Prototype is freely distributable under the terms of an MIT-style license.
 *  For details, see the Prototype web site: http://www.prototypejs.org/
 *
 *--------------------------------------------------------------------------*/

var Prototype = {
  Version: '1.6.1',

  Browser: (function(){
    var ua = navigator.userAgent;
    var isOpera = Object.prototype.toString.call(window.opera) == '[object Opera]';
    return {
      IE:             !!window.attachEvent && !isOpera,
      Opera:          isOpera,
      WebKit:         ua.indexOf('AppleWebKit/') > -1,
      Gecko:          ua.indexOf('Gecko') > -1 && ua.indexOf('KHTML') === -1,
      MobileSafari:   /Apple.*Mobile.*Safari/.test(ua)
    }
  })(),

  BrowserFeatures: {
    XPath: !!document.evaluate,
    SelectorsAPI: !!document.querySelector,
    ElementExtensions: (function() {
      var constructor = window.Element || window.HTMLElement;
      return !!(constructor && constructor.prototype);
    })(),
    SpecificElementExtensions: (function() {
      if (typeof window.HTMLDivElement !== 'undefined')
        return true;

      var div = document.createElement('div');
      var form = document.createElement('form');
      var isSupported = false;

      if (div['__proto__'] && (div['__proto__'] !== form['__proto__'])) {
        isSupported = true;
      }

      div = form = null;

      return isSupported;
    })()
  },

  ScriptFragment: '<script[^>]*>([\\S\\s]*?)<\/script>',
  JSONFilter: /^\/\*-secure-([\s\S]*)\*\/\s*$/,

  emptyFunction: function() { },
  K: function(x) { return x }
};

if (Prototype.Browser.MobileSafari)
  Prototype.BrowserFeatures.SpecificElementExtensions = false;


var Abstract = { };


var Try = {
  these: function() {
    var returnValue;

    for (var i = 0, length = arguments.length; i < length; i++) {
      var lambda = arguments[i];
      try {
        returnValue = lambda();
        break;
      } catch (e) { }
    }

    return returnValue;
  }
};

/* Based on Alex Arnell's inheritance implementation. */

var Class = (function() {
  function subclass() {};
  function create() {
    var parent = null, properties = $A(arguments);
    if (Object.isFunction(properties[0]))
      parent = properties.shift();

    function klass() {
      this.initialize.apply(this, arguments);
    }

    Object.extend(klass, Class.Methods);
    klass.superclass = parent;
    klass.subclasses = [];

    if (parent) {
      subclass.prototype = parent.prototype;
      klass.prototype = new subclass;
      parent.subclasses.push(klass);
    }

    for (var i = 0; i < properties.length; i++)
      klass.addMethods(properties[i]);

    if (!klass.prototype.initialize)
      klass.prototype.initialize = Prototype.emptyFunction;

    klass.prototype.constructor = klass;
    return klass;
  }

  function addMethods(source) {
    var ancestor   = this.superclass && this.superclass.prototype;
    var properties = Object.keys(source);

    if (!Object.keys({ toString: true }).length) {
      if (source.toString != Object.prototype.toString)
        properties.push("toString");
      if (source.valueOf != Object.prototype.valueOf)
        properties.push("valueOf");
    }

    for (var i = 0, length = properties.length; i < length; i++) {
      var property = properties[i], value = source[property];
      if (ancestor && Object.isFunction(value) &&
          value.argumentNames().first() == "$super") {
        var method = value;
        value = (function(m) {
          return function() { return ancestor[m].apply(this, arguments); };
        })(property).wrap(method);

        value.valueOf = method.valueOf.bind(method);
        value.toString = method.toString.bind(method);
      }
      this.prototype[property] = value;
    }

    return this;
  }

  return {
    create: create,
    Methods: {
      addMethods: addMethods
    }
  };
})();
(function() {

  var _toString = Object.prototype.toString;

  function extend(destination, source) {
    // aaa: Hacked by Adam, not sure what else to do.
    for (var property in source) {
      if (property !== '__annotation__') {
        destination[property] = source[property];
      }
    }
    return destination;
  }

  function inspect(object) {
    try {
      if (isUndefined(object)) return 'undefined';
      if (object === null) return 'null';
      return object.inspect ? object.inspect() : String(object);
    } catch (e) {
      if (e instanceof RangeError) return '...';
      throw e;
    }
  }

  function toJSON(object) {
    var type = typeof object;
    switch (type) {
      case 'undefined':
      case 'function':
      case 'unknown': return;
      case 'boolean': return object.toString();
    }

    if (object === null) return 'null';
    if (object.toJSON) return object.toJSON();
    if (isElement(object)) return;

    var results = [];
    for (var property in object) {
      if (property !== '__annotation__') { // added by Adam to prevent infinite recursion
	var value = toJSON(object[property]);
	if (!isUndefined(value))
	  results.push(property.toJSON() + ': ' + value);
      }
    }

    return '{' + results.join(', ') + '}';
  }

  function toQueryString(object) {
    return $H(object).toQueryString();
  }

  function toHTML(object) {
    return object && object.toHTML ? object.toHTML() : String.interpret(object);
  }

  function keys(object) {
    var results = [];
    for (var property in object)
      results.push(property);
    return results;
  }

  function values(object) {
    var results = [];
    for (var property in object)
      results.push(object[property]);
    return results;
  }

  function clone(object) {
    return extend({ }, object);
  }

  function isElement(object) {
    return !!(object && object.nodeType == 1);
  }

  function isArray(object) {
    return _toString.call(object) == "[object Array]";
  }


  function isHash(object) {
    return object instanceof Hash;
  }

  function isFunction(object) {
    return typeof object === "function";
  }

  function isString(object) {
    return _toString.call(object) == "[object String]";
  }

  function isNumber(object) {
    return _toString.call(object) == "[object Number]";
  }

  function isUndefined(object) {
    return typeof object === "undefined";
  }

  extend(Object, {
    extend:        extend,
    inspect:       inspect,
    toJSON:        toJSON,
    toQueryString: toQueryString,
    toHTML:        toHTML,
    keys:          keys,
    values:        values,
    clone:         clone,
    isElement:     isElement,
    isArray:       isArray,
    isHash:        isHash,
    isFunction:    isFunction,
    isString:      isString,
    isNumber:      isNumber,
    isUndefined:   isUndefined
  });
})();
Object.extend(Function.prototype, (function() {
  var slice = Array.prototype.slice;

  function update(array, args) {
    var arrayLength = array.length, length = args.length;
    while (length--) array[arrayLength + length] = args[length];
    return array;
  }

  function merge(array, args) {
    array = slice.call(array, 0);
    return update(array, args);
  }

  function argumentNames() {
    var names = this.toString().match(/^[\s\(]*function[^(]*\(([^)]*)\)/)[1]
      .replace(/\/\/.*?[\r\n]|\/\*(?:.|[\r\n])*?\*\//g, '')
      .replace(/\s+/g, '').split(',');
    return names.length == 1 && !names[0] ? [] : names;
  }

  function bind(context) {
    if (arguments.length < 2 && Object.isUndefined(arguments[0])) return this;
    var __method = this, args = slice.call(arguments, 1);
    return function() {
      var a = merge(args, arguments);
      return __method.apply(context, a);
    }
  }

  function bindAsEventListener(context) {
    var __method = this, args = slice.call(arguments, 1);
    return function(event) {
      var a = update([event || window.event], args);
      return __method.apply(context, a);
    }
  }

  function curry() {
    if (!arguments.length) return this;
    var __method = this, args = slice.call(arguments, 0);
    return function() {
      var a = merge(args, arguments);
      return __method.apply(this, a);
    }
  }

  function delay(timeout) {
    var __method = this, args = slice.call(arguments, 1);
    timeout = timeout * 1000
    return window.setTimeout(function() {
      return __method.apply(__method, args);
    }, timeout);
  }

  function defer() {
    var args = update([0.01], arguments);
    return this.delay.apply(this, args);
  }

  function wrap(wrapper) {
    var __method = this;
    return function() {
      var a = update([__method.bind(this)], arguments);
      return wrapper.apply(this, a);
    }
  }

  function methodize() {
    if (this._methodized) return this._methodized;
    var __method = this;
    return this._methodized = function() {
      var a = update([this], arguments);
      return __method.apply(null, a);
    };
  }

  return {
    argumentNames:       argumentNames,
    bind:                bind,
    bindAsEventListener: bindAsEventListener,
    curry:               curry,
    delay:               delay,
    defer:               defer,
    wrap:                wrap,
    methodize:           methodize
  }
})());


Date.prototype.toJSON = function() {
  return '"' + this.getUTCFullYear() + '-' +
    (this.getUTCMonth() + 1).toPaddedString(2) + '-' +
    this.getUTCDate().toPaddedString(2) + 'T' +
    this.getUTCHours().toPaddedString(2) + ':' +
    this.getUTCMinutes().toPaddedString(2) + ':' +
    this.getUTCSeconds().toPaddedString(2) + 'Z"';
};


RegExp.prototype.match = RegExp.prototype.test;

RegExp.escape = function(str) {
  return String(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
};
var PeriodicalExecuter = Class.create({
  initialize: function(callback, frequency) {
    this.callback = callback;
    this.frequency = frequency;
    this.currentlyExecuting = false;

    this.registerCallback();
  },

  registerCallback: function() {
    this.timer = setInterval(this.onTimerEvent.bind(this), this.frequency * 1000);
  },

  execute: function() {
    this.callback(this);
  },

  stop: function() {
    if (!this.timer) return;
    clearInterval(this.timer);
    this.timer = null;
  },

  onTimerEvent: function() {
    if (!this.currentlyExecuting) {
      try {
        this.currentlyExecuting = true;
        this.execute();
        this.currentlyExecuting = false;
      } catch(e) {
        this.currentlyExecuting = false;
        throw e;
      }
    }
  }
});
Object.extend(String, {
  interpret: function(value) {
    return value == null ? '' : String(value);
  },
  specialChar: {
    '\b': '\\b',
    '\t': '\\t',
    '\n': '\\n',
    '\f': '\\f',
    '\r': '\\r',
    '\\': '\\\\'
  }
});

Object.extend(String.prototype, (function() {

  function prepareReplacement(replacement) {
    if (Object.isFunction(replacement)) return replacement;
    var template = new Template(replacement);
    return function(match) { return template.evaluate(match) };
  }

  function gsub(pattern, replacement) {
    var result = '', source = this, match;
    replacement = prepareReplacement(replacement);

    if (Object.isString(pattern))
      pattern = RegExp.escape(pattern);

    if (!(pattern.length || pattern.source)) {
      replacement = replacement('');
      return replacement + source.split('').join(replacement) + replacement;
    }

    while (source.length > 0) {
      if (match = source.match(pattern)) {
        result += source.slice(0, match.index);
        result += String.interpret(replacement(match));
        source  = source.slice(match.index + match[0].length);
      } else {
        result += source, source = '';
      }
    }
    return result;
  }

  function sub(pattern, replacement, count) {
    replacement = prepareReplacement(replacement);
    count = Object.isUndefined(count) ? 1 : count;

    return this.gsub(pattern, function(match) {
      if (--count < 0) return match[0];
      return replacement(match);
    });
  }

  function scan(pattern, iterator) {
    this.gsub(pattern, iterator);
    return String(this);
  }

  function truncate(length, truncation) {
    length = length || 30;
    truncation = Object.isUndefined(truncation) ? '...' : truncation;
    return this.length > length ?
      this.slice(0, length - truncation.length) + truncation : String(this);
  }

  function strip() {
    return this.replace(/^\s+/, '').replace(/\s+$/, '');
  }

  function stripTags() {
    return this.replace(/<\w+(\s+("[^"]*"|'[^']*'|[^>])+)?>|<\/\w+>/gi, '');
  }

  function stripScripts() {
    return this.replace(new RegExp(Prototype.ScriptFragment, 'img'), '');
  }

  function extractScripts() {
    var matchAll = new RegExp(Prototype.ScriptFragment, 'img');
    var matchOne = new RegExp(Prototype.ScriptFragment, 'im');
    return (this.match(matchAll) || []).map(function(scriptTag) {
      return (scriptTag.match(matchOne) || ['', ''])[1];
    });
  }

  function evalScripts() {
    return this.extractScripts().map(function(script) { return eval(script) });
  }

  function escapeHTML() {
    return this.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  }

  function unescapeHTML() {
    return this.stripTags().replace(/&lt;/g,'<').replace(/&gt;/g,'>').replace(/&amp;/g,'&');
  }


  function toQueryParams(separator) {
    var match = this.strip().match(/([^?#]*)(#.*)?$/);
    if (!match) return { };

    return match[1].split(separator || '&').inject({ }, function(hash, pair) {
      if ((pair = pair.split('='))[0]) {
        var key = decodeURIComponent(pair.shift());
        var value = pair.length > 1 ? pair.join('=') : pair[0];
        if (value != undefined) value = decodeURIComponent(value);

        if (key in hash) {
          if (!Object.isArray(hash[key])) hash[key] = [hash[key]];
          hash[key].push(value);
        }
        else hash[key] = value;
      }
      return hash;
    });
  }

  function toArray() {
    return this.split('');
  }

  function succ() {
    return this.slice(0, this.length - 1) +
      String.fromCharCode(this.charCodeAt(this.length - 1) + 1);
  }

  function times(count) {
    return count < 1 ? '' : new Array(count + 1).join(this);
  }

  function camelize() {
    var parts = this.split('-'), len = parts.length;
    if (len == 1) return parts[0];

    var camelized = this.charAt(0) == '-'
      ? parts[0].charAt(0).toUpperCase() + parts[0].substring(1)
      : parts[0];

    for (var i = 1; i < len; i++)
      camelized += parts[i].charAt(0).toUpperCase() + parts[i].substring(1);

    return camelized;
  }

  function capitalize() {
    return this.charAt(0).toUpperCase() + this.substring(1).toLowerCase();
  }

  function underscore() {
    return this.replace(/::/g, '/')
               .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')
               .replace(/([a-z\d])([A-Z])/g, '$1_$2')
               .replace(/-/g, '_')
               .toLowerCase();
  }

  function dasherize() {
    return this.replace(/_/g, '-');
  }

  function inspect(useDoubleQuotes) {
    var escapedString = this.replace(/[\x00-\x1f\\]/g, function(character) {
      if (character in String.specialChar) {
        return String.specialChar[character];
      }
      return '\\u00' + character.charCodeAt().toPaddedString(2, 16);
    });
    if (useDoubleQuotes) return '"' + escapedString.replace(/"/g, '\\"') + '"';
    return "'" + escapedString.replace(/'/g, '\\\'') + "'";
  }

  function toJSON() {
    return this.inspect(true);
  }

  function unfilterJSON(filter) {
    return this.replace(filter || Prototype.JSONFilter, '$1');
  }

  function isJSON() {
    var str = this;
    if (str.blank()) return false;
    str = this.replace(/\\./g, '@').replace(/"[^"\\\n\r]*"/g, '');
    return (/^[,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]*$/).test(str);
  }

  function evalJSON(sanitize) {
    var json = this.unfilterJSON();
    try {
      if (!sanitize || json.isJSON()) return eval('(' + json + ')');
    } catch (e) { }
    throw new SyntaxError('Badly formed JSON string: ' + this.inspect());
  }

  function include(pattern) {
    return this.indexOf(pattern) > -1;
  }

  function startsWith(pattern) {
    return this.indexOf(pattern) === 0;
  }

  function endsWith(pattern) {
    var d = this.length - pattern.length;
    return d >= 0 && this.lastIndexOf(pattern) === d;
  }

  function empty() {
    return this == '';
  }

  function blank() {
    return /^\s*$/.test(this);
  }

  function interpolate(object, pattern) {
    return new Template(this, pattern).evaluate(object);
  }

  return {
    gsub:           gsub,
    sub:            sub,
    scan:           scan,
    truncate:       truncate,
    strip:          String.prototype.trim ? String.prototype.trim : strip,
    stripTags:      stripTags,
    stripScripts:   stripScripts,
    extractScripts: extractScripts,
    evalScripts:    evalScripts,
    escapeHTML:     escapeHTML,
    unescapeHTML:   unescapeHTML,
    toQueryParams:  toQueryParams,
    parseQuery:     toQueryParams,
    toArray:        toArray,
    succ:           succ,
    times:          times,
    camelize:       camelize,
    capitalize:     capitalize,
    underscore:     underscore,
    dasherize:      dasherize,
    inspect:        inspect,
    toJSON:         toJSON,
    unfilterJSON:   unfilterJSON,
    isJSON:         isJSON,
    evalJSON:       evalJSON,
    include:        include,
    startsWith:     startsWith,
    endsWith:       endsWith,
    empty:          empty,
    blank:          blank,
    interpolate:    interpolate
  };
})());

var Template = Class.create({
  initialize: function(template, pattern) {
    this.template = template.toString();
    this.pattern = pattern || Template.Pattern;
  },

  evaluate: function(object) {
    if (object && Object.isFunction(object.toTemplateReplacements))
      object = object.toTemplateReplacements();

    return this.template.gsub(this.pattern, function(match) {
      if (object == null) return (match[1] + '');

      var before = match[1] || '';
      if (before == '\\') return match[2];

      var ctx = object, expr = match[3];
      var pattern = /^([^.[]+|\[((?:.*?[^\\])?)\])(\.|\[|$)/;
      match = pattern.exec(expr);
      if (match == null) return before;

      while (match != null) {
        var comp = match[1].startsWith('[') ? match[2].replace(/\\\\]/g, ']') : match[1];
        ctx = ctx[comp];
        if (null == ctx || '' == match[3]) break;
        expr = expr.substring('[' == match[3] ? match[1].length : match[0].length);
        match = pattern.exec(expr);
      }

      return before + String.interpret(ctx);
    });
  }
});
Template.Pattern = /(^|.|\r|\n)(#\{(.*?)\})/;

var $break = { };

window.Enumerable = (function() { // changed by Adam to say "window." instead of "var", for systems where file scope isn't the global scope
  function each(iterator, context) {
    var index = 0;
    try {
      this._each(function(value) {
        iterator.call(context, value, index++);
      });
    } catch (e) {
      if (e != $break) throw e;
    }
    return this;
  }

  function eachSlice(number, iterator, context) {
    var index = -number, slices = [], array = this.toArray();
    if (number < 1) return array;
    while ((index += number) < array.length)
      slices.push(array.slice(index, index+number));
    return slices.collect(iterator, context);
  }

  function all(iterator, context) {
    iterator = iterator || Prototype.K;
    var result = true;
    this.each(function(value, index) {
      result = result && !!iterator.call(context, value, index);
      if (!result) throw $break;
    });
    return result;
  }

  function any(iterator, context) {
    iterator = iterator || Prototype.K;
    var result = false;
    this.each(function(value, index) {
      if (result = !!iterator.call(context, value, index))
        throw $break;
    });
    return result;
  }

  function collect(iterator, context) {
    iterator = iterator || Prototype.K;
    var results = [];
    this.each(function(value, index) {
      results.push(iterator.call(context, value, index));
    });
    return results;
  }

  function detect(iterator, context) {
    var result;
    this.each(function(value, index) {
      if (iterator.call(context, value, index)) {
        result = value;
        throw $break;
      }
    });
    return result;
  }

  function findAll(iterator, context) {
    var results = [];
    this.each(function(value, index) {
      if (iterator.call(context, value, index))
        results.push(value);
    });
    return results;
  }

  function grep(filter, iterator, context) {
    iterator = iterator || Prototype.K;
    var results = [];

    if (Object.isString(filter))
      filter = new RegExp(RegExp.escape(filter));

    this.each(function(value, index) {
      if (filter.match(value))
        results.push(iterator.call(context, value, index));
    });
    return results;
  }

  function include(object) {
    if (Object.isFunction(this.indexOf))
      if (this.indexOf(object) != -1) return true;

    var found = false;
    this.each(function(value) {
      if (value == object) {
        found = true;
        throw $break;
      }
    });
    return found;
  }

  function inGroupsOf(number, fillWith) {
    fillWith = Object.isUndefined(fillWith) ? null : fillWith;
    return this.eachSlice(number, function(slice) {
      while(slice.length < number) slice.push(fillWith);
      return slice;
    });
  }

  function inject(memo, iterator, context) {
    this.each(function(value, index) {
      memo = iterator.call(context, memo, value, index);
    });
    return memo;
  }

  function invoke(method) {
    var args = $A(arguments).slice(1);
    return this.map(function(value) {
      return value[method].apply(value, args);
    });
  }

  function max(iterator, context) {
    iterator = iterator || Prototype.K;
    var result;
    this.each(function(value, index) {
      value = iterator.call(context, value, index);
      if (result == null || value >= result)
        result = value;
    });
    return result;
  }

  function min(iterator, context) {
    iterator = iterator || Prototype.K;
    var result;
    this.each(function(value, index) {
      value = iterator.call(context, value, index);
      if (result == null || value < result)
        result = value;
    });
    return result;
  }

  function partition(iterator, context) {
    iterator = iterator || Prototype.K;
    var trues = [], falses = [];
    this.each(function(value, index) {
      (iterator.call(context, value, index) ?
        trues : falses).push(value);
    });
    return [trues, falses];
  }

  function pluck(property) {
    var results = [];
    this.each(function(value) {
      results.push(value[property]);
    });
    return results;
  }

  function reject(iterator, context) {
    var results = [];
    this.each(function(value, index) {
      if (!iterator.call(context, value, index))
        results.push(value);
    });
    return results;
  }

  function sortBy(iterator, context) {
    return this.map(function(value, index) {
      return {
        value: value,
        criteria: iterator.call(context, value, index)
      };
    }).sort(function(left, right) {
      var a = left.criteria, b = right.criteria;
      return a < b ? -1 : a > b ? 1 : 0;
    }).pluck('value');
  }

  function toArray() {
    return this.map();
  }

  function zip() {
    var iterator = Prototype.K, args = $A(arguments);
    if (Object.isFunction(args.last()))
      iterator = args.pop();

    var collections = [this].concat(args).map($A);
    return this.map(function(value, index) {
      return iterator(collections.pluck(index));
    });
  }

  function size() {
    return this.toArray().length;
  }

  function inspect() {
    return '#<Enumerable:' + this.toArray().inspect() + '>';
  }









  return {
    each:       each,
    eachSlice:  eachSlice,
    all:        all,
    every:      all,
    any:        any,
    some:       any,
    collect:    collect,
    map:        collect,
    detect:     detect,
    findAll:    findAll,
    select:     findAll,
    filter:     findAll,
    grep:       grep,
    include:    include,
    member:     include,
    inGroupsOf: inGroupsOf,
    inject:     inject,
    invoke:     invoke,
    max:        max,
    min:        min,
    partition:  partition,
    pluck:      pluck,
    reject:     reject,
    sortBy:     sortBy,
    toArray:    toArray,
    entries:    toArray,
    zip:        zip,
    size:       size,
    inspect:    inspect,
    find:       detect
  };
})();
function $A(iterable) {
  if (!iterable) return [];
  if ('toArray' in Object(iterable)) return iterable.toArray();
  var length = iterable.length || 0, results = new Array(length);
  while (length--) results[length] = iterable[length];
  return results;
}

function $w(string) {
  if (!Object.isString(string)) return [];
  string = string.strip();
  return string ? string.split(/\s+/) : [];
}

Array.from = $A;


(function() {
  var arrayProto = Array.prototype,
      slice = arrayProto.slice,
      _each = arrayProto.forEach; // use native browser JS 1.6 implementation if available

  function each(iterator) {
    for (var i = 0, length = this.length; i < length; i++)
      iterator(this[i]);
  }
  if (!_each) _each = each;

  function clear() {
    this.length = 0;
    return this;
  }

  function first() {
    return this[0];
  }

  function last() {
    return this[this.length - 1];
  }

  function compact() {
    return this.select(function(value) {
      return value != null;
    });
  }

  function flatten() {
    return this.inject([], function(array, value) {
      if (Object.isArray(value))
        return array.concat(value.flatten());
      array.push(value);
      return array;
    });
  }

  function without() {
    var values = slice.call(arguments, 0);
    return this.select(function(value) {
      return !values.include(value);
    });
  }

  function reverse(inline) {
    return (inline !== false ? this : this.toArray())._reverse();
  }

  function uniq(sorted) {
    return this.inject([], function(array, value, index) {
      if (0 == index || (sorted ? array.last() != value : !array.include(value)))
        array.push(value);
      return array;
    });
  }

  function intersect(array) {
    return this.uniq().findAll(function(item) {
      return array.detect(function(value) { return item === value });
    });
  }


  function clone() {
    return slice.call(this, 0);
  }

  function size() {
    return this.length;
  }

  function inspect() {
    return '[' + this.map(Object.inspect).join(', ') + ']';
  }

  function toJSON() {
    var results = [];
    this.each(function(object) {
      var value = Object.toJSON(object);
      if (!Object.isUndefined(value)) results.push(value);
    });
    return '[' + results.join(', ') + ']';
  }

  function indexOf(item, i) {
    i || (i = 0);
    var length = this.length;
    if (i < 0) i = length + i;
    for (; i < length; i++)
      if (this[i] === item) return i;
    return -1;
  }

  function lastIndexOf(item, i) {
    i = isNaN(i) ? this.length : (i < 0 ? this.length + i : i) + 1;
    var n = this.slice(0, i).reverse().indexOf(item);
    return (n < 0) ? n : i - n - 1;
  }

  function concat() {
    var array = slice.call(this, 0), item;
    for (var i = 0, length = arguments.length; i < length; i++) {
      var item = arguments[i];
      if (Object.isArray(item) && !('callee' in item)) {
        for (var j = 0, arrayLength = item.length; j < arrayLength; j++)
          array.push(item[j]);
      } else {
        array.push(item);
      }
    }
    return array;
  }

  Object.extend(arrayProto, Enumerable);

  if (!arrayProto._reverse)
    arrayProto._reverse = arrayProto.reverse;

  Object.extend(arrayProto, {
    _each:     _each,
    clear:     clear,
    first:     first,
    last:      last,
    compact:   compact,
    flatten:   flatten,
    without:   without,
    reverse:   reverse,
    uniq:      uniq,
    intersect: intersect,
    clone:     clone,
    toArray:   clone,
    size:      size,
    inspect:   inspect,
    toJSON:    toJSON
  });

  var CONCAT_ARGUMENTS_BUGGY = (function() {
    return [].concat(arguments)[0][0] !== 1;
  })(1,2)

  if (CONCAT_ARGUMENTS_BUGGY) arrayProto.concat = concat;

  if (!arrayProto.indexOf) arrayProto.indexOf = indexOf;
  if (!arrayProto.lastIndexOf) arrayProto.lastIndexOf = lastIndexOf;
})();
function $H(object) {
  return new Hash(object);
};

var Hash = Class.create(Enumerable, (function() {
  function initialize(object) {
    this._object = Object.isHash(object) ? object.toObject() : Object.clone(object);
  }

  function _each(iterator) {
    for (var key in this._object) {
      var value = this._object[key], pair = [key, value];
      pair.key = key;
      pair.value = value;
      iterator(pair);
    }
  }

  function set(key, value) {
    return this._object[key] = value;
  }

  function get(key) {
    if (this._object[key] !== Object.prototype[key])
      return this._object[key];
  }

  function unset(key) {
    var value = this._object[key];
    delete this._object[key];
    return value;
  }

  function toObject() {
    return Object.clone(this._object);
  }

  function keys() {
    return this.pluck('key');
  }

  function values() {
    return this.pluck('value');
  }

  function index(value) {
    var match = this.detect(function(pair) {
      return pair.value === value;
    });
    return match && match.key;
  }

  function merge(object) {
    return this.clone().update(object);
  }

  function update(object) {
    return new Hash(object).inject(this, function(result, pair) {
      result.set(pair.key, pair.value);
      return result;
    });
  }

  function toQueryPair(key, value) {
    if (Object.isUndefined(value)) return key;
    return key + '=' + encodeURIComponent(String.interpret(value));
  }

  function toQueryString() {
    return this.inject([], function(results, pair) {
      var key = encodeURIComponent(pair.key), values = pair.value;

      if (values && typeof values == 'object') {
        if (Object.isArray(values))
          return results.concat(values.map(toQueryPair.curry(key)));
      } else results.push(toQueryPair(key, values));
      return results;
    }).join('&');
  }

  function inspect() {
    return '#<Hash:{' + this.map(function(pair) {
      return pair.map(Object.inspect).join(': ');
    }).join(', ') + '}>';
  }

  function toJSON() {
    return Object.toJSON(this.toObject());
  }

  function clone() {
    return new Hash(this);
  }

  return {
    initialize:             initialize,
    _each:                  _each,
    set:                    set,
    get:                    get,
    unset:                  unset,
    toObject:               toObject,
    toTemplateReplacements: toObject,
    keys:                   keys,
    values:                 values,
    index:                  index,
    merge:                  merge,
    update:                 update,
    toQueryString:          toQueryString,
    inspect:                inspect,
    toJSON:                 toJSON,
    clone:                  clone
  };
})());

Hash.from = $H;
Object.extend(Number.prototype, (function() {
  function toColorPart() {
    return this.toPaddedString(2, 16);
  }

  function succ() {
    return this + 1;
  }

  function times(iterator, context) {
    $R(0, this, true).each(iterator, context);
    return this;
  }

  function toPaddedString(length, radix) {
    var string = this.toString(radix || 10);
    return '0'.times(length - string.length) + string;
  }

  function toJSON() {
    return isFinite(this) ? this.toString() : 'null';
  }

  function abs() {
    return Math.abs(this);
  }

  function round() {
    return Math.round(this);
  }

  function ceil() {
    return Math.ceil(this);
  }

  function floor() {
    return Math.floor(this);
  }

  return {
    toColorPart:    toColorPart,
    succ:           succ,
    times:          times,
    toPaddedString: toPaddedString,
    toJSON:         toJSON,
    abs:            abs,
    round:          round,
    ceil:           ceil,
    floor:          floor
  };
})());

function $R(start, end, exclusive) {
  return new ObjectRange(start, end, exclusive);
}

var ObjectRange = Class.create(Enumerable, (function() {
  function initialize(start, end, exclusive) {
    this.start = start;
    this.end = end;
    this.exclusive = exclusive;
  }

  function _each(iterator) {
    var value = this.start;
    while (this.include(value)) {
      iterator(value);
      value = value.succ();
    }
  }

  function include(value) {
    if (value < this.start)
      return false;
    if (this.exclusive)
      return value < this.end;
    return value <= this.end;
  }

  return {
    initialize: initialize,
    _each:      _each,
    include:    include
  };
})());



var Ajax = {
  getTransport: function() {
    return Try.these(
      function() {return new XMLHttpRequest()},
      function() {return new ActiveXObject('Msxml2.XMLHTTP')},
      function() {return new ActiveXObject('Microsoft.XMLHTTP')}
    ) || false;
  },

  activeRequestCount: 0
};

Ajax.Responders = {
  responders: [],

  _each: function(iterator) {
    this.responders._each(iterator);
  },

  register: function(responder) {
    if (!this.include(responder))
      this.responders.push(responder);
  },

  unregister: function(responder) {
    this.responders = this.responders.without(responder);
  },

  dispatch: function(callback, request, transport, json) {
    this.each(function(responder) {
      if (Object.isFunction(responder[callback])) {
        try {
          responder[callback].apply(responder, [request, transport, json]);
        } catch (e) { }
      }
    });
  }
};

Object.extend(Ajax.Responders, Enumerable);

Ajax.Responders.register({
  onCreate:   function() { Ajax.activeRequestCount++ },
  onComplete: function() { Ajax.activeRequestCount-- }
});
Ajax.Base = Class.create({
  initialize: function(options) {
    this.options = {
      method:       'post',
      asynchronous: true,
      contentType:  'application/x-www-form-urlencoded',
      encoding:     'UTF-8',
      parameters:   '',
      evalJSON:     true,
      evalJS:       true
    };
    Object.extend(this.options, options || { });

    this.options.method = this.options.method.toLowerCase();

    if (Object.isString(this.options.parameters))
      this.options.parameters = this.options.parameters.toQueryParams();
    else if (Object.isHash(this.options.parameters))
      this.options.parameters = this.options.parameters.toObject();
  }
});
Ajax.Request = Class.create(Ajax.Base, {
  _complete: false,

  initialize: function($super, url, options) {
    $super(options);
    this.transport = Ajax.getTransport();
    this.request(url);
  },

  request: function(url) {
    this.url = url;
    this.method = this.options.method;
    var params = Object.clone(this.options.parameters);

    if (!['get', 'post'].include(this.method)) {
      params['_method'] = this.method;
      this.method = 'post';
    }

    this.parameters = params;

    if (params = Object.toQueryString(params)) {
      if (this.method == 'get')
        this.url += (this.url.include('?') ? '&' : '?') + params;
      else if (/Konqueror|Safari|KHTML/.test(navigator.userAgent))
        params += '&_=';
    }

    try {
      var response = new Ajax.Response(this);
      if (this.options.onCreate) this.options.onCreate(response);
      Ajax.Responders.dispatch('onCreate', this, response);

      this.transport.open(this.method.toUpperCase(), this.url,
        this.options.asynchronous);

      if (this.options.asynchronous) this.respondToReadyState.bind(this).defer(1);

      this.transport.onreadystatechange = this.onStateChange.bind(this);
      this.setRequestHeaders();

      this.body = this.method == 'post' ? (this.options.postBody || params) : null;
      this.transport.send(this.body);

      /* Force Firefox to handle ready state 4 for synchronous requests */
      if (!this.options.asynchronous && this.transport.overrideMimeType)
        this.onStateChange();

    }
    catch (e) {
      this.dispatchException(e);
    }
  },

  onStateChange: function() {
    var readyState = this.transport.readyState;
    if (readyState > 1 && !((readyState == 4) && this._complete))
      this.respondToReadyState(this.transport.readyState);
  },

  setRequestHeaders: function() {
    var headers = {
      'X-Requested-With': 'XMLHttpRequest',
      'X-Prototype-Version': Prototype.Version,
      'Accept': 'text/javascript, text/html, application/xml, text/xml, */*'
    };

    if (this.method == 'post') {
      headers['Content-type'] = this.options.contentType +
        (this.options.encoding ? '; charset=' + this.options.encoding : '');

      /* Force "Connection: close" for older Mozilla browsers to work
       * around a bug where XMLHttpRequest sends an incorrect
       * Content-length header. See Mozilla Bugzilla #246651.
       */
      if (this.transport.overrideMimeType &&
          (navigator.userAgent.match(/Gecko\/(\d{4})/) || [0,2005])[1] < 2005)
            headers['Connection'] = 'close';
    }

    if (typeof this.options.requestHeaders == 'object') {
      var extras = this.options.requestHeaders;

      if (Object.isFunction(extras.push))
        for (var i = 0, length = extras.length; i < length; i += 2)
          headers[extras[i]] = extras[i+1];
      else
        $H(extras).each(function(pair) { headers[pair.key] = pair.value });
    }

    for (var name in headers)
      this.transport.setRequestHeader(name, headers[name]);
  },

  success: function() {
    var status = this.getStatus();
    return !status || (status >= 200 && status < 300);
  },

  getStatus: function() {
    try {
      return this.transport.status || 0;
    } catch (e) { return 0 }
  },

  respondToReadyState: function(readyState) {
    var state = Ajax.Request.Events[readyState], response = new Ajax.Response(this);

    if (state == 'Complete') {
      try {
        this._complete = true;
        (this.options['on' + response.status]
         || this.options['on' + (this.success() ? 'Success' : 'Failure')]
         || Prototype.emptyFunction)(response, response.headerJSON);
      } catch (e) {
        this.dispatchException(e);
      }

      var contentType = response.getHeader('Content-type');
      if (this.options.evalJS == 'force'
          || (this.options.evalJS && this.isSameOrigin() && contentType
          && contentType.match(/^\s*(text|application)\/(x-)?(java|ecma)script(;.*)?\s*$/i)))
        this.evalResponse();
    }

    try {
      (this.options['on' + state] || Prototype.emptyFunction)(response, response.headerJSON);
      Ajax.Responders.dispatch('on' + state, this, response, response.headerJSON);
    } catch (e) {
      this.dispatchException(e);
    }

    if (state == 'Complete') {
      this.transport.onreadystatechange = Prototype.emptyFunction;
    }
  },

  isSameOrigin: function() {
    var m = this.url.match(/^\s*https?:\/\/[^\/]*/);
    return !m || (m[0] == '#{protocol}//#{domain}#{port}'.interpolate({
      protocol: location.protocol,
      domain: document.domain,
      port: location.port ? ':' + location.port : ''
    }));
  },

  getHeader: function(name) {
    try {
      return this.transport.getResponseHeader(name) || null;
    } catch (e) { return null; }
  },

  evalResponse: function() {
    try {
      return eval((this.transport.responseText || '').unfilterJSON());
    } catch (e) {
      this.dispatchException(e);
    }
  },

  dispatchException: function(exception) {
    (this.options.onException || Prototype.emptyFunction)(this, exception);
    Ajax.Responders.dispatch('onException', this, exception);
  }
});

Ajax.Request.Events =
  ['Uninitialized', 'Loading', 'Loaded', 'Interactive', 'Complete'];








Ajax.Response = Class.create({
  initialize: function(request){
    this.request = request;
    var transport  = this.transport  = request.transport,
        readyState = this.readyState = transport.readyState;

    if((readyState > 2 && !Prototype.Browser.IE) || readyState == 4) {
      this.status       = this.getStatus();
      this.statusText   = this.getStatusText();
      this.responseText = String.interpret(transport.responseText);
      this.headerJSON   = this._getHeaderJSON();
    }

    if(readyState == 4) {
      var xml = transport.responseXML;
      this.responseXML  = Object.isUndefined(xml) ? null : xml;
      this.responseJSON = this._getResponseJSON();
    }
  },

  status:      0,

  statusText: '',

  getStatus: Ajax.Request.prototype.getStatus,

  getStatusText: function() {
    try {
      return this.transport.statusText || '';
    } catch (e) { return '' }
  },

  getHeader: Ajax.Request.prototype.getHeader,

  getAllHeaders: function() {
    try {
      return this.getAllResponseHeaders();
    } catch (e) { return null }
  },

  getResponseHeader: function(name) {
    return this.transport.getResponseHeader(name);
  },

  getAllResponseHeaders: function() {
    return this.transport.getAllResponseHeaders();
  },

  _getHeaderJSON: function() {
    var json = this.getHeader('X-JSON');
    if (!json) return null;
    json = decodeURIComponent(escape(json));
    try {
      return json.evalJSON(this.request.options.sanitizeJSON ||
        !this.request.isSameOrigin());
    } catch (e) {
      this.request.dispatchException(e);
    }
  },

  _getResponseJSON: function() {
    var options = this.request.options;
    if (!options.evalJSON || (options.evalJSON != 'force' &&
      !(this.getHeader('Content-type') || '').include('application/json')) ||
        this.responseText.blank())
          return null;
    try {
      return this.responseText.evalJSON(options.sanitizeJSON ||
        !this.request.isSameOrigin());
    } catch (e) {
      this.request.dispatchException(e);
    }
  }
});

Ajax.Updater = Class.create(Ajax.Request, {
  initialize: function($super, container, url, options) {
    this.container = {
      success: (container.success || container),
      failure: (container.failure || (container.success ? null : container))
    };

    options = Object.clone(options);
    var onComplete = options.onComplete;
    options.onComplete = (function(response, json) {
      this.updateContent(response.responseText);
      if (Object.isFunction(onComplete)) onComplete(response, json);
    }).bind(this);

    $super(url, options);
  },

  updateContent: function(responseText) {
    var receiver = this.container[this.success() ? 'success' : 'failure'],
        options = this.options;

    if (!options.evalScripts) responseText = responseText.stripScripts();

    if (receiver = $(receiver)) {
      if (options.insertion) {
        if (Object.isString(options.insertion)) {
          var insertion = { }; insertion[options.insertion] = responseText;
          receiver.insert(insertion);
        }
        else options.insertion(receiver, responseText);
      }
      else receiver.update(responseText);
    }
  }
});

Ajax.PeriodicalUpdater = Class.create(Ajax.Base, {
  initialize: function($super, container, url, options) {
    $super(options);
    this.onComplete = this.options.onComplete;

    this.frequency = (this.options.frequency || 2);
    this.decay = (this.options.decay || 1);

    this.updater = { };
    this.container = container;
    this.url = url;

    this.start();
  },

  start: function() {
    this.options.onComplete = this.updateComplete.bind(this);
    this.onTimerEvent();
  },

  stop: function() {
    this.updater.options.onComplete = undefined;
    clearTimeout(this.timer);
    (this.onComplete || Prototype.emptyFunction).apply(this, arguments);
  },

  updateComplete: function(response) {
    if (this.options.decay) {
      this.decay = (response.responseText == this.lastText ?
        this.decay * this.options.decay : 1);

      this.lastText = response.responseText;
    }
    this.timer = this.onTimerEvent.bind(this).delay(this.decay * this.frequency);
  },

  onTimerEvent: function() {
    this.updater = new Ajax.Updater(this.container, this.url, this.options);
  }
});



function $(element) {
  if (arguments.length > 1) {
    for (var i = 0, elements = [], length = arguments.length; i < length; i++)
      elements.push($(arguments[i]));
    return elements;
  }
  if (Object.isString(element))
    element = document.getElementById(element);
  return Element.extend(element);
}

if (Prototype.BrowserFeatures.XPath) {
  document._getElementsByXPath = function(expression, parentElement) {
    var results = [];
    var query = document.evaluate(expression, $(parentElement) || document,
      null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
    for (var i = 0, length = query.snapshotLength; i < length; i++)
      results.push(Element.extend(query.snapshotItem(i)));
    return results;
  };
}

/*--------------------------------------------------------------------------*/

if (!window.Node) window.Node = { }; // changed by Adam to say "window." instead of "var", for systems where file scope isn't the global scope

if (!Node.ELEMENT_NODE) {
  Object.extend(Node, {
    ELEMENT_NODE: 1,
    ATTRIBUTE_NODE: 2,
    TEXT_NODE: 3,
    CDATA_SECTION_NODE: 4,
    ENTITY_REFERENCE_NODE: 5,
    ENTITY_NODE: 6,
    PROCESSING_INSTRUCTION_NODE: 7,
    COMMENT_NODE: 8,
    DOCUMENT_NODE: 9,
    DOCUMENT_TYPE_NODE: 10,
    DOCUMENT_FRAGMENT_NODE: 11,
    NOTATION_NODE: 12
  });
}


(function(global) {

  var SETATTRIBUTE_IGNORES_NAME = (function(){
    var elForm = document.createElement("form");
    var elInput = document.createElement("input");
    var root = document.documentElement;
    elInput.setAttribute("name", "test");
    elForm.appendChild(elInput);
    root.appendChild(elForm);
    var isBuggy = elForm.elements
      ? (typeof elForm.elements.test == "undefined")
      : null;
    root.removeChild(elForm);
    elForm = elInput = null;
    return isBuggy;
  })();

  var element = global.Element;
  global.Element = function(tagName, attributes) {
    attributes = attributes || { };
    tagName = tagName.toLowerCase();
    var cache = Element.cache;
    if (SETATTRIBUTE_IGNORES_NAME && attributes.name) {
      tagName = '<' + tagName + ' name="' + attributes.name + '">';
      delete attributes.name;
      return Element.writeAttribute(document.createElement(tagName), attributes);
    }
    if (!cache[tagName]) cache[tagName] = Element.extend(document.createElement(tagName));
    return Element.writeAttribute(cache[tagName].cloneNode(false), attributes);
  };
  Object.extend(global.Element, element || { });
  if (element) global.Element.prototype = element.prototype;
})(this);

Element.cache = { };
Element.idCounter = 1;

Element.Methods = {
  visible: function(element) {
    return $(element).style.display != 'none';
  },

  toggle: function(element) {
    element = $(element);
    Element[Element.visible(element) ? 'hide' : 'show'](element);
    return element;
  },


  hide: function(element) {
    element = $(element);
    element.style.display = 'none';
    return element;
  },

  show: function(element) {
    element = $(element);
    element.style.display = '';
    return element;
  },

  remove: function(element) {
    element = $(element);
    element.parentNode.removeChild(element);
    return element;
  },

  update: (function(){

    var SELECT_ELEMENT_INNERHTML_BUGGY = (function(){
      var el = document.createElement("select"),
          isBuggy = true;
      el.innerHTML = "<option value=\"test\">test</option>";
      if (el.options && el.options[0]) {
        isBuggy = el.options[0].nodeName.toUpperCase() !== "OPTION";
      }
      el = null;
      return isBuggy;
    })();

    var TABLE_ELEMENT_INNERHTML_BUGGY = (function(){
      try {
        var el = document.createElement("table");
        if (el && el.tBodies) {
          el.innerHTML = "<tbody><tr><td>test</td></tr></tbody>";
          var isBuggy = typeof el.tBodies[0] == "undefined";
          el = null;
          return isBuggy;
        }
      } catch (e) {
        return true;
      }
    })();

    var SCRIPT_ELEMENT_REJECTS_TEXTNODE_APPENDING = (function () {
      var s = document.createElement("script"),
          isBuggy = false;
      try {
        s.appendChild(document.createTextNode(""));
        isBuggy = !s.firstChild ||
          s.firstChild && s.firstChild.nodeType !== 3;
      } catch (e) {
        isBuggy = true;
      }
      s = null;
      return isBuggy;
    })();

    function update(element, content) {
      element = $(element);

      if (content && content.toElement)
        content = content.toElement();

      if (Object.isElement(content))
        return element.update().insert(content);

      content = Object.toHTML(content);

      var tagName = element.tagName.toUpperCase();

      if (tagName === 'SCRIPT' && SCRIPT_ELEMENT_REJECTS_TEXTNODE_APPENDING) {
        element.text = content;
        return element;
      }

      if (SELECT_ELEMENT_INNERHTML_BUGGY || TABLE_ELEMENT_INNERHTML_BUGGY) {
        if (tagName in Element._insertionTranslations.tags) {
          while (element.firstChild) {
            element.removeChild(element.firstChild);
          }
          Element._getContentFromAnonymousElement(tagName, content.stripScripts())
            .each(function(node) {
              element.appendChild(node)
            });
        }
        else {
          element.innerHTML = content.stripScripts();
        }
      }
      else {
        element.innerHTML = content.stripScripts();
      }

      content.evalScripts.bind(content).defer();
      return element;
    }

    return update;
  })(),

  replace: function(element, content) {
    element = $(element);
    if (content && content.toElement) content = content.toElement();
    else if (!Object.isElement(content)) {
      content = Object.toHTML(content);
      var range = element.ownerDocument.createRange();
      range.selectNode(element);
      content.evalScripts.bind(content).defer();
      content = range.createContextualFragment(content.stripScripts());
    }
    element.parentNode.replaceChild(content, element);
    return element;
  },

  insert: function(element, insertions) {
    element = $(element);

    if (Object.isString(insertions) || Object.isNumber(insertions) ||
        Object.isElement(insertions) || (insertions && (insertions.toElement || insertions.toHTML)))
          insertions = {bottom:insertions};

    var content, insert, tagName, childNodes;

    for (var position in insertions) {
      content  = insertions[position];
      position = position.toLowerCase();
      insert = Element._insertionTranslations[position];

      if (content && content.toElement) content = content.toElement();
      if (Object.isElement(content)) {
        insert(element, content);
        continue;
      }

      content = Object.toHTML(content);

      tagName = ((position == 'before' || position == 'after')
        ? element.parentNode : element).tagName.toUpperCase();

      childNodes = Element._getContentFromAnonymousElement(tagName, content.stripScripts());

      if (position == 'top' || position == 'after') childNodes.reverse();
      childNodes.each(insert.curry(element));

      content.evalScripts.bind(content).defer();
    }

    return element;
  },

  wrap: function(element, wrapper, attributes) {
    element = $(element);
    if (Object.isElement(wrapper))
      $(wrapper).writeAttribute(attributes || { });
    else if (Object.isString(wrapper)) wrapper = new Element(wrapper, attributes);
    else wrapper = new Element('div', wrapper);
    if (element.parentNode)
      element.parentNode.replaceChild(wrapper, element);
    wrapper.appendChild(element);
    return wrapper;
  },

  inspect: function(element) {
    element = $(element);
    var result = '<' + element.tagName.toLowerCase();
    $H({'id': 'id', 'className': 'class'}).each(function(pair) {
      var property = pair.first(), attribute = pair.last();
      var value = (element[property] || '').toString();
      if (value) result += ' ' + attribute + '=' + value.inspect(true);
    });
    return result + '>';
  },

  recursivelyCollect: function(element, property) {
    element = $(element);
    var elements = [];
    while (element = element[property])
      if (element.nodeType == 1)
        elements.push(Element.extend(element));
    return elements;
  },

  ancestors: function(element) {
    return Element.recursivelyCollect(element, 'parentNode');
  },

  descendants: function(element) {
    return Element.select(element, "*");
  },

  firstDescendant: function(element) {
    element = $(element).firstChild;
    while (element && element.nodeType != 1) element = element.nextSibling;
    return $(element);
  },

  immediateDescendants: function(element) {
    if (!(element = $(element).firstChild)) return [];
    while (element && element.nodeType != 1) element = element.nextSibling;
    if (element) return [element].concat($(element).nextSiblings());
    return [];
  },

  previousSiblings: function(element) {
    return Element.recursivelyCollect(element, 'previousSibling');
  },

  nextSiblings: function(element) {
    return Element.recursivelyCollect(element, 'nextSibling');
  },

  siblings: function(element) {
    element = $(element);
    return Element.previousSiblings(element).reverse()
      .concat(Element.nextSiblings(element));
  },

  match: function(element, selector) {
    if (Object.isString(selector))
      selector = new Selector(selector);
    return selector.match($(element));
  },

  up: function(element, expression, index) {
    element = $(element);
    if (arguments.length == 1) return $(element.parentNode);
    var ancestors = Element.ancestors(element);
    return Object.isNumber(expression) ? ancestors[expression] :
      Selector.findElement(ancestors, expression, index);
  },

  down: function(element, expression, index) {
    element = $(element);
    if (arguments.length == 1) return Element.firstDescendant(element);
    return Object.isNumber(expression) ? Element.descendants(element)[expression] :
      Element.select(element, expression)[index || 0];
  },

  previous: function(element, expression, index) {
    element = $(element);
    if (arguments.length == 1) return $(Selector.handlers.previousElementSibling(element));
    var previousSiblings = Element.previousSiblings(element);
    return Object.isNumber(expression) ? previousSiblings[expression] :
      Selector.findElement(previousSiblings, expression, index);
  },

  next: function(element, expression, index) {
    element = $(element);
    if (arguments.length == 1) return $(Selector.handlers.nextElementSibling(element));
    var nextSiblings = Element.nextSiblings(element);
    return Object.isNumber(expression) ? nextSiblings[expression] :
      Selector.findElement(nextSiblings, expression, index);
  },


  select: function(element) {
    var args = Array.prototype.slice.call(arguments, 1);
    return Selector.findChildElements(element, args);
  },

  adjacent: function(element) {
    var args = Array.prototype.slice.call(arguments, 1);
    return Selector.findChildElements(element.parentNode, args).without(element);
  },

  identify: function(element) {
    element = $(element);
    var id = Element.readAttribute(element, 'id');
    if (id) return id;
    do { id = 'anonymous_element_' + Element.idCounter++ } while ($(id));
    Element.writeAttribute(element, 'id', id);
    return id;
  },

  readAttribute: function(element, name) {
    element = $(element);
    if (Prototype.Browser.IE) {
      var t = Element._attributeTranslations.read;
      if (t.values[name]) return t.values[name](element, name);
      if (t.names[name]) name = t.names[name];
      if (name.include(':')) {
        return (!element.attributes || !element.attributes[name]) ? null :
         element.attributes[name].value;
      }
    }
    return element.getAttribute(name);
  },

  writeAttribute: function(element, name, value) {
    element = $(element);
    var attributes = { }, t = Element._attributeTranslations.write;

    if (typeof name == 'object') attributes = name;
    else attributes[name] = Object.isUndefined(value) ? true : value;

    for (var attr in attributes) {
      name = t.names[attr] || attr;
      value = attributes[attr];
      if (t.values[attr]) name = t.values[attr](element, value);
      if (value === false || value === null)
        element.removeAttribute(name);
      else if (value === true)
        element.setAttribute(name, name);
      else element.setAttribute(name, value);
    }
    return element;
  },

  getHeight: function(element) {
    return Element.getDimensions(element).height;
  },

  getWidth: function(element) {
    return Element.getDimensions(element).width;
  },

  classNames: function(element) {
    return new Element.ClassNames(element);
  },

  hasClassName: function(element, className) {
    if (!(element = $(element))) return;
    var elementClassName = element.className;
    return (elementClassName.length > 0 && (elementClassName == className ||
      new RegExp("(^|\\s)" + className + "(\\s|$)").test(elementClassName)));
  },

  addClassName: function(element, className) {
    if (!(element = $(element))) return;
    if (!Element.hasClassName(element, className))
      element.className += (element.className ? ' ' : '') + className;
    return element;
  },

  removeClassName: function(element, className) {
    if (!(element = $(element))) return;
    element.className = element.className.replace(
      new RegExp("(^|\\s+)" + className + "(\\s+|$)"), ' ').strip();
    return element;
  },

  toggleClassName: function(element, className) {
    if (!(element = $(element))) return;
    return Element[Element.hasClassName(element, className) ?
      'removeClassName' : 'addClassName'](element, className);
  },

  cleanWhitespace: function(element) {
    element = $(element);
    var node = element.firstChild;
    while (node) {
      var nextNode = node.nextSibling;
      if (node.nodeType == 3 && !/\S/.test(node.nodeValue))
        element.removeChild(node);
      node = nextNode;
    }
    return element;
  },

  empty: function(element) {
    return $(element).innerHTML.blank();
  },

  descendantOf: function(element, ancestor) {
    element = $(element), ancestor = $(ancestor);

    if (element.compareDocumentPosition)
      return (element.compareDocumentPosition(ancestor) & 8) === 8;

    if (ancestor.contains)
      return ancestor.contains(element) && ancestor !== element;

    while (element = element.parentNode)
      if (element == ancestor) return true;

    return false;
  },

  scrollTo: function(element) {
    element = $(element);
    var pos = Element.cumulativeOffset(element);
    window.scrollTo(pos[0], pos[1]);
    return element;
  },

  getStyle: function(element, style) {
    element = $(element);
    style = style == 'float' ? 'cssFloat' : style.camelize();
    var value = element.style[style];
    if (!value || value == 'auto') {
      var css = document.defaultView.getComputedStyle(element, null);
      value = css ? css[style] : null;
    }
    if (style == 'opacity') return value ? parseFloat(value) : 1.0;
    return value == 'auto' ? null : value;
  },

  getOpacity: function(element) {
    return $(element).getStyle('opacity');
  },

  setStyle: function(element, styles) {
    element = $(element);
    var elementStyle = element.style, match;
    if (Object.isString(styles)) {
      element.style.cssText += ';' + styles;
      return styles.include('opacity') ?
        element.setOpacity(styles.match(/opacity:\s*(\d?\.?\d*)/)[1]) : element;
    }
    for (var property in styles)
      if (property == 'opacity') element.setOpacity(styles[property]);
      else
        elementStyle[(property == 'float' || property == 'cssFloat') ?
          (Object.isUndefined(elementStyle.styleFloat) ? 'cssFloat' : 'styleFloat') :
            property] = styles[property];

    return element;
  },

  setOpacity: function(element, value) {
    element = $(element);
    element.style.opacity = (value == 1 || value === '') ? '' :
      (value < 0.00001) ? 0 : value;
    return element;
  },

  getDimensions: function(element) {
    element = $(element);
    var display = Element.getStyle(element, 'display');
    if (display != 'none' && display != null) // Safari bug
      return {width: element.offsetWidth, height: element.offsetHeight};

    var els = element.style;
    var originalVisibility = els.visibility;
    var originalPosition = els.position;
    var originalDisplay = els.display;
    els.visibility = 'hidden';
    if (originalPosition != 'fixed') // Switching fixed to absolute causes issues in Safari
      els.position = 'absolute';
    els.display = 'block';
    var originalWidth = element.clientWidth;
    var originalHeight = element.clientHeight;
    els.display = originalDisplay;
    els.position = originalPosition;
    els.visibility = originalVisibility;
    return {width: originalWidth, height: originalHeight};
  },

  makePositioned: function(element) {
    element = $(element);
    var pos = Element.getStyle(element, 'position');
    if (pos == 'static' || !pos) {
      element._madePositioned = true;
      element.style.position = 'relative';
      if (Prototype.Browser.Opera) {
        element.style.top = 0;
        element.style.left = 0;
      }
    }
    return element;
  },

  undoPositioned: function(element) {
    element = $(element);
    if (element._madePositioned) {
      element._madePositioned = undefined;
      element.style.position =
        element.style.top =
        element.style.left =
        element.style.bottom =
        element.style.right = '';
    }
    return element;
  },

  makeClipping: function(element) {
    element = $(element);
    if (element._overflow) return element;
    element._overflow = Element.getStyle(element, 'overflow') || 'auto';
    if (element._overflow !== 'hidden')
      element.style.overflow = 'hidden';
    return element;
  },

  undoClipping: function(element) {
    element = $(element);
    if (!element._overflow) return element;
    element.style.overflow = element._overflow == 'auto' ? '' : element._overflow;
    element._overflow = null;
    return element;
  },

  cumulativeOffset: function(element) {
    var valueT = 0, valueL = 0;
    do {
      valueT += element.offsetTop  || 0;
      valueL += element.offsetLeft || 0;
      element = element.offsetParent;
    } while (element);
    return Element._returnOffset(valueL, valueT);
  },

  positionedOffset: function(element) {
    var valueT = 0, valueL = 0;
    do {
      valueT += element.offsetTop  || 0;
      valueL += element.offsetLeft || 0;
      element = element.offsetParent;
      if (element) {
        if (element.tagName.toUpperCase() == 'BODY') break;
        var p = Element.getStyle(element, 'position');
        if (p !== 'static') break;
      }
    } while (element);
    return Element._returnOffset(valueL, valueT);
  },

  absolutize: function(element) {
    element = $(element);
    if (Element.getStyle(element, 'position') == 'absolute') return element;

    var offsets = Element.positionedOffset(element);
    var top     = offsets[1];
    var left    = offsets[0];
    var width   = element.clientWidth;
    var height  = element.clientHeight;

    element._originalLeft   = left - parseFloat(element.style.left  || 0);
    element._originalTop    = top  - parseFloat(element.style.top || 0);
    element._originalWidth  = element.style.width;
    element._originalHeight = element.style.height;

    element.style.position = 'absolute';
    element.style.top    = top + 'px';
    element.style.left   = left + 'px';
    element.style.width  = width + 'px';
    element.style.height = height + 'px';
    return element;
  },

  relativize: function(element) {
    element = $(element);
    if (Element.getStyle(element, 'position') == 'relative') return element;

    element.style.position = 'relative';
    var top  = parseFloat(element.style.top  || 0) - (element._originalTop || 0);
    var left = parseFloat(element.style.left || 0) - (element._originalLeft || 0);

    element.style.top    = top + 'px';
    element.style.left   = left + 'px';
    element.style.height = element._originalHeight;
    element.style.width  = element._originalWidth;
    return element;
  },

  cumulativeScrollOffset: function(element) {
    var valueT = 0, valueL = 0;
    do {
      valueT += element.scrollTop  || 0;
      valueL += element.scrollLeft || 0;
      element = element.parentNode;
    } while (element);
    return Element._returnOffset(valueL, valueT);
  },

  getOffsetParent: function(element) {
    if (element.offsetParent) return $(element.offsetParent);
    if (element == document.body) return $(element);

    while ((element = element.parentNode) && element != document.body)
      if (Element.getStyle(element, 'position') != 'static')
        return $(element);

    return $(document.body);
  },

  viewportOffset: function(forElement) {
    var valueT = 0, valueL = 0;

    var element = forElement;
    do {
      valueT += element.offsetTop  || 0;
      valueL += element.offsetLeft || 0;

      if (element.offsetParent == document.body &&
        Element.getStyle(element, 'position') == 'absolute') break;

    } while (element = element.offsetParent);

    element = forElement;
    do {
      if (!Prototype.Browser.Opera || (element.tagName && (element.tagName.toUpperCase() == 'BODY'))) {
        valueT -= element.scrollTop  || 0;
        valueL -= element.scrollLeft || 0;
      }
    } while (element = element.parentNode);

    return Element._returnOffset(valueL, valueT);
  },

  clonePosition: function(element, source) {
    var options = Object.extend({
      setLeft:    true,
      setTop:     true,
      setWidth:   true,
      setHeight:  true,
      offsetTop:  0,
      offsetLeft: 0
    }, arguments[2] || { });

    source = $(source);
    var p = Element.viewportOffset(source);

    element = $(element);
    var delta = [0, 0];
    var parent = null;
    if (Element.getStyle(element, 'position') == 'absolute') {
      parent = Element.getOffsetParent(element);
      delta = Element.viewportOffset(parent);
    }

    if (parent == document.body) {
      delta[0] -= document.body.offsetLeft;
      delta[1] -= document.body.offsetTop;
    }

    if (options.setLeft)   element.style.left  = (p[0] - delta[0] + options.offsetLeft) + 'px';
    if (options.setTop)    element.style.top   = (p[1] - delta[1] + options.offsetTop) + 'px';
    if (options.setWidth)  element.style.width = source.offsetWidth + 'px';
    if (options.setHeight) element.style.height = source.offsetHeight + 'px';
    return element;
  }
};

Object.extend(Element.Methods, {
  getElementsBySelector: Element.Methods.select,

  childElements: Element.Methods.immediateDescendants
});

Element._attributeTranslations = {
  write: {
    names: {
      className: 'class',
      htmlFor:   'for'
    },
    values: { }
  }
};

if (Prototype.Browser.Opera) {
  Element.Methods.getStyle = Element.Methods.getStyle.wrap(
    function(proceed, element, style) {
      switch (style) {
        case 'left': case 'top': case 'right': case 'bottom':
          if (proceed(element, 'position') === 'static') return null;
        case 'height': case 'width':
          if (!Element.visible(element)) return null;

          var dim = parseInt(proceed(element, style), 10);

          if (dim !== element['offset' + style.capitalize()])
            return dim + 'px';

          var properties;
          if (style === 'height') {
            properties = ['border-top-width', 'padding-top',
             'padding-bottom', 'border-bottom-width'];
          }
          else {
            properties = ['border-left-width', 'padding-left',
             'padding-right', 'border-right-width'];
          }
          return properties.inject(dim, function(memo, property) {
            var val = proceed(element, property);
            return val === null ? memo : memo - parseInt(val, 10);
          }) + 'px';
        default: return proceed(element, style);
      }
    }
  );

  Element.Methods.readAttribute = Element.Methods.readAttribute.wrap(
    function(proceed, element, attribute) {
      if (attribute === 'title') return element.title;
      return proceed(element, attribute);
    }
  );
}

else if (Prototype.Browser.IE) {
  Element.Methods.getOffsetParent = Element.Methods.getOffsetParent.wrap(
    function(proceed, element) {
      element = $(element);
      try { element.offsetParent }
      catch(e) { return $(document.body) }
      var position = element.getStyle('position');
      if (position !== 'static') return proceed(element);
      element.setStyle({ position: 'relative' });
      var value = proceed(element);
      element.setStyle({ position: position });
      return value;
    }
  );

  $w('positionedOffset viewportOffset').each(function(method) {
    Element.Methods[method] = Element.Methods[method].wrap(
      function(proceed, element) {
        element = $(element);
        try { element.offsetParent }
        catch(e) { return Element._returnOffset(0,0) }
        var position = element.getStyle('position');
        if (position !== 'static') return proceed(element);
        var offsetParent = element.getOffsetParent();
        if (offsetParent && offsetParent.getStyle('position') === 'fixed')
          offsetParent.setStyle({ zoom: 1 });
        element.setStyle({ position: 'relative' });
        var value = proceed(element);
        element.setStyle({ position: position });
        return value;
      }
    );
  });

  Element.Methods.cumulativeOffset = Element.Methods.cumulativeOffset.wrap(
    function(proceed, element) {
      try { element.offsetParent }
      catch(e) { return Element._returnOffset(0,0) }
      return proceed(element);
    }
  );

  Element.Methods.getStyle = function(element, style) {
    element = $(element);
    style = (style == 'float' || style == 'cssFloat') ? 'styleFloat' : style.camelize();
    var value = element.style[style];
    if (!value && element.currentStyle) value = element.currentStyle[style];

    if (style == 'opacity') {
      if (value = (element.getStyle('filter') || '').match(/alpha\(opacity=(.*)\)/))
        if (value[1]) return parseFloat(value[1]) / 100;
      return 1.0;
    }

    if (value == 'auto') {
      if ((style == 'width' || style == 'height') && (element.getStyle('display') != 'none'))
        return element['offset' + style.capitalize()] + 'px';
      return null;
    }
    return value;
  };

  Element.Methods.setOpacity = function(element, value) {
    function stripAlpha(filter){
      return filter.replace(/alpha\([^\)]*\)/gi,'');
    }
    element = $(element);
    var currentStyle = element.currentStyle;
    if ((currentStyle && !currentStyle.hasLayout) ||
      (!currentStyle && element.style.zoom == 'normal'))
        element.style.zoom = 1;

    var filter = element.getStyle('filter'), style = element.style;
    if (value == 1 || value === '') {
      (filter = stripAlpha(filter)) ?
        style.filter = filter : style.removeAttribute('filter');
      return element;
    } else if (value < 0.00001) value = 0;
    style.filter = stripAlpha(filter) +
      'alpha(opacity=' + (value * 100) + ')';
    return element;
  };

  Element._attributeTranslations = (function(){

    var classProp = 'className';
    var forProp = 'for';

    var el = document.createElement('div');

    el.setAttribute(classProp, 'x');

    if (el.className !== 'x') {
      el.setAttribute('class', 'x');
      if (el.className === 'x') {
        classProp = 'class';
      }
    }
    el = null;

    el = document.createElement('label');
    el.setAttribute(forProp, 'x');
    if (el.htmlFor !== 'x') {
      el.setAttribute('htmlFor', 'x');
      if (el.htmlFor === 'x') {
        forProp = 'htmlFor';
      }
    }
    el = null;

    return {
      read: {
        names: {
          'class':      classProp,
          'className':  classProp,
          'for':        forProp,
          'htmlFor':    forProp
        },
        values: {
          _getAttr: function(element, attribute) {
            return element.getAttribute(attribute);
          },
          _getAttr2: function(element, attribute) {
            return element.getAttribute(attribute, 2);
          },
          _getAttrNode: function(element, attribute) {
            var node = element.getAttributeNode(attribute);
            return node ? node.value : "";
          },
          _getEv: (function(){

            var el = document.createElement('div');
            el.onclick = Prototype.emptyFunction;
            var value = el.getAttribute('onclick');
            var f;

            if (String(value).indexOf('{') > -1) {
              f = function(element, attribute) {
                attribute = element.getAttribute(attribute);
                if (!attribute) return null;
                attribute = attribute.toString();
                attribute = attribute.split('{')[1];
                attribute = attribute.split('}')[0];
                return attribute.strip();
              };
            }
            else if (value === '') {
              f = function(element, attribute) {
                attribute = element.getAttribute(attribute);
                if (!attribute) return null;
                return attribute.strip();
              };
            }
            el = null;
            return f;
          })(),
          _flag: function(element, attribute) {
            return $(element).hasAttribute(attribute) ? attribute : null;
          },
          style: function(element) {
            return element.style.cssText.toLowerCase();
          },
          title: function(element) {
            return element.title;
          }
        }
      }
    }
  })();

  Element._attributeTranslations.write = {
    names: Object.extend({
      cellpadding: 'cellPadding',
      cellspacing: 'cellSpacing'
    }, Element._attributeTranslations.read.names),
    values: {
      checked: function(element, value) {
        element.checked = !!value;
      },

      style: function(element, value) {
        element.style.cssText = value ? value : '';
      }
    }
  };

  Element._attributeTranslations.has = {};

  $w('colSpan rowSpan vAlign dateTime accessKey tabIndex ' +
      'encType maxLength readOnly longDesc frameBorder').each(function(attr) {
    Element._attributeTranslations.write.names[attr.toLowerCase()] = attr;
    Element._attributeTranslations.has[attr.toLowerCase()] = attr;
  });

  (function(v) {
    Object.extend(v, {
      href:        v._getAttr2,
      src:         v._getAttr2,
      type:        v._getAttr,
      action:      v._getAttrNode,
      disabled:    v._flag,
      checked:     v._flag,
      readonly:    v._flag,
      multiple:    v._flag,
      onload:      v._getEv,
      onunload:    v._getEv,
      onclick:     v._getEv,
      ondblclick:  v._getEv,
      onmousedown: v._getEv,
      onmouseup:   v._getEv,
      onmouseover: v._getEv,
      onmousemove: v._getEv,
      onmouseout:  v._getEv,
      onfocus:     v._getEv,
      onblur:      v._getEv,
      onkeypress:  v._getEv,
      onkeydown:   v._getEv,
      onkeyup:     v._getEv,
      onsubmit:    v._getEv,
      onreset:     v._getEv,
      onselect:    v._getEv,
      onchange:    v._getEv
    });
  })(Element._attributeTranslations.read.values);

  if (Prototype.BrowserFeatures.ElementExtensions) {
    (function() {
      function _descendants(element) {
        var nodes = element.getElementsByTagName('*'), results = [];
        for (var i = 0, node; node = nodes[i]; i++)
          if (node.tagName !== "!") // Filter out comment nodes.
            results.push(node);
        return results;
      }

      Element.Methods.down = function(element, expression, index) {
        element = $(element);
        if (arguments.length == 1) return element.firstDescendant();
        return Object.isNumber(expression) ? _descendants(element)[expression] :
          Element.select(element, expression)[index || 0];
      }
    })();
  }

}

else if (Prototype.Browser.Gecko && /rv:1\.8\.0/.test(navigator.userAgent)) {
  Element.Methods.setOpacity = function(element, value) {
    element = $(element);
    element.style.opacity = (value == 1) ? 0.999999 :
      (value === '') ? '' : (value < 0.00001) ? 0 : value;
    return element;
  };
}

else if (Prototype.Browser.WebKit) {
  Element.Methods.setOpacity = function(element, value) {
    element = $(element);
    element.style.opacity = (value == 1 || value === '') ? '' :
      (value < 0.00001) ? 0 : value;

    if (value == 1)
      if(element.tagName.toUpperCase() == 'IMG' && element.width) {
        element.width++; element.width--;
      } else try {
        var n = document.createTextNode(' ');
        element.appendChild(n);
        element.removeChild(n);
      } catch (e) { }

    return element;
  };

  Element.Methods.cumulativeOffset = function(element) {
    var valueT = 0, valueL = 0;
    do {
      valueT += element.offsetTop  || 0;
      valueL += element.offsetLeft || 0;
      if (element.offsetParent == document.body)
        if (Element.getStyle(element, 'position') == 'absolute') break;

      element = element.offsetParent;
    } while (element);

    return Element._returnOffset(valueL, valueT);
  };
}

if ('outerHTML' in document.documentElement) {
  Element.Methods.replace = function(element, content) {
    element = $(element);

    if (content && content.toElement) content = content.toElement();
    if (Object.isElement(content)) {
      element.parentNode.replaceChild(content, element);
      return element;
    }

    content = Object.toHTML(content);
    var parent = element.parentNode, tagName = parent.tagName.toUpperCase();

    if (Element._insertionTranslations.tags[tagName]) {
      var nextSibling = element.next();
      var fragments = Element._getContentFromAnonymousElement(tagName, content.stripScripts());
      parent.removeChild(element);
      if (nextSibling)
        fragments.each(function(node) { parent.insertBefore(node, nextSibling) });
      else
        fragments.each(function(node) { parent.appendChild(node) });
    }
    else element.outerHTML = content.stripScripts();

    content.evalScripts.bind(content).defer();
    return element;
  };
}

Element._returnOffset = function(l, t) {
  var result = [l, t];
  result.left = l;
  result.top = t;
  return result;
};

Element._getContentFromAnonymousElement = function(tagName, html) {
  var div = new Element('div'), t = Element._insertionTranslations.tags[tagName];
  if (t) {
    div.innerHTML = t[0] + html + t[1];
    t[2].times(function() { div = div.firstChild });
  } else div.innerHTML = html;
  return $A(div.childNodes);
};

Element._insertionTranslations = {
  before: function(element, node) {
    element.parentNode.insertBefore(node, element);
  },
  top: function(element, node) {
    element.insertBefore(node, element.firstChild);
  },
  bottom: function(element, node) {
    element.appendChild(node);
  },
  after: function(element, node) {
    element.parentNode.insertBefore(node, element.nextSibling);
  },
  tags: {
    TABLE:  ['<table>',                '</table>',                   1],
    TBODY:  ['<table><tbody>',         '</tbody></table>',           2],
    TR:     ['<table><tbody><tr>',     '</tr></tbody></table>',      3],
    TD:     ['<table><tbody><tr><td>', '</td></tr></tbody></table>', 4],
    SELECT: ['<select>',               '</select>',                  1]
  }
};

(function() {
  var tags = Element._insertionTranslations.tags;
  Object.extend(tags, {
    THEAD: tags.TBODY,
    TFOOT: tags.TBODY,
    TH:    tags.TD
  });
})();

Element.Methods.Simulated = {
  hasAttribute: function(element, attribute) {
    attribute = Element._attributeTranslations.has[attribute] || attribute;
    var node = $(element).getAttributeNode(attribute);
    return !!(node && node.specified);
  }
};

Element.Methods.ByTag = { };

Object.extend(Element, Element.Methods);

(function(div) {

  if (!Prototype.BrowserFeatures.ElementExtensions && div['__proto__']) {
    window.HTMLElement = { };
    window.HTMLElement.prototype = div['__proto__'];
    Prototype.BrowserFeatures.ElementExtensions = true;
  }

  div = null;

})(document.createElement('div'))

Element.extend = (function() {

  function checkDeficiency(tagName) {
    if (typeof window.Element != 'undefined') {
      var proto = window.Element.prototype;
      if (proto) {
        var id = '_' + (Math.random()+'').slice(2);
        var el = document.createElement(tagName);
        proto[id] = 'x';
        var isBuggy = (el[id] !== 'x');
        delete proto[id];
        el = null;
        return isBuggy;
      }
    }
    return false;
  }

  function extendElementWith(element, methods) {
    for (var property in methods) {
      var value = methods[property];
      if (Object.isFunction(value) && !(property in element))
        element[property] = value.methodize();
    }
  }

  var HTMLOBJECTELEMENT_PROTOTYPE_BUGGY = checkDeficiency('object');

  if (Prototype.BrowserFeatures.SpecificElementExtensions) {
    if (HTMLOBJECTELEMENT_PROTOTYPE_BUGGY) {
      return function(element) {
        if (element && typeof element._extendedByPrototype == 'undefined') {
          var t = element.tagName;
          if (t && (/^(?:object|applet|embed)$/i.test(t))) {
            extendElementWith(element, Element.Methods);
            extendElementWith(element, Element.Methods.Simulated);
            extendElementWith(element, Element.Methods.ByTag[t.toUpperCase()]);
          }
        }
        return element;
      }
    }
    return Prototype.K;
  }

  var Methods = { }, ByTag = Element.Methods.ByTag;

  var extend = Object.extend(function(element) {
    if (!element || typeof element._extendedByPrototype != 'undefined' ||
        element.nodeType != 1 || element == window) return element;

    var methods = Object.clone(Methods),
        tagName = element.tagName.toUpperCase();

    if (ByTag[tagName]) Object.extend(methods, ByTag[tagName]);

    extendElementWith(element, methods);

    element._extendedByPrototype = Prototype.emptyFunction;
    return element;

  }, {
    refresh: function() {
      if (!Prototype.BrowserFeatures.ElementExtensions) {
        Object.extend(Methods, Element.Methods);
        Object.extend(Methods, Element.Methods.Simulated);
      }
    }
  });

  extend.refresh();
  return extend;
})();

Element.hasAttribute = function(element, attribute) {
  if (element.hasAttribute) return element.hasAttribute(attribute);
  return Element.Methods.Simulated.hasAttribute(element, attribute);
};

Element.addMethods = function(methods) {
  var F = Prototype.BrowserFeatures, T = Element.Methods.ByTag;

  if (!methods) {
    Object.extend(Form, Form.Methods);
    Object.extend(Form.Element, Form.Element.Methods);
    Object.extend(Element.Methods.ByTag, {
      "FORM":     Object.clone(Form.Methods),
      "INPUT":    Object.clone(Form.Element.Methods),
      "SELECT":   Object.clone(Form.Element.Methods),
      "TEXTAREA": Object.clone(Form.Element.Methods)
    });
  }

  if (arguments.length == 2) {
    var tagName = methods;
    methods = arguments[1];
  }

  if (!tagName) Object.extend(Element.Methods, methods || { });
  else {
    if (Object.isArray(tagName)) tagName.each(extend);
    else extend(tagName);
  }

  function extend(tagName) {
    tagName = tagName.toUpperCase();
    if (!Element.Methods.ByTag[tagName])
      Element.Methods.ByTag[tagName] = { };
    Object.extend(Element.Methods.ByTag[tagName], methods);
  }

  function copy(methods, destination, onlyIfAbsent) {
    onlyIfAbsent = onlyIfAbsent || false;
    for (var property in methods) {
      var value = methods[property];
      if (!Object.isFunction(value)) continue;
      if (!onlyIfAbsent || !(property in destination))
        destination[property] = value.methodize();
    }
  }

  function findDOMClass(tagName) {
    var klass;
    var trans = {
      "OPTGROUP": "OptGroup", "TEXTAREA": "TextArea", "P": "Paragraph",
      "FIELDSET": "FieldSet", "UL": "UList", "OL": "OList", "DL": "DList",
      "DIR": "Directory", "H1": "Heading", "H2": "Heading", "H3": "Heading",
      "H4": "Heading", "H5": "Heading", "H6": "Heading", "Q": "Quote",
      "INS": "Mod", "DEL": "Mod", "A": "Anchor", "IMG": "Image", "CAPTION":
      "TableCaption", "COL": "TableCol", "COLGROUP": "TableCol", "THEAD":
      "TableSection", "TFOOT": "TableSection", "TBODY": "TableSection", "TR":
      "TableRow", "TH": "TableCell", "TD": "TableCell", "FRAMESET":
      "FrameSet", "IFRAME": "IFrame"
    };
    if (trans[tagName]) klass = 'HTML' + trans[tagName] + 'Element';
    if (window[klass]) return window[klass];
    klass = 'HTML' + tagName + 'Element';
    if (window[klass]) return window[klass];
    klass = 'HTML' + tagName.capitalize() + 'Element';
    if (window[klass]) return window[klass];

    var element = document.createElement(tagName);
    var proto = element['__proto__'] || element.constructor.prototype;
    element = null;
    return proto;
  }

  var elementPrototype = window.HTMLElement ? HTMLElement.prototype :
   Element.prototype;

  if (F.ElementExtensions) {
    copy(Element.Methods, elementPrototype);
    copy(Element.Methods.Simulated, elementPrototype, true);
  }

  if (F.SpecificElementExtensions) {
    for (var tag in Element.Methods.ByTag) {
      var klass = findDOMClass(tag);
      if (Object.isUndefined(klass)) continue;
      copy(T[tag], klass.prototype);
    }
  }

  Object.extend(Element, Element.Methods);
  delete Element.ByTag;

  if (Element.extend.refresh) Element.extend.refresh();
  Element.cache = { };
};


document.viewport = {

  getDimensions: function() {
    return { width: this.getWidth(), height: this.getHeight() };
  },

  getScrollOffsets: function() {
    return Element._returnOffset(
      window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft,
      window.pageYOffset || document.documentElement.scrollTop  || document.body.scrollTop);
  }
};

(function(viewport) {
  var B = Prototype.Browser, doc = document, element, property = {};

  function getRootElement() {
    if (B.WebKit && !doc.evaluate)
      return document;

    if (B.Opera && window.parseFloat(window.opera.version()) < 9.5)
      return document.body;

    return document.documentElement;
  }

  function define(D) {
    if (!element) element = getRootElement();

    property[D] = 'client' + D;

    viewport['get' + D] = function() { return element[property[D]] };
    return viewport['get' + D]();
  }

  viewport.getWidth  = define.curry('Width');

  viewport.getHeight = define.curry('Height');
})(document.viewport);


Element.Storage = {
  UID: 1
};

Element.addMethods({
  getStorage: function(element) {
    if (!(element = $(element))) return;

    var uid;
    if (element === window) {
      uid = 0;
    } else {
      if (typeof element._prototypeUID === "undefined")
        element._prototypeUID = [Element.Storage.UID++];
      uid = element._prototypeUID[0];
    }

    if (!Element.Storage[uid])
      Element.Storage[uid] = $H();

    return Element.Storage[uid];
  },

  store: function(element, key, value) {
    if (!(element = $(element))) return;

    if (arguments.length === 2) {
      Element.getStorage(element).update(key);
    } else {
      Element.getStorage(element).set(key, value);
    }

    return element;
  },

  retrieve: function(element, key, defaultValue) {
    if (!(element = $(element))) return;
    var hash = Element.getStorage(element), value = hash.get(key);

    if (Object.isUndefined(value)) {
      hash.set(key, defaultValue);
      value = defaultValue;
    }

    return value;
  },

  clone: function(element, deep) {
    if (!(element = $(element))) return;
    var clone = element.cloneNode(deep);
    clone._prototypeUID = void 0;
    if (deep) {
      var descendants = Element.select(clone, '*'),
          i = descendants.length;
      while (i--) {
        descendants[i]._prototypeUID = void 0;
      }
    }
    return Element.extend(clone);
  }
});
/* Portions of the Selector class are derived from Jack Slocum's DomQuery,
 * part of YUI-Ext version 0.40, distributed under the terms of an MIT-style
 * license.  Please see http://www.yui-ext.com/ for more information. */

var Selector = Class.create({
  initialize: function(expression) {
    this.expression = expression.strip();

    if (this.shouldUseSelectorsAPI()) {
      this.mode = 'selectorsAPI';
    } else if (this.shouldUseXPath()) {
      this.mode = 'xpath';
      this.compileXPathMatcher();
    } else {
      this.mode = "normal";
      this.compileMatcher();
    }

  },

  shouldUseXPath: (function() {

    var IS_DESCENDANT_SELECTOR_BUGGY = (function(){
      var isBuggy = false;
      if (document.evaluate && window.XPathResult) {
        var el = document.createElement('div');
        el.innerHTML = '<ul><li></li></ul><div><ul><li></li></ul></div>';

        var xpath = ".//*[local-name()='ul' or local-name()='UL']" +
          "//*[local-name()='li' or local-name()='LI']";

        var result = document.evaluate(xpath, el, null,
          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);

        isBuggy = (result.snapshotLength !== 2);
        el = null;
      }
      return isBuggy;
    })();

    return function() {
      if (!Prototype.BrowserFeatures.XPath) return false;

      var e = this.expression;

      if (Prototype.Browser.WebKit &&
       (e.include("-of-type") || e.include(":empty")))
        return false;

      if ((/(\[[\w-]*?:|:checked)/).test(e))
        return false;

      if (IS_DESCENDANT_SELECTOR_BUGGY) return false;

      return true;
    }

  })(),

  shouldUseSelectorsAPI: function() {
    if (!Prototype.BrowserFeatures.SelectorsAPI) return false;

    if (Selector.CASE_INSENSITIVE_CLASS_NAMES) return false;

    if (!Selector._div) Selector._div = new Element('div');

    try {
      Selector._div.querySelector(this.expression);
    } catch(e) {
      return false;
    }

    return true;
  },

  compileMatcher: function() {
    var e = this.expression, ps = Selector.patterns, h = Selector.handlers,
        c = Selector.criteria, le, p, m, len = ps.length, name;

    if (Selector._cache[e]) {
      this.matcher = Selector._cache[e];
      return;
    }

    this.matcher = ["this.matcher = function(root) {",
                    "var r = root, h = Selector.handlers, c = false, n;"];

    while (e && le != e && (/\S/).test(e)) {
      le = e;
      for (var i = 0; i<len; i++) {
        p = ps[i].re;
        name = ps[i].name;
        if (m = e.match(p)) {
          this.matcher.push(Object.isFunction(c[name]) ? c[name](m) :
            new Template(c[name]).evaluate(m));
          e = e.replace(m[0], '');
          break;
        }
      }
    }

    this.matcher.push("return h.unique(n);\n}");
    eval(this.matcher.join('\n'));
    Selector._cache[this.expression] = this.matcher;
  },

  compileXPathMatcher: function() {
    var e = this.expression, ps = Selector.patterns,
        x = Selector.xpath, le, m, len = ps.length, name;

    if (Selector._cache[e]) {
      this.xpath = Selector._cache[e]; return;
    }

    this.matcher = ['.//*'];
    while (e && le != e && (/\S/).test(e)) {
      le = e;
      for (var i = 0; i<len; i++) {
        name = ps[i].name;
        if (m = e.match(ps[i].re)) {
          this.matcher.push(Object.isFunction(x[name]) ? x[name](m) :
            new Template(x[name]).evaluate(m));
          e = e.replace(m[0], '');
          break;
        }
      }
    }

    this.xpath = this.matcher.join('');
    Selector._cache[this.expression] = this.xpath;
  },

  findElements: function(root) {
    root = root || document;
    var e = this.expression, results;

    switch (this.mode) {
      case 'selectorsAPI':
        if (root !== document) {
          var oldId = root.id, id = $(root).identify();
          id = id.replace(/([\.:])/g, "\\$1");
          e = "#" + id + " " + e;
        }

        results = $A(root.querySelectorAll(e)).map(Element.extend);
        root.id = oldId;

        return results;
      case 'xpath':
        return document._getElementsByXPath(this.xpath, root);
      default:
       return this.matcher(root);
    }
  },

  match: function(element) {
    this.tokens = [];

    var e = this.expression, ps = Selector.patterns, as = Selector.assertions;
    var le, p, m, len = ps.length, name;

    while (e && le !== e && (/\S/).test(e)) {
      le = e;
      for (var i = 0; i<len; i++) {
        p = ps[i].re;
        name = ps[i].name;
        if (m = e.match(p)) {
          if (as[name]) {
            this.tokens.push([name, Object.clone(m)]);
            e = e.replace(m[0], '');
          } else {
            return this.findElements(document).include(element);
          }
        }
      }
    }

    var match = true, name, matches;
    for (var i = 0, token; token = this.tokens[i]; i++) {
      name = token[0], matches = token[1];
      if (!Selector.assertions[name](element, matches)) {
        match = false; break;
      }
    }

    return match;
  },

  toString: function() {
    return this.expression;
  },

  inspect: function() {
    return "#<Selector:" + this.expression.inspect() + ">";
  }
});

if (Prototype.BrowserFeatures.SelectorsAPI &&
 document.compatMode === 'BackCompat') {
  Selector.CASE_INSENSITIVE_CLASS_NAMES = (function(){
    var div = document.createElement('div'),
     span = document.createElement('span');

    div.id = "prototype_test_id";
    span.className = 'Test';
    div.appendChild(span);
    var isIgnored = (div.querySelector('#prototype_test_id .test') !== null);
    div = span = null;
    return isIgnored;
  })();
}

Object.extend(Selector, {
  _cache: { },

  xpath: {
    descendant:   "//*",
    child:        "/*",
    adjacent:     "/following-sibling::*[1]",
    laterSibling: '/following-sibling::*',
    tagName:      function(m) {
      if (m[1] == '*') return '';
      return "[local-name()='" + m[1].toLowerCase() +
             "' or local-name()='" + m[1].toUpperCase() + "']";
    },
    className:    "[contains(concat(' ', @class, ' '), ' #{1} ')]",
    id:           "[@id='#{1}']",
    attrPresence: function(m) {
      m[1] = m[1].toLowerCase();
      return new Template("[@#{1}]").evaluate(m);
    },
    attr: function(m) {
      m[1] = m[1].toLowerCase();
      m[3] = m[5] || m[6];
      return new Template(Selector.xpath.operators[m[2]]).evaluate(m);
    },
    pseudo: function(m) {
      var h = Selector.xpath.pseudos[m[1]];
      if (!h) return '';
      if (Object.isFunction(h)) return h(m);
      return new Template(Selector.xpath.pseudos[m[1]]).evaluate(m);
    },
    operators: {
      '=':  "[@#{1}='#{3}']",
      '!=': "[@#{1}!='#{3}']",
      '^=': "[starts-with(@#{1}, '#{3}')]",
      '$=': "[substring(@#{1}, (string-length(@#{1}) - string-length('#{3}') + 1))='#{3}']",
      '*=': "[contains(@#{1}, '#{3}')]",
      '~=': "[contains(concat(' ', @#{1}, ' '), ' #{3} ')]",
      '|=': "[contains(concat('-', @#{1}, '-'), '-#{3}-')]"
    },
    pseudos: {
      'first-child': '[not(preceding-sibling::*)]',
      'last-child':  '[not(following-sibling::*)]',
      'only-child':  '[not(preceding-sibling::* or following-sibling::*)]',
      'empty':       "[count(*) = 0 and (count(text()) = 0)]",
      'checked':     "[@checked]",
      'disabled':    "[(@disabled) and (@type!='hidden')]",
      'enabled':     "[not(@disabled) and (@type!='hidden')]",
      'not': function(m) {
        var e = m[6], p = Selector.patterns,
            x = Selector.xpath, le, v, len = p.length, name;

        var exclusion = [];
        while (e && le != e && (/\S/).test(e)) {
          le = e;
          for (var i = 0; i<len; i++) {
            name = p[i].name
            if (m = e.match(p[i].re)) {
              v = Object.isFunction(x[name]) ? x[name](m) : new Template(x[name]).evaluate(m);
              exclusion.push("(" + v.substring(1, v.length - 1) + ")");
              e = e.replace(m[0], '');
              break;
            }
          }
        }
        return "[not(" + exclusion.join(" and ") + ")]";
      },
      'nth-child':      function(m) {
        return Selector.xpath.pseudos.nth("(count(./preceding-sibling::*) + 1) ", m);
      },
      'nth-last-child': function(m) {
        return Selector.xpath.pseudos.nth("(count(./following-sibling::*) + 1) ", m);
      },
      'nth-of-type':    function(m) {
        return Selector.xpath.pseudos.nth("position() ", m);
      },
      'nth-last-of-type': function(m) {
        return Selector.xpath.pseudos.nth("(last() + 1 - position()) ", m);
      },
      'first-of-type':  function(m) {
        m[6] = "1"; return Selector.xpath.pseudos['nth-of-type'](m);
      },
      'last-of-type':   function(m) {
        m[6] = "1"; return Selector.xpath.pseudos['nth-last-of-type'](m);
      },
      'only-of-type':   function(m) {
        var p = Selector.xpath.pseudos; return p['first-of-type'](m) + p['last-of-type'](m);
      },
      nth: function(fragment, m) {
        var mm, formula = m[6], predicate;
        if (formula == 'even') formula = '2n+0';
        if (formula == 'odd')  formula = '2n+1';
        if (mm = formula.match(/^(\d+)$/)) // digit only
          return '[' + fragment + "= " + mm[1] + ']';
        if (mm = formula.match(/^(-?\d*)?n(([+-])(\d+))?/)) { // an+b
          if (mm[1] == "-") mm[1] = -1;
          var a = mm[1] ? Number(mm[1]) : 1;
          var b = mm[2] ? Number(mm[2]) : 0;
          predicate = "[((#{fragment} - #{b}) mod #{a} = 0) and " +
          "((#{fragment} - #{b}) div #{a} >= 0)]";
          return new Template(predicate).evaluate({
            fragment: fragment, a: a, b: b });
        }
      }
    }
  },

  criteria: {
    tagName:      'n = h.tagName(n, r, "#{1}", c);      c = false;',
    className:    'n = h.className(n, r, "#{1}", c);    c = false;',
    id:           'n = h.id(n, r, "#{1}", c);           c = false;',
    attrPresence: 'n = h.attrPresence(n, r, "#{1}", c); c = false;',
    attr: function(m) {
      m[3] = (m[5] || m[6]);
      return new Template('n = h.attr(n, r, "#{1}", "#{3}", "#{2}", c); c = false;').evaluate(m);
    },
    pseudo: function(m) {
      if (m[6]) m[6] = m[6].replace(/"/g, '\\"');
      return new Template('n = h.pseudo(n, "#{1}", "#{6}", r, c); c = false;').evaluate(m);
    },
    descendant:   'c = "descendant";',
    child:        'c = "child";',
    adjacent:     'c = "adjacent";',
    laterSibling: 'c = "laterSibling";'
  },

  patterns: [
    { name: 'laterSibling', re: /^\s*~\s*/ },
    { name: 'child',        re: /^\s*>\s*/ },
    { name: 'adjacent',     re: /^\s*\+\s*/ },
    { name: 'descendant',   re: /^\s/ },

    { name: 'tagName',      re: /^\s*(\*|[\w\-]+)(\b|$)?/ },
    { name: 'id',           re: /^#([\w\-\*]+)(\b|$)/ },
    { name: 'className',    re: /^\.([\w\-\*]+)(\b|$)/ },
    { name: 'pseudo',       re: /^:((first|last|nth|nth-last|only)(-child|-of-type)|empty|checked|(en|dis)abled|not)(\((.*?)\))?(\b|$|(?=\s|[:+~>]))/ },
    { name: 'attrPresence', re: /^\[((?:[\w-]+:)?[\w-]+)\]/ },
    { name: 'attr',         re: /\[((?:[\w-]*:)?[\w-]+)\s*(?:([!^$*~|]?=)\s*((['"])([^\4]*?)\4|([^'"][^\]]*?)))?\]/ }
  ],

  assertions: {
    tagName: function(element, matches) {
      return matches[1].toUpperCase() == element.tagName.toUpperCase();
    },

    className: function(element, matches) {
      return Element.hasClassName(element, matches[1]);
    },

    id: function(element, matches) {
      return element.id === matches[1];
    },

    attrPresence: function(element, matches) {
      return Element.hasAttribute(element, matches[1]);
    },

    attr: function(element, matches) {
      var nodeValue = Element.readAttribute(element, matches[1]);
      return nodeValue && Selector.operators[matches[2]](nodeValue, matches[5] || matches[6]);
    }
  },

  handlers: {
    concat: function(a, b) {
      for (var i = 0, node; node = b[i]; i++)
        a.push(node);
      return a;
    },

    mark: function(nodes) {
      var _true = Prototype.emptyFunction;
      for (var i = 0, node; node = nodes[i]; i++)
        node._countedByPrototype = _true;
      return nodes;
    },

    unmark: (function(){

      var PROPERTIES_ATTRIBUTES_MAP = (function(){
        var el = document.createElement('div'),
            isBuggy = false,
            propName = '_countedByPrototype',
            value = 'x'
        el[propName] = value;
        isBuggy = (el.getAttribute(propName) === value);
        el = null;
        return isBuggy;
      })();

      return PROPERTIES_ATTRIBUTES_MAP ?
        function(nodes) {
          for (var i = 0, node; node = nodes[i]; i++)
            node.removeAttribute('_countedByPrototype');
          return nodes;
        } :
        function(nodes) {
          for (var i = 0, node; node = nodes[i]; i++)
            node._countedByPrototype = void 0;
          return nodes;
        }
    })(),

    index: function(parentNode, reverse, ofType) {
      parentNode._countedByPrototype = Prototype.emptyFunction;
      if (reverse) {
        for (var nodes = parentNode.childNodes, i = nodes.length - 1, j = 1; i >= 0; i--) {
          var node = nodes[i];
          if (node.nodeType == 1 && (!ofType || node._countedByPrototype)) node.nodeIndex = j++;
        }
      } else {
        for (var i = 0, j = 1, nodes = parentNode.childNodes; node = nodes[i]; i++)
          if (node.nodeType == 1 && (!ofType || node._countedByPrototype)) node.nodeIndex = j++;
      }
    },

    unique: function(nodes) {
      if (nodes.length == 0) return nodes;
      var results = [], n;
      for (var i = 0, l = nodes.length; i < l; i++)
        if (typeof (n = nodes[i])._countedByPrototype == 'undefined') {
          n._countedByPrototype = Prototype.emptyFunction;
          results.push(Element.extend(n));
        }
      return Selector.handlers.unmark(results);
    },

    descendant: function(nodes) {
      var h = Selector.handlers;
      for (var i = 0, results = [], node; node = nodes[i]; i++)
        h.concat(results, node.getElementsByTagName('*'));
      return results;
    },

    child: function(nodes) {
      var h = Selector.handlers;
      for (var i = 0, results = [], node; node = nodes[i]; i++) {
        for (var j = 0, child; child = node.childNodes[j]; j++)
          if (child.nodeType == 1 && child.tagName != '!') results.push(child);
      }
      return results;
    },

    adjacent: function(nodes) {
      for (var i = 0, results = [], node; node = nodes[i]; i++) {
        var next = this.nextElementSibling(node);
        if (next) results.push(next);
      }
      return results;
    },

    laterSibling: function(nodes) {
      var h = Selector.handlers;
      for (var i = 0, results = [], node; node = nodes[i]; i++)
        h.concat(results, Element.nextSiblings(node));
      return results;
    },

    nextElementSibling: function(node) {
      while (node = node.nextSibling)
        if (node.nodeType == 1) return node;
      return null;
    },

    previousElementSibling: function(node) {
      while (node = node.previousSibling)
        if (node.nodeType == 1) return node;
      return null;
    },

    tagName: function(nodes, root, tagName, combinator) {
      var uTagName = tagName.toUpperCase();
      var results = [], h = Selector.handlers;
      if (nodes) {
        if (combinator) {
          if (combinator == "descendant") {
            for (var i = 0, node; node = nodes[i]; i++)
              h.concat(results, node.getElementsByTagName(tagName));
            return results;
          } else nodes = this[combinator](nodes);
          if (tagName == "*") return nodes;
        }
        for (var i = 0, node; node = nodes[i]; i++)
          if (node.tagName.toUpperCase() === uTagName) results.push(node);
        return results;
      } else return root.getElementsByTagName(tagName);
    },

    id: function(nodes, root, id, combinator) {
      var targetNode = $(id), h = Selector.handlers;

      if (root == document) {
        if (!targetNode) return [];
        if (!nodes) return [targetNode];
      } else {
        if (!root.sourceIndex || root.sourceIndex < 1) {
          var nodes = root.getElementsByTagName('*');
          for (var j = 0, node; node = nodes[j]; j++) {
            if (node.id === id) return [node];
          }
        }
      }

      if (nodes) {
        if (combinator) {
          if (combinator == 'child') {
            for (var i = 0, node; node = nodes[i]; i++)
              if (targetNode.parentNode == node) return [targetNode];
          } else if (combinator == 'descendant') {
            for (var i = 0, node; node = nodes[i]; i++)
              if (Element.descendantOf(targetNode, node)) return [targetNode];
          } else if (combinator == 'adjacent') {
            for (var i = 0, node; node = nodes[i]; i++)
              if (Selector.handlers.previousElementSibling(targetNode) == node)
                return [targetNode];
          } else nodes = h[combinator](nodes);
        }
        for (var i = 0, node; node = nodes[i]; i++)
          if (node == targetNode) return [targetNode];
        return [];
      }
      return (targetNode && Element.descendantOf(targetNode, root)) ? [targetNode] : [];
    },

    className: function(nodes, root, className, combinator) {
      if (nodes && combinator) nodes = this[combinator](nodes);
      return Selector.handlers.byClassName(nodes, root, className);
    },

    byClassName: function(nodes, root, className) {
      if (!nodes) nodes = Selector.handlers.descendant([root]);
      var needle = ' ' + className + ' ';
      for (var i = 0, results = [], node, nodeClassName; node = nodes[i]; i++) {
        nodeClassName = node.className;
        if (nodeClassName.length == 0) continue;
        if (nodeClassName == className || (' ' + nodeClassName + ' ').include(needle))
          results.push(node);
      }
      return results;
    },

    attrPresence: function(nodes, root, attr, combinator) {
      if (!nodes) nodes = root.getElementsByTagName("*");
      if (nodes && combinator) nodes = this[combinator](nodes);
      var results = [];
      for (var i = 0, node; node = nodes[i]; i++)
        if (Element.hasAttribute(node, attr)) results.push(node);
      return results;
    },

    attr: function(nodes, root, attr, value, operator, combinator) {
      if (!nodes) nodes = root.getElementsByTagName("*");
      if (nodes && combinator) nodes = this[combinator](nodes);
      var handler = Selector.operators[operator], results = [];
      for (var i = 0, node; node = nodes[i]; i++) {
        var nodeValue = Element.readAttribute(node, attr);
        if (nodeValue === null) continue;
        if (handler(nodeValue, value)) results.push(node);
      }
      return results;
    },

    pseudo: function(nodes, name, value, root, combinator) {
      if (nodes && combinator) nodes = this[combinator](nodes);
      if (!nodes) nodes = root.getElementsByTagName("*");
      return Selector.pseudos[name](nodes, value, root);
    }
  },

  pseudos: {
    'first-child': function(nodes, value, root) {
      for (var i = 0, results = [], node; node = nodes[i]; i++) {
        if (Selector.handlers.previousElementSibling(node)) continue;
          results.push(node);
      }
      return results;
    },
    'last-child': function(nodes, value, root) {
      for (var i = 0, results = [], node; node = nodes[i]; i++) {
        if (Selector.handlers.nextElementSibling(node)) continue;
          results.push(node);
      }
      return results;
    },
    'only-child': function(nodes, value, root) {
      var h = Selector.handlers;
      for (var i = 0, results = [], node; node = nodes[i]; i++)
        if (!h.previousElementSibling(node) && !h.nextElementSibling(node))
          results.push(node);
      return results;
    },
    'nth-child':        function(nodes, formula, root) {
      return Selector.pseudos.nth(nodes, formula, root);
    },
    'nth-last-child':   function(nodes, formula, root) {
      return Selector.pseudos.nth(nodes, formula, root, true);
    },
    'nth-of-type':      function(nodes, formula, root) {
      return Selector.pseudos.nth(nodes, formula, root, false, true);
    },
    'nth-last-of-type': function(nodes, formula, root) {
      return Selector.pseudos.nth(nodes, formula, root, true, true);
    },
    'first-of-type':    function(nodes, formula, root) {
      return Selector.pseudos.nth(nodes, "1", root, false, true);
    },
    'last-of-type':     function(nodes, formula, root) {
      return Selector.pseudos.nth(nodes, "1", root, true, true);
    },
    'only-of-type':     function(nodes, formula, root) {
      var p = Selector.pseudos;
      return p['last-of-type'](p['first-of-type'](nodes, formula, root), formula, root);
    },

    getIndices: function(a, b, total) {
      if (a == 0) return b > 0 ? [b] : [];
      return $R(1, total).inject([], function(memo, i) {
        if (0 == (i - b) % a && (i - b) / a >= 0) memo.push(i);
        return memo;
      });
    },

    nth: function(nodes, formula, root, reverse, ofType) {
      if (nodes.length == 0) return [];
      if (formula == 'even') formula = '2n+0';
      if (formula == 'odd')  formula = '2n+1';
      var h = Selector.handlers, results = [], indexed = [], m;
      h.mark(nodes);
      for (var i = 0, node; node = nodes[i]; i++) {
        if (!node.parentNode._countedByPrototype) {
          h.index(node.parentNode, reverse, ofType);
          indexed.push(node.parentNode);
        }
      }
      if (formula.match(/^\d+$/)) { // just a number
        formula = Number(formula);
        for (var i = 0, node; node = nodes[i]; i++)
          if (node.nodeIndex == formula) results.push(node);
      } else if (m = formula.match(/^(-?\d*)?n(([+-])(\d+))?/)) { // an+b
        if (m[1] == "-") m[1] = -1;
        var a = m[1] ? Number(m[1]) : 1;
        var b = m[2] ? Number(m[2]) : 0;
        var indices = Selector.pseudos.getIndices(a, b, nodes.length);
        for (var i = 0, node, l = indices.length; node = nodes[i]; i++) {
          for (var j = 0; j < l; j++)
            if (node.nodeIndex == indices[j]) results.push(node);
        }
      }
      h.unmark(nodes);
      h.unmark(indexed);
      return results;
    },

    'empty': function(nodes, value, root) {
      for (var i = 0, results = [], node; node = nodes[i]; i++) {
        if (node.tagName == '!' || node.firstChild) continue;
        results.push(node);
      }
      return results;
    },

    'not': function(nodes, selector, root) {
      var h = Selector.handlers, selectorType, m;
      var exclusions = new Selector(selector).findElements(root);
      h.mark(exclusions);
      for (var i = 0, results = [], node; node = nodes[i]; i++)
        if (!node._countedByPrototype) results.push(node);
      h.unmark(exclusions);
      return results;
    },

    'enabled': function(nodes, value, root) {
      for (var i = 0, results = [], node; node = nodes[i]; i++)
        if (!node.disabled && (!node.type || node.type !== 'hidden'))
          results.push(node);
      return results;
    },

    'disabled': function(nodes, value, root) {
      for (var i = 0, results = [], node; node = nodes[i]; i++)
        if (node.disabled) results.push(node);
      return results;
    },

    'checked': function(nodes, value, root) {
      for (var i = 0, results = [], node; node = nodes[i]; i++)
        if (node.checked) results.push(node);
      return results;
    }
  },

  operators: {
    '=':  function(nv, v) { return nv == v; },
    '!=': function(nv, v) { return nv != v; },
    '^=': function(nv, v) { return nv == v || nv && nv.startsWith(v); },
    '$=': function(nv, v) { return nv == v || nv && nv.endsWith(v); },
    '*=': function(nv, v) { return nv == v || nv && nv.include(v); },
    '~=': function(nv, v) { return (' ' + nv + ' ').include(' ' + v + ' '); },
    '|=': function(nv, v) { return ('-' + (nv || "").toUpperCase() +
     '-').include('-' + (v || "").toUpperCase() + '-'); }
  },

  split: function(expression) {
    var expressions = [];
    expression.scan(/(([\w#:.~>+()\s-]+|\*|\[.*?\])+)\s*(,|$)/, function(m) {
      expressions.push(m[1].strip());
    });
    return expressions;
  },

  matchElements: function(elements, expression) {
    var matches = $$(expression), h = Selector.handlers;
    h.mark(matches);
    for (var i = 0, results = [], element; element = elements[i]; i++)
      if (element._countedByPrototype) results.push(element);
    h.unmark(matches);
    return results;
  },

  findElement: function(elements, expression, index) {
    if (Object.isNumber(expression)) {
      index = expression; expression = false;
    }
    return Selector.matchElements(elements, expression || '*')[index || 0];
  },

  findChildElements: function(element, expressions) {
    expressions = Selector.split(expressions.join(','));
    var results = [], h = Selector.handlers;
    for (var i = 0, l = expressions.length, selector; i < l; i++) {
      selector = new Selector(expressions[i].strip());
      h.concat(results, selector.findElements(element));
    }
    return (l > 1) ? h.unique(results) : results;
  }
});

if (Prototype.Browser.IE) {
  Object.extend(Selector.handlers, {
    concat: function(a, b) {
      for (var i = 0, node; node = b[i]; i++)
        if (node.tagName !== "!") a.push(node);
      return a;
    }
  });
}

function $$() {
  return Selector.findChildElements(document, $A(arguments));
}

var Form = {
  reset: function(form) {
    form = $(form);
    form.reset();
    return form;
  },

  serializeElements: function(elements, options) {
    if (typeof options != 'object') options = { hash: !!options };
    else if (Object.isUndefined(options.hash)) options.hash = true;
    var key, value, submitted = false, submit = options.submit;

    var data = elements.inject({ }, function(result, element) {
      if (!element.disabled && element.name) {
        key = element.name; value = $(element).getValue();
        if (value != null && element.type != 'file' && (element.type != 'submit' || (!submitted &&
            submit !== false && (!submit || key == submit) && (submitted = true)))) {
          if (key in result) {
            if (!Object.isArray(result[key])) result[key] = [result[key]];
            result[key].push(value);
          }
          else result[key] = value;
        }
      }
      return result;
    });

    return options.hash ? data : Object.toQueryString(data);
  }
};

Form.Methods = {
  serialize: function(form, options) {
    return Form.serializeElements(Form.getElements(form), options);
  },

  getElements: function(form) {
    var elements = $(form).getElementsByTagName('*'),
        element,
        arr = [ ],
        serializers = Form.Element.Serializers;
    for (var i = 0; element = elements[i]; i++) {
      arr.push(element);
    }
    return arr.inject([], function(elements, child) {
      if (serializers[child.tagName.toLowerCase()])
        elements.push(Element.extend(child));
      return elements;
    })
  },

  getInputs: function(form, typeName, name) {
    form = $(form);
    var inputs = form.getElementsByTagName('input');

    if (!typeName && !name) return $A(inputs).map(Element.extend);

    for (var i = 0, matchingInputs = [], length = inputs.length; i < length; i++) {
      var input = inputs[i];
      if ((typeName && input.type != typeName) || (name && input.name != name))
        continue;
      matchingInputs.push(Element.extend(input));
    }

    return matchingInputs;
  },

  disable: function(form) {
    form = $(form);
    Form.getElements(form).invoke('disable');
    return form;
  },

  enable: function(form) {
    form = $(form);
    Form.getElements(form).invoke('enable');
    return form;
  },

  findFirstElement: function(form) {
    var elements = $(form).getElements().findAll(function(element) {
      return 'hidden' != element.type && !element.disabled;
    });
    var firstByIndex = elements.findAll(function(element) {
      return element.hasAttribute('tabIndex') && element.tabIndex >= 0;
    }).sortBy(function(element) { return element.tabIndex }).first();

    return firstByIndex ? firstByIndex : elements.find(function(element) {
      return /^(?:input|select|textarea)$/i.test(element.tagName);
    });
  },

  focusFirstElement: function(form) {
    form = $(form);
    form.findFirstElement().activate();
    return form;
  },

  request: function(form, options) {
    form = $(form), options = Object.clone(options || { });

    var params = options.parameters, action = form.readAttribute('action') || '';
    if (action.blank()) action = window.location.href;
    options.parameters = form.serialize(true);

    if (params) {
      if (Object.isString(params)) params = params.toQueryParams();
      Object.extend(options.parameters, params);
    }

    if (form.hasAttribute('method') && !options.method)
      options.method = form.method;

    return new Ajax.Request(action, options);
  }
};

/*--------------------------------------------------------------------------*/


Form.Element = {
  focus: function(element) {
    $(element).focus();
    return element;
  },

  select: function(element) {
    $(element).select();
    return element;
  }
};

Form.Element.Methods = {

  serialize: function(element) {
    element = $(element);
    if (!element.disabled && element.name) {
      var value = element.getValue();
      if (value != undefined) {
        var pair = { };
        pair[element.name] = value;
        return Object.toQueryString(pair);
      }
    }
    return '';
  },

  getValue: function(element) {
    element = $(element);
    var method = element.tagName.toLowerCase();
    return Form.Element.Serializers[method](element);
  },

  setValue: function(element, value) {
    element = $(element);
    var method = element.tagName.toLowerCase();
    Form.Element.Serializers[method](element, value);
    return element;
  },

  clear: function(element) {
    $(element).value = '';
    return element;
  },

  present: function(element) {
    return $(element).value != '';
  },

  activate: function(element) {
    element = $(element);
    try {
      element.focus();
      if (element.select && (element.tagName.toLowerCase() != 'input' ||
          !(/^(?:button|reset|submit)$/i.test(element.type))))
        element.select();
    } catch (e) { }
    return element;
  },

  disable: function(element) {
    element = $(element);
    element.disabled = true;
    return element;
  },

  enable: function(element) {
    element = $(element);
    element.disabled = false;
    return element;
  }
};

/*--------------------------------------------------------------------------*/

var Field = Form.Element;

var $F = Form.Element.Methods.getValue;

/*--------------------------------------------------------------------------*/

Form.Element.Serializers = {
  input: function(element, value) {
    switch (element.type.toLowerCase()) {
      case 'checkbox':
      case 'radio':
        return Form.Element.Serializers.inputSelector(element, value);
      default:
        return Form.Element.Serializers.textarea(element, value);
    }
  },

  inputSelector: function(element, value) {
    if (Object.isUndefined(value)) return element.checked ? element.value : null;
    else element.checked = !!value;
  },

  textarea: function(element, value) {
    if (Object.isUndefined(value)) return element.value;
    else element.value = value;
  },

  select: function(element, value) {
    if (Object.isUndefined(value))
      return this[element.type == 'select-one' ?
        'selectOne' : 'selectMany'](element);
    else {
      var opt, currentValue, single = !Object.isArray(value);
      for (var i = 0, length = element.length; i < length; i++) {
        opt = element.options[i];
        currentValue = this.optionValue(opt);
        if (single) {
          if (currentValue == value) {
            opt.selected = true;
            return;
          }
        }
        else opt.selected = value.include(currentValue);
      }
    }
  },

  selectOne: function(element) {
    var index = element.selectedIndex;
    return index >= 0 ? this.optionValue(element.options[index]) : null;
  },

  selectMany: function(element) {
    var values, length = element.length;
    if (!length) return null;

    for (var i = 0, values = []; i < length; i++) {
      var opt = element.options[i];
      if (opt.selected) values.push(this.optionValue(opt));
    }
    return values;
  },

  optionValue: function(opt) {
    return Element.extend(opt).hasAttribute('value') ? opt.value : opt.text;
  }
};

/*--------------------------------------------------------------------------*/


Abstract.TimedObserver = Class.create(PeriodicalExecuter, {
  initialize: function($super, element, frequency, callback) {
    $super(callback, frequency);
    this.element   = $(element);
    this.lastValue = this.getValue();
  },

  execute: function() {
    var value = this.getValue();
    if (Object.isString(this.lastValue) && Object.isString(value) ?
        this.lastValue != value : String(this.lastValue) != String(value)) {
      this.callback(this.element, value);
      this.lastValue = value;
    }
  }
});

Form.Element.Observer = Class.create(Abstract.TimedObserver, {
  getValue: function() {
    return Form.Element.getValue(this.element);
  }
});

Form.Observer = Class.create(Abstract.TimedObserver, {
  getValue: function() {
    return Form.serialize(this.element);
  }
});

/*--------------------------------------------------------------------------*/

Abstract.EventObserver = Class.create({
  initialize: function(element, callback) {
    this.element  = $(element);
    this.callback = callback;

    this.lastValue = this.getValue();
    if (this.element.tagName.toLowerCase() == 'form')
      this.registerFormCallbacks();
    else
      this.registerCallback(this.element);
  },

  onElementEvent: function() {
    var value = this.getValue();
    if (this.lastValue != value) {
      this.callback(this.element, value);
      this.lastValue = value;
    }
  },

  registerFormCallbacks: function() {
    Form.getElements(this.element).each(this.registerCallback, this);
  },

  registerCallback: function(element) {
    if (element.type) {
      switch (element.type.toLowerCase()) {
        case 'checkbox':
        case 'radio':
          PrototypeEvent.observe(element, 'click', this.onElementEvent.bind(this));
          break;
        default:
          PrototypeEvent.observe(element, 'change', this.onElementEvent.bind(this));
          break;
      }
    }
  }
});

Form.Element.EventObserver = Class.create(Abstract.EventObserver, {
  getValue: function() {
    return Form.Element.getValue(this.element);
  }
});

Form.EventObserver = Class.create(Abstract.EventObserver, {
  getValue: function() {
    return Form.serialize(this.element);
  }
});
(function() {

  var Event = {
    KEY_BACKSPACE: 8,
    KEY_TAB:       9,
    KEY_RETURN:   13,
    KEY_ESC:      27,
    KEY_LEFT:     37,
    KEY_UP:       38,
    KEY_RIGHT:    39,
    KEY_DOWN:     40,
    KEY_DELETE:   46,
    KEY_HOME:     36,
    KEY_END:      35,
    KEY_PAGEUP:   33,
    KEY_PAGEDOWN: 34,
    KEY_INSERT:   45,

    cache: {}
  };

  var PrototypeEvent = Event;

  var docEl = document.documentElement;
  var MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED = 'onmouseenter' in docEl
    && 'onmouseleave' in docEl;

  var _isButton;
  if (Prototype.Browser.IE) {
    var buttonMap = { 0: 1, 1: 4, 2: 2 };
    _isButton = function(event, code) {
      return event.button === buttonMap[code];
    };
  } else if (Prototype.Browser.WebKit) {
    _isButton = function(event, code) {
      switch (code) {
        case 0: return event.which == 1 && !event.metaKey;
        case 1: return event.which == 1 && event.metaKey;
        default: return false;
      }
    };
  } else {
    _isButton = function(event, code) {
      return event.which ? (event.which === code + 1) : (event.button === code);
    };
  }

  function isLeftClick(event)   { return _isButton(event, 0) }

  function isMiddleClick(event) { return _isButton(event, 1) }

  function isRightClick(event)  { return _isButton(event, 2) }

  function element(event) {
    event = PrototypeEvent.extend(event);

    var node = event.target, type = event.type,
     currentTarget = event.currentTarget;

    if (currentTarget && currentTarget.tagName) {
      if (type === 'load' || type === 'error' ||
        (type === 'click' && currentTarget.tagName.toLowerCase() === 'input'
          && currentTarget.type === 'radio'))
            node = currentTarget;
    }

    if (node.nodeType == Node.TEXT_NODE)
      node = node.parentNode;

    return Element.extend(node);
  }

  function findElement(event, expression) {
    var element = PrototypeEvent.element(event);
    if (!expression) return element;
    var elements = [element].concat(element.ancestors());
    return Selector.findElement(elements, expression, 0);
  }

  function pointer(event) {
    return { x: pointerX(event), y: pointerY(event) };
  }

  function pointerX(event) {
    var docElement = document.documentElement,
     body = document.body || { scrollLeft: 0 };

    return event.pageX || (event.clientX +
      (docElement.scrollLeft || body.scrollLeft) -
      (docElement.clientLeft || 0));
  }

  function pointerY(event) {
    var docElement = document.documentElement,
     body = document.body || { scrollTop: 0 };

    return  event.pageY || (event.clientY +
       (docElement.scrollTop || body.scrollTop) -
       (docElement.clientTop || 0));
  }


  function stop(event) {
    PrototypeEvent.extend(event);
    event.preventDefault();
    event.stopPropagation();

    event.stopped = true;
  }

  Event.Methods = {
    isLeftClick: isLeftClick,
    isMiddleClick: isMiddleClick,
    isRightClick: isRightClick,

    element: element,
    findElement: findElement,

    pointer: pointer,
    pointerX: pointerX,
    pointerY: pointerY,

    stop: stop
  };


  var methods = Object.keys(PrototypeEvent.Methods).inject({ }, function(m, name) {
    m[name] = PrototypeEvent.Methods[name].methodize();
    return m;
  });

  if (Prototype.Browser.IE) {
    function _relatedTarget(event) {
      var element;
      switch (event.type) {
        case 'mouseover': element = event.fromElement; break;
        case 'mouseout':  element = event.toElement;   break;
        default: return null;
      }
      return Element.extend(element);
    }

    Object.extend(methods, {
      stopPropagation: function() { this.cancelBubble = true },
      preventDefault:  function() { this.returnValue = false },
      inspect: function() { return '[object Event]' }
    });

    Event.extend = function(event, element) {
      if (!event) return false;
      if (event._extendedByPrototype) return event;

      event._extendedByPrototype = Prototype.emptyFunction;
      var pointer = PrototypeEvent.pointer(event);

      Object.extend(event, {
        target: event.srcElement || element,
        relatedTarget: _relatedTarget(event),
        pageX:  pointer.x,
        pageY:  pointer.y
      });

      return Object.extend(event, methods);
    };
  } else {
    Event.prototype = window.Event.prototype || document.createEvent('HTMLEvents').__proto__;
    Object.extend(Event.prototype, methods);
    Event.extend = Prototype.K;
  }

  function _createResponder(element, eventName, handler) {
    var registry = Element.retrieve(element, 'prototype_event_registry');

    if (Object.isUndefined(registry)) {
      CACHE.push(element);
      registry = Element.retrieve(element, 'prototype_event_registry', $H());
    }

    var respondersForEvent = registry.get(eventName);
    if (Object.isUndefined(respondersForEvent)) {
      respondersForEvent = [];
      registry.set(eventName, respondersForEvent);
    }

    if (respondersForEvent.pluck('handler').include(handler)) return false;

    var responder;
    if (eventName.include(":")) {
      responder = function(event) {
        if (Object.isUndefined(event.eventName))
          return false;

        if (event.eventName !== eventName)
          return false;

        Event.extend(event, element);
        handler.call(element, event);
      };
    } else {
      if (!MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED &&
       (eventName === "mouseenter" || eventName === "mouseleave")) {
        if (eventName === "mouseenter" || eventName === "mouseleave") {
          responder = function(event) {
            Event.extend(event, element);

            var parent = event.relatedTarget;
            while (parent && parent !== element) {
              try { parent = parent.parentNode; }
              catch(e) { parent = element; }
            }

            if (parent === element) return;

            handler.call(element, event);
          };
        }
      } else {
        responder = function(event) {
          Event.extend(event, element);
          handler.call(element, event);
        };
      }
    }

    responder.handler = handler;
    respondersForEvent.push(responder);
    return responder;
  }

  function _destroyCache() {
    for (var i = 0, length = CACHE.length; i < length; i++) {
      Event.stopObserving(CACHE[i]);
      CACHE[i] = null;
    }
  }

  var CACHE = [];

  if (Prototype.Browser.IE)
    window.attachEvent('onunload', _destroyCache);

  if (Prototype.Browser.WebKit)
    window.addEventListener('unload', Prototype.emptyFunction, false);


  var _getDOMEventName = Prototype.K;

  if (!MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED) {
    _getDOMEventName = function(eventName) {
      var translations = { mouseenter: "mouseover", mouseleave: "mouseout" };
      return eventName in translations ? translations[eventName] : eventName;
    };
  }

  function observe(element, eventName, handler) {
    element = $(element);

    var responder = _createResponder(element, eventName, handler);

    if (!responder) return element;

    if (eventName.include(':')) {
      if (element.addEventListener)
        element.addEventListener("dataavailable", responder, false);
      else {
        element.attachEvent("ondataavailable", responder);
        element.attachEvent("onfilterchange", responder);
      }
    } else {
      var actualEventName = _getDOMEventName(eventName);

      if (element.addEventListener)
        element.addEventListener(actualEventName, responder, false);
      else
        element.attachEvent("on" + actualEventName, responder);
    }

    return element;
  }

  function stopObserving(element, eventName, handler) {
    element = $(element);

    var registry = Element.retrieve(element, 'prototype_event_registry');

    if (Object.isUndefined(registry)) return element;

    if (eventName && !handler) {
      var responders = registry.get(eventName);

      if (Object.isUndefined(responders)) return element;

      responders.each( function(r) {
        Element.stopObserving(element, eventName, r.handler);
      });
      return element;
    } else if (!eventName) {
      registry.each( function(pair) {
        var eventName = pair.key, responders = pair.value;

        responders.each( function(r) {
          Element.stopObserving(element, eventName, r.handler);
        });
      });
      return element;
    }

    var responders = registry.get(eventName);

    if (!responders) return;

    var responder = responders.find( function(r) { return r.handler === handler; });
    if (!responder) return element;

    var actualEventName = _getDOMEventName(eventName);

    if (eventName.include(':')) {
      if (element.removeEventListener)
        element.removeEventListener("dataavailable", responder, false);
      else {
        element.detachEvent("ondataavailable", responder);
        element.detachEvent("onfilterchange",  responder);
      }
    } else {
      if (element.removeEventListener)
        element.removeEventListener(actualEventName, responder, false);
      else
        element.detachEvent('on' + actualEventName, responder);
    }

    registry.set(eventName, responders.without(responder));

    return element;
  }

  function fire(element, eventName, memo, bubble) {
    element = $(element);

    if (Object.isUndefined(bubble))
      bubble = true;

    if (element == document && document.createEvent && !element.dispatchEvent)
      element = document.documentElement;

    var event;
    if (document.createEvent) {
      event = document.createEvent('HTMLEvents');
      event.initEvent('dataavailable', true, true);
    } else {
      event = document.createEventObject();
      event.eventType = bubble ? 'ondataavailable' : 'onfilterchange';
    }

    event.eventName = eventName;
    event.memo = memo || { };

    if (document.createEvent)
      element.dispatchEvent(event);
    else
      element.fireEvent(event.eventType, event);

    return Event.extend(event);
  }


  Object.extend(Event, Event.Methods);

  Object.extend(Event, {
    fire:          fire,
    observe:       observe,
    stopObserving: stopObserving
  });

  Element.addMethods({
    fire:          fire,

    observe:       observe,

    stopObserving: stopObserving
  });

  Object.extend(document, {
    fire:          fire.methodize(),

    observe:       observe.methodize(),

    stopObserving: stopObserving.methodize(),

    loaded:        false
  });

  if (window.Event) Object.extend(window.Event, Event);
  else window.Event = Event;
})();

(function() {
  /* Support for the DOMContentLoaded event is based on work by Dan Webb,
     Matthias Miller, Dean Edwards, John Resig, and Diego Perini. */

  var timer;

  function fireContentLoadedEvent() {
    if (document.loaded) return;
    if (timer) window.clearTimeout(timer);
    document.loaded = true;
    document.fire('dom:loaded');
  }

  function checkReadyState() {
    if (document.readyState === 'complete') {
      document.stopObserving('readystatechange', checkReadyState);
      fireContentLoadedEvent();
    }
  }

  function pollDoScroll() {
    try { document.documentElement.doScroll('left'); }
    catch(e) {
      timer = pollDoScroll.defer();
      return;
    }
    fireContentLoadedEvent();
  }

  if (document.addEventListener) {
    document.addEventListener('DOMContentLoaded', fireContentLoadedEvent, false);
  } else {
    document.observe('readystatechange', checkReadyState);
    if (window == top)
      timer = pollDoScroll.defer();
  }

  Event.observe(window, 'load', fireContentLoadedEvent);
})();

Element.addMethods();

/*------------------------------- DEPRECATED -------------------------------*/

Hash.toQueryString = Object.toQueryString;

var Toggle = { display: Element.toggle };

Element.Methods.childOf = Element.Methods.descendantOf;

var Insertion = {
  Before: function(element, content) {
    return Element.insert(element, {before:content});
  },

  Top: function(element, content) {
    return Element.insert(element, {top:content});
  },

  Bottom: function(element, content) {
    return Element.insert(element, {bottom:content});
  },

  After: function(element, content) {
    return Element.insert(element, {after:content});
  }
};

var $continue = new Error('"throw $continue" is deprecated, use "return" instead');

var Position = {
  includeScrollOffsets: false,

  prepare: function() {
    this.deltaX =  window.pageXOffset
                || document.documentElement.scrollLeft
                || document.body.scrollLeft
                || 0;
    this.deltaY =  window.pageYOffset
                || document.documentElement.scrollTop
                || document.body.scrollTop
                || 0;
  },

  within: function(element, x, y) {
    if (this.includeScrollOffsets)
      return this.withinIncludingScrolloffsets(element, x, y);
    this.xcomp = x;
    this.ycomp = y;
    this.offset = Element.cumulativeOffset(element);

    return (y >= this.offset[1] &&
            y <  this.offset[1] + element.offsetHeight &&
            x >= this.offset[0] &&
            x <  this.offset[0] + element.offsetWidth);
  },

  withinIncludingScrolloffsets: function(element, x, y) {
    var offsetcache = Element.cumulativeScrollOffset(element);

    this.xcomp = x + offsetcache[0] - this.deltaX;
    this.ycomp = y + offsetcache[1] - this.deltaY;
    this.offset = Element.cumulativeOffset(element);

    return (this.ycomp >= this.offset[1] &&
            this.ycomp <  this.offset[1] + element.offsetHeight &&
            this.xcomp >= this.offset[0] &&
            this.xcomp <  this.offset[0] + element.offsetWidth);
  },

  overlap: function(mode, element) {
    if (!mode) return 0;
    if (mode == 'vertical')
      return ((this.offset[1] + element.offsetHeight) - this.ycomp) /
        element.offsetHeight;
    if (mode == 'horizontal')
      return ((this.offset[0] + element.offsetWidth) - this.xcomp) /
        element.offsetWidth;
  },


  cumulativeOffset: Element.Methods.cumulativeOffset,

  positionedOffset: Element.Methods.positionedOffset,

  absolutize: function(element) {
    Position.prepare();
    return Element.absolutize(element);
  },

  relativize: function(element) {
    Position.prepare();
    return Element.relativize(element);
  },

  realOffset: Element.Methods.cumulativeScrollOffset,

  offsetParent: Element.Methods.getOffsetParent,

  page: Element.Methods.viewportOffset,

  clone: function(source, target, options) {
    options = options || { };
    return Element.clonePosition(target, source, options);
  }
};

/*--------------------------------------------------------------------------*/

if (!document.getElementsByClassName) document.getElementsByClassName = function(instanceMethods){
  function iter(name) {
    return name.blank() ? null : "[contains(concat(' ', @class, ' '), ' " + name + " ')]";
  }

  instanceMethods.getElementsByClassName = Prototype.BrowserFeatures.XPath ?
  function(element, className) {
    className = className.toString().strip();
    var cond = /\s/.test(className) ? $w(className).map(iter).join('') : iter(className);
    return cond ? document._getElementsByXPath('.//*' + cond, element) : [];
  } : function(element, className) {
    className = className.toString().strip();
    var elements = [], classNames = (/\s/.test(className) ? $w(className) : null);
    if (!classNames && !className) return elements;

    var nodes = $(element).getElementsByTagName('*');
    className = ' ' + className + ' ';

    for (var i = 0, child, cn; child = nodes[i]; i++) {
      if (child.className && (cn = ' ' + child.className + ' ') && (cn.include(className) ||
          (classNames && classNames.all(function(name) {
            return !name.toString().blank() && cn.include(' ' + name + ' ');
          }))))
        elements.push(Element.extend(child));
    }
    return elements;
  };

  return function(className, parentElement) {
    return $(parentElement || document.body).getElementsByClassName(className);
  };
}(Element.Methods);

/*--------------------------------------------------------------------------*/

Element.ClassNames = Class.create();
Element.ClassNames.prototype = {
  initialize: function(element) {
    this.element = $(element);
  },

  _each: function(iterator) {
    this.element.className.split(/\s+/).select(function(name) {
      return name.length > 0;
    })._each(iterator);
  },

  set: function(className) {
    this.element.className = className;
  },

  add: function(classNameToAdd) {
    if (this.include(classNameToAdd)) return;
    this.set($A(this).concat(classNameToAdd).join(' '));
  },

  remove: function(classNameToRemove) {
    if (!this.include(classNameToRemove)) return;
    this.set($A(this).without(classNameToRemove).join(' '));
  },

  toString: function() {
    return $A(this).join(' ');
  }
};

Object.extend(Element.ClassNames.prototype, Enumerable);

/*--------------------------------------------------------------------------*/
avocado.transporter.module.onLoadCallbacks["prototype/prototype"] = 'done';

avocado.transporter.module.onLoadCallbacks["lk/JSON"] = function() {};
/*
    JSON.js
    2007-10-02

    Based on Doug Crockford's Public Domain
    json.js
    2007-09-27

...............................................................................

This file adds these methods to JavaScript:

        JSON.serialize(value, optFilter)

            JSON.serialize(value) does much the same job that
            value.toJSONString() is supposed to do in the original
            json.js library on normal JSON objects. However, they
            provide different hooks for having their behavior extended.

            For json.js, other objects can provide their own
            implementation of toJSONString(), in which case JSON
            serialization relies on these objects to return a correct
            JSON string. But if one object instead returns an
            unbalanced part of a JSON string and another object
            returns a compensating unbalanced string, then an outer
            toJSONString() can produce quoting confusions that invite
            XSS-like attacks. The primary purpose of JSON.js is
            to prevent such attacks.

            The design of JSON.js borrows ideas from Java's object
            serialization streams.

        JSON.unserialize(string, optFilter)

            JSON.unserialize(string, optFilter) acts like json.js's
            string.parseJSON(optFilter). This version also fixes a bug
            in the original: json.js specifies "If [the optional filter]
            returns undefined then the member is deleted." However,
            the implemenation in json.js instead defines the property to
            have the value undefined. JSON.unserialize() does indeed
            delete the property in this case.

            Bug: If the JSON expression to be unserialized contains
            the key "__proto__", this will be silently ignored on
            Firefox independent of the behavior of optFilter. json.js
            exhibits the same bug on Firefox. Whether this is a bug in
            these JSON libraries, in the Javascript spec, or in the
            Firefox implementation of Javascript is open to debate. In
            any case, this problem is unlikely to be fixed.

        JSON.defaultFilter(baseObj, key)

            A filter is a function that takes a baseObj and a key for
            indexing into that baseObj -- the name of one of its
            properties. A filter can:
              * return baseObj[key], in which case serialization
                or unserialization proceeds normally.
              * return undefined, suppressing the apparent existence
                of this property on this baseObj.
              * return something else, in which case it will be used
                instead of baseObj[key].
              * throw, terminating serialization or unserialization.

            If a filter is provided to serialize(), it is applied in
            top-down order, so traversal proceeds only into the
            results of filtering. If a filter is provided to
            unserialize(), it is applied in bottom-up order, so that
            reconstructed parts are available for building
            reconstructed wholes.

            If no optFilter argument is provided to serialize(),
            this defaultFilter is used. It is part of the API so that
            other filters can be built by composing with it. 
            This default filter will return undefined unless key is a
            string and an own-property of baseObj, or if key is a
            number and baseObj is an array. If baseObj[key]
            implements toJSON(), the default filter will return
            baseObj[key].toJSON(), enabling individual objects (such
            as dates) to offer replacements for themselves. Otherwise,
            it returns baseObj[key].

            If no optFilter argument is provided to unserialize(),
            then the result is just the literal tree of JSON objects.

        Date.toJSON()

            Returns an ISO string encoding the date. When serializing
            with the default filter, this brings about the same effect
            as json.js's Date.toJSONString().

Use your own copy. It is extremely unwise to load untrusted third
party code into your pages.  
*/


/**
 * Like the date.toJSONString() method defined in json.js, except
 * without the surrounding quotes. This should be identical to
 * Date.prototype.toISOString when that is defined, as it is in caja.js
 */
Date.prototype.toJSON = function () {
    function f(n) {
        return n < 10 ? '0' + n : n;
    }
    return (this.getUTCFullYear()     + '-' +
            f(this.getUTCMonth() + 1) + '-' +
            f(this.getUTCDate())      + 'T' +
            f(this.getUTCHours())     + ':' +
            f(this.getUTCMinutes())   + ':' +
            f(this.getUTCSeconds())   + 'Z');
};


CustomJSON = (function () {

    function defaultFilter(baseObj, key) {
        var result;

        if (typeof key === 'string') {
            if (!Object.prototype.hasOwnProperty.call(baseObj, key)) {
                return undefined;
            }
        } else if (typeof key === 'number') {
            if (!(baseObj instanceof Array)) {
                return undefined;
            }
        } else {
            return undefined;
        }
        result = baseObj[key];
        if (result && typeof result.toJSON === 'function') {
            return result.toJSON();
        } else {
            return result;
        }
    }
    
    /** m is a table of character substitutions. */
    var m = {
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    };

    return {
        defaultFilter: defaultFilter,

        serialize: function(value, optFilter) {
            var out = []; // array holding partial texts
            // var stack = []; // for diagnosing cycles
            var filter = optFilter || defaultFilter;

            /**
             * The internal recursive serialization function.
             */
            function serialize(value) {
                var i,j; // loop counters
                var len; // array lengths;
                var needComma = false;
                var k,v; // property key and value
                
                // stack.push(value);
                
                switch (typeof value) {
                case 'object':
                    if (value === null) {
                        out.push('null');
                        
                    } else if (value instanceof Array) {
                        len = value.length;
                        out.push('[');
                        for (i = 0; i < len; i += 1) {
                            v = filter(value, i);
                            if (v !== undefined) {
                                if (needComma) {
                                    out.push(',');
                                } else {
                                    needComma = true;
                                }
                                serialize(v);
                            }
                        }
                        out.push(']');
                        
                    } else {
                        out.push('{');
                        for (k in value) {
                            v = filter(value, k);
                            if (v !== undefined) {
                                if (needComma) {
                                    out.push(',');
                                } else {
                                    needComma = true;
                                }
                                serialize(k);
                                out.push(':');
                                serialize(v);
                            }
                        }
                        out.push('}');
                    }
                    break;
                    
                case 'string':
                    // If the string contains no control characters, no quote
                    // characters, and no backslash characters, then we can
                    // simply slap some quotes around it.  Otherwise we must
                    // also replace the offending characters with safe
                    // sequences.
                    if ((/["\\\x00-\x1f]/).test(value)) { //"])){
                        out.push('"' + 
                                 value.replace((/[\x00-\x1f\\"]/g), //"]),
                                               function (a) {
                            var c = m[a];
                            if (c) {
                                return c;
                            }
                            c = a.charCodeAt();
                            return '\\u00' + Math.floor(c / 16).toString(16) +
                                                       (c % 16).toString(16);
                        }) + '"');
                    } else {
                        out.push('"' + value + '"');
                    }
                    break;

                case 'number':
                    // JSON numbers must be finite. Encode non-finite numbers
                    // as null. 
                    out.push(isFinite(value) ? String(value) : 'null');
                    break;

                case 'boolean':
                    out.push(String(value));
                    break;

                default:
                    out.push('null');
                }
                // stack.pop();
            }

            var fakeRoot = [value];
            serialize(filter(fakeRoot, 0));
            return out.join('');
        },

        unserialize: function(str, optFilter) {

            var result;
            
            function walk(value) {
                var i,len,k,v;

                if (value && typeof value === 'object') {
                    if (value instanceof Array) {
                        len = value.length;
                        for (i = 0; i < len; i += 1) {
                            walk(value[i]);
                            v = optFilter(value, i);
                            if (v === undefined) {
                                delete value[i];
                            } else {
                                value[i] = v;
                            }
                        }
                    } else {
                        for (k in value) {
                            walk(value[k]);
                            v = optFilter(value, k);
                            if (v === undefined) {
                                delete value[k];
                            } else {
                                value[k] = v;
                            }
                        }
                    }
                }
                
            }

            if ((/^[,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]*$/).
                test(str.
                     replace((/\\./g), '@').
                     replace((/"[^"\\\n\r]*"/g), ''))) { //"))) {
                result = eval('(' + str + ')');
                if (optFilter) {
                    var fakeRoot = [result];
                    walk(fakeRoot);
                    return fakeRoot[0];
                } else {
                    return result;
                }
            }
            throw new SyntaxError('parseJSON');
        }
    };
})();

// reuse existing JSON implementation
if (window.JSON) { // "window" added by Adam - seems to break otherwise
	for (var name in CustomJSON)
		JSON[name] = CustomJSON[name];
} else {
	JSON = CustomJSON
}
avocado.transporter.module.onLoadCallbacks["lk/JSON"] = 'done';

avocado.transporter.module.onLoadCallbacks["lk/defaultconfig"] = function() {};
/*
 * Copyright (c) 2006-2009 Sun Microsystems, Inc. 
 *
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * defaultconfig.js.  System default configuration.
 *
 *  Note that if a file localconfig.js can be found, it will be read
 *  immediately after this one, thus allowing any of these settings
 *  to be overridden.
 */

var UserAgent = (function() {

    var webKitVersion = (function() {
        if (!window.navigator) return 0;
        var match = navigator.userAgent.match(/.*AppleWebKit\/(\d+).*/) 
        return match ? parseInt(match[1]) : 0;
    })();

    var isRhino = !window.navigator || window.navigator.userAgent.indexOf("Rhino") > -1;
    var isMozilla = window.navigator && window.navigator.userAgent.indexOf("Mozilla") > -1;
    var isChrome = window.navigator && window.navigator.userAgent.indexOf("Chrome") > -1;
    var isOpera = window.navigator && window.navigator.userAgent.indexOf("Opera") > -1;
    var fireFoxVersion = window.navigator && window.navigator.userAgent.split("Firefox/")[1]; // may be undefined
    if (fireFoxVersion == null)
	fireFoxVersion = window.navigator && window.navigator.userAgent.split("Minefield/")[1];

    // Determines User Agent capabilities
    return {
        // Newer versions of WebKit implement proper SVGTransform API,
        // with potentially better performance. Scratch that, lets make it more predictable:
        usableTransformAPI: (webKitVersion < 0), //webKitVersion >= 525,
        usableDropShadow: webKitVersion >= 525,
        canExtendBrowserObjects: !isRhino, // Error, document
        usableOwnerSVGElement: !isRhino && !isMozilla,

        // WebKit XMLSerializer seems to do weird things with namespaces
        usableNamespacesInSerializer: false, //webKitVersion <= 0,

        usableXmlHttpRequest: !isRhino,

        usableHTMLEnvironment: !isRhino,

        webKitVersion: webKitVersion,
	
        isRhino: isRhino,
	
        isMozilla: isMozilla,

        isChrome: isChrome,

        isOpera: isOpera,

	fireFoxVersion: fireFoxVersion ? fireFoxVersion.split('.') : null, 
	
        isWindows: window.navigator && window.navigator.platform == "Win32",

        isLinux: window.navigator && window.navigator.platform.startsWith("Linux"),

        isIPhone: window.navigator && window.navigator.platform == "iPhone",

        isTouch: window.navigator && (window.navigator.platform == "iPhone" || window.navigator.platform == "iPad" || window.navigator.platform == "iPod"),
		touchIsMouse: false

    };

})();

//--------------------------
//  iPhone/iPad support...
// Here is a first cut at iPad touch/mouse compatibility
//  set usePieMenus = true since we can't use modifier keys on clicks
// In touch mode [only get mouseDown events]
//		if down/up with little movement, then set drag mode (touchIsMouse = true)
//	In drag mode
//		if down/up with little movement, then set touch mode
//	detect both of these in WoldMorph showPieMenu
//	Indicate touch mode by pentagonal blue cursor
//	Indicate drag mode by regular arrow, but bigger for iPad
//--------------------------
// Following iPhone/iPad code borrowed from...
//	http://rossboucher.com/2008/08/19/iphone-touch-events-in-javascript/
/*
UserAgent.touchHandler = function(event) {
    var first = event.changedTouches[0],
        type = "";
    switch(event.type) {  
		case "touchstart": type = "mousedown"; break;
        case "touchmove":  type = "mousemove"; break;        
        case "touchend":   type = "mouseup"; break;
        default: return;
    }

    //initMouseEvent(type, canBubble, cancelable, view, clickCount, 
    //           screenX, screenY, clientX, clientY, ctrlKey, 
    //           altKey, shiftKey, metaKey, button, relatedTarget);
    var simulatedEvent = document.createEvent("MouseEvent");
    simulatedEvent.initMouseEvent(type, true, true, window, 1, 
                              first.screenX, first.screenY, 
                              first.clientX, first.clientY, false, 
                              false, false, false, 0, null); // 0 is left
    first.target.dispatchEvent(simulatedEvent);
    event.preventDefault();
};
UserAgent.touchBeMouse = function (evt) {
    if (this.touchIsMouse) return;
	this.touchIsMouse = true;
	if (evt) evt.hand.lookNormal();  // indicate mouse mode
    document.addEventListener("touchstart", this.touchHandler, true);
    document.addEventListener("touchmove", this.touchHandler, true);
    document.addEventListener("touchend", this.touchHandler, true);
    document.addEventListener("touchcancel", this.touchHandler, true); 
};
UserAgent.touchBeTouch = function (evt) {
    if (!this.touchIsMouse) return;
	this.touchIsMouse = false;
    if (evt) evt.hand.lookTouchy();  // Indicate touch mode (pan / zoom)
    document.removeEventListener("touchstart", this.touchHandler, true);
    document.removeEventListener("touchmove", this.touchHandler, true);
    document.removeEventListener("touchend", this.touchHandler, true);
    document.removeEventListener("touchcancel", this.touchHandler, true); 
};
if (UserAgent.isTouch) UserAgent.touchBeMouse();
*/


//--------------------------
// Determine runtime behavior based on UA capabilities and user choices (override in localconfig.js)
//--------------------------
var Config = {

    // Allows easy object duplication using the Shift key
    shiftDragForDup: true,
    
    // URL that acts as a proxy for network operations 
    proxyURL: null,

    // Quickly enable/disable most demos
    skipMostExamples: false,
    skipAllExamples:  false,
    showCurveExample: false,
    showGridDemo: false,
    
    // Additional demo configuration options 
    showThumbnail: false,
    suppressBalloonHelp: false,
    usePieMenus: UserAgent.isTouch,
    
    // Enables/disables network-dependent demos
    showNetworkExamples: UserAgent.usableXmlHttpRequest,

    // Ignore function logging through the prototype.js wrap mechanism
    // rhino will give more useful exception info 
    ignoreAdvice: UserAgent.isRhino,

    // Derive font metrics from (X)HTML
    fontMetricsFromHTML: UserAgent.usableHTMLEnvironment,

    // Derive font metrics from SVG
    fontMetricsFromSVG: false,

    // Try to make up font metrics entirely (can be overriden to use the native SVG API, which rarely works)
    fakeFontMetrics: !UserAgent.usableHTMLEnvironment,

    // Use the browser's affine transforms
    useTransformAPI: (!UserAgent.isOpera) && UserAgent.usableTransformAPI, 

    // Firefox 2 has known problems with getTransformToElement, detect it
    useGetTransformToElement: false && !(UserAgent.isOpera ||
	UserAgent.fireFoxVersion && (UserAgent.fireFoxVersion[0] == '2' || UserAgent.fireFoxVersion[0] == '3')),  // getTransformToElement seems really slow -- Adam

    // Enable drop shadows for objects (does not work well in most browsers)
    useDropShadow: UserAgent.usableDropShadow,

    // We haven't decided on the behavior yet, but let's be brave!
    // This option suspends all the scripts in a world as soon as
    // the user moves to another world.  This should really be a
    // world-specific option.
    suspendScriptsOnWorldExit: true,

    // For the engine/piano demo (and any other simulation interacting with unmoving mouse)
    // it is necessary to generate a mouseMove event after each tick
    // set this true in localconfig if you need this behavior 
    nullMoveAfterTicks: false,

    // Open up our console
    showLivelyConsole: false,

    // Disable caching of webstore requests
    suppressWebStoreCaching: false,

    // Defeat bundled type-in for better response in short strings
    showMostTyping: true,

    // Defeat all bundled type-in for testing
    showAllTyping: true,  // Until we're confident

    // Use the meta modifier (maps to Command on the Mac) instead of alt
    useMetaAsCommand: false,

    // Confirm system shutdown from the user
    askBeforeQuit: true,
    
    // Enable advanced debugging options
    debugExtras: false,

    // enable grab halo (alternative to shadow) on objects in the hand.
    showGrabHalo: false,
    useShadowMorphs: true,

    // load serialized worlds instead of building them from Javascript
    loadSerializedSubworlds: false,  //*** temporary avoidance of a failure

    // where the local web server runs
    // FIXME: parse /trunk/source/server/brazil.config to figure out the port?
    personalServerPort: 8081,

    // the delay set on the main() function
    mainDelay: 0.05,

    // whether the .style property should be used
    useStyling: false,

    verboseImport: false,

    // some widgets self connect to a private model on startup, but it doesn't
    // seem necessary, turn on to override
    selfConnect: false,
    suppressClipboardHack: false,

	// e.g. don't open standard Brwser menu on right
    suppressDefaultMouseBehavior: UserAgent.canExtendBrowserObjects,

    resizeScreenToWorldBounds: false
};

// Note this patch fixes a problem with recent WebKit builds and Safari 4 beta
// We should test for these versions, and drop this code when it's no longer needed
// Thanks to Phil Weaver for tracking this down and suggesting this fix.
/* aaaaaaa - This breaks stuff - maybe Ajax, or Orbited, or something? Can't add stuff to the basic objects, I think. -- Adam, Jan. 2010
String.fromCharCode = String.fromCharCode.wrap(
	function(originalDef, charCode) {
		if (charCode == 173) return '-';
		return originalDef(charCode);
});
*/

// These various overrides of the above have been moved here from main.js
//	so that they can be overridden in localconfig.js
//	at some point we should refactor this file nicely.
Config.showClock = true;
Config.showStar = true;
Config.spinningStar = true;
Config.showHilbertFun = true;
Config.showPenScript = true;
Config.showTester = true;
Config.showBitmap = false;
Config.showMap = !Config.skipMostExamples && !UserAgent.isTouch;
Config.showSampleMorphs = true;
Config.showTextSamples = true;
// Config.random is used as the ID for the messenger morph for each user
Config.random = Math.round(Math.random()*2147483647);

// More complex demos
Object.extend(Config, {
    showClipMorph: function() { return !Config.skipMostExamples},
    show3DLogo: function() { return !Config.skipMostExamples},
    showAsteroids: function() { return !Config.skipMostExamples && !UserAgent.isTouch},
    showEngine: function() { return !Config.skipMostExamples},
    showIcon: function() { return !Config.skipMostExamples},
    showWeather: function() { return !Config.skipMostExamples},
    showStocks: function() { return !Config.skipMostExamples},
    showCanvasScape: function() { return !Config.skipMostExamples && !UserAgent.isTouch},
    showRSSReader: function() { return !Config.skipMostExamples},
    showSquiggle: function() { return !Config.skipMostExamples},
    showWebStore: function() { return !Config.skipMostExamples || Config.browserAnyway},
    showVideo: function() { return !Config.skipMostExamples && !UserAgent.isTouch},
    // Worlds
    showInnerWorld: true, //!Config.skipMostExamples;
    showSlideWorld: true, //!Config.skipMostExamples;
    showDeveloperWorld: true //!Config.skipMostExamples;
});

Object.extend(Config, {
	getDocumentDirectory: function() {
		var url = document.documentURI;
		return url.substring(0, url.lastIndexOf('/') + 1);
	},
});

Object.extend(Config, {
	// Morphic
	alignToGridSpace: 10, // determins the pixels to snap to during shift dragging with mouse
	ballonHelpDelay: 1000,
	// Fabrik
	showFabrikComponentBox: false,
	showFahrenheitCelsiusExample: false,
	showTextListExample: false,
	openFabrikBrowserExample: false,
	// Wiki
	showWikiNavigator: true,
	// Tests
	loadTests: [], //e.g. ["FabrikTest", "RecordTest", "TestFrameworkTests", "ClassTest", "LKWikiTest", "DevelopTest", "MorphTest"]
	showTesterRunner: false,
	// Modules
	modulesBeforeChanges: ['lively.LKWiki', 'lively.ChangeSet', 'lively.Styles'], // evaluated first, even before ChangeSet of a world
	modulesBeforeWorldLoad: [], // evaluated before all changes
	modulesOnWorldLoad: ['lively.TouchSupport'], // evaluated before ChangeSet initializer
	codeBase: Config.getDocumentDirectory(),
	disableScriptCaching: false,
	defaultDisplayTheme: 'lively'
});

Config.onWindowResizeUpdateWorldBounds = true;
Config.disableNoConsoleWarning = false;

//	*** Minimal World Only ***
//  In spite of all the foregoing complexity, merely changing this conditional
//	to true will bypass all examples and worlds, and only create a few
//	simple morphs in a simple world.
//
//	If you copy these lines to localconfig.js you won't need
//	to alter any of the supplied Lively Kernel files.
if (false) {
    Config.showInnerWorld = false;
    Config.showDeveloperWorld = false;
    Config.showSlideWorld = false;
    Config.showOnlySimpleMorphs = true;
    Config.showStar = false;  // true to show star
    Config.spinningStar = false;  // true to enable spinning
}

Config.confirmNavigation = false; // don't show confirmation dialog when navigating a link
Config.useAltAsCommand = false; // User Platform Keys (Ctrl und Windows and Meta under Mac as command key)

Config.pageNavigationName = "nothing"
Config.pageNavigationWithKeys = true // boy, that's ugly!!!
Config.showPageNumber = true;

Config.touchBeMouse = UserAgent.isTouch
avocado.transporter.module.onLoadCallbacks["lk/defaultconfig"] = 'done';

avocado.transporter.module.onLoadCallbacks["local-LK-config"] = function() {};
Config.codeBase = document.documentURI.substring(0, document.documentURI.lastIndexOf('/') + 1) + "javascripts/lk/";
Config.showInnerWorld = false;
Config.showDeveloperWorld = false;
Config.showSlideWorld = false;
Config.showOnlySimpleMorphs = true;
Config.showStar = false;  // true to show star
Config.spinningStar = false;  // true to enable spinning
Config.showSampleMorphs = false;
Config.disableNoConsoleWarning = true;
Config.showTesterRunnerForDevelopment = true;
Config.usePieMenus = false; // LK default says UserAgent.isTouch, but I'm not sure I like it -- Adam
Config.fatFingers = UserAgent.isTouch;
Config.defaultFontSize = UserAgent.isTouch ? 12 : 12; // aaa - Why does this crash mobile Safari if I make it 16 instead of 12 on touch devices?
avocado.transporter.module.onLoadCallbacks["local-LK-config"] = 'done';

avocado.transporter.module.onLoadCallbacks["lk/Base"] = function() {};
/*
 * Copyright (c) 2006-2009 Sun Microsystems, Inc.
 *
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

 (function() {
// ES 3.1 proposed static functions
// according to rationale_for_es3_1_static_object_methodsaug26.pdf on wiki.ecmascript.org
// implementation uses __defineGetter__/__proto__ logic


Object.defineProperty = function(object, property, descriptor) {
	if (typeof descriptor  !== 'object') throw new TypeError();
	if (descriptor.value) {
		object[String(property)] = descriptor.value;
	} else {
		if (descriptor.getter) 
			object.__defineGetter__(property, descriptor.getter);
		if (descriptor.setter)
			object.__defineSetter__(property, descriptor.setter);
	}
	return object;
};
	 
Object.defineProperties = function(object, descriptorSet) {
	for (var name in descriptorSet) {
		if (!descriptorSet.hasOwnProperty(name)) continue;
		Object.defineProperty(object, name, descriptorSet[name]);
	}
	return object;
}
	 
Object.defineProperties(Object, {
  // I like mine better. -- Adam
  /*
	create: { 
		value: function(proto, descriptorSet) { //descriptor can be undefined
			var object = {};
			object.__proto__ = proto;
			Object.defineProperties(object, descriptorSet);
			return object;
		}
	},
	*/

	keys: { 
		value: function(object, optFast) {
			if (typeof object !== 'object') throw new TypeError('not an object');
			var names = []; // check behavior wrt arrays
			for (var name in object) {
				if (object.hasOwnProperty(name)) 
					names.push(name);
			}
			if (!optFast) names.sort();
			return names;
		}
	},
	 
	getOwnPropertyNames: { 
		value: function(object) {
			// would be different from keys if we could access non-enumerable properties
			return Object.keys(object);
		}
	},
	 
	getPrototypeOf: { 
		value: function(object) {
			if (typeof object !== 'object') throw new TypeError('type ' + (typeof object) + ' does not have a prototype');
			return object.__proto__;
		}
	},
	 
	getOwnPropertyDescriptor: { 
		value: function(object, name) {
			// FIXME? use $schema?
			var descriptor = { enumerable: true, writable: true, flexible: true};
			var getter = object.__lookupGetter__(name);
			var setter = object.__lookupSetter__(name);
			if (getter || setter) {
				descriptor.getter = getter;
				descriptor.setter = setter;
			} else {
				descriptor.value = object[name];
			}
			return descriptor;
		}
	},
	 
	seal: {
		value: function(object) {
			// prevent adding and removing properties
			// in rhino only see use org.mozilla.javascript.tools.shell.Global.seal
			// not implementable yet
			return object;
		}
	},

	freeze: { 
		value: function(object) {
			// like seal, but properties are read-only now
			// not implementable yet
			return object;
		}
	}
});

Object.defineProperties(Function.prototype, {
	bind: { 
		value: function(self, var_args) {
			var thisFunc = this;
			if (arguments.length === 0) {
				return function() {
					return thisFunc.apply(self, arguments);
				}
			}
			var leftArgs = Array.prototype.slice.call(arguments, 1);
			return function(var_args) {
				var args = leftArgs.concat(Array.prototype.slice.call(arguments, 0));
				return thisFunc.apply(self, args);
			};
		}
	},

	// FIXME redefining, 
	bind: {
		value: function bind() {
			function cdr(iterable) {
				var length = iterable.length, results = new Array(length - 1);
				while (length--) results[length - 1] = iterable[length];
				return results;
			}
			// this is the prototype.js definition

      var __method = this, object = arguments[0];
			// Hacked to speed up the very common case where we're only binding the receiver. -- Adam
			if (arguments.length < 2) {
  			if (object === undefined) { return this; }
  			return function thisBound() {
  				return __method.apply(object, arguments);
  			}
			}

			var args = cdr(arguments);
			return function bound() {
				return __method.apply(object, args.concat($A(arguments)));
			}
		}
	}
});
})();


// set to the context enclosing the SVG context.
// rk: replaced "this.window.top || this.window" with "this.window"
// rk: when is it necessary to use the parent context?
var Global = this.window || GLOBAL /*for Node.js*/;
function dbgOn(cond, optMessage) {
	if (optMessage) console.log(optMessage);
	if (cond) eval('debugger'); // note that rhino has issues with this keyword  // aaa hacked to say eval('debugger') instead of just debugger, because YUI compressor barfs on it -- Adam
	// also call as: throw dbgOn(new Error(....))
	return cond;
}

// namespace logic adapted from
// http://higher-order.blogspot.com/2008/02/designing-clientserver-web-applications.html
var using = (function() {

	function Util(args) {  // args is an escaping arguments array
		this.objects = Array.prototype.concat.apply([], args);
		//var ownArgs = this.objects = new Array(args.length);
		//for (var i = 0; i < args.length; i++) ownArgs[i] = args[i];
	};

	Util.prototype = {

		log: function(msg) {
			console.log(msg);
		},

		run: function(inner) {
			var args = this.objects;
			if (this.moduleName) { 
				// little convenience, 
				if (args.length > 0) this.log('using().module(): ignoring args ' + args);
				return module(this.moduleName).requires().toRun(inner);
			} else return inner.apply(args[0], args); 
		},

		model: function(model) {
			// KP: interestingly, declaring the above as "model: function model(model)" 
			// seems to bind model to to the function, not the formal parameter, at least in rhino!
			this.model = model;
			return this;
		},

		module: function(moduleName) {
			this.moduleName = moduleName;
			return this;
		},

		link: function link(literal, variableMap) { 
			variableMap = variableMap || {};
			return new lively.data.Resolver().link(literal, [], undefined, variableMap, this.objects, this.model); 
		},

		extend: function extend(base, extLiteral) {
			return this.link(Object.extend(Object.clone(base), extLiteral));
		},

		test: function(inner) {
			try {
				return this.run(inner);
			} catch (er) {
				alert('test failed: ' + er);
				return undefined;
			}
		}
	}

	return function using() {
		return new Util(arguments);
	}
})();


function namespace(spec, context) {
	var	 i,N;
	context = context || Global;
	spec = spec.valueOf();
	if (typeof spec === 'object') {
		if (typeof spec.length === 'number') {//assume an array-like object
			for (i = 0,N = spec.length; i < N; i++) {
				return namespace(spec[i], context);
			}
		} else {//spec is a specification object e.g, {com: {trifork: ['model,view']}}
			for (i in spec) if (spec.hasOwnProperty(i)) {
				context[i] = context[i] || new lively.lang.Namespace(context, i);
					return namespace(spec[i], context[i]);//recursively descend tree
			}
		}
	} else if (typeof spec === 'string') {
		(function handleStringCase() {
			var parts;
			parts = spec.split('.');
			for (i = 0, N = parts.length; i<N; i++) {
				spec = parts[i];
				if (!Class.isValidIdentifier(spec)) {
					throw new Error('"'+spec+'" is not a valid name for a package.');
				}
				context[spec] = context[spec] || new lively.lang.Namespace(context, spec);
				context = context[spec];
			}
		})();
		return context;
	} else {
		throw new TypeError();
	}
}


function module(moduleName) {
	
	function isNamespaceAwareModule(moduleName) {
		return moduleName && !moduleName.endsWith('.js');
	}
	
	function convertUrlToNSIdentifier(url) {
		var result = url;
		result = result.replace(/\//, '.');
		// get rid of '.js'
		if (result.endsWith('.js')) result = result.substring(0, result.lastIndexOf('.'));
		return result;
	}
	
	function createNamespaceModule(moduleName) {
		return namespace(isNamespaceAwareModule(moduleName) ? moduleName : convertUrlToNSIdentifier(moduleName));
	}
	
	function basicRequire(/*module, requiredModuleNameOrAnArray, anotherRequiredModuleName, ...*/) {
		var args = $A(arguments);	 
		var module = args.shift();
		var preReqModuleNames = Object.isArray(args[0]) ? args[0] : args; // support modulenames as array and parameterlist
		var requiredModules = [];
		for (var i = 0; i < preReqModuleNames.length; i++) {
			var reqModule = createNamespaceModule(preReqModuleNames[i]);
			module.addRequiredModule(reqModule);
			requiredModules.push(reqModule);
		}

		return {
			toRun: function(code) {
				code = code.curry(module); // pass in own module name for nested requirements
				var codeWrapper = function() { // run code with namespace modules as additional parameters
					code.apply(this, requiredModules);
				}
				module.addOnloadCallback(codeWrapper);
				module.load();
			}
		};
	};

	dbgOn(!Object.isString(moduleName));
	var module = createNamespaceModule(moduleName);
	module.wasDefined = true;
	module.requires = basicRequire.curry(module);
	return module;
};

function require(/*requiredModuleNameOrAnArray, anotherRequiredModuleName, ...*/) {
	function getUniqueName() { return 'anonymous_module_' + require.counter }
	require.counter !== undefined ? require.counter++ : require.counter = 0;
	var args = $A(arguments);
	return module(getUniqueName()).beAnonymous().requires(Object.isArray(args[0]) ? args[0] : args);
};


// ===========================================================================
// Our JS library extensions (JS 1.5, no particular browser or graphics engine)
// ===========================================================================

/**
  * LK class system.
  */

Object.extend(Function.prototype, {

	subclass: function(/*... */) {
		// Main method of the LK class system.

		// {className} is the name of the new class constructor which this method synthesizes
		// and binds to {className} in the Global namespace. 
		// Remaining arguments are (inline) properties and methods to be copied into the prototype 
		// of the newly created constructor.

		// modified from prototype.js
	
		var args = arguments;
		var className = args[0];
		var targetScope = Global;
		var shortName = null;
		if (className) {
			targetScope = Class.namespaceFor(className);
			shortName = Class.unqualifiedNameFor(className);
		}  else {
			shortName = "anonymous_" + (Class.anonymousCounter++);
			className = shortName;
		}
	
		var klass;
		if (className && targetScope[shortName] && (targetScope[shortName].superclass === this)) {
			// preserve the class to allow using the subclass construct in interactive development
			klass = targetScope[shortName]; 
		} else {
			klass = Class.newInitializer(shortName);
			klass.superclass = this;
			var protoclass = function() { }; // that's the constructor of the new prototype object
			protoclass.prototype = this.prototype;
			klass.prototype = new protoclass();
			klass.prototype.constructor = klass;
			klass.prototype.constructor.type = className; // KP: .name would be better but js ignores .name on anonymous functions
			klass.prototype.constructor.displayName = className; // for debugging, because name can not be assigned
			if (className) {
			  targetScope[shortName] = klass; // otherwise it's anonymous
			  avocado.annotator.annotationOf(klass).setCreatorSlot(shortName, targetScope); // aaa - kind of a hack, added by Adam so that we can file out Morph subclasses
			  
			  // aaa - Another hack to avoid having hundreds of uncategorized classes cluttering
			  // up the global namespace. -- Adam, August 2010
			  if (targetScope === Global) {
			    avocado.annotator.annotationOf(Global).setSlotAnnotation(shortName, {initializeTo: ['null']}); // so it doesn't show up as an unowned slot
			    avocado.annotator.annotationOf(Global).categorize(['avocado', 'lively kernel'], [shortName]);
			  }

			}
		};

		for (var i = 1; i < args.length; i++) {
			klass.addMethods(args[i] instanceof Function ? (args[i])() : args[i]);
		}
		if (!klass.prototype.initialize) {
			klass.prototype.initialize = Functions.Empty;
		}

		return klass;
	},

	addMethods: function(source) {
		// copy all the methods and properties from {source} into the
		// prototype property of the receiver, which is intended to be
		// a class constructor.	 Method arguments named '$super' are treated
		// specially, see Prototype.js documentation for "Class.create()" for details.
		// derived from Class.Methods.addMethods() in prototype.js
		var ancestor = this.superclass && this.superclass.prototype;
		
		var className = this.type || "Anonymous";

		for (var property in source) {
		  if (property !== '__annotation__') { // aaa - Hacked by Adam, not sure what else to do.
			var getter = source.__lookupGetter__(property);
			if (getter) this.prototype.__defineGetter__(property, getter);
			var setter = source.__lookupSetter__(property);
			if (setter) this.prototype.__defineSetter__(property, setter);
			if (getter || setter)
			continue;

			var value = source[property];
			// weirdly, RegExps are functions in Safari, so testing for Object.isFunction on
			// regexp field values will return true. But they're not full-blown functions and don't 
			// inherit argumentNames from Function.prototype
		
			if (ancestor && Object.isFunction(value) && value.argumentNames
				&& value.argumentNames().first() == "$super") {
				(function() { // wrapped in a method to save the value of 'method' for advice
					var method = value;
					var advice = (function(m) {
						return function callSuper() {
							var method = ancestor[m];
							if (!method)
								throw new Error(Strings.format('Trying to call super of' + 
									'%s>>%s but super method non existing in %s',
									className, m, ancestor.constructor.type));
							return method.apply(this, arguments);
						};
					})(property);

					advice.methodName = "$super:" + (this.superclass ? this.superclass.type + "." : "") + property;

					value = Object.extend(advice.wrap(method), {
						valueOf:  function() { return method },
						toString: function() { return method.toString() },
						originalFunction: method
					});
				})();
			}
			
			if (Object.isFunction(value)) {
				
				
			}
			
			this.prototype[property] = value;
		
			if (property === "formals") { // rk FIXME remove this cruft
				// special property (used to be pins, but now called formals to disambiguate old and new style
				Class.addPins(this, value);
			} else if (Object.isFunction(value)) {
				// remember name for profiling in WebKit
				value.displayName = property; // aaa changed this from className + "$" + property to make implicit creator slots work -- Adam
				
				for ( ; value; value = value.originalFunction) {
					if (value.methodName) {
						//console.log("class " + this.prototype.constructor.type 
						// + " borrowed " + value.qualifiedMethodName());
					}
					value.declaredClass = this.prototype.constructor.type;
					value._creatorSlotHolder = this.prototype; // added by Adam to allow implicit creator slots
					value.methodName = property;
				}
			}
		  }
		} // end of for (var property in source)
		
		return this;
	},

	addProperties: function(spec, recordType) {
		Class.addMixin(this, recordType.prototype.create(spec).prototype);
	},

	isSubclassOf: function(aClass) {
		return this.superclasses().include(aClass);
	},
	
	allSubclasses: function() {
		return Global.classes(true).select(function(ea) { return ea.isSubclassOf(this) }.bind(this));
	},
	
	superclasses: function() {
		if (!this.superclass) return [];
		if (this.superclass === Object) return [Object];
		return this.superclass.superclasses().concat([this.superclass]);
	}

});

var Class = {
	
	anonymousCounter: 0,
	
	initializerTemplate: (function CLASS(){ Class.initializer.apply(this, arguments) }).toString(),
	
	newInitializer: function(name) {
		// this hack ensures that class instances have a name
		return eval(Class.initializerTemplate.replace(/CLASS/g, name) + ";" + name);
	},

	initializer: function initializer() {
		// check for the existence of Importer, which may not be defined very early on
		if (Global.Importer && (arguments[0] instanceof Importer)) {
			this.deserialize.apply(this, arguments);
		} else if (Global.Copier && (arguments[0] instanceof Copier)) {
			this.copyFrom.apply(this, arguments);
		} else if (Global.Restorer && (arguments[0] instanceof Restorer)) {
			// for WebCards)
			//Do nothing
		} else {
			// if this.initialize is undefined then prolly the constructor was called without 'new'
			this.initialize.apply(this, arguments); 
		}
	},

	def: function Class$def(constr, superConstr, optProtos, optStatics) {
		// currently not used
		// Main method of the LK class system.

		// {className} is the name of the new class constructor which this method synthesizes
		// and binds to {className} in the Global namespace. 
		// Remaining arguments are (inline) properties and methods to be copied into the prototype 
		// of the newly created constructor.

		// modified from prototype.js

		var klass = Class.newInitializer("klass");
		klass.superclass = superConstr;

		var protoclass = function() { }; // that's the constructor of the new prototype object
		protoclass.prototype = superConstr.prototype;

		klass.prototype = new protoclass();

		// Object.extend(klass.prototype, constr.prototype);
		klass.prototype.constructor = klass; 
		var className  = constr.name; // getName()
		klass.addMethods({initialize: constr});
		// KP: .name would be better but js ignores .name on anonymous functions
		klass.type = className;


		if (optProtos) klass.addMethods(optProtos);
		if (optStatics) Object.extend(klass, optStatics);

		Global[className] = klass;
		return klass;
	},

	isValidIdentifier: function(str) {
		return (/^(?:[a-zA-Z_][\w\-]*[.])*[a-zA-Z_][\w\-]*$/).test(str);
	},
	
	isClass: function Class$isClass(object) {
		if(object === Object
			|| object === Array
			|| object === Function
			|| object === String
			|| object === Number) {
				return true;
		} 
		return (object instanceof Function) && (object.superclass !== undefined);
	},

	className: function Class$className(cl) {
		if(cl === Object) return "Object"
		if(cl === Array) return "Array"
		if(cl === Function) return "Function"
		if(cl === String) return "String"
		if(cl === Number) return "Number"
		return cl.type;
	},

	forName: function forName(name) {
		// lookup the class object given the qualified name
		var lastDot = name.lastIndexOf('.'); // lastDot may be -1
		var ns = Class.namespaceFor(name);
		var shortName = Class.unqualifiedNameFor(name);
		return ns[shortName];
	},

	deleteObjectNamed: function Class$delteObjectNamed(name) {
		var lastDot = name.lastIndexOf('.'); // lastDot may be -1
		var ns = Class.namespaceFor(name);
		var shortName = Class.unqualifiedNameFor(name);
		if (!ns[shortName]) return;
		delete ns[shortName];
	},

	unqualifiedNameFor: function Class$unqualifiedNameFor(name) {
		var lastDot = name.lastIndexOf('.'); // lastDot may be -1
		var unqualifiedName = name.substring(lastDot + 1);
		if (!Class.isValidIdentifier(unqualifiedName)) throw new Error('not a name ' + unqualifiedName);
		return unqualifiedName;
	},

	namespaceFor: function Class$namespaceFor(className) {
		// get the namespace object given the qualified name
		var lastDot = className.lastIndexOf('.');
		if (lastDot < 0) return Global;
		else return namespace(className.substring(0, lastDot));
	},

	withAllClassNames: function Class$withAllClassNames(scope, callback) {
		for (var name in scope) {
			try {
				if (Class.isClass(scope[name]))
					callback(name);
			} catch (er) { // FF exceptions
			}
		}
		callback("Object");
		callback("Global");
	},

	makeEnum: function Class$makeEnum(strings) {
		// simple mechanism for making objecs with property values set to
		// property names, to be used as enums.

		var e = {};
		for (var i = 0; i < strings.length; i++) {
			e[strings[i]] = strings[i];
		}
		return e;
	},

	getConstructor: function Class$getConstructor(object) {
		return object.constructor.getOriginal();
	},

	getPrototype: function Class$getPrototype(object) {
		return object.constructor.getOriginal().prototype;
	},

	applyPrototypeMethod: function Class$applyPrototypeMethod(methodName, target, args) {
		var method = this.getPrototype(target);
		if (!method) throw new Error("method " + methodName + " not found");
		return method.apply(this, args);
	},

	getSuperConstructor: function Class$getSuperConstructor(object) {
		return object.constructor.getOriginal().superclass;
	},

	getSuperPrototype: function Class$getSuperPrototype(object) {
		var sup = this.getSuperConstructor(object);
		return sup && sup.prototype;
	},

	addPins: function Class$addPins(cls, spec) {
		Class.addMixin(cls, Relay.newDelegationMixin(spec).prototype);
	},
	
	addMixin: function Class$addMixin(cls, source) {
		var spec = {};
		for (var prop in source) {
			var value = source[prop];
			switch (prop) {
				case "constructor": case "initialize": case "deserialize": case "copyFrom": 
				case "toString": case "definition": case "description":
				break;
				default:
				if (cls.prototype[prop] === undefined) // do not override existing values!
				spec[prop] = value;
			}
		}
		cls.addMethods(spec);
	}

};

var Strings = {
	documentation: "Convenience methods on strings",
	
	format: function Strings$format() {
		return this.formatFromArray($A(arguments));
	},
	
	// adapted from firebug lite
	formatFromArray: function Strings$formatFromArray(objects) {
		var self = objects.shift();
		if(!self) {console.log("Error in Strings>>formatFromArray, self is undefined")};

		function appendText(object, string) {
			return "" + object;
		}
	
		function appendObject(object, string) {
			return "" + object;
		}
	
		function appendInteger(value, string) {
			return value.toString();
		}
	
		function appendFloat(value, string, precision) {
			if (precision > -1) return value.toFixed(precision);
			else return value.toString();
		}
	
		var appenderMap = {s: appendText, d: appendInteger, i: appendInteger, f: appendFloat}; 
		var reg = /((^%|[^\\]%)(\d+)?(\.)([a-zA-Z]))|((^%|[^\\]%)([a-zA-Z]))/; 
	
		function parseFormat(fmt) {
			var oldFmt = fmt;
			var parts = [];
		
			for (var m = reg.exec(fmt); m; m = reg.exec(fmt)) {
				var type = m[8] || m[5];
				var appender = type in appenderMap ? appenderMap[type] : appendObject;
				var precision = m[3] ? parseInt(m[3]) : (m[4] == "." ? -1 : 0);
				parts.push(fmt.substr(0, m[0][0] == "%" ? m.index : m.index + 1));
				parts.push({appender: appender, precision: precision});
		
				fmt = fmt.substr(m.index + m[0].length);
			}
			if (fmt)
				parts.push(fmt.toString());
		
			return parts;
		};
	
		var parts = parseFormat(self);
		var str = "";
		var objIndex = 0;
	
		for (var i = 0; i < parts.length; ++i) {
			var part = parts[i];
			if (part && typeof(part) == "object") {
				var object = objects[objIndex++];
				str += (part.appender || appendText)(object, str, part.precision);
			} else {
				str += appendText(part, str);
			}
		}
		return str;
	},

	withDecimalPrecision: function Strings$withDecimalPrecision(str, precision) {
		var floatValue = parseFloat(str);
		return isNaN(floatValue) ? str : floatValue.toFixed(precision);
	}
};


var Functions = {
	documentation: "collection of reusable functions",

	Empty: function() {},

	K: function(arg) { return arg; },

	Null: function Functions$Null() { return null; },

	False: function Functions$False() { return false; },

	True: function Functions$True() { return true; },

	all: function Functions$all(object) {
		var a = [];
		for (var name in object) {	
			if (object[name] instanceof Function)
				a.push(name);
		} 
		return a;
	},

	timeToRun: function Functions$timeToRun(func) {
		var startTime = (new Date()).getTime(); 
		func();
		return new Date().getTime() - startTime;
	}
};
	
var Properties = {
	documentation: "convenience property access functions",

	all: function Properties$all(object, predicate) {
		var a = [];
		for (var name in object) {	
			if (!(object[name] instanceof Function) && (predicate ? predicate(name, object) : true)) {
			a.push(name);
			}
		} 
		return a;
	},
	
	own: function Properties$own(object) {
		var a = [];
		for (var name in object) {	
			if (object.hasOwnProperty(name)) {
			var value = object[name];
			if (!(value instanceof Function))
				a.push(name);
			}
		} 
		return a;
	},

	forEachOwn: function Properties$forEachOwn(object, func, context) {
		for (var name in object) {
			if (object.hasOwnProperty(name)) {
				var value = object[name];
				if (!(value instanceof Function)) {
					var result = func.call(context || this, name, value);
					// cont && cont.call(context || this, result); 
				}
			}
		}
	}
};


// bootstrap namespaces
Object.subclass('Namespace', {

	initialize: function(context, nsName) {
		this.namespaceIdentifier = context.namespaceIdentifier + '.' + nsName;
		this.createTime = new Date();
	},
		
	gather: function(selector, condition, recursive) {
		var result = Object.values(this).select(function(ea) { return condition.call(this, ea) }, this);
		if (!recursive) return result;
		return	this.subNamespaces().inject(result, function(result, ns) { return result.concat(ns[selector](true)) });
	},
	
	subNamespaces: function(recursive) {
		return this.gather(
			'subNamespaces',
			function(ea) { return (ea instanceof lively.lang.Namespace || ea === Global) && ea !== this },
			recursive);
	},
	
	classes: function(recursive) {		  
		var normalClasses = this.gather(
			'classes',
			function(ea) { return ea && ea !== this.constructor && Class.isClass(ea) },
			recursive);
		if (this === Global)
			return [Array, Number, String, Function].concat(normalClasses);
		return normalClasses;
	},
	
	functions: function(recursive) {
		return this.gather(
			'functions',
			function(ea) { return ea && !Class.isClass(ea) && Object.isFunction(ea) && !ea.declaredClass && this.requires !== ea },
			recursive);
	}
	
});

// let Glabal act like a namespace itself
Object.extend(Global, Namespace.prototype);
Global.namespaceIdentifier = 'Global';

Namespace.addMethods({ // module specific, should be a subclass?
	
	uri: function() { // FIXME cleanup necessary
		var id = this.namespaceIdentifier; // something like lively.Core
		var namespacePrefix;
		if (id.startsWith('Global.')) namespacePrefix = 'Global.';
		else throw dbgOn(new Error('unknown namespaceIdentifier'));
		var url = Config.codeBase + this.namespaceIdentifier.substr(namespacePrefix.length).replace(/\./g, '/');
		if (!this.isAnonymous()) url += '.js'; // FIXME not necessary JavaScript?!
		return url;
	},
	
	addDependendModule: function(depModule) {
		if (!this.dependendModules) this.dependendModules = [];
		this.dependendModules.push(depModule);
	},

	informDependendModules: function() {
		if (!this.dependendModules) return;
		var deps = this.dependendModules.uniq();
		this.dependendModules = [];
		deps.forEach(function(ea) { ea.removeRequiredModule(this) }, this);
	},
	
	addRequiredModule: function(requiredModule) {
		if (requiredModule.isLoaded()) return;
		if (!this.pendingRequirements) this.pendingRequirements = [];
		this.pendingRequirements.push(requiredModule);
		requiredModule.addDependendModule(this);
	},
	
	removeRequiredModule: function(requiredModule) {
		if (this.pendingRequirements && !this.pendingRequirements.include(requiredModule))
			throw dbgOn(new Error('requiredModule not there'));
		this.pendingRequirements = this.pendingRequirements.without(requiredModule);
		if (!this.hasPendingRequirements()) {
			// console.log('no more requirements for ' + this.uri());
			this.load();
		}
	},
		
	pendingRequirementNames: function() {
		if (!this.pendingRequirements) return [];
		return this.pendingRequirements.collect(function(ea) { return ea.uri() });	  
	},
	
	hasPendingRequirements: function() {
		return this.pendingRequirements && this.pendingRequirements.length > 0;
	},
	
	loadRequirementsFirst: function() {
		this.pendingRequirements && this.pendingRequirements.invoke('load');
	},
	
	addOnloadCallback: function(cb) {
		if (!this.callbacks) this.callbacks = [];
		this.callbacks.push(cb);
	},
	
	runOnloadCallbacks: function() {
		if (!this.callbacks) return;
		var cb;
		while (cb = this.callbacks.shift()) { cb() };
	},
	
	isLoaded: function() {
		return this._isLoaded;
	},
		
	isLoading: function() {
		// aaa - hack added by Adam to enable static loading
		if (window.avocado && avocado.isLoadingStatically) {return true;}

		// aaa - another hack added by Adam, to enable XHR+eval loading
		if (window.avocado && avocado.transporter && typeof avocado.transporter.loadedURLs[this.uri()] === 'function') {return true;}

		// aaa - jeez, one more hack, for when we use urlForKernelModuleName (like on GAE) -- Adam
		var name = this.namespaceIdentifier;
		if (name.indexOf("Global.") === 0) { name = name.substr("Global.".length); }
		if (name.indexOf("lively.") === 0) { name = name.substr("lively.".length); }
		if (name === 'jslint') {  // blecch
		} else {
		  name = "lk/" + name.replace(/\./g, '/');
		}

		var realURI;
		if (window.urlForKernelModuleName) {
  		realURI = window.urlForKernelModuleName(name);
		  if (window.avocado && avocado.transporter && typeof avocado.transporter.loadedURLs[realURI] === 'function') { return true;}
		}

		if (this.isLoaded()) return false;
		if (this.uri().include('anonymous')) return true;

		// Check both what LK thinks the URI should be and what Avocado thinks the URI should be. -- Adam
		if (Loader.scriptInDOM(this.uri())) return true;
		if (realURI && Loader.scriptInDOM(realURI)) return true;
		return false;
	},
	
	load: function() {
		if (this.isLoaded()) {
			this.runOnloadCallbacks();
			return;
		}
		if (this.isLoading() && this.wasDefined && !this.hasPendingRequirements()) {
			this.runOnloadCallbacks();
			this._isLoaded = true;
			// time is not only the time needed for the Netrequest and code evaluation
			// but the complete time span from the creation of the module (when the module is first encountered)
			// to evaluation the evaluation of its code, including load time of all requirements
			var time = this.createTime ? new Date() - this.createTime : 'na';
			// console.log(this.uri() + ' loaded in ' + time + ' ms'); // aaa - commented this out, it's annoying. -- Adam
			this.informDependendModules();
			return;
		}
		if (this.isLoading()) {
			this.loadRequirementsFirst();
			return;
		}
		Loader.loadJs(this.uri());
	},
	
	isAnonymous: function() {
		return this._isAnonymous
	},
	
	beAnonymous: function() {
		this._isAnonymous = true;
		return this;
	}
	
});

(function moveNamespaceClassToLivelyLang() {
	// namespace('lively.lang');
	lively = new Namespace(Global, 'lively');
	lively.lang = new Namespace(lively, 'lang');
	lively.lang.Namespace = Namespace;
	delete Namespace;
})();

lively.lang.Execution = { // will be extended later
	showStack: Functions.Null,
	resetDebuggingStack: Functions.Null,
	installStackTracers: Functions.Null,
};


lively.lang.let = function(/** **/) {
	// lively.lang.let(y, function(x) { body }) is equivalent to { let y = x; body; }
	return arguments[arguments.length - 1].apply(this, arguments);
}

/*
 * Stack Viewer when Dan's StackTracer is not available
 * FIXME rk: move this to Helper.js?
 */
function getStack() {
	var result = [];
	for(var caller = arguments.callee.caller; caller; caller = caller.caller) {
		if (result.indexOf(caller) != -1) {
		   result.push({name: "recursive call can't be traced"});
		   break;
		}
		result.push(caller);
	};
	return result;	
};

function printStack() {	 
	function guessFunctionName(func) {
		if(func.name) return func.name;
		var m = func.toString().match(/function (.+)\(/);
		if (m) return m[1];
		return func
	};

	var string = "== Stack ==\n";
	var stack = getStack();
	stack.shift(); // for getStack
	stack.shift(); // for printStack (me)
	var indent = "";
	for(var i=0; i < stack.length; i++) {
		string += indent + i + ": " +guessFunctionName(stack[i]) + "\n";
		indent += " ";		  
	};
	return string;
};

function logStack() {
	this.console.log(printStack())
};

/**
/* Our extensions to JavaScript base classes
 */

/**
  * Extensions to class Function
  */  
Object.extend(Function.prototype, {

	inspectFull: function() {
		var methodBody = this.toString();
		methodBody = methodBody.substring(8, methodBody.length);
		return this.qualifiedMethodName() + methodBody;
	},

	inspect: function() {
		// Print method name (if any) and the first 80 characters of the decompiled source (without 'function')
		var def = this.toString();
		var i = def.indexOf('{');
		var header = this.qualifiedMethodName() + def.substring(8, i);
		var body = (def.substring(i, 88) + (def.length > 88 ? '...' : '')).replace(/\n/g, ' ');	 // strip newlines
		return header + body;
	},

	qualifiedMethodName: function() {
		return (this.declaredClass ? this.declaredClass + "." : "")	 
		+ (this.methodName || this.name || "anonymous");
	},

	functionNames: function(filter) {
		var functionNames = [];

		for (var name in this.prototype) { 
			try {
				if ((this.prototype[name] instanceof Function) 
				&& (!filter || filter(name))) { 
					functionNames.push(name);
				} 
			} catch (er) {
				// FF can throw an exception here ...
			}
		}

		return functionNames;
	},

	withAllFunctionNames: function(callback) {
		for (var name in this.prototype) { 
			try {
				var value = this.prototype[name];
				if (value instanceof Function) 
					callback(name, value, this);
			} catch (er) {
				// FF can throw an exception here ...
			}
		}
	},

	localFunctionNames: function() {
		var sup = this.superclass || ((this === Object) ? null : Object);

		try {
			var superNames = (sup == null) ? [] : sup.functionNames();
		} catch (e) {
			var superNames = [];
		}
		var result = [];

		this.withAllFunctionNames(function(name, value, target) {
			if (!superNames.include(name) || target.prototype[name] !== sup.prototype[name]) 
				result.push(name);
		});
		return result;
	},

	getOriginal: function() {
		// get the original 'unwrapped' function, traversing as many wrappers as necessary.
		var func = this;
		while (func.originalFunction) func = func.originalFunction;
		return func;
	},
	
	logErrors: function(prefix) {
	  return this; // aaa this interferes with Chrome's debugging stuff -- Adam
	  
		if (Config.ignoreAdvice) return this;

		var advice = function logErrorsAdvice(proceed/*,args*/) {
			var args = $A(arguments); args.shift(); 
			try {
				return proceed.apply(this, args); 
			} catch (er) {
				if (prefix) console.warn("ERROR: %s.%s(%s): err: %s %s", this, prefix, args,  er, er.stack || "");
				else console.warn("ERROR: %s %s", er, er.stack || "");
				logStack();
				if (Global.printObject)
					console.warn("details: " + printObject(er));
				// lively.lang.Execution.showStack();
				throw er;
			}
		}
	
		advice.methodName = "$logErrorsAdvice";
		var result = this.wrap(advice);
		result.originalFunction = this;
		result.methodName = "$logErrorsWrapper";
		return result;
	},
	
	logCompletion: function(module) {
		if (Config.ignoreAdvice) return this;

		var advice = function logCompletionAdvice(proceed) {
			var args = $A(arguments); args.shift(); 
			try {
				var result = proceed.apply(this, args);
			} catch (er) {
				console.warn('failed to load %s: %s', module, er);
				lively.lang.Execution.showStack();
				throw er;
			}
			if (window.shouldShowLoadingMessages) { console.log('completed %s', module); }
			return result;
		}

		advice.methodName = "$logCompletionAdvice::" + module;

		var result = this.wrap(advice);
		result.methodName = "$logCompletionWrapper::" + module;
		result.originalFunction = this;
		return result;
	},

	logCalls: function(isUrgent) {
		if (Config.ignoreAdvice) return this;

		var original = this;
		var advice = function logCallsAdvice(proceed) {
			var args = $A(arguments); args.shift(); 
			var result = proceed.apply(this, args);
			if (isUrgent) { 
				console.warn('%s(%s) -> %s', original.qualifiedMethodName(), args, result); 
			} else {
				console.log( '%s(%s) -> %s', original.qualifiedMethodName(), args, result);
			}
			return result;
		}

		advice.methodName = "$logCallsAdvice::" + this.qualifiedMethodName();

		var result = this.wrap(advice);
		result.originalFunction = this;
		result.methodName = "$logCallsWrapper::" + this.qualifiedMethodName();
		return result;
	},
	
	traceCalls: function(stack) {
		var advice = function traceCallsAdvice(proceed) {
			var args = $A(arguments); args.shift();
			stack.push(args);
			var result = proceed.apply(this, args);
			stack.pop();
			return result;
		};
		return this.wrap(advice);
	}
	
});



/**
  * Extensions to class Number
  */  
Object.extend(Number.prototype, {

	// random integer in 0 .. n-1
	randomSmallerInteger: function() {
		return Math.floor(Math.random()*this); 
	},

	roundTo: function(quantum) {
		return Math.round(this/quantum)*quantum; 
	},

	toDegrees: function() { 
		return (this*180/Math.PI) % 360; 
	},

	toRadians: function() { 
		return this/180 * Math.PI; 
	}

});


/**
  * Extensions to class String
  */  
Object.extend(String.prototype, {
	size: function() { // so code can treat, eg, Texts like Strings
		return this.length;
	},

	asString: function() { // so code can treat, eg, Texts like Strings
		return this;
	}
});

/**
  * Extensions to class Array
  */  
Object.extend(Array.prototype, { 
	forEachShowingProgress: function(progressBar, iterator, labelFunc, whenDoneFunc) {
		progressBar.setValue(0);
		var steps = this.length;
		(this.reverse().inject(
			function() { progressBar.setValue(1); whenDoneFunc && whenDoneFunc() },
			function(nextFunc, item, idx) {
				return function() {
					progressBar.setValue((steps-idx) / steps);
					if (labelFunc)
						progressBar.setLabel(labelFunc(item, idx));
					iterator(item, idx);
					nextFunc.delay(0);
				}
			}
		))();
	},
});
Object.subclass('CharSet', {
	documentation: "limited support for charsets"
});

Object.extend(CharSet, {
	lowercase: "abcdefghijklmnopqrstuvwxyz",
	uppercase: "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
	digits: "0123456789",
	underscore: "_",
	nonAlpha: "`1234567890-=[]\;',./",
	shiftedNonAlpha: '~!@#$%^&*()_+{}:"<>?|',
	leftBrackets: "*({[<'" + '"',
	rightBrackets: "*)}]>'" + '"'
});

Object.extend(CharSet, {
	// select word, brackets
	alphaNum: CharSet.lowercase + CharSet.uppercase + CharSet.digits + CharSet.underscore,
	charsAsTyped: CharSet.uppercase + CharSet.nonAlpha,
	charsUnshifted: CharSet.lowercase + CharSet.nonAlpha,
	charsShifted: CharSet.uppercase + CharSet.shiftedNonAlpha,

	nonBlank: function(cc) {  
		return " \n\r\t".include(cc) == false;
	}

});
	
Object.subclass('Record', {

	description: "abstract data structure that maps getters/setters onto DOM properties or plain JS objects",
	definition: "none yet",
	// Note: can act as a mixin, so no instance state!

	initialize: function(rawNode, spec) {
		this.rawNode = rawNode; // DOM or plain JS Object
		Properties.forEachOwn(spec, function(key, value) { 
			this["set" + key].call(this, value); 
		}, this);
	},
	
	newRelay: function(spec) {
		return Relay.newInstance(spec, this);
	},

	addObserver: function(dep, optForwardingSpec) {
		if (optForwardingSpec) {
			// do forwarding
			dep = Relay.newInstance(optForwardingSpec, dep);
		}
		// find all the "on"<Variable>"Update" methods of dep
		for (var name in dep) {
			var match = name.match(/on(.*)Update/);
			if (match) {
				var varname = match[1];
				if (!this["set" + varname])
					throw new Error("cannot observe nonexistent variable " + varname);
				Record.addObserverTo(this, varname, dep);
			}
		}
	},

	// dep may be the relay or relay.delegate, can be called with dep, dep and fielName, or only with fielName
	removeObserver: function(dep, fieldName) {
		if (fieldName && !this[fieldName + '$observers']) {
			console.log('Tried to remove non existing observer:' + fieldName + '$observers');
			return;
		};
		if (fieldName && !dep) { // remove all abservers from this field
			this[Record.observerListName(fieldName)] = null;
			return;
		};
		var observerFields = fieldName ?
			[Record.observerListName(fieldName)] :
			Object.keys(this).select(function(ea) { return ea.endsWith('$observers') });
		observerFields.forEach(function(ea) {
			this[ea] = this[ea].reject(function(relay) { return relay === dep || relay.delegate === dep });
		}, this);
	},

	addObserversFromSetters: function(reverseSpec, dep, optKickstartUpdates) {
		var forwardSpec = {};
		Properties.forEachOwn(reverseSpec, function each(key, value) {
			if (Object.isString(value.valueOf())) {
				if (!value.startsWith("+")) // if not write only, get updates
					forwardSpec[value.startsWith("-") ? value.substring(1) : value] = "!" + key;
			} else if (value.mode !== '+') {
				var spec = forwardSpec[value.name] =  {};
				spec.name = "!" + key;
				// FIXME: Q&A the following
				spec.from = value.from;
				spec.to = value.to;
			}
		});
		// FIXME: sometimes automatic update callbacks are not desired!
		this.addObserver(dep, forwardSpec);
		function callUpdate(self, key, value, from) {
			var target = "on" + key + "Update";
			var source = "get" + value;
			// trigger updates
			try {
				var tmp = self[source].call(self);
				dep[target].call(dep, from ? from(tmp) : tmp);
			} catch (er) {
				console.log("on kickstart update: " + er + " on " + dep + " " + target
				+ " mapping to " + source + " " + er.stack);
			}
		}

		if (!optKickstartUpdates) return;
		Properties.forEachOwn(reverseSpec, function each(key, value) {
			if (Object.isString(value.valueOf())) {
				if (!value.startsWith("+")) {
					if (value.startsWith("-")) value = value.substring(1);
					callUpdate(this, key, value, value.from);
				}
			} else if (value.mode !== '+') {
				callUpdate(this, key, value.name, value.from);
			}
		}, this);
	},


	toString: function() {
		return "#<Record{" + String(JSON.serialize(this.definition)) + "}>";
	},

	create: function(bodySpec) { // called most likely on the prototype object
		var klass = this.constructor.subclass.apply(this.constructor);
		//console.log('got record type ' + this.constructor.name);
		klass.addMethods(Record.extendRecordClass(bodySpec));
		klass.prototype.definition = bodySpec;
		return klass;
	},
	
	// needed for adding fields for fabric
	addField: function(fieldName, coercionSpec, forceSet) {
		var spec = {}; spec[fieldName] = coercionSpec || {};
		this.constructor.addMethods(new Record.extendRecordClass(spec));
		this.definition[fieldName]= spec[fieldName];
		if (!forceSet) return;
		// does this do anything now?
		this['set' + fieldName] = this['set' + fieldName].wrap(function(proceed, value, optSource, force) {
			proceed(value, optSource, true);
		})
	}
	
});


Record.subclass('PlainRecord', {
	getRecordField: function(name) { return this.rawNode[name] },

	setRecordField: function(name, value) { return this.rawNode[name] = value },

	removeRecordField: function(name) { delete this.rawNode[name] }
});

Object.extend(Record, {
	
	newPlainInstance: function(spec) {
		var argSpec = {};
		var fieldSpec = {};
		Properties.forEachOwn(spec, function (key, value) {
			fieldSpec[key] = {};
			argSpec[key] = value;
		});
		return this.newInstance(fieldSpec, argSpec, {});
	},

	newNodeInstance: function(spec) { // backed by a DOM node
		var argSpec = {};
		var fieldSpec = {};
		Properties.forEachOwn(spec, function (key, value) {
			fieldSpec[key] = {};
			argSpec[key] = value;
		});
		return this.newInstance(fieldSpec, argSpec, NodeFactory.create("record"));
	},

	newInstance: function(fieldSpec, argSpec, optStore) {
		if (arguments.length < 2) throw new Error("call with two or more arguments");
		var storeClass;
		if (!optStore) {
			storeClass = lively.data.DOMNodeRecord; // FXIME forward reference
			optStore = NodeFactory.create("record"); // FIXME flat JavaScript instead by default?
		} else {
			storeClass = optStore instanceof Global.Node ? lively.data.DOMNodeRecord : PlainRecord;
		}

		var Rec = storeClass.prototype.create(fieldSpec);
		return new Rec(optStore, argSpec);
	},

	extendRecordClass: function(bodySpec) {
		var def = {};
		Properties.forEachOwn(bodySpec, function(name, value) {
			Record.addAccessorMethods(def, name, value);
		});
		return def;
	},

	addAccessorMethods: function(def, fieldName, spec) {
		dbgOn(fieldName.startsWith("set") || fieldName.startsWith("get")); // prolly a prob
		if (spec.mode !== "-")
			def["set" + fieldName] = this.newRecordSetter(spec.name || fieldName, spec.to, spec.byDefault);
		if (spec.mode !== "+")
			def["get" + fieldName] = this.newRecordGetter(spec.name || fieldName, spec.from, spec.byDefault);
	},

	
	observerListName: function(name) { return name + "$observers"},

	addObserverTo: function(rec, varname, dep) {
		var deps = rec[Record.observerListName(varname)];
		if (!deps) deps = rec[Record.observerListName(varname)] = [];
		else if (deps.indexOf(dep) >= 0) return;
		deps.push(dep);
	},
   
	notifyObserversOf: function(rec, fieldName, coercedValue, optSource, oldValue, force) {
		var deps = rec[Record.observerListName(fieldName)];
		if (!force && (oldValue === coercedValue)) {
			// console.log("--- notifyObserversOf stops here: " + rec + ", "+ fieldName + ", " + coercedValue);
			return;
		};
		var updateName = "on" + fieldName + "Update";
		if (!deps) return;
		for (var i = 0; i < deps.length; i++) {
			var dep = deps[i];
			// shouldn't this be uncoerced value? ......
			var method = dep[updateName];
			// console.log('updating  ' + updateName + ' in ' + Object.keys(dep));
			// "force" should not be propageted
			method.call(dep, coercedValue, optSource || rec /*rk: why pass rec in ?*/);
		}
	},

	newRecordSetter: function newRecordSetter(fieldName, to, byDefault) {
		var name = fieldName;
		return function recordSetter(value, optSource, optForce) {
			// console.log("set " + value + ", " + optSource + ", " + force)
			var coercedValue;
			if (value === undefined) {
				this.removeRecordField(name);
			} else {
				if (value == null && byDefault) value = byDefault;
				coercedValue = to ? to(value) : value;
				var oldValue = this.getRecordField(name) 
				this.setRecordField(name, coercedValue);
			}
			Record.notifyObserversOf(this, name, coercedValue, optSource, oldValue, optForce);
		}
	},
	
	newRecordGetter: function newRecordGetter(name, from, byDefault) {
		return function recordGetter() {
			if (this === this.constructor.prototype) // we are the prototype? not foolproof but works in LK
				return byDefault; 
			if (!this.rawNode)
				throw new Error("no rawNode");
			var value = this.getRecordField(name);
			if (!value && byDefault) return byDefault;
			else if (from) return from(value);
			else return value;
		}
	},

	createDependentObserver: function(target, computedProperty, baseProperties /*:Array*/) {
		// create an observer that will trigger the observers of
		// computedProperty whenever one of the baseProperties changes
		// The returned observer has to be added to target (as in target.addObserver

		var getterName = "get" + computedProperty;
		if (!target[getterName])
			throw new Error('unknown computedProperty ' + computedProperty);

		function notifier(value, source, record) {
			var newValue = record[getterName].call(record);
			return Record.notifyObserversOf(record, computedProperty, newValue);
		}
		var observer = {};
		baseProperties.forEach(function(prop) {
			// FIXME check if target has field "get" + prop
			observer["on" + prop + "Update"] = notifier;
		});
		return observer;
	},

});

Object.subclass('Relay', {
	documentation: "Property access forwarder factory",
	initialize: function(delegate) {
		// FIXME here a checker could verify this.prototype and check
		// that the delegate really has all the methods
		this.delegate = delegate; 
	}
});

Object.extend(Relay, {

	newRelaySetter: function newRelaySetter(targetName, optConv) {
		return function setterRelay(/*...*/) {
			if (!this.delegate)
				new Error("delegate in relay not existing " + targetName);
			var impl = this.delegate[targetName];
			if (!impl)
				throw dbgOn(new Error("delegate " + this.delegate + " does not implement " + targetName));
			var args = arguments;
			if (optConv) {
				args = $A(arguments);
				args.unshift(optConv(args.shift()));
			}
			return impl.apply(this.delegate, args);
		}
	},

	newRelayGetter: function newRelayGetter(targetName, optConv) {
		return function getterRelay(/*...*/) {
			if (!this.delegate)
				throw dbgOn(new Error("delegate in relay not existing " + targetName)); 
			var impl = this.delegate[targetName];
			if (!impl)
				throw dbgOn(new Error("delegate " + this.delegate + " does not implement " + targetName)); 
			var result = impl.apply(this.delegate, arguments);
			return optConv ? optConv(result) : result;
		}
	},

	newRelayUpdater: function newRelayUpdater(targetName, optConv) {
		return function updateRelay(/*...*/) {
			var impl = this.delegate[targetName];
			if (!impl)
				throw dbgOn(new Error("delegate " + this.delegate + " does not implement " + targetName)); 
			return impl.apply(this.delegate, arguments);
		}
	},

	handleStringSpec: function(def, key, value) {
		dbgOn(value.startsWith("set") || value.startsWith("get")); // probably a mixup

		if (value.startsWith("!")) {
			// call an update method with the derived name
			def["on" + key + "Update"] = Relay.newRelayUpdater("on" + value.substring(1) + "Update");
			// see below
			def["set" + key] = Relay.newRelayUpdater("on" + value.substring(1) + "Update");
		} else if (value.startsWith("=")) {
			// call exactly that method
			def["on" + key + "Update"] = Relay.newRelayUpdater(value.substring(1));
			// FIXME: e.g. closeHalo is a ButtonMorph,
			// this.closeHalo.connectModel(Relay.newInstance({Value: "=onRemoveButtonPress"}, this)); should call
			// this.onRemoveButtonPress()
			// the method newDelegatorSetter --> setter() which is triggered from setValue() of the button would only look
			// for the method setValue in def, but there is onyl onValueUpdate, so add also setValue ...
			def["set" + key] = Relay.newRelayUpdater(value.substring(1));
		} else {
			if (!value.startsWith('-')) { // not read-only
				var stripped = value.startsWith('+') ? value.substring(1) : value;
				def["set" + key] = Relay.newRelaySetter("set" + stripped);
			}
			if (!value.startsWith('+')) { // not write-only
				var stripped = value.startsWith('-') ? value.substring(1) : value;
				def["get" + key] = Relay.newRelayGetter("get" + stripped);
			}
		}
	},


	handleDictSpec: function(def, key, spec) { // FIXME unused
		var mode = spec.mode;
		if (mode === "!") {
			// call an update method with the derived name
			def["on" + key + "Update"] = Relay.newRelayUpdater("on" + spec.name + "Update", spec.from);
		} else if (mode === "=") {
			// call exactly that method
			def["on" + key + "Update"] = Relay.newRelayUpdater(spec.name, spec.from);
		} else {
			if (mode !== '-') { // not read-only
				def["set" + key] = Relay.newRelaySetter("set" + spec.name, spec.to);
			}
			if (mode !== '+') { // not write-only
				def["get" + key] = Relay.newRelayGetter("get" + spec.name, spec.from);
			}
		}
	},

	create: function(args) {
		var klass = Relay.subclass();
		var def = {
			definition: Object.clone(args), // how the relay was constructed
			copy: function(copier) {
				var result =  Relay.create(this.definition);
				copier.shallowCopyProperty("delegatee", result, this);
				return result
			},
			toString: function() {
				return "#<Relay{" + String(JSON.serialize(args)) + "}>";
			}
		};
		Properties.forEachOwn(args, function(key, spec) { 
			if (Object.isString(spec.valueOf()))
				Relay.handleStringSpec(def, key, spec); 
			else 
			Relay.handleDictSpec(def, key, spec);
		});

		klass.addMethods(def);
		return klass;
	},

	newInstance: function(spec, delegate) {
		var Fwd = Relay.create(spec); // make a new class
		return new Fwd(delegate); // now make a new instance
	},
	
	// not sure if it belongs in Relay	  
	newDelegationMixin: function(spec) {

		function newDelegatorGetter (name, from, byDefault) {
			var methodName = "get" + name;
			return function getter() {
				var m = this.formalModel;
				if (!m)
					return this.getModelValue(methodName, byDefault);
				var method = m[methodName];
				if (!method) return byDefault;
				var result = method.call(m);
				return (result === undefined) ? byDefault : (from ? from(result) : result);
			}
		}

		function newDelegatorSetter(name, to) {
			var methodName = "set" + name;
			return function setter(value, force) {
				var m = this.formalModel;
				if (!m) 
					return this.setModelValue(methodName, value);
				var method = m[methodName];
				// third arg is source, fourth arg forces relay to set value even if oldValue === value
				return method && method.call(m, to ? to(value) : value, this, force);
			}
		}

		var klass = Object.subclass();

		if (spec instanceof Array) {
			spec.forEach(function(name) {
				if (!name.startsWith('-')) { // not read-only
					var stripped = name.startsWith('+') ? name.substring(1) : name;
					klass.prototype["set" + stripped] = newDelegatorSetter(stripped);
				}
				if (!name.startsWith('+')) { // not write-only
					var stripped = name.startsWith('-') ? name.substring(1) : name;
					klass.prototype["get" + stripped] = newDelegatorGetter(stripped);
				}
			});
		} else {
			Properties.forEachOwn(spec, function(name, desc) {
				var mode = desc.mode;
				if (mode !== "-")
					klass.prototype["set" + name] = newDelegatorSetter(name, desc.to);
				if (mode !== "+")
					klass.prototype["get" + name] = newDelegatorGetter(name, desc.from, desc.byDefault);
			});
		}
		return klass;
	}

});

namespace('lively');
// Global.console && Global.console.log("loaded basic library"); // commented out by Adam - it's getting annoying


// ===========================================================================
// Portable graphics foundations
// ===========================================================================

Object.subclass("Point", {
	documentation: "2D Point",

	initialize: function(x, y) {
		this.x = x;
		this.y = y;
		return this;
	},

	deserialize: function(importer, string) { // reverse of toString
		var array = string.slice(3, -1).split(',');
		this.x = lively.data.Coordinate.parse(array[0]);
		this.y = lively.data.Coordinate.parse(array[1]);
	},

	addPt: function(p) { return new Point(this.x + p.x, this.y + p.y); },
	addXY: function(dx,dy) { return new Point(this.x + dx, this.y + dy); },
	midPt: function(p) { return new Point((this.x + p.x)/2, (this.y + p.y)/2); },
	subPt: function(p) { return new Point(this.x - p.x, this.y - p.y); },
	negated: function() { return new Point(-this.x, -this.y); },
	inverted: function() { return new Point(1.0/this.x, 1.0/this.y); },
	invertedSafely: function() { return new Point(this.x && 1.0/this.x, this.y && 1.0/this.y); },
	scaleBy: function(scale) { return new Point(this.x*scale,this.y*scale); },
	scaleByPt: function(scalePt) { return new Point(this.x*scalePt.x,this.y*scalePt.y); },
	lessPt: function(p) { return this.x < p.x && this.y < p.y; },
	leqPt: function(p) { return this.x <= p.x && this.y <= p.y; },
	eqPt: function(p) { return this.x == p.x && this.y == p.y; },
	withX: function(x) { return pt(x, this.y); },
	withY: function(y) { return pt(this.x, y); },

	normalized: function() {
		var r = this.r();
		return pt(this.x / r, this.y / r);
	},

	dotProduct: function(p) { return this.x * p.x + this.y * p.y },

	minPt: function(p, acc) { 
		if (!acc) acc = new Point(0, 0); 
		acc.x = Math.min(this.x, p.x); 
		acc.y = Math.min(this.y, p.y);	
		return acc;
	},

	maxPt: function(p, acc) { 
		if (!acc) acc = new Point(0, 0);
		acc.x = Math.max(this.x, p.x);
		acc.y = Math.max(this.y, p.y); 
		return acc;
	},

	roundTo: function(quantum) { return new Point(this.x.roundTo(quantum), this.y.roundTo(quantum)); },

	random: function() {  return new Point(this.x*Math.random(), this.y*Math.random());	 },

	dist: function(p) { 
		var dx = this.x - p.x;
		var dy = this.y - p.y;
		return Math.sqrt(dx*dx + dy*dy); 
	},

	nearestPointOnLineBetween: function(p1, p2) { // fasten seat belts...
		if (p1.x == p2.x) return pt(p1.x, this.y);
		if (p1.y == p2.y) return pt(this.x, p1.y);
		var x1 = p1.x;
		var y1 = p1.y;
		var x21 = p2.x - x1;
		var y21 = p2.y - y1;
		var t = (((this.y - y1) / x21) + ((this.x - x1) / y21)) / ((x21 / y21) + (y21 / x21));
		return pt(x1 + (t * x21) , y1 + (t * y21)); 
	},

	asRectangle: function() { return new Rectangle(this.x, this.y, 0, 0); },
	extent: function(ext) { return new Rectangle(this.x, this.y, ext.x, ext.y); },
	extentAsRectangle: function() { return new Rectangle(0, 0, this.x, this.y) },

	toString: function() {
		return Strings.format("pt(%1.f,%1.f)", this.x, this.y);
	},

	toTuple: function() {
		return [ this.x, this.y ];
	},

	toLiteral: function() { return {x: this.x, y: this.y}; },

	inspect: function() {
		return JSON.serialize(this);
	},

	matrixTransform: function(mx, acc) {
		if (!acc) acc = pt(0, 0); // if no accumulator passed, allocate a fresh one
		acc.x = mx.a * this.x + mx.c * this.y + mx.e;
		acc.y = mx.b * this.x + mx.d * this.y + mx.f;
		return acc;
	},

	matrixTransformDirection: function(mx, acc) {
		if (!acc) acc = pt(0, 0); // if no accumulator passed, allocate a fresh one
		acc.x = mx.a * this.x + mx.c * this.y ;
		acc.y = mx.b * this.x + mx.d * this.y ;
		return acc;
	},
	
	// added by Adam for compatibility with other coordinate systems where y goes up instead of down
  moveDownAndRightBy: function (x, y) {
    return this.addXY(x, y);
  },

	// Polar coordinates (theta=0 is East on screen, and increases in CCW direction
	r: function() { return this.dist(pt(0,0)); },
	theta: function() { return Math.atan2(this.y,this.x); },

	copy: function() { return new Point(this.x, this.y); }
});

Point.addMethods({

	fastR: function() { 
		var a = this.x*this.x+this.y*this.y;
		var x = 17;
		for (var i = 0; i < 6; i++)
		x = (x+a/x)/2;
		return x;
	},

	fastNormalized: function() {
		var r = this.fastR();
		return pt(this.x / r, this.y / r);
	},
});

Object.extend(Point, {

	ensure: function(duck) { // make sure we have a Lively point
		if (duck instanceof Point) { 
			return duck;
		} else { 
			return new Point(duck.x, duck.y);
		}
	},

	// Note: theta=0 is East on the screen, and increases in counter-clockwise direction
	polar: function(r, theta) { return new Point(r*Math.cos(theta), r*Math.sin(theta)); },
	random: function(scalePt) { return new Point(scalePt.x.randomSmallerInteger(), scalePt.y.randomSmallerInteger()); },

	fromLiteral: function(literal) {
		return pt(literal.x, literal.y);
	}

});

// Shorthand for creating point objects
function pt(x, y) { 
	return new Point(x, y);
}

Object.subclass("Rectangle", {

	documentation: "primitive rectangle", 
	// structually equivalent to SVGRect 
	
	initialize: function(x, y, w, h) {
	this.x = x;
	this.y = y;
	this.width = w;
	this.height = h;
	return this;
	},

	copy: function() { return new Rectangle(this.x, this.y, this.width, this.height);  },
	maxX: function() { return this.x + this.width; },
	maxY: function() { return this.y + this.height; },
	withWidth: function(w) { return new Rectangle(this.x, this.y, w, this.height)},
	withHeight: function(h) { return new Rectangle(this.x, this.y, this.width, h)},
	withX: function(x) { return new Rectangle(x, this.y, this.width, this.height)},
	withY: function(y) { return new Rectangle(this.x, y, this.width, this.height)},
	extent: function() { return new Point(this.width,this.height); },
	withExtent: function(ext) { return new Rectangle(this.x, this.y, ext.x, ext.y); },
	center: function() { return new Point(this.x+(this.width/2),this.y+(this.height/2))},
	//Control point readers and writers
	topLeft: function() { return new Point(this.x, this.y)},
	topRight: function() { return new Point(this.maxX(), this.y)},
	bottomRight: function() { return new Point(this.maxX(), this.maxY())},
	bottomLeft: function() { return new Point(this.x, this.maxY())},
	leftCenter: function() { return new Point(this.x, this.center().y)},
	rightCenter: function() { return new Point(this.maxX(), this.center().y)},
	topCenter: function() { return new Point(this.center().x, this.y)},
	bottomCenter: function() { return new Point(this.center().x, this.maxY())},
	withTopLeft: function(p) { return Rectangle.fromAny(p, this.bottomRight()) },
	withTopRight: function(p) { return Rectangle.fromAny(p, this.bottomLeft()) },
	withBottomRight: function(p) { return Rectangle.fromAny(p, this.topLeft()) },
	withBottomLeft: function(p) { return Rectangle.fromAny(p, this.topRight()) },
	withLeftCenter: function(p) { return new Rectangle(p.x, this.y, this.width + (this.x - p.x), this.height)},
	withRightCenter: function(p) { return new Rectangle(this.x, this.y, p.x - this.x, this.height)},
	withTopCenter: function(p) { return new Rectangle(this.x, p.y, this.width, this.height + (this.y - p.y))},
	withBottomCenter: function(p) { return new Rectangle(this.x, this.y, this.width, p.y - this.y)}
});

Rectangle.addMethods({

	containsPoint: function(p) {
		return this.x <= p.x && p.x <= this.x + this.width && this.y<= p.y && p.y <= this.y + this.height;
	},

	containsRect: function(r) {
		return this.x <= r.x && this.y<= r.y && r.maxX()<=this.maxX() && r.maxY()<=this.maxY();
	},

	constrainPt: function(pt) { return pt.maxPt(this.topLeft()).minPt(this.bottomRight()); },

	intersection: function(r) {
		// return rect(this.topLeft().maxPt(r.topLeft()),this.bottomRight().minPt(r.bottomRight())); 
		var nx = Math.max(this.x, r.x);
		var ny = Math.max(this.y, r.y);
		var nw = Math.min(this.x + this.width, r.x + r.width) - nx;
		var nh = Math.min(this.y + this.height, r.y + r.height) - ny;
		return new Rectangle(nx, ny, nw, nh);
	},

	intersects: function(r) { return this.intersection(r).isNonEmpty(); },	// not the fastest

	union: function(r) {
	  // Optimized to avoid creating Point objects. -- Adam
	  var locationX = Math.min(this.x, r.x);
	  var locationY = Math.min(this.y, r.y);
	  var cornerX = Math.max(this.maxX(), r.maxX());
	  var cornerY = Math.max(this.maxY(), r.maxY());
  	return new Rectangle(locationX, locationY, cornerX - locationX, cornerY - locationY);
		// return rect(this.topLeft().minPt(r.topLeft()),this.bottomRight().maxPt(r.bottomRight())); 
	},

	isNonEmpty: function(rect) { return this.width > 0 && this.height > 0; },

	dist: function(r) { // dist between two rects
		var p1 = this.closestPointToPt(r.center()); 
		var p2 = r.closestPointToPt(p1);  
		return p1.dist(p2); 
	},

	closestPointToPt: function(p) { // Assume p lies outside me; return a point on my perimeter
		return pt(Math.min(Math.max(this.x, p.x), this.maxX()),
		Math.min(Math.max(this.y, p.y), this.maxY())); 
	},

	randomPoint: function() { // return a some point from inside me
		return Point.random(pt(this.width, this.height)).addPt(this.topLeft());
	},

  // Hacked to allow callers to avoid creating the Point object. -- Adam
	translatedBy: function(d) {
		return this.translatedByXY(d.x, d.y);
	},
	translatedByXY: function(dx, dy) {
		return new Rectangle(this.x+dx, this.y+dy, this.width, this.height); 
	},

	scaleByRect: function(r) { // r is a relative rect, as a pane spec in a window
		return new Rectangle (
			this.x + (r.x*this.width),
			this.y + (r.y*this.height),
			r.width * this.width,
			r.height * this.height ); 
	},

	scaleRectIn: function(fullRect) { // return a relative rect for this as a part of fullRect
		return new Rectangle (
			(this.x - fullRect.x) / fullRect.width,
			(this.y - fullRect.y) / fullRect.height,
			this.width	/ fullRect.width,
			this.height / fullRect.height ); 
	},
	
	// Added by Adam
	matrixTransform: function(tfm) {
    return rect(this.topLeft().matrixTransform(tfm), this.bottomRight().matrixTransform(tfm));
	},

	insetBy: function(d) {
		return new Rectangle(this.x+d, this.y+d, this.width-(d*2), this.height-(d*2));
	},

	insetByPt: function(p) {
		return new Rectangle(this.x+p.x, this.y+p.y, this.width-(p.x*2), this.height-(p.y*2));
	},

	expandBy: function(delta) { return this.insetBy(0 - delta); }

});

Object.extend(Rectangle, {
	corners: ["topLeft","topRight","bottomRight","bottomLeft"], 
	sides: ["leftCenter","rightCenter","topCenter","bottomCenter"]
});

Rectangle.addMethods({

	partNamed: function(partName) { 
		return this[partName].call(this); 
	},

	withPartNamed: function(partName,newValue) {
		return this[this.setterName(partName)].call(this, newValue); 
	},

	setterName: function(partName) {
		return "with" + partName[0].toUpperCase() + partName.slice(1); 
	},

	partNameNear: function(partNames,p,dist) { 
		var partName = this.partNameNearest(partNames,p);
		return (p.dist(this.partNamed(partName)) < dist) ? partName : null; 
	},

	partNameNearest: function(partNames, p) { 
		var dist = 1.0e99;
		var partName = partNames[0];

		for (var i=0; i<partNames.length; i++) { 
			var partName = partNames[i];
			var pDist = p.dist(this.partNamed(partName));
			if (pDist < dist) {var nearest = partName; dist = pDist} 
		}

		return nearest; 
	},

	toString: function() { 
		return Strings.format("rect(%s,%s)", this.topLeft(), this.bottomRight());
	},

	toTuple: function() {
		return [this.x, this.y, this.width, this.height];
	},

	inspect: function() {
		return JSON.serialize(this);
	}
});

Rectangle.addMethods({
	// These methods enable using rectangles as insets, modeled after
	// the CSS box model, see http://www.w3.org/TR/REC-CSS2/box.html
	// note topLeft() bottomRight() etc, return the intuitively
	// correct values for Rectangles used as insets.

	left: function() {
		return this.x;
	},

	right: function() {
		return this.maxX();
	},

	top: function() {
		return this.y;
	},

	bottom: function() {
		return this.maxY();
	},

	toInsetTuple: function() {
		return [this.left(), this.top(), this.right(), this.bottom()];
	},

	toAttributeValue: function(d) {
		var d = 0.01;
		var result = [this.left()];
		if (this.top() === this.bottom() && this.left() === this.right()) {
			if (this.top() === this.left()) result.push(this.top());
			} else result = result.concat([this.top(), this.right(), this.bottom()]);
			return result.invoke('roundTo', d || 0.01);
	},

	insetByRect: function(r) {
		return new Rectangle(this.x + r.left(), this.y + r.top(), this.width - (r.left() + r.right()), this.height - (r.top() + r.bottom()));
	},

	outsetByRect: function(r) {
		return new Rectangle(this.x - r.left(), this.y - r.top(), this.width + (r.left() + r.right()), this.height + (r.top() + r.bottom()));
	},

	toLiteral: function() { return {x: this.x, y: this.y, width: this.width, height: this.height}; },

});



Object.extend(Rectangle, {

	fromAny: function(ptA, ptB) {
		return rect(ptA.minPt(ptB), ptA.maxPt(ptB));
	},

	fromLiteral: function(literal) {
		return new Rectangle(literal.x, literal.y, literal.width, literal.height);
	},

	unionPts: function(points) {
		var min = points[0];
		var max = points[0];

		// AT: Loop starts from 1 intentionally
		for (var i = 1; i < points.length; i++) {
			min = min.minPt(points[i]);
			max = max.maxPt(points[i]); 
		}

		return rect(min, max); 
	},

	ensure: function(duck) {
		if (duck instanceof Rectangle) {
			return duck;
		} else {
			return new Rectangle(duck.x, duck.y, duck.width, duck.height);
		}
	},

	fromElement: function(element) {
		return new Rectangle(element.x.baseVal.value, element.y.baseVal.value, 
			element.width.baseVal.value, element.height.baseVal.value);
	},

	inset: function(left, top, right, bottom) {
		if (top === undefined) top = left;
		if (right === undefined) right = left;
		if (bottom === undefined) bottom = top;
		return new Rectangle(left, top, right - left, bottom - top);
	}

});

// Shorthand for creating rectangle objects
function rect(location, corner) {
	return new Rectangle(location.x, location.y, corner.x - location.x, corner.y - location.y);
};

// ===========================================================================
// Color support
// ===========================================================================

Object.subclass("Color", { 

	documentation: "Fully portable support for RGB colors",

	initialize: function(r, g, b) {
		this.r = r;
		this.g = g;
		this.b = b;
	},

	// Mix with another color -- 1.0 is all this, 0.0 is all other
	mixedWith: function(other, proportion) { 
		var p = proportion;
		var q = 1.0 - p;
		return new Color(this.r*p + other.r*q, this.g*p + other.g*q, this.b*p + other.b*q); 
	},

	darker: function(recursion) { 
		var result = this.mixedWith(Color.black, 0.5);
		return recursion > 1  ? result.darker(recursion - 1) : result;
	},

	lighter: function(recursion) { 
		if (recursion == 0) 
			return this;
		var result = this.mixedWith(Color.white, 0.5);
		return recursion > 1 ? result.lighter(recursion - 1) : result;
	},
	
	// added by Adam
	isVeryLight: function() { return this.r >= 0.95 && this.g >= 0.95 && this.b >= 0.95; },
	isVeryDark:  function() { return this.r <= 0.05 && this.g <= 0.05 && this.b <= 0.05; },

	toString: function() {
		function floor(x) { return Math.floor(x*255.99) };
		return "rgb(" + floor(this.r) + "," + floor(this.g) + "," + floor(this.b) + ")";
	},

	toTuple: function() {
		return [this.r, this.g, this.b];
	},
	
	deserialize: function(importer, colorStringOrTuple) {
		if (!colorStringOrTuple) return null;
		// dbgOn(!str.match);
		var color;
		if (colorStringOrTuple instanceof Color) color = colorStringOrTuple;
		else if (colorStringOrTuple instanceof String) color = Color.fromString(colorStringOrTuple)
		else color = Color.fromTuple(colorStringOrTuple);
		this.r = color.r;
		this.g = color.g;
		this.b = color.b;
	}
});

Object.extend(Color, {

	black: new Color(0,0,0),
	white: new Color(1,1,1),
	gray: new Color(0.8,0.8,0.8),
	red: new Color(0.8,0,0),
	green: new Color(0,0.8,0),
	yellow: new Color(0.8,0.8,0),
	blue:  new Color(0,0,0.8),
	purple: new Color(1,0,1),
	magenta: new Color(1,0,1),
	

	random: function() {
		return new Color(Math.random(),Math.random(),Math.random()); 
	},

	hsb: function(hue,sat,brt) {
		var s = sat;
		var b = brt;
		// zero saturation yields gray with the given brightness
		if (sat == 0) return new Color(b,b,b);
		var h = hue % 360;
		var h60 = h / 60;
		var i = Math.floor(h60); // integer part of hue
		var f = h60 - i; // fractional part of hue
		var p = (1.0 - s) * b;
		var q = (1.0 - (s * f)) * b;
		var t = (1.0 - (s * (1.0 - f))) * b;

		switch (i) {
			case 0:	 return new Color(b,t,p);
			case 1:	 return new Color(q,b,p);
			case 2:	 return new Color(p,b,t);
			case 3:	 return new Color(p,q,b);
			case 4:	 return new Color(t,p,b);
			case 5:	 return new Color(b,p,q);
			default: return new Color(0,0,0); 
		} 
	},

	wheel: function(n) { 
		return Color.wheelHsb(n,0.0,0.9,0.7); 
	},

	// Return an array of n colors of varying hue
	wheelHsb: function(n,hue,sat,brt) {
		var a = new Array(n);
		var step = 360.0 / (Math.max(n,1));

		for (var i = 0; i < n; i++) 
		a[i] = Color.hsb(hue + i*step, sat, brt);

		return a; 
	},

	rgb: function(r, g, b) {
		return new Color(r/255, g/255, b/255);
	},

	fromLiteral: function(spec) {
		return new Color(spec.r, spec.g, spec.b);
	},

	fromTuple: function(tuple) {
		return new Color(tuple[0], tuple[1], tuple[2]);
	},

	fromString: function(str) {
		var tuple = Color.parse(str);
		return tuple && Color.fromTuple(tuple);
	},

	parse: function(str) { 
		// FIXME this should be much more refined
		// FIXME handle keywords
		if (!str || str == 'none')
			return null;
		var match = str.match("rgb\\((\\d+),(\\d+),(\\d+)\\)");
		var r,g,b;
		if (match) { 
			r = parseInt(match[1])/255;
			g = parseInt(match[2])/255;
			b = parseInt(match[3])/255;
			return [r, g, b];
		} else if (str.length == 7 && str.charAt(0) == '#') {
			r = parseInt(str.substring(1,3), 16)/255;
			g = parseInt(str.substring(3,5), 16)/255;
			b = parseInt(str.substring(5,7), 16)/255;
			return [r, g, b];
		} else return null;
	}
});


Object.extend(Color, {
	darkGray: Color.gray.darker(),
	lightGray: Color.gray.lighter(),
	veryLightGray: Color.gray.lighter().lighter(),
	turquoise: Color.rgb(0, 240, 255),
	//	  brown: Color.rgb(182, 67, 0),
	//	  red: Color.rgb(255, 0, 0),
	orange: Color.rgb(255, 153, 0),
	//	  yellow: Color.rgb(204, 255, 0),
	//	  limeGreen: Color.rgb(51, 255, 0),
	//	  green: Color.rgb(0, 255, 102),
	//	  cyan: Color.rgb(0, 255, 255),
	//	  blue: Color.rgb(0, 102, 255),
	//	  purple: Color.rgb(131, 0, 201),
	//	  magenta: Color.rgb(204, 0, 255),
	//	  pink: Color.rgb(255, 30, 153),

	tangerine: Color.rgb(242, 133, 0),

	primary: {
		// Sun palette
		blue: Color.rgb(0x53, 0x82, 0xA1),
		orange: Color.rgb(0xef, 0x6f, 0x00),
		green: Color.rgb(0xb2, 0xbc, 00),
		yellow: Color.rgb(0xff, 0xc7, 0x26)
	},

	secondary: {
		blue: Color.rgb(0x35, 0x55, 0x6b),
		orange: Color.rgb(0xc0, 0x66, 0x00),
		green: Color.rgb(0x7f, 0x79, 0x00),
		yellow: Color.rgb(0xc6, 0x92, 0x00)
	},

	neutral: {
		lightGray: Color.rgb(0xbd, 0xbe, 0xc0),
		gray: Color.rgb(0x80, 0x72, 0x77)
	}

});

// Global.console && Global.console.log("Loaded platform-independent graphics primitives"); // commented out by Adam - it's getting annoying

namespace('lively.data');
// FIXME the following does not really belong to Base should be somewhere else
Record.subclass('lively.data.DOMRecord', {
	description: "base class for records backed by a DOM Node",
	noShallowCopyProperties: ['id', 'rawNode', '__annotation__'], // __annotation__ added by Adam

	initialize: function($super, store, argSpec) {
		$super(store, argSpec);
		this.setId(this.newId());
		var def = this.rawNode.appendChild(NodeFactory.create("definition"));
		def.appendChild(NodeFactory.createCDATA(String(JSON.serialize(this.definition))));
	},

	deserialize: function(importer, rawNode) {
		this.rawNode = rawNode;
	},

	getRecordField: function(name) { 
		dbgOn(!this.rawNode || !this.rawNode.getAttributeNS);
		var result = this.rawNode.getAttributeNS(null, name);
		if (result === null) return undefined;
		else if (result === "") return null;
		if (result.startsWith("json:")) return Converter.fromJSONAttribute(result.substring("json:".length));
		else return result;
	},

	setRecordField: function(name, value) {
		if (value === undefined) {
			throw new Error("use removeRecordField to remove " + name);
		}
		if (value && Converter.needsJSONEncoding(value)) {
			value = "json:" + Converter.toJSONAttribute(value);
		}

		return this.rawNode.setAttributeNS(null, name, value || "");
	},

	removeRecordField: function(name) {
		return this.rawNode.removeAttributeNS(null, name);
	},

	copyFrom: function(copier, other) {
		// console.log("COPY DOM RECORD")
		if (other.rawNode) this.rawNode = other.rawNode.cloneNode(true);
		this.setId(this.newId());
		copier.addMapping(other.id(), this);

		copier.shallowCopyProperties(this, other);
		
		return this; 
	},

});

lively.data.DOMRecord.subclass('lively.data.DOMNodeRecord', {
	documentation: "uses nodes instead of attributes to store values",

	getRecordField: function(name) { 
		var fieldElement = this[name + "$Element"];
		if (fieldElement) {
			if (lively.data.Wrapper.isInstance(fieldElement)) {
				return fieldElement; // wrappers are stored directly
			};			
			if (LivelyNS.getAttribute(fieldElement, "isNode")) return fieldElement.firstChild; // Replace with DocumentFragment
			var value = fieldElement.textContent;
			if (value) {
			var family = LivelyNS.getAttribute(fieldElement, "family");
			if (family) {
				var klass = Class.forName(family);
				if (klass) throw new Error('unknown type ' + family);
				return klass.fromLiteral(JSON.unserialize(value, Converter.nodeDecodeFilter));
				} else {
					if (value == 'NaN') return NaN;
					if (value == 'undefined') return undefined;
					if (value == 'null') return null;
					// jl: fixes a bug but wrapperAndNodeDecodeFilter is not clever enought... 
					// so waiting for pending refactoring
					// return JSON.unserialize(value, Converter.wrapperAndNodeDecodeFilter);
					return JSON.unserialize(value);
				}
			}
		} else {
			// console.log('not found ' + name);
			return undefined;
		}
	},
	
	setRecordField: function(name, value) {
		if (value === undefined) {
			throw new Error("use removeRecordField to remove " + name);
		}
		var propName = name + "$Element"; 
		var fieldElement = this[propName];
		if (fieldElement && fieldElement.parentElement === this.rawNode) {
			this.rawNode.removeChild(fieldElement);
		}
		
		if (lively.data.Wrapper.isInstance(value)) { 
			this[propName] = value; // don't encode wrappers, handle serialization somewhere else 
		} else {
			fieldElement = Converter.encodeProperty(name, value);
			if (fieldElement) this.rawNode.appendChild(fieldElement);
			else console.log("failed to encode " + name + "= " + value);
			this[propName] = fieldElement;
		}
		// console.log("created cdata " + fieldElement.textContent);
	},
	
	removeRecordField: function(name) {
		var fieldElement = this[name + "$Element"];
		if (fieldElement) {
			try { // FIXME ... argh!!!
				this.rawNode.removeChild(fieldElement);
			} catch(e) {
				console.warn('Cannot remove record field' + name + ' of ' + this + ' because ' + e);
			}
			delete this.fieldElement;
		}
	},

	

	deserialize: function(importer, rawNode) {
		this.rawNode = rawNode;
	
		var bodySpec = JSON.unserialize(rawNode.getElementsByTagName('definition')[0].firstChild.textContent);
		this.constructor.addMethods(Record.extendRecordClass(bodySpec));
		this.definition = bodySpec;
	
		$A(rawNode.getElementsByTagName("field")).forEach(function(child) {
				// this[name + "$Element"] = child.getAttributeNS(null, "name");
			this[child.getAttributeNS(null, "name") + "$Element"] = child;
		}, this);
	},

	copyFrom: function($super, copier, other) {
		$super(copier, other);
		this.constructor.addMethods(Record.extendRecordClass(other.definition));
		$A(this.rawNode.getElementsByTagName("field")).forEach(function(child) {
			this[child.getAttributeNS(null, "name") + "$Element"] = child;
		}, this);
		return this; 
	},

	updateDefintionNode: function() {
		var definitionNode = this.rawNode.getElementsByTagName("definition")[0];
		definitionNode.removeChild(definitionNode.firstChild);
		definitionNode.appendChild(NodeFactory.createCDATA(String(JSON.serialize(this.definition))));  
	},
	
	addField: function($super, fieldName, coercionSpec, forceSet) {
		$super(fieldName, coercionSpec, forceSet);
		this.updateDefintionNode();
	}
	
});

// note: the following happens later
//Class.addMixin(DOMRecord, lively.data.Wrapper.prototype);

Record.subclass('lively.data.StyleRecord', {
	description: "base class for records backed by a DOM Node",
	getRecordField: function(name) { 
		dbgOn(!this.rawNode || !this.rawNode.style);
		var result = this.rawNode.style.getPropertyValue(name);

		if (result === null) return undefined;
		else if (result === "") return null;
		else return result;
	},

	setRecordField: function(name, value) {
		dbgOn(!this.rawNode || !this.rawNode.style);
		if (value === undefined) {
			throw new Error("use removeRecordField to remove " + name);
		}
		return this.rawNode.style.setProperty(name, value || "", "");
	},

	removeRecordField: function(name) {
		dbgOn(!this.rawNode || !this.rawNode.style);
		return this.rawNode.style.removeProperty(name);
	}

});


Object.subclass('lively.data.Bind', {
	// unify with the record mechanism
	
	// note that Bind could specify which model to bind to, not just the default one
	initialize: function(varName, kickstart, debugString) {
		this.varName = varName;
		this.kickstart = kickstart;
		this.key = null;
		this.debugString = debugString;
		this["on" + varName + "Update"] = this.update;
	},

	update: function(value) {
		if (Object.isNumber(this.key)) {
			console.log('cannot notify owner of array ' + this.target + ' to update element ' + this.key);
			return;
		}
		var method = this.target["set" + this.key];
		if (!method) { console.warn('no method for binding ' + this.varName + " to " + this.key); return }
		if (this.debugString) console.log('triggering update of ' + this.varName  + " to " + value 
		+ " context " + this.debugString);
		method.call(this.target, value);
	},


	get: function(model) {
		if (!model) return undefined;
		var method = model["get" + this.varName];
		dbgOn(!method);
		var result = method.call(model);
		if (this.debugString) 
			console.log('Bind to:' + this.varName  + " retrieved model value " + result	 
		+ ' context '  + this.debugString);
		return result;
	},

	toString: function() {
		return "{Bind to: " + this.varName + "}";
	},

	hookup: function(target, model) {
		this.target = target;
		model.addObserver(this);
		if (this.kickstart)
			this.update(this.get(model)); // kickstart
	}
});

Object.extend(lively.data.Bind, {
	fromLiteral: function(literal) {
		return new lively.data.Bind(literal.to, literal.kickstart || false, literal.debugString);
	}	
});



Object.subclass('lively.data.Resolver', {
	description: "resolves literals to full-blown objects",
	storedClassKey: '$', // type info, missing in 
	variableBindingKey: '$var',
	defaultSearchPath: [Global],

	link: function(literal, binders, key, variableBindings, optSearchPath, optModel) {
		var constr;
		var type = literal[this.storedClassKey];
		if (type) {
			var path = optSearchPath || this.defaultSearchPath;
			for (var i = 0; i < path.length; i++)  {
				constr = path[i][type];
				if (constr) 
					break;
			}
			//console.log('was looking for ' + type + ' in ' +	path + ' and found ' + constr);
		} else if (literal.constructor !== Object) { 
			// not of the form {foo: 1, bar: "baz"},  return it as is
			return literal; 
		}

		var initializer = {}; 
		var subBinders = [];
		for (var name in literal) {
			if (name === this.storedClassKey) continue;
			if (name === this.variableBindingKey) continue;
			if (!literal.hasOwnProperty(name)) continue;
			var value = literal[name];
			if (value === null || value === undefined)
				initializer[name] = value;
			else switch (typeof value) {
				case "number":
				case "string":
				case "boolean":
				initializer[name] = value;
				break;
				case "function":
				break; // probably an error
				case "object": {
					if (value instanceof Array) {
						var array = initializer[name] = [];
						for (var i = 0; i < value.length; i++)	{
							array.push((this.link(value[i], subBinders, i, variableBindings, optSearchPath, optModel)));
						}
					} else {
						initializer[name] = this.link(value, subBinders, name, variableBindings, optSearchPath, optModel);
					}
					break;
				}
				default: 
				throw new TypeError('unexpeced type of value ' + value);
			}
		}

		var reified;
		if (type) {
			if (!constr) throw new Error('no class named ' + type);
			if (!constr.fromLiteral) throw new Error('class ' + constr.name + ' does not support fromLiteral');
			reified = constr.fromLiteral(initializer, optModel);
			if (reified instanceof lively.data.Bind) {
				reified.key = key;
				binders.push(reified);
				reified = reified.get(optModel);
			} else {
				subBinders.forEach(function(binder) {
					binder.hookup(reified, optModel);
				});
			}

		} else {
			//console.log('reified is ' + (initializer && initializer.constructor) + " vs  " + literal);
			reified = initializer;
		}

		if (literal[this.variableBindingKey]) {
			var varName = literal[this.variableBindingKey];
			//console.log('binding ' + varName + ' to ' + reified + " on " + variableBindings);
			variableBindings[varName] = reified;
		}

		return reified;
	}
});

Global.ModelMigration = {
	set: function(objectWithModel, slotName, value, force) { // derived from newDelegatorSetter -> setter
		var m = objectWithModel.formalModel;
		if (!m) 
			return objectWithModel.setModelValue('set' + slotName, value);
		var method = m['set' + slotName];
		// third arg is source, fourth arg forces relay to set value even if oldValue === value
		return method && method.call(m, value, objectWithModel, force);
	}
}
avocado.transporter.module.onLoadCallbacks["lk/Base"] = 'done';

avocado.transporter.module.onLoadCallbacks["lk/scene"] = function() {};
/*
 * Copyright (c) 2006-2009 Sun Microsystems, Inc.
 *
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
// ===========================================================================
// Graphics primitives (SVG specific, browser-independent)
// ===========================================================================


namespace('lively.data');

Object.subclass('lively.data.Wrapper', {
	documentation: "A wrapper around a native object, stored as rawNode",

	rawNode: null,

	deserialize: function(importer, rawNode) {
		this.rawNode = rawNode;
		reflect(this).slotAt('rawNode').beCreator(); // aaa - kind of a hack, added by Adam so that we can file out morphs
		dbgOn(!rawNode);
		var id = rawNode.getAttribute("id");
		if (id) importer.addMapping(id, this); 
	},

	copyFrom: function(copier, other) {
		if (other.rawNode) {
		  this.rawNode = other.rawNode.cloneNode(true);
  		reflect(this).slotAt('rawNode').beCreator(); // aaa - kind of a hack, added by Adam so that we can file out morphs
	  }
	},

	copy: function(copier) {
		// Make copying work even with non-class-based Morphs. -- Adam
		// var myClass = Class.forName(this.getType());
		// return new myClass(copier || Copier.marker, this);
		var c = Object.create(this['__proto__']);
		c.copyFrom(copier || Copier.marker, this);
		return c;
	},

	getType: function() {
		var ctor = this.constructor.getOriginal();
		if (ctor.type) return ctor.type;
		console.log("no type for " + ctor);
		lively.lang.Execution.showStack();
		return null;
	},

	newId: (function() {
		// this may be a Problem, after deserializing and when copy and pasting... 
		var wrapperCounter = 0;
		return function(optNewCounter) {
			if (optNewCounter) {
				wrapperCounter = optNewCounter;
				return;
			}
			return Math.uuid ? Math.uuid() : ++wrapperCounter; // so use (pseudo) uuids when available
		}
	})(),

	id: function() {
		dbgOn(!this.rawNode);
		return this.rawNode.getAttribute("id");
	},

	setId: function(value) {
		var prev = this.id();
		// easy parsing if value is an int, just call parseInt()
		this.rawNode.setAttribute("id", value + ":" + this.getType()); // this may happen automatically anyway by setting the id property
		return prev;
	},

	setDerivedId: function(origin) {
		this.setId(origin.id().split(':')[0]);
		return this;
	},

	removeRawNode: function() {
		var parent = this.rawNode && this.rawNode.parentNode;
		return parent && parent.removeChild(this.rawNode);
	},

	replaceRawNode: function(newRawNode) { // added by Adam
		var parent = this.rawNode && this.rawNode.parentNode;
		return parent && parent.replaceChild(newRawNode, this.rawNode);
	},

	replaceRawNodeChildren: function(replacement) {
		while (this.rawNode.firstChild) this.rawNode.removeChild(this.rawNode.firstChild);
		if (replacement) this.rawNode.appendChild(replacement);
	},

	toString: function() {
		try {
			return "#<" + this.getType() +	":" + this.rawNode + ">";
		} catch (err) {
			return "#<toString error: " + err + ">";
		}
	},

	inspect: function() {
		try {
			return this.toString() + "[" + this.toMarkupString() + "]";
		} catch (err) {
			return "#<inspect error: " + err + ">";
		}
	},

	toMarkupString: function() {
		// note forward reference
		return Exporter.stringify(this.rawNode);
	},

	uri: function() {
		return lively.data.FragmentURI.fromString(this.id());
	},

	// convenience attribute access
	getLivelyTrait: function(name) {
		return this.rawNode.getAttributeNS(Namespace.LIVELY, name);
	},

	// convenience attribute access
	setLivelyTrait: function(name, value) {
		return this.rawNode.setAttributeNS(Namespace.LIVELY, name, value);
	},

	// convenience attribute access
	removeLivelyTrait: function(name) {
		return this.rawNode.removeAttributeNS(Namespace.LIVELY, name);
	},

	getLengthTrait: function(name) {
		return lively.data.Length.parse(this.rawNode.getAttributeNS(null, name));
	},

	setLengthTrait: function(name, value) {
		this.setTrait(name, value);
	},

	getTrait: function(name) {
		return this.rawNode.getAttributeNS(null, name);
	},

	setTrait: function(name, value) {
		return this.rawNode.setAttributeNS(null, name, String(value));
	},

	removeTrait: function(name) {
		return this.rawNode.removeAttributeNS(null, name);
	},

	getDefsNode: function() {
		var defNode = $A(this.rawNode.getElementsByTagName('defs')).detect(function(ea) {
			if (ea == null) {
				lively.lang.Execution.showStack();
				return false;
			}
			return ea.parentNode === this.rawNode;
		}, this);
		// create and append one when defNode is not there
		if (!defNode)
			defNode = this.rawNode.appendChild(NodeFactory.create('defs'));
		return defNode;
	},
	
	doNotSerialize: ['rawNode'],

	isPropertyOnIgnoreList: function(prop) {
		return this.doNotSerialize.include(prop) || this.isPropertyOnIgnoreListInClassHierarchy(prop, this.constructor);
	},

	isPropertyOnIgnoreListInClassHierarchy: function(prop, klass) {
		if (klass === Object)
			return false;
		return klass.prototype.doNotSerialize.include(prop) || this.isPropertyOnIgnoreListInClassHierarchy(prop, klass.superclass);
	},
	
	prepareForSerialization: function(extraNodes, optSystemDictionary) {
		for (var prop in this) {
			if (!this.hasOwnProperty(prop)) 
				continue;
			if (this.isPropertyOnIgnoreList(prop))
				continue;
			var m = this[prop];
			if (m === this.constructor.prototype[prop])	 // save space
				continue;
			this.preparePropertyForSerialization(prop, m, extraNodes, optSystemDictionary);
		}
	},

	appendHelperNode: function(node, extraNodes) {
		try {
			extraNodes.push(this.rawNode.appendChild(node));
		} catch (er) { throw er;}
		// console.log("appendHelperNode " + node.tagName + " " + node.parentNode)
		node.isHelper = true;
		// who deletes the extra whitespace after the nodes are reloaded? 
		// extraNodes.push(this.rawNode.appendChild(NodeFactory.createNL())); 
	},
	
	prepareArrayPropertyForSerialization: function(prop, propValue, extraNodes, optSystemDictionary) {
		if (prop === 'submorphs')
			return;	 // we'll deal manually
		var arr = LivelyNS.create("array", {name: prop});
		var abort = false;
		propValue.forEach(function iter(elt) {
			if (elt && lively.data.Wrapper.isInstance(elt)) { // FIXME what if Wrapper is a mixin?
				// if item empty, don't set the ref field
				var item =	(elt && elt.id()) ? LivelyNS.create("item", {ref: elt.id()}) : LivelyNS.create("item"); 
				extraNodes.push(arr.appendChild(item));
				extraNodes.push(arr.appendChild(NodeFactory.createNL()));
			} else {
				var item = Converter.encodeProperty(null, elt, true);
				if (item) {
					extraNodes.push(arr.appendChild(item));
					extraNodes.push(arr.appendChild(NodeFactory.createNL()));
				} else {
					console.log("ERROR Serializing item in array " + prop + " of " + this)
					abort = true;
					return;
				}
			}
		}, this);
		if (!abort) { 
			//console.assert($A(this.rawNode.getElementsByTagName("array")).select(function(ea){ 
			//	  return ea.getAttribute("name") == prop }).length == 1, "ERROR: node with " + prop + " is already in raw Node");
			this.appendHelperNode(arr, extraNodes);
		}	
	},
	
	prepareWrapperPropertyForSerialization: function(prop, propValue, extraNodes, optSystemDictionary) {
		if (prop === 'owner') 
		return; // we'll deal manually
		if (propValue instanceof lively.paint.Gradient || propValue	 instanceof lively.scene.Image) {
			return; // these should sit in defs and be handled by restoreDefs() 
		}

		//console.log("serializing field name='%s', ref='%s'", prop, m.id(), m.getType());
		if (!propValue.rawNode) {
			console.log("wha', no raw node on " + propValue);
		} else if (propValue.id() != null) {
			var desc = LivelyNS.create("field", {name: prop, ref: propValue.id()});
			this.appendHelperNode(desc, extraNodes);;
			if (prop === "ownerWidget") {
				// console.log('recursing for field ' + prop);
				propValue.prepareForSerialization(extraNodes, optSystemDictionary);
				this.appendHelperNode(propValue.rawNode, extraNodes);
			}
		}
	},
	
	prepareRelayPropertyForSerialization: function(prop, propValue, extraNodes, optSystemDictionary) {
		var delegate = propValue.delegate;
		if (lively.data.Wrapper.isInstance(delegate)) { // FIXME: better instanceof
			var desc = LivelyNS.create("relay", {name: prop, ref: delegate.id()});
			Properties.forEachOwn(propValue.definition, function(key, value) {
				var binding = desc.appendChild(LivelyNS.create("binding"));
				// extraNodes.push(binding); 
				binding.setAttributeNS(null, "formal", key);
				binding.setAttributeNS(null, "actual", value);
			});
			this.appendHelperNode(desc, extraNodes);
		} else {
			console.warn('unexpected: '+ propValue + 's delegate is ' + delegate);
		}		
	},

	preparePropertyForSerialization: function(prop, propValue, extraNodes, optSystemDictionary) {
		// console.log("prepare property " + prop + ": " + optSystemDictionary)
		if (propValue instanceof Function) {
			return;
		} else if (lively.data.Wrapper.isInstance(propValue)) { 
			this.prepareWrapperPropertyForSerialization(prop, propValue, extraNodes, optSystemDictionary)
		} else if (propValue instanceof Relay) {
			this.prepareRelayPropertyForSerialization(prop, propValue, extraNodes, optSystemDictionary)
		} else if (propValue instanceof Array) {
			this.prepareArrayPropertyForSerialization(prop, propValue, extraNodes, optSystemDictionary) 
		} else if (prop === 'rawNode' || prop === 'defs') { // necessary because nodes get serialized
			return;
		} else {
			var node = Converter.encodeProperty(prop, propValue);
			node && this.appendHelperNode(node, extraNodes);;
		}
	},

	reference: function() {
		// console.log("reference " + this)
		if (!this.refcount) {
			if (!this.id()) {
				this.setId(this.newId());
			}
			this.dictionary().appendChild(this.rawNode);
			this.refcount = 1; 
			return;
		}
		this.refcount ++;
	},

	dereference: function() {
		// console.log("dereference " + this)
		// sadly, when the object owning the gradient is reclaimed, nobody will tell us to dereference
		if (this.refcount === undefined) throw new Error('sorry, undefined');
		this.refcount --;
		if (this.refcount == 0) {
			if (this.rawNode.parentNode) this.dictionary().removeChild(this.rawNode);
		}
	},

	dictionary: function() {
		if (lively.data.Wrapper.dictionary)
			return	lively.data.Wrapper.dictionary;
		if (lively.data.Wrapper.dictionary = Global.document.getElementById("SystemDictionary"))
			return lively.data.Wrapper.dictionary;
		var canvas = Global.document.getElementById("canvas");
		lively.data.Wrapper.dictionary =  canvas.appendChild(NodeFactory.create("defs"));
		lively.data.Wrapper.dictionary.setAttribute("id", "SystemDictionary");
		return lively.data.Wrapper.dictionary;
	},
	
	deserializeWidgetFromNode: function(importer, node) {
		var type = lively.data.Wrapper.getEncodedType(node);
		if (!type)
			throw new Error("Error in deserializing Widget: no getEncodedType for " + node);
		var klass = Class.forName(type);
		if (!klass)
			throw new Error("Error in deserializing Widget:" + type + ", no class");

		var widget = new klass(importer, node);
		widget.restoreFromSubnodes(importer, node);
		return widget
	},
	
	deserializeValueFromNode: function(importer, node) {
		var value = node.textContent;
		if (!value) return null
		
		if (value === 'NaN')
			return	NaN; // JSON doesn't unserializes NaN

		var family = LivelyNS.getAttribute(node, "family");
		if (family) {
			var cls = Class.forName(family);
			if (!cls) throw new Error('unknown type ' + family);
			return cls.fromLiteral(JSON.unserialize(value), importer);
		}
			
		try {
			return JSON.unserialize(value);
		} catch (e) {
			console.log('Error in lively.data.Wrapper.deserializeValueFromNode:');
			console.log(e + ' was thrown when deserializing: ' + value);
		}
	},
		
	deserializeFieldFromNode: function(importer, node) {
		var name = LivelyNS.getAttribute(node, "name");
		if (!name)
			throw new Error("could not deserialize field without name");
		
		var ref = LivelyNS.getAttribute(node, "ref");
		if (ref) {
			importer.addPatchSite(this, name, ref);
			return
		}
		
		var isNode = node.getAttributeNS(null, 'isNode');
		if (isNode !== '' && isNode != null) {
			// we have a normal node, nothing to deserialize but reassign
			var realNode = node.firstChild;
			node.removeChild(realNode);
			this[name] = realNode;
			this.addNonMorph(realNode);
			return
		}
		
		this[name] = this.deserializeValueFromNode(importer, node);
	},

	deserializeRelayFromNode: function(importer, node) {
	   var spec = {};
		$A(node.getElementsByTagName("binding")).forEach(function(elt) {
			var key = elt.getAttributeNS(null, "formal");
			var value = elt.getAttributeNS(null, "actual");
			spec[key] = value;
		});
		var name = LivelyNS.getAttribute(node, "name");
		if (name) {
			var relay = this[name] = Relay.newInstance(spec, null);
			var ref = LivelyNS.getAttribute(node, "ref");
			importer.addPatchSite(relay, "delegate", ref);
		}
		node.parentNode.removeChild(node);
	},
	
	deserializeRecordFromNode: function(importer, node) { 
		var spec = JSON.unserialize(node.getElementsByTagName("definition")[0].textContent);
		var Rec = lively.data.DOMNodeRecord.prototype.create(spec);
		var model = new Rec(importer, node);
		var id = node.getAttribute("id");
		if (id) importer.addMapping(id, model); 
		this.actualModel = model;
	},
	
	deserializeArrayFromNode: function(importer, node) {
		var name = LivelyNS.getAttribute(node, "name");
		this[name] = [];
		var index = 0;
		$A(node.getElementsByTagName("item")).forEach(function(elt) {
			var ref = LivelyNS.getAttribute(elt, "ref");
			if (ref) {
				importer.addPatchSite(this, name, ref, index);
			} else {
				// rk 3/22/10 node instead of elt was used, was that a bug?
				this[name].push(this.deserializeValueFromNode(importer, elt));
			}
			index ++;
		}, this);
	},

	resolveUriToObject: function(uri) {
		if (this.id() == uri)
			return this;
		return null
	}

});

Object.extend(lively.data.Wrapper, {
	getEncodedType: function(node) { // this should be merged with getType
		var id = node.getAttribute("id");
		return id && id.split(":")[1];
	},

	isInstance: function(m) {
		return m instanceof lively.data.Wrapper || m instanceof lively.data.DOMRecord;
	}

});


/* Garbage Collection */

lively.data.Wrapper.addMethods({
	removeGarbageRelayNodes: function() {
		$A(this.rawNode.childNodes).each(function(ea) {
			if(ea.tagName == "relay")
				this.rawNode.removeChild(ea)
		}, this)	
	},

	removeGarbageFromRawNode: function() {
		"WorldMorph.current().removeGarbageFromRawNode()"
		this.removeGarbageRelayNodes();
		this.submorphs.each(function(ea) {
			ea.removeGarbageFromRawNode()
		})
	}
	
});

lively.data.Wrapper.addMethods({
	collectAllUsedFills: function(result) {
		// do nothing
		return result || [];
	},
});

Object.extend(lively.data.Wrapper, {

	collectAllFillsInObjects: function(objects, result) {
		result = result || [];
		var self = this;
		objects.each(function(ea) {
			self.collectAllFillsInObject(ea, result);
		})
		return result		
	},

	collectAllFillsInObject: function(object, result) {
		result = result || [];
		if (!object)
			return result;
		Properties.forEachOwn(object, function(key, value) { 
			// console.log("key " + key + " value" + value)
			if (value && value instanceof lively.paint.Gradient) {
				result.push(value)
			}
		});

		// we could walkup all properties in all objects recursivly...
		// but that may take some time (measure it?)
		// lookup static fills in classes
		if (object.prototype) {
			this.collectAllFillsInObject(object.prototype, result)
		};

		// look into the style object
		if (object.style) {
			this.collectAllFillsInObject(object.style, result)
		};

		return result
	},

	collectSystemDictionaryGarbage: function(rootMorph) {
		"lively.data.Wrapper.collectSystemDictionaryGarbage()"
		if (!rootMorph)
			rootMorph = WorldMorph.current();
		var fills = [];
		this.collectAllFillsInObjects(Object.values(Global), fills);
		rootMorph.collectAllUsedFills(fills)
		var usedFillIds = fills.collect(function(ea){return ea.id()});
		var dict = rootMorph.dictionary();
		$A(dict.childNodes).each(function(ea) {
			// console.log("GC considering " + ea)
			if(['linearGradient', 'radialGradient'].include(ea.tagName) && !usedFillIds.include(ea.id)) {
				// console.log("SystemDictionary GC: remove " + ea)
				dict.removeChild(ea)
			}
		});
	},
});

Object.extend(Object.subclass('lively.data.FragmentURI'), {
	parse: function(string) {
		var match = string && string.match("url\\(#(.*)\\)");
		return match && match[1];
		// 'ur(#fragmentURI)'
		//return string.substring(5, string.length - 1);
	},

	fromString: function(id) {
		return "url(#" + id + ")";
	},

	getElement: function(string) {
		var id = this.parse(string);
		return id && Global.document.getElementById(id);
	}
});

// See http://www.w3.org/TR/css3-values/
// and http://www.w3.org/TR/CSS2/syndata.html#values	

Object.extend(Object.subclass('lively.data.Length'), {

	parse: function(string) {
	// FIXME: handle units
	return parseFloat(string);
	}
});


Object.extend(lively.data.Length.subclass('lively.data.Coordinate'), {
	parse: function(string) {
	// FIXME: handle units
	return parseFloat(string);
	}
});

using(namespace('lively.scene'), lively.data.Wrapper).run(function(unused, Wrapper) {

function locateCanvas() {
	// dirty secret
	return Global.document.getElementById("canvas");
}

Wrapper.subclass('lively.scene.Node');
	
this.Node.addProperties({ 
	FillOpacity: { name: "fill-opacity", from: Number, to: String, byDefault: 1.0},
	StrokeOpacity: { name: "stroke-opacity", from: Number, to: String, byDefault: 1.0},
	StrokeWidth: { name: "stroke-width", from: Number, to: String, byDefault: 1.0},
	LineJoin: {name: "stroke-linejoin"},
	LineCap: {name: "stroke-linecap"},
	StrokeDashArray: {name: "stroke-dasharray"},
	StyleClass: {name: "class"}
}, Config.useStyling ? lively.data.StyleRecord : lively.data.DOMRecord);

this.Node.addMethods({	 

	documentation:	"Objects that can be located on the screen",
	//In this particular implementation, graphics primitives are
	//mapped onto various SVG objects and attributes.

	rawNode: null, // set by subclasses

	setBounds: function(bounds) { 
		//copy uses this, so throwing is not nice
    	console.warn('Node: setBounds unsupported on type ' + this.getType());
		// throw new Error('setBounds unsupported on type ' + this.getType());
	},

	copyFrom: function($super, copier, other) {
		$super(copier, other);
		this._fill = other._fill;

		if (this._fill instanceof lively.paint.Gradient) {
			this._fill.reference();
		}
		this._stroke = other._stroke;
		if (this._stroke instanceof lively.paint.Gradient) {
			this._stroke.reference();
		}
	},

	deserialize: function($super, importer, rawNode) {
		$super(importer, rawNode);
		var attr = rawNode.getAttributeNS(null, "fill");
		var url = lively.data.FragmentURI.parse(attr);
		if (url) {
			// FIXME
			//this._fill = lively.data.FragmentURI.getElement(fillAttr);
		} else {
			this._fill = Color.fromString(attr);
		}

		attr = rawNode.getAttributeNS(null, "stroke");
		url = lively.data.FragmentURI.parse(attr);
		if (url) {
			// FIXME
			//this._stroke = lively.data.FragmentURI.getElement(fillAttr);
		} else {
			this._stroke = Color.fromString(attr);
		}
	},

	canvas: function() {
		if (!UserAgent.usableOwnerSVGElement) {
			// so much for multiple worlds on one page
			return locateCanvas();
		} else {
			return (this.rawNode && this.rawNode.ownerSVGElement) || locateCanvas();
		}
	},

	nativeContainsWorldPoint: function(p) {
		var r = this.canvas().createSVGRect();
		r.x = p.x;
		r.y = p.y;
		r.width = r.height = 0;
		return this.canvas().checkIntersection(this.rawNode, r);
	},

	setVisible: function(flag) {
		if (flag) this.rawNode.removeAttributeNS(null, "display");
		else this.rawNode.setAttributeNS(null, "display", "none");
		return this;
	},

	isVisible: function() {
		// Note: this may not be correct in general in SVG due to inheritance,
		// but should work in LIVELY.
		var hidden = this.rawNode.getAttributeNS(null, "display") == "none";
		return hidden == false;
	},

	applyFilter: function(filterUri) {
		// deprecated
		if (filterUri) 
			this.rawNode.setAttributeNS(null, "filter", filterUri);
		else
			this.rawNode.removeAttributeNS(null, "filter");
	},

	translateBy: function(displacement) {
		// todo
	},

	setFill: function(paint) {
		if ((this._fill !== paint) && (this._fill instanceof lively.paint.Gradient)) {
			this._fill.dereference();
		}
		this._fill = paint;
		if (paint === undefined) {
			this.rawNode.removeAttributeNS(null, "fill");
		} else if (paint === null) {
			this.rawNode.setAttributeNS(null, "fill", "none");
		} else if (paint instanceof Color) {
			this.rawNode.setAttributeNS(null, "fill", String(paint));
		} else if (paint instanceof lively.paint.Gradient) {
			paint.reference();
			this.rawNode.setAttributeNS(null, "fill", paint.uri());
		} else {
			throw dbgOn(new TypeError('cannot deal with paint ' + paint));
		}
	},

	getFill: function() {
		// hack
		if (this._fill || this._fill === null)
			return this._fill;
		var attr = this.rawNode.getAttribute('fill');
		if (!attr) { 
			false && console.log("Didn't find fill for " + this); return null; 
		};
		var rawFill = lively.data.FragmentURI.getElement(attr);
		if (!rawFill) { 
			false && console.log("Didn't find fill for " + this); return null; 
		};
		var klass = lively.data.Wrapper.getEncodedType(rawFill);
		klass = Class.forName(klass) || Class.forName('lively.paint.' + klass);
		if (!klass) { 
			false && console.log("Didn't find fill for " + this); return null; 
		};
		var importer = new Importer();
		//dbgOn(true);
		this._fill = new klass(importer, rawFill);
		return this._fill;
	},
	
	setStroke: function(paint) {
		if ((this._stroke !== paint) && (this._stroke instanceof lively.paint.Gradient)) {
			this._stroke.dereference();
		}
		this._stroke = paint;
		if (paint === undefined) {
			this.rawNode.removeAttributeNS(null, "stroke");
		} else if (paint === null) {
			this.rawNode.setAttributeNS(null, "stroke", "none");
		} else if (paint instanceof Color) {
			this.rawNode.setAttributeNS(null, "stroke", String(paint));
		} else if (paint instanceof lively.paint.Gradient) {
			paint.reference();
			this.rawNode.setAttributeNS(null, "stroke", paint.uri());
		} else throw dbgOn(new TypeError('cannot deal with paint ' + paint));
	},

	getStroke: function() {
		return this._stroke;
	},

	getTransforms: function() {
		if (!this.cachedTransforms) {
			var list = this.rawNode.transform.baseVal;
			var array = this.cachedTransforms = new Array(list.numberOfItems);
  		reflect(this).slotAt('cachedTransforms').setInitializationExpression('undefined'); // aaa hack? -- Adam
			for (var i = 0; i < list.numberOfItems; i++) {
				// FIXME: create specialized classes (Rotate/Translate etc)
				array[i] = new lively.scene.Transform(list.getItem(i), this);
			}
		}
		return this.cachedTransforms;
	},

	setTransforms: function(array) {
		var useDOM = Config.useTransformAPI;
		if (useDOM) {
			var list = this.rawNode.transform.baseVal;
			list.clear();
		}
		this.cachedTransforms = array;
		reflect(this).slotAt('cachedTransforms').setInitializationExpression('undefined'); // aaa hack? -- Adam
		for (var i = 0; i < array.length; i++) {
			var existingTargetNode = array[i].targetNode;
			if (existingTargetNode && existingTargetNode !== this) 
				console.warn('reusing transforms? not good');
			array[i].targetNode = this;
			useDOM && list.appendItem(array[i].rawNode);
		}
		useDOM || this.rawNode.setAttributeNS(null, "transform" , array.invoke('toString').join(' '));

	},

	transformListItemChanged: function(tfm) {  // note that Morph has transformChanged (singular)
		if (!Config.useTransformAPI) {
			//console.log('changed ' + tfm + ' on ' + this);
			var array = this.cachedTransforms;
			if (array) {
				//(array.indexOf(tfm) < 0) && console.warn('cached transforms not set? passing ' + tfm);
				this.rawNode.setAttributeNS(null, "transform" , array.invoke('toString').join(' '));
			} 
		}
	}
});

// FIXME: unfortunate aliasing for FX, should be removed (Bind doesn't translate accessors properly)
this.Node.addMethods({
	setstroke: lively.scene.Node.prototype.setStroke,
	setfill: lively.scene.Node.prototype.setFill,
	setfillOpacity: lively.scene.Node.prototype.setFillOpacity,
	setvisible: lively.scene.Node.prototype.setVisible
});


// ===========================================================================
// Shape functionality
// ===========================================================================

// Shapes are portable graphics structures that are used for isolating
// the implementation details of the underlying graphics architecture from
// the programmer.	Each Morph in our system has an underlying Shape object
// that maps the behavior of the Morph to the underlying graphics system
// in a fully portable fashion.


this.Node.subclass('lively.scene.Shape', {

	shouldIgnorePointerEvents: false,
	controlPointProximity: 10,
	hasElbowProtrusions: false,

	toString: function() {
		return Strings.format("a Shape(%s,%s)", this.getType(), this.bounds());
	},

	initialize: function() {
		if (this.shouldIgnorePointerEvents) this.ignoreEvents();
	},


	applyFunction: function(func,arg) { 
		func.call(this, arg); 
	},

	toPath: function() {
		throw new Error('unimplemented');
	},

	origin: function() {
		return this.bounds().topLeft();
	}
});


 Object.extend(this.Shape, {
	 // merge with Import.importWrapperFromNode?
	 importFromNode: function(importer, node) {
		switch (node.localName) {
			case "ellipse":
				return new lively.scene.Ellipse(importer, node);
				break;
			case "rect":
				return new lively.scene.Rectangle(importer, node);
				break;
			case "polyline":
				return new lively.scene.Polyline(importer, node);
				break;
			case "polygon":
				return new lively.scene.Polygon(importer, node);
				break;
			case "path":
				return new lively.scene.Path(importer, node);
				break;
			case "g":
				return new lively.scene.Group(importer, node);
				break;
			default:
				return null;
		}
	 },

	fromLiteral: function(node, literal) {
		// axiliary
		if (literal.stroke !== undefined) node.setStroke(literal.stroke);
		node.setStrokeWidth(literal.strokeWidth === undefined ? 1 : literal.strokeWidth);
		if (literal.fill !== undefined) node.setFill(literal.fill);
		if (literal.fillOpacity !== undefined) node.setFillOpacity(literal.fillOpacity);
		if (literal.strokeLineCap !== undefined) node.setLineCap(literal.strokeLineCap);

		if (literal.transforms !== undefined) node.setTransforms(literal.transforms);

		return node;
	}
});

Object.extend(this,	 { 
	LineJoins: Class.makeEnum(["Miter", "Round", "Bevel" ]), // note that values become attribute values
	LineCaps:  Class.makeEnum(["Butt",	"Round", "Square"])	 // likewise	
});

this.Shape.subclass('lively.scene.Rectangle', {

	documentation: "Rectangle shape",

	initialize: function($super, rect) {
		$super();
		this.rawNode = NodeFactory.create("rect");
		
    if (!avocado.shouldBreakCreatorSlotsInOrderToImprovePerformance) {
		  reflect(this).slotAt('rawNode').beCreator(); // aaa - kind of a hack, added by Adam so that we can file out morphs
	  }
	  
		this.setBounds(rect || new Rectangle(0, 0, 0, 0));
		return this;
	},

	setBounds: function(r) {
		dbgOn(!r);
		this.setLengthTrait("x", r.x);
		this.setLengthTrait("y", r.y);
		this.setLengthTrait("width", Math.max(0, r.width));
		this.setLengthTrait("height", Math.max(0, r.height));
		return this;
	},

	toPath: function() {
		// FIXME account for rounded edges
		return new lively.scene.Path(this.bounds());
	},

	bounds: function() {
		var x = this.rawNode.x.baseVal.value;
		var y = this.rawNode.y.baseVal.value;
		var width = this.rawNode.width.baseVal.value;
		var height = this.rawNode.height.baseVal.value;
		return new Rectangle(x, y, width, height);
	},

	translateBy: function(displacement) {
		this.setLengthTrait("x", this.getLengthTrait("x") + displacement.x);
		this.setLengthTrait("y", this.getLengthTrait("y") + displacement.y);
	},


	vertices: function() {
		var b = this.bounds();
		return [b.topLeft(), b.topRight(), b.bottomLeft(), b.bottomRight()];
	},

	containsPoint: function(p) {
		var x = this.rawNode.x.baseVal.value;
		var width = this.rawNode.width.baseVal.value;
		if (!(x <= p.x && p.x <= x + width))
			return false;
		var y = this.rawNode.y.baseVal.value;
		var height = this.rawNode.height.baseVal.value;
		return y <= p.y && p.y <= y + height;
	},

	reshape: function(partName,newPoint, ignored) {
		var r = this.bounds().withPartNamed(partName, newPoint);
		this.setBounds(r);
	},

	partNameNear: function(p) {
		return this.bounds().partNameNear(Rectangle.corners, p, this.controlPointProximity);
	},

	allPartNames: function() {return Rectangle.corners; },


	partPosition: function(partName) {
		return this.bounds().partNamed(partName);
	},

	getBorderRadius: function() {
		return this.getLengthTrait("rx") || 0;
	},

	// consider arcWidth and arcHeight instead
	roundEdgesBy: function(r) {
		if (r) {
			this.setLengthTrait("rx", r);
			this.setLengthTrait("ry", r);
			var w = this.getStrokeWidth();	// DI:	Needed to force repaint(!)
			this.setStrokeWidth(w+1); 
			this.setStrokeWidth(w); 
		}
		return this;
	}
});


Object.extend(this.Rectangle, {
	fromLiteral: function(literal) {
		var x = literal.x || 0.0;
		var y = literal.y || 0.0;
		var width = literal.width || 0.0;
		var height = literal.height || 0.0;

		var node = new lively.scene.Rectangle(new Rectangle(x, y, width, height));
		lively.scene.Shape.fromLiteral(node, literal);
		if (literal.arcWidth !== undefined) node.roundEdgesBy(literal.arcWidth/2);
		return node;
	}
});


this.Shape.subclass('lively.scene.Ellipse', {

	documentation: "Ellipses and circles",

	initialize: function($super /*,rest*/) {
		$super();
		this.rawNode = NodeFactory.create("ellipse");
		reflect(this).slotAt('rawNode').beCreator(); // aaa - kind of a hack, added by Adam so that we can file out morphs
		switch (arguments.length) {
			case 2:
				this.setBounds(arguments[1]);
				break;
			case 3:
				this.setBounds(arguments[1].asRectangle().expandBy(arguments[2]));
				break;
			default:
				throw new Error('bad arguments ' + $A(arguments));
		}
	},

	setBounds: function(r) {
		this.setLengthTrait("cx", r.x + r.width/2);
		this.setLengthTrait("cy", r.y + r.height/2);
		this.setLengthTrait("rx", r.width/2);
		this.setLengthTrait("ry", r.height/2);
		return this;
	},

	center: function() {
		return pt(this.rawNode.cx.baseVal.value, this.rawNode.cy.baseVal.value);
	},

	origin: function() {
		return this.center();
	},

	// For ellipses, test if x*x + y*y < r*r
	containsPoint: function(p) {
		var w = this.rawNode.rx.baseVal.value * 2;
		var h = this.rawNode.ry.baseVal.value * 2;
		var c = pt(this.rawNode.cx.baseVal.value, this.rawNode.cy.baseVal.value);
		var dx = Math.abs(p.x - c.x);
		var dy = Math.abs(p.y - c.y)*w/h;
		return (dx*dx + dy*dy) <= (w*w/4) ; 
	},


	bounds: function() {
		//console.log("rawNode " + this.rawNode);
		var w = this.rawNode.rx.baseVal.value * 2;
		var h = this.rawNode.ry.baseVal.value * 2; 
		var x = this.rawNode.cx.baseVal.value - this.rawNode.rx.baseVal.value;
		var y = this.rawNode.cy.baseVal.value - this.rawNode.ry.baseVal.value;
		return new Rectangle(x, y, w, h);
	}, 

	translateBy: function(displacement) {
		this.setLengthTrait("cx", this.getLengthTrait("cx") + displacement.x);
		this.setLengthTrait("cy", this.getLengthTrait("cy") + displacement.y);
	},

	vertices: function() {
		var b = this.bounds();
		var coeff = 4;
		var dx = b.width/coeff;
		var dy = b.height/coeff;
		// approximating by an octagon
		return [b.topCenter().addXY(-dx,0), b.topCenter().addXY(dx ,0),
		b.rightCenter().addXY(0, -dy), b.rightCenter().addXY(0, dy),
		b.bottomCenter().addXY(dx, 0), b.bottomCenter().addXY(-dx, 0),
		b.leftCenter().addXY(0, dy), b.leftCenter().addXY(0, -dy)];
	},

	partNameNear: function(p) {
		return this.bounds().partNameNear(Rectangle.sides, p, this.controlPointProximity);
	},
allPartNames: function() {return Rectangle.sides; },


	reshape: this.Rectangle.prototype.reshape,
	partPosition: this.Rectangle.prototype.partPosition

});

Object.extend(this.Ellipse, {
	fromLiteral: function(literal) {
		var node = new lively.scene.Ellipse(pt(literal.centerX || 0.0, literal.centerY || 0.0), literal.radius);
		lively.scene.Shape.fromLiteral(node, literal);
		return node;
	}
});



this.Shape.subclass('lively.scene.Polygon', {
	documentation: "polygon",

	hasElbowProtrusions: true,
	useDOM: false,

	initialize: function($super, vertlist) {
		this.rawNode = NodeFactory.create("polygon");
		reflect(this).slotAt('rawNode').beCreator(); // aaa - kind of a hack, added by Adam so that we can file out morphs
		this.setVertices(vertlist);
		$super();
		return this;
	},

	copyFrom: function($super, copier, other) {
		$super(copier, other);
		this.setVertices(other.vertices());
	},

	setVertices: function(vertlist) {
		if (this.rawNode.points) {
			this.rawNode.points.clear();
		}
		if (this.useDOM) vertlist.forEach(function(p) { this.rawNode.points.appendItem(p) }, this);
		else this.rawNode.setAttribute("points",
		vertlist.map(function (p) { return (p.x||0.0) + "," + (p.y||0.0) }).join(' '));
	},

	vertices: function() {
		var array = [];
		for (var i = 0; i < this.rawNode.points.numberOfItems; i++) {
			var item = this.rawNode.points.getItem(i);
			array.push(Point.ensure(item));
		}
		return array;
	},

	translateBy: function(displacement) {
		var array = [];
		for (var i = 0; i < this.rawNode.points.numberOfItems; i++) {
			var item = this.rawNode.points.getItem(i);
			array.push(Point.ensure(item).addPt(displacement));
		}
		this.setVertices(array);
	},

	toString: function() {
		var pts = this.vertices();
		return this.rawNode.tagName + "[" + pts + "]";
	},


	bounds: function() {
		// FIXME very quick and dirty, consider caching or iterating over this.points
		var vertices = this.vertices();
		// Opera has been known not to update the SVGPolygonShape.points property to reflect the SVG points attribute
		console.assert(vertices.length > 0, 
			"lively.scene.Polygon.bounds: vertices has zero length, " + this.rawNode.points 
			+ " vs " + this.rawNode.getAttributeNS(null, "points"));
			return Rectangle.unionPts(vertices);
	},

	origin: function() {
		// no natural choice to pick the origin of a polgon/polyline
		return pt(0, 0);
	},

	reshape: function(ix, newPoint, lastCall) {
		// See the comment in allPartNames
		// Here we decode the "partName" index to select a vertex, midpoint or control point
		// and then replace that point with newPoint, and update the shape

		// ix is an index into vertices
		var verts = this.vertices();  // less verbose
		if (ix < 0) { // negative means insert a vertex
			ix = -ix;
			verts.splice(ix, 0, newPoint);
			this.setVertices(verts);
			return; // undefined result for insertion 
		}
		var closed = verts[0].eqPt(verts[verts.length - 1]);
		if (closed && ix == 0) {  // and we're changing the shared point (will always be the first)
			verts[0] = newPoint;  // then change them both
			verts[verts.length - 1] = newPoint; 
		} else {
			verts[ix] = newPoint;
		}

		var shouldMerge = false;
		var howClose = 6;
		if (verts.length > 2) {
			// if vertex being moved is close to an adjacent vertex, make handle show it (red)
			// and if its the last call (mouse up), then merge this with the other vertex
			if (ix > 0 && verts[ix - 1].dist(newPoint) < howClose) {
				if (lastCall) { 
					verts.splice(ix, 1); 
					if (closed) verts[0] = verts[verts.length - 1]; 
				} else {
					shouldMerge = true;
				} 
			}

			if (ix < verts.length - 1 && verts[ix + 1].dist(newPoint) < howClose) {
				if (lastCall) { 
					verts.splice(ix, 1); 
					if (closed) verts[verts.length - 1] = verts[0];
				} else {
					shouldMerge = true;
				} 
			}
		}
		this.setVertices(verts); 
		return shouldMerge;
	},

	partNameNear: function(p) {
		var codes = this.allPartNames();
		for (var i=0; i<codes.length; i++)
			if (this.partPosition(codes[i]).dist(p) < this.controlPointProximity) return codes[i];
		return null;
	},
allPartNames: function() {
		// Note: for reshaping of polygons and lines, the "partNames" are
		//  integer codes with the following meaning...
		//	0...(N-1)  -- the N vertices themselves
		//	-1...-N  -- negative of the line segment index for inserting a new vertex
		//  This scheme may also be extended to curves as follows...
		//	N...(2N-1)  -- first control point for the given (i-N)-th line segment
		//  2N...(3N-1)  -- second control point for the (i-2N)-th line segment
		// This encoding scheme is shared also by partPosition() and reshape()

		var verts = this.vertices();
		var locs = [];
		for (var i = 0; i < verts.length; i++) { locs.push(i); };  // vertices

		var nLines = verts.length-1;
		// Some polygons have last point = first; some don't
		if ((this instanceof lively.scene.Polygon) && !verts.first().eqPt(verts.last())) nLines = verts.length;
		for (var i = 0; i < nLines; i++) { locs.push(-(i + 1)); };  // midpoints
		return locs; 
	},


	// borrowed from http://local.wasp.uwa.edu.au/~pbourke/geometry/insidepoly/
	containsPoint: function(p) {
		var counter = 0;
		var vertices = this.vertices();
		var p1 = vertices[0];
		for (var i = 1; i <= vertices.length; i++) {
			var p2 = vertices[i % vertices.length];
			if (p.y > Math.min(p1.y, p2.y)) {
				if (p.y <= Math.max(p1.y, p2.y)) {
					if (p.x <= Math.max(p1.x, p2.x)) {
						if (p1.y != p2.y) {
							var xinters = (p.y-p1.y)*(p2.x-p1.x)/(p2.y-p1.y)+p1.x;
							if (p1.x == p2.x || p.x <= xinters)
								counter ++;
						}
					}
				}
			}
			p1 = p2;
		}

		if (counter % 2 == 0) {
			return false;
		} else {
			return true;
		}
	},

	partPosition: function(partName) {
		// See the comment in allPartNames
		// Here we decode the "partName" index to select a vertex, midpoint or control point
		var verts = this.vertices();
		if (partName >= 0) return verts[partName];
		// Case of midpoint of last segment when first vertex is not duplicated
		if (-partName > (verts.length-1)) return verts[-partName - 1].midPt(verts[0]); 
		return verts[-partName].midPt(verts[-partName - 1]); 
	}

});

Object.extend(this.Polygon, {
	fromLiteral: function(literal) {
		return lively.scene.Shape.fromLiteral(new lively.scene.Polygon(literal.points), literal);
	}
});

lively.scene.Shape.subclass('lively.scene.Polyline', {
	documentation: "Like polygon but not necessarily closed and does not include the interior",

	hasElbowProtrusions: true,

	initialize: function($super, vertlist) {
		this.rawNode = NodeFactory.create("polyline");
		reflect(this).slotAt('rawNode').beCreator(); // aaa - kind of a hack, added by Adam so that we can file out morphs
		this.setVertices(vertlist);
		$super();
	},

	containsPoint: function(p) {
		var howNear = 6;
		var vertices = this.vertices();
		for (var i = 1; i < vertices.length; i++) {
			var pNear = p.nearestPointOnLineBetween(vertices[i-1], vertices[i]);
			if (pNear.dist(p) < howNear) {
				return true; 
			}
		}
		return false; 
	},

	setStartX: function(x) {
		var v = this.vertices();
		var first = v.first();
		v.splice(0, 1, first.withX(x));
		this.setVertices(v);
	},

	setStartY: function(y) {
		var v = this.vertices();
		var first = v.first();
		v.splice(0, 1, first.withY(y));
		this.setVertices(v);
	},

	setEndX: function(x) {
		var v = this.vertices();
		var last = v.last();
		v.splice(-1, 1, last.withX(x));
		this.setVertices(v);
	},

	setEndY: function(y) {
		var v = this.vertices();
		var last = v.last();
		v.splice(-1, 1, last.withY(y));
		this.setVertices(v);
	},

	addPoint: function(point) {
		// FIXME can this be done more efficiently? certainly...
		this.setVertices(this.vertices().concat(point));
	},
	
	// poorman's traits :)
	bounds: this.Polygon.prototype.bounds,
	origin: this.Polygon.prototype.origin,
	vertices: this.Polygon.prototype.vertices,
	setVertices: this.Polygon.prototype.setVertices,
	reshape: this.Polygon.prototype.reshape,
	partNameNear: this.Polygon.prototype.partNameNear,
allPartNames: this.Polygon.prototype.allPartNames,

	partPosition: this.Polygon.prototype.partPosition,
	translateBy: this.Polygon.prototype.translateBy
});

Object.extend(this.Polyline, {
	fromLiteral: function(literal) {
	return lively.scene.Shape.fromLiteral(new lively.scene.Polyline(literal.points), literal);
	}
});

this.Line = { // sugar syntax
	fromLiteral: function(literal) {
		var pts = [
			pt(literal.StartX || 0.0, literal.StartY || 0.0),
			pt(literal.EndX || 0.0, literal.EndY || 0.0)];
		// FIXME more efficient?
		return lively.scene.Polyline.fromLiteral(Object.extend(literal, {points: pts}));
	}
};


// --------------------
// --------- Paths ----
// --------------------
// see http://www.w3.org/TR/SVG/paths.html
Wrapper.subclass('lively.scene.PathElement', {
	initialize: function(isAbsolute) {
		this.isAbsolute = isAbsolute;
	},
	realCharCode: function() {
		return this.isAbsolute ? this.charCode.toUpperCase() : this.charCode.toLowerCase();
	},
	attributeFormat: function() {
		throw new Error('subclass responsiblity');
	},
	translate:function(x, y, force) {
		throw new Error('subclass responsiblity (' + this.constructor.type + ')');
	},
	toString: function() { return 'PathElement("' + this.attributeFormat() + '")' },
});

Object.extend(lively.scene.PathElement, {
	parse: function(data) {
		var
			splitNumberRegex = /[\s*,\s*]+/,
			splitTypeAndNumberRegex = /(NaN|[^a-df-zA-Z]+)?([A-Za-df-z])?(NaN|[^a-df-zA-Z]+)?/,
			typeTestRegex = /[a-df-zA-Z]/,
			typeAbsTestRegex = /[A-Z]/;

		// split number pairs
		var chunks = data.split(splitNumberRegex);
		// split up types
		chunks = chunks.inject([], function(all, chunk) {
			var splitted = splitTypeAndNumberRegex.exec(chunk);
			if (!splitted) return all;
			if (splitted[1] !== undefined)
				all.push(splitted[1]);
			if (splitted[2] !== undefined)
				all.push(splitted[2]);
			if (splitted[3] !== undefined)
				all.push(splitted[3]);
			return all;
		});
console.log(chunks)
		// create PathElement objects from splitted data
		var
			pathElementClasses = lively.scene.PathElement.allSubclasses(),
			pathElements = [],
			klass = null,
			currentChunks = [],
			isAbsolute;
		while (chunks.length > 0) {
			var chunk = chunks.shift()
			if (typeTestRegex.test(chunk)) {
				isAbsolute = typeAbsTestRegex.test(chunk);
				var klass = pathElementClasses.detect(function(klass) {
					return klass.prototype.charCode == chunk.toUpperCase();
				});
				if (!klass)
					throw dbgOn(new Error('Trying to parse SVG path elements. No support for ' + chunk));
			} else {
				currentChunks.push(Number(chunk) || 0);
			};
			if (currentChunks.length == klass.dataLength) {
				pathElements.push(klass.create(isAbsolute, currentChunks));
				currentChunks = [];
			}
		}
		return pathElements;
	},	
});

this.PathElement.subclass('lively.scene.MoveTo', {
	charCode: 'M',

	initialize: function($super, isAbsolute, x, y) {
		$super(isAbsolute);
		this.x = x;
		this.y = y;
	},

	allocateRawNode: function(rawPathNode) {
		this.rawNode = this.isAbsolute ?
			rawPathNode.createSVGPathSegMovetoAbs(this.x, this.y) :
			rawPathNode.createSVGPathSegMovetoRel;
		return this.rawNode;
	},

	controlPoints: function() {
		return [pt(this.x, this.y)];
	},
	
	attributeFormat: function() {
		return this.realCharCode() + this.x + "," + this.y;
	},
	
	translate:function(x, y, force) {
		if (!this.isAbsolute && !force) return;
		this.x += x;
		this.y += y;
	},
});
Object.extend(lively.scene.MoveTo, {
	fromLiteral: function(literal) {
		return new lively.scene.MoveTo(literal.isAbsolute, literal.x || 0.0, literal.y || 0.0);
	},
	parse: function(data) {
		var codeExtractor = /([A-Za-z])\s?(-?[0-9]+(?:.[0-9]+)?|NaN),(-?[0-9]+(?:.[0-9]+)?|NaN)/;
	},
	dataLength: 2,
	create: function(isAbsolute, arr) {
		return new this(isAbsolute, arr[0], arr[1])
	},
});


this.PathElement.subclass('lively.scene.LineTo', {
	charCode: 'L',
	initialize: function($super, isAbsolute, x, y) {
		$super(isAbsolute);
		this.x = x;
		this.y = y;
	},

	allocateRawNode: function(rawPathNode) {
		this.rawNode = this.isAbsolute ?
			rawPathNode.createSVGPathSegLinetoAbs(this.x, this.y) :
			rawPathNode.createSVGPathSegLinetoRel(this.x, this.y);
		return this.rawNode;
	},

	controlPoints: function() {
		return [pt(this.x, this.y)];
	},
	
	attributeFormat: function() {
		return this.realCharCode() + this.x + "," + this.y;
	},
	
	translate:function(x, y, force) {
		if (!this.isAbsolute && !force) return;
		this.x += x;
		this.y += y;
	},
});
Object.extend(lively.scene.LineTo, {
	fromLiteral: function(literal) {
		return new lively.scene.LineTo(literal.isAbsolute, literal.x || 0.0, literal.y || 0.0);
	},
	dataLength: 2,
	create: function(isAbsolute, arr) {
		return new this(isAbsolute, arr[0], arr[1])
	},
});


this.PathElement.subclass('lively.scene.HorizontalTo', {
	charCode: 'H',
	initialize: function($super, isAbsolute, x) {
		$super(isAbsolute);
		this.x = x;
	},

	allocateRawNode: function(rawPathNode) {
		this.rawNode = this.isAbsolute ?
			rawPathNode.createSVGPathSegLinetoHorizontalAbs(this.x) :
			rawPathNode.createSVGPathSegLinetoHorizontalRel(this.x);
		return this.rawNode;
	},

	controlPoints: function() {
		return [];
	},
	
	attributeFormat: function() {
		return this.realCharCode() + this.x;
	},
	translate:function(x, y, force) {
		if (!this.isAbsolute && !force) return;
		this.x += x;
	},
});
Object.extend(lively.scene.HorizontalTo, {
	fromLiteral: function(literal) {
		return new lively.scene.HorizontalTo(literal.isAbsolute, literal.x || 0.0);
	},
	dataLength: 1,
	create: function(isAbsolute, arr) {
		return new this(isAbsolute, arr[0])
	},
});


this.PathElement.subclass('lively.scene.VerticalTo', {
	charCode: 'V',
	initialize: function($super, isAbsolute, y) {
		$super(isAbsolute);
		this.y = y;
	},

	allocateRawNode: function(rawPathNode) {
		this.rawNode = this.isAbsolute ?
			rawPathNode.createSVGPathSegLinetoVerticalAbs(this.y) :
			rawPathNode.createSVGPathSegLinetoVerticalRel(this.y);
		return this.rawNode;
	},

	controlPoints: function() {
		return [];
	},
	
	attributeFormat: function() {
		return this.realCharCode() + this.y;
	},
	
	translate:function(x, y, force) {
		if (!this.isAbsolute && !force) return;
		this.y += y;
	},
});
Object.extend(lively.scene.VerticalTo, {
	fromLiteral: function(literal) {
		return new lively.scene.VerticalTo(literal.isAbsolute, literal.y || 0.0);
	},
	dataLength: 1,
	create: function(isAbsolute, arr) {
		return new this(isAbsolute, arr[0])
	},
});


this.PathElement.subclass('lively.scene.CurveTo', {

	charCode: 'T', // shouldn't it be the S type anyway?

	initialize: function($super, isAbsolute, x, y) {
		$super(isAbsolute);
		this.x = x;
		this.y = y;
	},

	allocateRawNode: function(rawPathNode) {
		this.rawNode = this.isAbsolute ?
			rawPathNode.createSVGPathSegCurvetoQuadraticSmoothAbs(this.x, this.y) :
			rawPathNode.createSVGPathSegCurvetoQuadraticSmoothRel(this.x, this.y);
		return this.rawNode;
	},

	controlPoints: function() {
		return [pt(this.x, this.y)];
	},
	
	attributeFormat: function() {
		return this.realCharCode() + this.x + "," + this.y;
	},
	
	translate:function(x, y, force) {
		if (!this.isAbsolute && !force) return;
		this.x += x;
		this.y += y;
	},
});
Object.extend(lively.scene.CurveTo, {
	fromLiteral: function(literal) {
		return new lively.scene.CurveTo(literal.isAbsolute, literal.x || 0.0, literal.y || 0.0);
	},
	dataLength: 2,
	create: function(isAbsolute, arr) {
		return new this(isAbsolute, arr[0], arr[1])
	},
});

this.PathElement.subclass('lively.scene.QuadCurveTo', {

	charCode: 'Q',

	initialize: function($super, isAbsolute, x, y, controlX, controlY) {
		$super(isAbsolute);
		this.x = x;
		this.y = y;
		this.controlX = controlX;
		this.controlY = controlY;
	},

	allocateRawNode: function(rawPathNode) {
		this.rawNode = this.isAbsolute ?
			rawPathNode.createSVGPathSegCurvetoQuadraticAbs(this.x, this.y, this.controlX, this.controlY) :
			rawPathNode.createSVGPathSegCurvetoQuadraticRel(this.x, this.y, this.controlX, this.controlY);
		return this.rawNode;
	},

	controlPoints: function() {
		return [pt(this.controlX, this.controlY), pt(this.x, this.y)];
	},

	attributeFormat: function() {
		return this.realCharCode() + this.controlX + "," + this.controlY + " " + this.x + "," + this.y;
	},

	translate:function(x, y, force) {
		if (!this.isAbsolute && !force) return;
		this.x += x;
		this.y += y;
		this.controlX += x;
		this.controlY += y;
	},
});
Object.extend(lively.scene.QuadCurveTo, {
	fromLiteral: function(literal) {
		return new lively.scene.QuadCurveTo(literal.isAbsolute, literal.x || 0.0, literal.y || 0.0, 
			literal.controlX || 0.0, literal.controlY || 0.0);
	},
	dataLength: 4,
	create: function(isAbsolute, arr) {
		return new this(isAbsolute, arr[2], arr[3], arr[0], arr[1])
	},
}); 


this.PathElement.subclass('lively.scene.BezierCurve2CtlTo', {

	charCode: 'C',

	initialize: function($super, isAbsolute, x, y, controlX1, controlY1, controlX2, controlY2) {
		$super(isAbsolute);
		this.x = x;
		this.y = y;
		this.controlX1 = controlX1
		this.controlY1 = controlY1
		this.controlX2 = controlX2
		this.controlY2 = controlY2
	},

	allocateRawNode: function(rawPathNode) {
		this.rawNode = this.isAbsolute ?
			rawPathNode.createSVGPathSegCurvetoCubicAbs(this.x, this.y, this.controlX1, this.controlY1, this.controlX2, this.controlY2) :
			rawPathNode.createSVGPathSegCurvetoCubicRel(this.x, this.y, this.controlX1, this.controlY1, this.controlX2, this.controlY2);
		return this.rawNode;
	},

	controlPoints: function() {
		return [pt(this.controlX1, this.controlY1), pt(this.controlX2, this.controlY2), pt(this.x, this.y)];
	},

	attributeFormat: function() {
		return this.realCharCode() + this.controlX1 + "," + this.controlY1 + " " + this.controlX2 + "," + this.controlY2 + " " + this.x + "," + this.y;
	},
	
	translate:function(x, y, force) {
		if (!this.isAbsolute && !force) return;
		this.x += x;
		this.y += y;
		this.controlX1 += x;
		this.controlY1 += y;
		this.controlX2 += x;
		this.controlY2 += y;
	},

});
Object.extend(lively.scene.BezierCurve2CtlTo, {
	fromLiteral: function(literal) {
		return new lively.scene.BezierCurve2CtlTo(literal.isAbsolute, literal.x || 0.0, literal.y || 0.0, 
			literal.controlX1 || 0.0, literal.controlY1 || 0.0,
			literal.controlX2 || 0.0, literal.controlY2 || 0.0);
	},
	dataLength: 6,
	create: function(isAbsolute, arr) {
		return new this(isAbsolute, arr[4], arr[5], arr[0], arr[1], arr[2], arr[3])
	},
});


this.PathElement.subclass('lively.scene.BezierCurve1CtlTo', {

	charCode: 'S',

	initialize: function($super, isAbsolute, x, y, controlX2, controlY2/*no typo*/) {
		$super(isAbsolute);
		this.x = x;
		this.y = y;
		this.controlX2 = controlX2
		this.controlY2 = controlY2
	},

	allocateRawNode: function(rawPathNode) {
		this.rawNode = this.isAbsolute ?
			rawPathNode.createSVGPathSegCurvetoCubicSmoothAbs(this.x, this.y, this.controlX2, this.controlY2) :
			rawPathNode.createSVGPathSegCurvetoCubicSmoothAbs(this.x, this.y, this.controlX2, this.controlY2);
		return this.rawNode;
	},

	controlPoints: function() {
		return [pt(this.controlX2, this.controlY2), pt(this.x, this.y)];
	},

	attributeFormat: function() {
		return this.realCharCode() + this.controlX2 + "," + this.controlY2 + " " + this.x + "," + this.y;
	},
	
	translate:function(x, y, force) {
		if (!this.isAbsolute && !force) return;
		this.x += x;
		this.y += y;
		this.controlX2 += x;
		this.controlY2 += y;
	},

});
Object.extend(lively.scene.BezierCurve1CtlTo, {
	fromLiteral: function(literal) {
		return new lively.scene.BezierCurve1CtlTo(literal.isAbsolute, literal.x || 0.0, literal.y || 0.0, 
			literal.controlX2 || 0.0, literal.controlY2 || 0.0);
	},
	dataLength: 4,
	create: function(isAbsolute, arr) {
		return new this(isAbsolute, arr[2], arr[3], arr[0], arr[1])
	},
});


this.PathElement.subclass('lively.scene.ArcTo', {

	charCode: 'A',

	initialize: function($super, isAbsolute, x, y, rx, ry, xRotation, largeFlag, sweepFlag) {
		$super(isAbsolute);
		this.x = x;
		this.y = y;
		this.rx = rx;
		this.ry = ry;
		this.xRotation = xRotation;
		this.largeFlag = largeFlag;
		this.sweepFlag = sweepFlag;
	},

	allocateRawNode: function(rawPathNode) {
		this.rawNode = this.isAbsolute ?
			rawPathNode.createSVGPathSegArcAbs(this.x, this.y, this.rx, this.ry, this.xRotation, this.largeFlag, this.sweepFlag) :
			rawPathNode.createSVGPathSegArcRel(this.x, this.y, this.rx, this.ry, this.xRotation, this.largeFlag, this.sweepFlag);
		return this.rawNode;
	},

	controlPoints: function() {
		return [pt(this.rx, this.ry), pt(this.x, this.y)];
	},

	attributeFormat: function() {
		return this.realCharCode() + this.rx + "," + this.ry + " " + this.xRotation + " " + this.largeFlag + " " + this.sweepFlag + " " + this.x + "," + this.y;
	},
	
	translate:function(x, y, force) {
		if (!this.isAbsolute && !force) return;
		this.x += x;
		this.y += y;
	},

});
Object.extend(lively.scene.ArcTo, {
	fromLiteral: function(literal) {
		return new lively.scene.ArcTo(literal.isAbsolute, literal.x || 0.0, literal.y || 0.0, 
			literal.rx || 0, literal.ry || 0, literal.xRotation || 0, literal.largeFlag || 0, literal.sweepFlag || 0);
	},
	dataLength: 7,
	create: function(isAbsolute, arr) {
		return new this(isAbsolute, arr[5], arr[6], arr[0], arr[1], arr[2], arr[3], arr[4])
	},
});


this.PathElement.subclass('lively.scene.ClosePath', {

	charCode: 'Z',

	allocateRawNode: function(rawPathNode) {
		this.rawNode = rawPathNode.createSVGPathSegClosePath();
		return this.rawNode;
	},

	controlPoints: function() {
		return [];
	},
	
	attributeFormat: function() {
		return this.realCharCode();
	},
	
	translate:function(x, y, force) {},
});
Object.extend(lively.scene.ClosePath, {
	fromLiteral: function(literal) {
		return new lively.scene.ClosePath(literal.isAbsolute); // necessary?
	},
	dataLength: 0,
	create: function(isAbsolute, arr) {
		return new this(isAbsolute)
	},
});


this.Shape.subclass('lively.scene.Path', {
	documentation: "Generic Path with arbitrary Bezier curves",

	hasElbowProtrusions: true,

	initialize: function($super, elements, morph) {
		this.rawNode = NodeFactory.create("path");
		this.dontChangeShape = false;
		this.morph = morph;  // Only for temporary testing -- see setVerticesAndControls
		this.setElements(elements || []);
		return this;
	},
	
	deserialize: function($super, importer, rawNode) {
		$super(importer, rawNode);
		this.setElementsFromSVGData(rawNode.getAttributeNS(null, 'd'));
	},

	copyFrom: function($super, copier, other) {
		$super(copier, other);		
		this.setElements(other.elements);
		
		// aaa hack for morph-saving - don't want copies sharing elements -- Adam
		this.setElementsFromSVGData(this.createSVGDataFromElements());

		// WebCards Changes:
		// var res = $super(copier, other);
		// 		this.setVertices(other.vertices());
		// 		this.cachedVertices = other.cachedVertices;
		// 		return res;		
	},
	
	setElementsFromSVGData: function(data) {
		var elements = lively.scene.PathElement.parse(data);
		this.setElements(elements);
	},
	
	createSVGDataFromElements: function() {
		var attr = "";
		for (var i = 0; i < this.elements.length; i++) {
			// var seg = elts[i].allocateRawNode(this.rawNode);
			// this.rawNode.pathSegList.appendItem(seg);
			attr += this.elements[i].attributeFormat() + " ";
		}
		return attr
	},

	setElements: function(elts) {
		this.cachedVertices = null;
		this.elements = elts;
		
		// aaa hack for morph-saving -- Adam
		elts.makeAllCreatorSlots();
		reflect(this).slotAt('elements').beCreator();
		reflect(this).slotAt('cachedVertices').setInitializationExpression('undefined');
		
		this.rawNode.setAttributeNS(null, "d", this.createSVGDataFromElements());
	},

	normalize: function(hintX, hintY) {
		// when elements are translated and are not beginning
		// in origin translate them so they do
		var first = this.elements[0];
		if (first.constructor != lively.scene.MoveTo) {
			console.warn('cannot normalize path not beginning with MoveTo');
			return;
		}
		var x = first.x * -1 + (hintX || 0);
		var y = first.y * -1 + (hintY || 0);
		var isFirst = true;
		for (var i = 0; i < this.elements.length; i++) {
			this.elements[i].translate(x, y, isFirst);
			isFirst = false;
		}
		this.setElements(this.elements);
	},
	
	setVertices: function(vertlist) {
		if (this.dontChangeShape) return
		// emit SVG path symbol based on point attributes
		// p==point, i=array index
		function map2svg(p,i) {
			var code;
			if (i==0 || p.type && p.type=="move") {
				code = "M";
			} else if (p.type && p.type=="line") {
				code = "L";
			} else if (p.type && p.type=="arc" && p.radius) {
				code = "A" + (p.radius.x || p.radius) + "," +
				(p.radius.y || p.radius) + " " + (p.angle || "0") +
				" " + (p.mode || "0,1") + " ";
			} else if (p.type && p.type=="curve" && p.control) {
				// keep control points relative so translation works
				code = "Q" + (p.x+p.control.x) + "," + (p.y+p.control.y) + " ";
			} else {
				code = "T";	 // default - bezier curve with implied control pts
			}
			return code + p.x + "," + p.y;
		}
		var d = vertlist.map(map2svg).join('');
		//console.log("d=" + d);
		if (d.length > 0)
			this.rawNode.setAttributeNS(null, "d", d);
	},

	setVerticesAndControls: function(verts, ctrls, closed) {
		// Complete hack only so that we can play with editing.  
		// May leaves garbage in DOM

		// copied from Morph.makeCurve...
		var g = lively.scene;
		var cmds = [];
		cmds.push(new g.MoveTo(true, verts[0].x,  verts[0].y));
		for (var i=1; i<verts.length; i++) {
			var el = ctrls[i] ?
				new g.QuadCurveTo(true, verts[i].x, verts[i].y, ctrls[i].x, ctrls[i].y) :
				new g.CurveTo(true, verts[i].x, verts[i].y);
			cmds.push(el);
		}
		this.setElements(cmds);
	},

	
	vertices: function() {
		// [DI] Note this is a test only -- not all path elements will work with this
		if (this.cachedVertices != null) return this.cachedVertices;
		this.cachedVertices = [];
		this.elements.forEach(function(el) {
			var vertex = el.controlPoints().last(); // FIXME controlPoints method should be fixed!
			if (vertex) this.cachedVertices.push(vertex);
		}, this);
		return this.cachedVertices;
	},

	controlPoints: function() {
		// [DI] Note this is a test only -- no caching, not all path elements will work with this
		var ctls = [];
			this.elements.forEach(function(el) { 
				var cs = el.controlPoints();  // cs = [vert] or [p1, vert] or [p1, p2, vert]
				ctls.push(cs.slice(0,cs.length-1));   // this is cs.butLast, ie [] or [p1] or [p1, p2]
				});
		return ctls;
	},


	containsPoint: function(p) {
	  /*
		var verts = this.vertices();
		//if (UserAgent.webKitVersion >= 525)
		return Rectangle.unionPts(verts).containsPoint(p);
		//else return this.nativeContainsWorldPoint(p);
		*/

  	// aaa - Copied from the Polygon code, works better, important for wheel menus because
  	// otherwise multiple wedges can be highlighted at a time -- Adam, June 2011
		var counter = 0;
		var vertices = this.vertices();
		var p1 = vertices[0];
		for (var i = 1; i <= vertices.length; i++) {
			var p2 = vertices[i % vertices.length];
			if (p.y > Math.min(p1.y, p2.y)) {
				if (p.y <= Math.max(p1.y, p2.y)) {
					if (p.x <= Math.max(p1.x, p2.x)) {
						if (p1.y != p2.y) {
							var xinters = (p.y-p1.y)*(p2.x-p1.x)/(p2.y-p1.y)+p1.x;
							if (p1.x == p2.x || p.x <= xinters)
								counter ++;
						}
					}
				}
			}
			p1 = p2;
		}

		if (counter % 2 == 0) {
			return false;
		} else {
			return true;
		}
	},

	bounds: function() {
		var u = Rectangle.unionPts(this.vertices());
		// FIXME this is not correct (extruding arcs) but it's an approximation
		return u;
	},

	setBounds: function(bounds) { 
		console.log('setBounds unsupported on type ' + this.getType());
	},

	// poorman's traits :)
	partNameNear: this.Polygon.prototype.partNameNear,
	allPartNames: function() {
		// Note: for reshaping of polygons and lines, the "partNames" are
		//  integer codes with the following meaning...
		//	0...(N-1)  -- the N vertices themselves
		//	-1...-N  -- negative of the line segment index for inserting a new vertex
		//  This scheme may also be extended to curves as follows...
		//	N...(2N-1)  -- first control point for the given (i-N)-th line segment
		//  2N...(3N-1)  -- second control point for the (i-2N)-th line segment
		// This encoding scheme is shared also by partPosition() and reshape()

		// Vertices...
		var locs = [];
		var verts = this.vertices();
		for (var i = 0; i < verts.length; i++) { locs.push(i); };  // vertices

		// Midpoints (for insertion)
		// Some polygons have last point = first; some don't
		if (false) {  // Note: this wont work right for paths yet
			var nLines = (verts.first().eqPt(verts.last())) ? verts.length-1 : verts.length;
			for (var i = 0; i < nLines; i++) { locs.push(-(i + 1)); };  // midpoints
		}

		// Control points
		var N = verts.length;
		var ctls = this.controlPoints();
		for (var i = 0; i < ctls.length; i++) { 
			var cs = ctls[i];
			if (cs.length > 0) locs.push(N + i);  // first control pt for curve elements
			if (cs.length > 1) locs.push(2*N + i);  // second control pt for curve elements
		};
		return locs; 
	},

	partPosition: function(partName) {
		// See the comment in allPartNames
		// Here we decode the "partName" index to select a vertex, midpoint or control point
		var verts = this.vertices();  var N = verts.length;

		// Midpoint of segment
		if (partName < 0) {  
			// Check for midpoint of last segment when first vertex is not duplicated
			if (-partName > (verts.length-1)) return verts[-partName - 1].midPt(verts[0]); 
			return verts[-partName].midPt(verts[-partName - 1]);
		}
		// Normal vertex
		if (partName < N) return verts[partName];

		var ctls = this.controlPoints();
		// First control point
		if (partName < N*2) return ctls[partName - N][0];

		// Second control point
		if (partName < N*3) return ctls[partName - N*2][1];
console.log("can't find partName = " + partName);
console.log("verts = " + Object.inspect(verts));
console.log("ctls = " + Object.inspect(ctls));
	},


	reshape: function(ix, newPoint, lastCall) {
		// See the comment in allPartNames
		// Here we decode the "partName" index to select a vertex, midpoint or control point
		// and then replace that point with newPoint, and update the shape

		// ix is an index into vertices
		var verts = this.vertices();  // less verbose
		var ctrls = this.controlPoints().map(function(elt) {return elt[0]; });
		if (!ctrls[0]) ctrls[0] = ctrls[1];
		if (ix < 0) { // negative means insert a vertex
			return false;  // Inserting a vertex wont work yet without splicing in a controlpt as well
			ix = -ix;
			verts.splice(ix, 0, newPoint);
			this.setVerticesAndControls(verts, ctrls);
			return; // undefined result for insertion 
		}
		var N = verts.length;
		var closed = verts[0].eqPt(verts[verts.length - 1]);
		if (ix >= N) {
			// Edit a control point
			ctrls[ix-N] = newPoint;
//console.log("verts = " + Object.inspect(verts));
//console.log("ctrls = " + Object.inspect(ctrls));
			this.setVerticesAndControls(verts, ctrls, closed);
			return false; // normal -- no merging
		}
		if (closed && ix == 0) {  // and we're changing the shared point (will always be the first)
			verts[0] = newPoint;  // then change them both
			verts[verts.length - 1] = newPoint; 
		} else {
			verts[ix] = newPoint;
		}

		var shouldMerge = false;
		var howClose = 6;
		if (verts.length > 2) {
			// if vertex being moved is close to an adjacent vertex, make handle show it (red)
			// and if its the last call (mouse up), then merge this with the other vertex
			if (ix > 0 && verts[ix - 1].dist(newPoint) < howClose) {
				if (lastCall) { 
					verts.splice(ix, 1); 
					if (closed) verts[0] = verts[verts.length - 1]; 
				} else {
					shouldMerge = true;
				} 
			}

			if (ix < verts.length - 1 && verts[ix + 1].dist(newPoint) < howClose) {
				if (lastCall) { 
					verts.splice(ix, 1); 
					if (closed) verts[verts.length - 1] = verts[0];
				} else {
					shouldMerge = true;
				} 
			}
		}
		this.setVerticesAndControls(verts, ctrls, closed); 
		return shouldMerge;
	},

});

Object.extend(lively.scene.Path, {
	fromLiteral: function(literal) {
		return new lively.scene.Path(literal.elements);
	},
});

this.Shape.subclass('lively.scene.Group', {
	documentation: 'Grouping of scene objects',

	initialize: function() {
		this.rawNode = NodeFactory.create("g");
		reflect(this).slotAt('rawNode').beCreator(); // aaa - kind of a hack, added by Adam so that we can file out morphs
		this.content = [];
		reflect(this).slotAt('content').beCreator(); // aaa - kind of a hack, added by Adam so that we can file out morphs
	},

	copyFrom: function($super, copier, other) {
		$super(copier, other);
		this.content = other.content.clone();
		/* firefox doesn't need this
		var tx = other.pvtGetTranslate();

if (tx) { 
console.log('translate ' + tx + ' on ' + this);
this.translateBy(tx);
} */
// FIXME deep copy?
	},

	deserialize: function($super, copier, rawNode) {
		$super(copier, rawNode);
		this.content = [];
	},

	add: function(node) {
		this.rawNode.appendChild(node.rawNode);
		this.content.push(node);
	},

	removeAll: function() {
		while (this.rawNode.firstChild) this.rawNode.removeChild(this.rawNode.firstChild);
		this.content = [];
	},

	setContent: function(nodes) {
		// FIXME how about clearing what's there
		nodes.forEach(function(node) { 
			this.add(node); 
		}, this);
	},

	bounds: function() {
		// this creates duplication between morphs and scene graphs, division of labor?
		// move Morph logic here
		var subBounds = null;
		var disp = this.pvtGetTranslate() || pt(0, 0);

		for (var i = 0; i < this.content.length; i++) {
			var item = this.content[i];
			if (!item.isVisible()) 
				continue;
			var itemBounds = item.bounds().translatedBy(disp);
			subBounds = subBounds == null ? itemBounds : subBounds.union(itemBounds);
		}
		var result =  subBounds || new Rectangle(0, 0, 0, 0);
		return result;
	},

	setBounds: function(bnds) {
		// console.log('doing nothing to set bounds on group');
	},

	containsPoint: function(p) {
		// FIXME this should mimic relativize in Morph
		var disp = this.pvtGetTranslate() || pt(0, 0);
		p = p.subPt(disp);
		return this.content.some(function(item) { return item.containsPoint(p); });
	},

	origin: function(shape) { 
		return this.bounds().topLeft();
	},

	pvtGetTranslate: function() {
		var tfms = this.getTransforms();
		if (tfms.length == 1 && tfms[0].type() == SVGTransform.SVG_TRANSFORM_TRANSLATE) {
			return tfms[0].getTranslate();
		} else return null;
	},

	translateBy: function(displacement) {
		var tfms = this.getTransforms();
		if (tfms.length == 1 && tfms[0].type() == SVGTransform.SVG_TRANSFORM_TRANSLATE) {
			var tr = tfms[0].getTranslate();
			tfms[0].setTranslate(tr.x + displacement.x, tr.y + displacement.y);
		} if (tfms.length == 0) {
			var tfm = new lively.scene.Transform(null, this);
			tfm.setTranslate(displacement.x, displacement.y);
			this.setTransforms([tfm]);

		} else console.warn('no translate for you ' + displacement + ' length ' + tfms.length + " type " + tfms[0].type());
	},
	reshape: Functions.Empty,

	partNameNear: this.Rectangle.prototype.partNameNear,
	allPartNames: this.Rectangle.prototype.allPartNames,

	partPosition: this.Rectangle.prototype.partPosition,
	vertices: this.Rectangle.prototype.vertices
});


Object.extend(this.Group, {
	fromLiteral: function(literal) {
		var group = new lively.scene.Group();
		literal.content && group.setContent(literal.content);
		if (literal.transforms) {
			group.setTransforms(literal.transforms);
		}
		if (literal.clip) {
			var clip = new lively.scene.Clip(literal.clip);
			var defs = group.rawNode.appendChild(NodeFactory.create('defs'));
			defs.appendChild(clip.rawNode);
			clip.applyTo(group);
		}
		return group;
	}
});

this.Node.subclass('lively.scene.Image');
	
this.Image.addProperties({ 
	Opacity: { name: "opacity", from: Number, to: String, byDefault: 1.0}
}, Config.useStyling ? lively.data.StyleRecord : lively.data.DOMRecord);

this.Image.addMethods({
	description: "Primitive wrapper around images",

	initialize: function(url, width, height) {
		if (!url) return;
		if (url.startsWith('#'))
			this.loadUse(url);
		else
		this.loadImage(url, width, height);
	},

	deserialize: function($super, importer, rawNode) {
		if (rawNode.namespaceURI != Namespace.SVG) {
			// this brittle and annoying piece of code is a workaround around the likely brokenness
			// of Safari's XMLSerializer's handling of namespaces
			var href = rawNode.getAttributeNS(null /* "xlink"*/, "href");
			if (href)
			if (href.startsWith("#")) {
				// not clear what to do, use target may or may not be in the target document
				this.loadUse(href);
			} else {
				this.loadImage(href);
			}
		} else {
			$super(importer, rawNode);
		}
	},

	bounds: function() {
		return new Rectangle(0, 0, this.getWidth(), this.getHeight());
	},

	containsPoint: function(p) {
		return this.bounds().containsPoint(p);
	},

	getWidth: function(optArg) {
		return lively.data.Length.parse((optArg || this.rawNode).getAttributeNS(null, "width"));
	},

	getHeight: function(optArg) {
		return lively.data.Length.parse((optArg || this.rawNode).getAttributeNS(null, "height"));
	},

	setWidth: function(width) {
		this.rawNode.setAttributeNS(null,"width", width);
	},

	setHeight: function(height) {
		this.rawNode.setAttributeNS(null, "height", height);
	},

	reload: function() {
		if (this.rawNode.localName == "image")	{
			XLinkNS.setHref(this.rawNode, this.getURL() + "?" + new Date());
		}
	},

	getURL: function() {
		return XLinkNS.getHref(this.rawNode);
	},

	scaleBy: function(factor) {
		new lively.scene.Similitude(pt(0, 0), 0, pt(factor, factor)).applyTo(this.rawNode);
	},

	loadUse: function(url) {
		if (this.rawNode && this.rawNode.localName == "use") {
			XLinkNS.setHref(this.rawNode, url);
			return null; // no new node;
		} else {
			this.removeRawNode();
			this.rawNode = NodeFactory.create("use");
			XLinkNS.setHref(this.rawNode, url);
			return this.rawNode;
		}
	},

	loadImage: function(href, width, height) {

		if (this.rawNode && this.rawNode.localName == "image") {
			XLinkNS.setHref(this.rawNode, href);
			return null;
		} else {
			var useDesperateSerializationHack = !Config.suppressImageElementSerializationHack;
			if (useDesperateSerializationHack) {
				width = width || this.getWidth();
				height = height || this.getHeight();

				// this desperate measure appears to be necessary to work
				// around Safari's serialization issues.  Note that
				// somehow this code has to be used both for normal
				// loading and loading at deserialization time, otherwise
				// it'll fail at deserialization
				var xml = Strings.format('<image xmlns="http://www.w3.org/2000/svg" ' 
				+ 'xmlns:xlink="http://www.w3.org/1999/xlink" ' 
				+ ' width="%s" height="%s" xlink:href="%s"/>', width, height, href);
				this.rawNode = new Importer().parse(xml);
			} else {

				// this should work but doesn't:

				this.rawNode = NodeFactory.createNS(Namespace.SVG, "image");
				this.rawNode.setAttribute("width", width);
				this.rawNode.setAttribute("height", height);
				XLinkNS.setHref(this.rawNode, href);
			}
			return this.rawNode;
		}
	}
});


this.Node.subclass('lively.scene.Clip', {
	documentation: "currently wrapper around SVG clipPath",

	initialize: function(shape) {
		this.rawNode = NodeFactory.create('clipPath');
		//var newId =  ++ this.constructor.clipCounter;
		this.setId(String(this.newId()));
		this.setClipShape(shape);
	},

	deserialize: function(importer, rawNode) {
		this.rawNode = rawNode;
		//FIXME remap the id?
		if (!rawNode) {
			// throw new Error("deserializing Clip without rawNode");
			console.log("Error: deserializing Clip without rawNode");
			return
		};
		var node = rawNode.firstChild; // really firstElement, allow for whitespace
		if (!node) return; // empty clipPath?
		this.shape = lively.scene.Shape.importFromNode(importer, node);

	},

	setClipShape: function(shape) {
		this.shape = shape.copy(); // FIXME: target.outline() ?
		this.replaceRawNodeChildren(this.shape.rawNode);
	},

	applyTo: function(target) {
		target.setTrait("clip-path", this.uri());	
	}

});

Object.extend(this.Clip, {
	clipCounter: 0,
});


Object.subclass('lively.scene.Similitude', {
	// could be made SVG indepenent
	documentation: "Support for object rotation, scaling, etc.",

	//translation: null, // may be set by instances to a component SVGTransform
	//rotation: null, // may be set by instances to a component SVGTransform
	//scaling: null, // may be set by instances to a component SVGTransform
	eps: 0.0001, // precision

	/**
	* create a similitude is a combination of translation rotation and scale.
	* @param [Point] delta
	* @param [float] angleInRadians
	* @param [float] scale
	*/

	initialize: function(duck) { 
		// matrix is a duck with a,b,c,d,e,f, could be an SVG matrix or a Lively Transform
		// alternatively, its a combination of translation rotation and scale
		if (duck) {
			if (duck instanceof Point) {
				var delta = duck;
				var angleInRadians = arguments[1] || 0.0;
				var scale = arguments[2];
				if (scale === undefined) scale = pt(1.0, 1.0); 
				this.a = this.ensureNumber(scale.x * Math.cos(angleInRadians));
				this.b = this.ensureNumber(scale.y * Math.sin(angleInRadians));
				this.c = this.ensureNumber(scale.x * - Math.sin(angleInRadians));
				this.d = this.ensureNumber(scale.y * Math.cos(angleInRadians));
				this.e = this.ensureNumber(delta.x);
				this.f = this.ensureNumber(delta.y);
			} else {
				this.fromMatrix(duck);
			}
		} else {
			this.a = this.d = 1.0;
			this.b = this.c = this.e = this.f = 0.0;
		}
		this.matrix_ = this.toMatrix();
	},

	getRotation: function() { // in degrees
		// Note the ambiguity with negative scales is resolved by assuming scale x is positive
		var r =	 Math.atan2(-this.c, this.a).toDegrees();
		return Math.abs(r) < this.eps ? 0 : r; // don't bother with values very close to 0
	},

	getScale: function() {
		// Note the ambiguity with negative scales and rotation is resolved by assuming scale x is positive
		var a = this.a;
		var c = this.c; 
		var s = Math.sqrt(a * a + c * c);
		return Math.abs(s - 1) < this.eps ? 1 : s; // don't bother with values very close to 1
	},

	getScalePoint: function() {
		// Note the ambiguity with negative scales and rotation is resolved by assuming scale x is positive
		var a = this.a;
		var b = this.b;
		var c = this.c;
		var d = this.d;
		var sx = Math.sqrt(a * a + c * c);
		var r =	 Math.atan2(-c, a);	 // radians
		var sy = (Math.abs(b) > Math.abs(d)) ? b / Math.sin(r) : d / Math.cos(r);  // avoid div by 0
		return pt(sx, sy);
	},

  // Hacked by Adam as a way to avoid creating the point object
	getScaleX: function() {
		var a = this.a;
		var c = this.c;
		return Math.sqrt(a * a + c * c);
	},
	getScaleY: function() {
		var a = this.a;
		var b = this.b;
		var c = this.c;
		var d = this.d;
		var r =	 Math.atan2(-c, a);	 // radians
		return (Math.abs(b) > Math.abs(d)) ? b / Math.sin(r) : d / Math.cos(r);  // avoid div by 0
	},


	isTranslation: function() {
		return this.matrix_.type === SVGTransform.SVG_TRANSFORM_TRANSLATE;
	},

	getTranslation: function() {
		return pt(this.e, this.f);
	},

	toAttributeValue: function() { 
	  // Optimization: don't create the point objects. -- Adam
	  
		// var delta = this.getTranslation();
		// var attr = "translate(" + delta.x + "," + delta.y +")";
		var attr = "translate(" + this.e + "," + this.f +")";

		var theta = this.getRotation();
		if (theta != 0.0) attr += " rotate(" + theta  +")"; // in degrees

		//var sp = this.getScalePoint();
		//if (sp.x != 1.0 || sp.y != 1.0)	 attr += " scale(" + sp.x + "," + sp.y + ")";
		var sx = this.getScaleX();
		var sy = this.getScaleY();
		if (sx != 1.0 || sy != 1.0)	 attr += " scale(" + sx + "," + sy + ")";

		return attr;
	},

	applyTo: function(rawNode) { 
		if (Config.useTransformAPI) {
			var list = rawNode.transform.baseVal;
			var canvas = locateCanvas();

			var translation = canvas.createSVGTransform();
			translation.setTranslate(this.e, this.f);
			list.initialize(translation);
			if (this.b || this.c) {
				var rotation = canvas.createSVGTransform();
				rotation.setRotate(this.getRotation(), 0, 0);
				list.appendItem(rotation);
			}
			if (this.a != 1.0 || this.d != 1.0) {
				var scaling = canvas.createSVGTransform();
				var sp = this.getScalePoint();
				scaling.setScale(sp.x, sp.y);
				list.appendItem(scaling);
			}
		} else {
			rawNode.setAttributeNS(null, "transform", this.toAttributeValue());
		}
	},

	toString: function() {
		return this.toAttributeValue();
	},

	transformPoint: function(p, acc) {
		return p.matrixTransform(this, acc);
	},

	transformDirection: function(p, acc) {
		return p.matrixTransformDirection(this, acc);
	},

	matrixTransformForMinMax: function(pt, minPt, maxPt) {
		var x = this.a * pt.x + this.c * pt.y + this.e;
		var y = this.b * pt.x + this.d * pt.y + this.f;
		if (x > maxPt.x) maxPt.x = x;
		if (y > maxPt.y) maxPt.y = y;
		if (x < minPt.x) minPt.x = x;
		if (y < minPt.y) minPt.y = y;
	},

	transformRectToRect: function(r) {
		// This gets called a lot from invalidRect, so it has been optimized a bit
		var minPt = pt(Infinity, Infinity);
		var maxPt = pt(-Infinity, -Infinity);
		this.matrixTransformForMinMax(r.topLeft(), minPt, maxPt);
		this.matrixTransformForMinMax(r.bottomRight(), minPt, maxPt);
		if (this.isTranslation()) return rect(minPt, maxPt);

		this.matrixTransformForMinMax(r.topRight(), minPt, maxPt);
		this.matrixTransformForMinMax(r.bottomLeft(), minPt, maxPt);
		return rect(minPt, maxPt);
	},

	copy: function() {
		return new lively.scene.Similitude(this);
	},

	toMatrix: function() {
		var mx = locateCanvas().createSVGMatrix();
		mx.a = this.a;
		mx.b = this.b;
		mx.c = this.c;
		mx.d = this.d;
		mx.e = this.e;
		mx.f = this.f;
		return mx;
	},

	ensureNumber: function(value) {
		// note that if a,b,.. f are not numbers, it's usually a
		// problem, which may crash browsers (like Safari) that don't
		// do good typechecking of SVGMatrix properties before passing
		// them to native code.	 It's probably too late to figure out
		// the cause, but at least we won't crash.
		if (isNaN(value)) { throw dbgOn(new Error('not a number'));}
		return value;
	},


	fromMatrix: function(mx) {
		this.a = this.ensureNumber(mx.a);
		this.b = this.ensureNumber(mx.b);
		this.c = this.ensureNumber(mx.c);
		this.d = this.ensureNumber(mx.d);
		this.e = this.ensureNumber(mx.e);
		this.f = this.ensureNumber(mx.f);
	},

	preConcatenate: function(t) {
		var m = this.matrix_;
		this.a =  t.a * m.a + t.c * m.b;
		this.b =  t.b * m.a + t.d * m.b;
		this.c =  t.a * m.c + t.c * m.d;
		this.d =  t.b * m.c + t.d * m.d;
		this.e =  t.a * m.e + t.c * m.f + t.e;
		this.f =  t.b * m.e + t.d * m.f + t.f;
		this.matrix_ = this.toMatrix();
		return this;
	},

	createInverse: function() {
		return new lively.scene.Similitude(this.matrix_.inverse());
	}

});

Wrapper.subclass('lively.scene.Transform', {
	// a more direct wrapper for SVGTransform
	initialize: function(rawNode, targetNode) {
		if (!rawNode) rawNode = locateCanvas().createSVGTransform();
		this.rawNode = rawNode;
		reflect(this).slotAt('rawNode').beCreator(); // aaa - kind of a hack, added by Adam so that we can file out morphs
		// we remember the target node so that we can inform it that we changed
		this.targetNode = targetNode; 
	},

	getTranslate: function() {
		if (this.rawNode.type == SVGTransform.SVG_TRANSFORM_TRANSLATE) {
			var mx = this.rawNode.matrix;
			return pt(mx.e, mx.f);
		} else throw new TypeError('not a translate ' + this + ' type ' + this.type());
	},

	setTranslate: function(x, y) {
		// note this overrides all the values
		this.rawNode.setTranslate(x, y);
		this.targetNode.transformListItemChanged(this);
		return this;
	},

	setRotate: function(angleInDegrees, anchorX, anchorY) {
		// note this overrides all the values
		this.rawNode.setRotate(angleInDegrees, anchorX || 0.0, anchorY || 0.0);
		this.targetNode.transformListItemChanged(this);
		return this;
	},

	setTranslateX: function(x) {
		if (this.rawNode.type == SVGTransform.SVG_TRANSFORM_TRANSLATE) {
			var tr = this.getTranslate();
			this.rawNode.setTranslate(x, tr.y);
			this.targetNode.transformListItemChanged(this);
		
		} else throw new TypeError('not a translate ' + this);
	},

	setX: function(x) {
		return this.setTranslateX(x);
	},
	
	setTranslateY: function(y) {
		if (this.rawNode.type == SVGTransform.SVG_TRANSFORM_TRANSLATE) {
			var tr = this.getTranslate();
			this.rawNode.setTranslate(tr.x, y);
			this.targetNode.transformListItemChanged(this);
		} else throw new TypeError('not a translate ' + this);
	},

	setY: function(y) {
		return this.setTranslateY(y);
	},


	type: function() {
		return this.rawNode.type;
	},

	getAngle: function() {
		/*
		var r =	 Math.atan2(this.matrix.b, this.matrix.d).toDegrees();
		return Math.abs(r) < this.eps ? 0 : r; // don't bother with values very close to 0
		*/
		return this.rawNode.angle;
	},

	getScale: function() {
		if (this.rawNode.type == SVGTransform.SVG_TRANSFORM_SCALE) {
			var mx = this.rawNode.matrix;
			var a = mx.a;
			var c = mx.c;
			return Math.sqrt(a * a + c * c);
		} else throw new TypeError('not a scale ' + this.rawNode);
	},
	
	toString: function() {
		switch (this.rawNode.type) {
		case SVGTransform.SVG_TRANSFORM_TRANSLATE:
			var delta = this.getTranslate();
			return "translate(" + delta.x + "," + delta.y +")";
		case SVGTransform.SVG_TRANSFORM_ROTATE:
			var mx = this.rawNode.matrix;
			if (mx.e || mx.f) {
				var disp = pt(mx.e || 0, mx.f || 0);
				var str = "translate(" + disp.x.toFixed(2) + "," + disp.y.toFixed(2) + ") "; 
				str += "rotate(" + this.getAngle().toFixed(2) + ") ";
				//str += "translate(" + (-disp.x).toFixed(2)  + ", " + (-disp.y).toFixed(2) + ")";
				// FIXME, hmm.... wouldn't we want to transform back?
				//console.log('format ' + str);
				return str;
			} else return "rotate(" + this.getAngle()  +")"; // in degrees
		case SVGTransform.SVG_TRANSFORM_SCALE:
			return "scale(" + this.getScale() + ")";
		default:
			var mx = this.rawNode.matrix;
			return "matrix(" + [mx.a, mx.b, mx.c, mx.d, mx.e, mx.f].join(', ') + ")"; // FIXME
		}
	}
});

lively.scene.Translate = {
	fromLiteral: function(literal) {
		var tfm = new lively.scene.Transform();
		tfm.rawNode.setTranslate(literal.X || 0.0, literal.Y || 0.0);
		// tfm.targetNode should be set from setTransforms, already on the call stack
		return tfm;
	}
};


lively.scene.Transform.subclass('lively.scene.Rotate', {
	// FIXME: fold into Transform
	initialize: function($super, degrees, anchorX, anchorY) {
		$super(null, null);
		// doesn't know its target node yet
		this.anchor = pt(anchorX|| 0.0, anchorY || 0.0);
		this.rawNode.setRotate(degrees, anchorX || 0.0, anchorY || 0.0);
	},

	setAngle: function(angle) {
		//console.log('setting angle to ' + angle);
		this.setRotate(angle, this.anchor.x, this.anchor.y);
	}
});

Object.extend(lively.scene.Rotate, {
	fromLiteral: function(literal) {
		return new lively.scene.Rotate(literal.Angle, literal.X, literal.Y);
	}
});

Wrapper.subclass('lively.scene.Effect', {

	initialize: function(id) {
		this.rawNode = NodeFactory.create("filter");
		this.effectNode = this.rawNode.appendChild(NodeFactory.create(this.nodeName));
		this.rawNode.setAttribute("id", id);
	},

	applyTo: function(target) {
		this.reference();
		target.setTrait("filter", this.uri());
	}

});

this.Effect.subclass('lively.scene.GaussianBlurEffect', {
	nodeName: "feGaussianBlur",
	initialize: function($super, radius, id) { // FIXME generate IDs automatically
		$super(id);
		this.effectNode['in'] = "SourceGraphics"; // FIXME more general
		this.setRadius(radius);
	},

	setRadius: function(radius) {
		var blur = this.effectNode;
		if (blur.setStdDeviation)
			blur.setStdDeviation(radius, radius);
		else  // Safari doesn't define the method
		blur.setAttributeNS(null, "stdDeviation", String(radius));
	},
});


this.Effect.subclass('lively.scene.BlendEffect', {
	nodeName: "feBlend",
	initialize: function($super, id, optSourceURL) { // FIXME generate IDs automatically
		$super(id);
		this.effectNode.setAttributeNS(null, "mode", "normal");
		this.effectNode.setAttributeNS(null, "in", "SourceGraphic"); // FIXME more general

		if (optSourceURL) {
			var feImage = this.rawNode.insertBefore(NodeFactory.create("feImage"), this.effectNode);
			feImage.setAttributeNS(null, "result", "image");
			feImage.setAttributeNS(Namespace.XLINK, "href", optSourceURL);
			this.effectNode.setAttributeNS(null, "in2", "image");
		} else {
			this.effectNode.setAttributeNS(null, "in2", optSourceURL);
		}
	}
});

this.Effect.subclass('lively.scene.ColorAdjustEffect', {
	nodeName: "feColorMatrix",
	initialize: function($super, id) { // FIXME generate IDs automatically
		$super(id);
		this.effectNode.setAttributeNS(null, "type", "matrix");
		this.effectNode.setAttributeNS(null, "in", "SourceGraphic"); // FIXME more general
		// FIXME: obviously random numbers
		this.effectNode.setAttributeNS(null, "values", [
			2/3, 2/3, 2/3, 0, 0,
			2/3, 2/3, 2/3, 0, 0,
			2/3, 2/3, 2/3, 0, 0,
			2/3, 2/3, 3/3, 0, 0].join(' '))
	}
});

this.Effect.subclass('lively.scene.SaturateEffect', {
	nodeName: "feColorMatrix",
	initialize: function($super, id, value) { // FIXME generate IDs automatically
		$super(id);
		this.effectNode.setAttributeNS(null, "type", "saturate");
		this.effectNode.setAttributeNS(null, "in", "SourceGraphic"); // FIXME more general
		this.effectNode.setAttributeNS(null, "values", String(value));
	}
});

lively.scene.Node.subclass('lively.scene.Text', {
	documentation: "wrapper around SVG Text elements",
	initialize: function() {
		this.rawNode = NodeFactory.create("text", { "kerning": 0 });
		reflect(this).slotAt('rawNode').beCreator(); // aaa - kind of a hack, added by Adam so that we can file out morphs
	},

	getFontSize: function() {
		return this.getLengthTrait("font-size");
	},

	getFontFamily: function() {
		return this.getTrait("font-family");
	}

});




}); // end using lively.scene

// ===========================================================================
// Gradient colors, stipple patterns and coordinate transformatins
// ===========================================================================


using(namespace('lively.paint'), lively.data.Wrapper).run(function(unused, Wrapper) {

Wrapper.subclass('lively.paint.Stop', {
	initialize: function(offset, color) {
		dbgOn(isNaN(offset));
		this.rawNode = NodeFactory.create("stop", { offset: offset, "stop-color": color});
	},

	deserialize: function(importer, rawNode) {
		this.rawNode = rawNode;
	},

	copyFrom: function(copier, other) {
		if (other.rawNode) this.rawNode = other.rawNode.cloneNode(true);
	},

	color: function() {
		return Color.fromString(this.getTrait("stop-color"));
	},

	offset: function() {
		return this.getLengthTrait("offset");
	},

	toLiteral: function() {
		return { offset: String(this.offset()), color: String(this.color()) };
	},

	toString: function() {
		return "#<Stop{" + JSON.serialize(this.toLiteral()) + "}>";
	}

});

Object.extend(this.Stop, {
	fromLiteral: function(literal) {
		return new lively.paint.Stop(literal.offset, literal.color);
	}
});


// note that Colors and Gradients are similar but Colors don't need an SVG node
Wrapper.subclass("lively.paint.Gradient", {

	dictionaryNode: null,
	initialize: function($super, node) {
		$super();
		this.stops = [];
		this.refcount = 0;
		this.rawNode = node;
	},

	deserialize: function($super, importer, rawNode) {
		$super(importer, rawNode);
		//rawNode.removeAttribute("id");
		var rawStopNodes = $A(this.rawNode.getElementsByTagNameNS(Namespace.SVG, 'stop'));
		this.stops = rawStopNodes.map(function(stopNode) { return new lively.paint.Stop(importer, stopNode) });
		this.refcount = 0;
	},

	copyFrom: function($super, copier, other) {
		$super(copier, other);
		dbgOn(!other.stops);
		//this.rawNode.removeAttribute("id");
		var rawStopNodes = $A(this.rawNode.getElementsByTagNameNS(Namespace.SVG, 'stop'));
		this.stops = rawStopNodes.map(function(stopNode) { return new lively.paint.Stop(importer, stopNode) });
		this.refcount = 0;
	},

	addStop: function(offset, color) {
		var stop = new lively.paint.Stop(offset, color);
		this.stops.push(stop);
		this.rawNode.appendChild(stop.rawNode);
		return this;
	},

	setStops: function(list) {
		if (this.stops && this.stops.length > 0) throw new Error('stops already initialized to ' + this.stops);
		list.forEach(function(stop) {
			this.stops.push(stop);
			this.rawNode.appendChild(stop.rawNode);
		}, this);
	},

	toString: function() {
		return "#<" + this.getType() + this.toMarkupString() + ">";
	},

  // added by Adam; should implement these properly
	isVeryLight: function() { return false; },
	isVeryDark:  function() { return false; },
});


this.Gradient.subclass("lively.paint.LinearGradient", {

	initialize: function($super, stopSpec, vector) {
		vector = vector || lively.paint.LinearGradient.NorthSouth;
		$super(NodeFactory.create("linearGradient",
					  {x1: vector.x, y1: vector.y, 
					   x2: vector.maxX(), y2: vector.maxY()})); 
		this.vector = vector;  // cache for access without rawNode
		this.setStops(stopSpec);
		return this;
	},

    /*
    Was this here in the first place, or did I add it? Anyway, I'm implementing it up on Gradient over in changes.js. -- Adam
	mixedWith: function(color, proportion) {
		var result = new lively.paint.LinearGradient([]);
		for (var i = 0; i < this.stops.length; ++i) {
			result.addStop(this.stops[i].offset(), 
				       this.stops[i].color().mixedWith(color, proportion));
		}
		return result;
	}
	*/

});


Object.extend(this.LinearGradient, {
	fromLiteral: function(literal) {
		return new lively.paint.LinearGradient(literal.stops, 
			literal.vector || lively.paint.LinearGradient.NorthSouth);
	}
});

Object.extend(this.LinearGradient, {
	NorthSouth: rect(pt(0, 0), pt(0, 1)),
	SouthNorth: rect(pt(0, 1), pt(0, 0)),
	EastWest:	rect(pt(0, 0), pt(1, 0)),
	WestEast:	rect(pt(1, 0), pt(0, 0)),
	SouthWest:	rect(pt(1, 0), pt(0, 1)),  // Down and to the left
	SouthEast:	rect(pt(0, 0), pt(1, 1))   // Down and to the right -- default lighting direction
});


this.Gradient.subclass('lively.paint.RadialGradient', {

	initialize: function($super, stopSpec, optF) {
		$super(NodeFactory.create("radialGradient"));
		this.setStops(stopSpec);
		if (optF) {
			this.setTrait("fx", optF.x);
			this.setTrait("fy", optF.y);
		}
	}
});

Object.extend(this.RadialGradient, {
	fromLiteral: function(literal) {
		return new lively.paint.RadialGradient(literal.stops, literal.focus);
	}
});

});// lively.paint
avocado.transporter.module.onLoadCallbacks["lk/scene"] = 'done';

avocado.transporter.module.onLoadCallbacks["lk/Core"] = function() {};
/*
 * Copyright (c) 2006-2009 Sun Microsystems, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


/* Code loader. Appends file to DOM. */
Object.subclass('ScriptLoader', {
	
	getScripts: function() { return $A(document.getElementsByTagName('script')) },

	loadJs: function(url, onLoadCb, embedSerializable/*currently not used*/) {
		if (this.scriptInDOM(url)) {
			console.log('script ' + url + ' already loaded');
			return
		};
		if (window.shouldShowLoadingMessages) { console.log('loading script ' + url); }
		// FIXME Assumption that first def node has scripts
		var node = document.getElementsByTagName("defs")[0] || this.getScripts()[0].parentElement;
		if (!node) throw(dbgOn(new Error('Cannot load script ' + url + ' dont know where to append it')));
		var exactUrl = Config.disableScriptCaching ? url + '?' + new Date().getTime() : url;
		var xmlNamespace = node.namespaceURI;

		var script = document.createElementNS(xmlNamespace, 'script');
		script.setAttributeNS(null, 'id', url);
		script.setAttributeNS(null, 'type', 'text/ecmascript');

		if (xmlNamespace == Namespace.SVG)
			script.setAttributeNS(Namespace.XLINK, 'href', exactUrl);
		else
		script.setAttributeNS(null, 'src', exactUrl);

		script.setAttributeNS(null, 'onload', onLoadCb);

		node.appendChild(script);
	},

	scriptInDOM2: function(url) {
		return this.getScripts().some(function(e) {
			return (e.getAttribute('xlink:href') && e.getAttribute('xlink:href') == url) ||
				(e.getAttribute('src') && e.getAttribute('src') == url)
		});
	},

	scriptInDOM: function(url) {
		if (document.getElementById(url)) return true;
		var scriptElements = this.getScripts();
		for (var i = 0; i < scriptElements.length; i++)
			if (this.scriptElementLinksTo(scriptElements[i], url)) return true;
		return false;
	},

	scriptElementLinksTo: function(el, url) {
		if (!el.getAttribute) return false;
		// FIXME use namespace consistently
		if (el.getAttribute('id') == url) return true;
		var link = el.getAttribute('xlink:href') || el.getAttribute('src');
		if (!link) return false;
		if (url == link) return true;
		// Hack
		// FIXME just using the file name does not really work for namespaces
		// http://bla/test.xhtml?01234 -> test.xhtml?01234 -> test.xhtml
		var linkName = link.split('/').last().split('?').first();
		var urlName = url.split('/').last().split('?').first();
		return linkName == urlName;
	},
	
}); 

Object.extend(Global, {
	Loader: new ScriptLoader(),
});

// test which checks if all modules are loaded
(function testModuleLoad() {
    var modules = Global.subNamespaces(true).select(function(ea) { return ea.wasDefined });
    modules
        .select(function(ea) { return ea.hasPendingRequirements() })
        .forEach(function(ea) { console.warn(ea.uri() + ' has unloaded requirements: ' + ea.pendingRequirementNames()) });
    if (window.shouldShowLoadingMessages) { console.log('Module load check done. ' + modules.length + ' modules loaded.'); }
}).delay(5);

// ===========================================================================
// Error/warning console (browser dependent)
// ===========================================================================

// console handling
(function() { 
    
    // from firebug lite
    function escapeHTML(value) {
		return value;
	
		function replaceChars(ch) {
			switch (ch) {
				case "<": return "&lt;";
				case ">": return "&gt;";
				case "&": return "&amp;";
				case "'": return "&#39;";
				case '"': return "&quot;";
			}
			return "?";
		}
	
		return String(value).replace(/[<>&"']/g, replaceChars); //KP: this comment to workaround a bug in my Emacs's javascript mode " ])
    }
    
	function LogWindow() {
		this.win = (function() { 
			var win = Global.window.open("", "log", "scrollbars,width=900,height=300"); 
			win.title = "Lively Kernel Log";
			win.document.write("<pre>"); 
			return win; 
		})();

		this.log = function(msg) {
			if (!this.win) return;
			this.win.document.writeln(escapeHTML(msg));
		}
	};
    
    var platformConsole = Global.window.console || ( Global.window.parent && Global.window.parent.console); 
    if (!platformConsole) {
		if (!Config.disableNoConsoleWarning) {
			window.alert && window.alert('no console! console output disabled');
		};
		platformConsole = { log: function(msg) { } } // do nothing as a last resort
    }
    
	if (Global.console && Global.console.firebug !== undefined) return; // Firebug doesn't like to be overwritten
	
 	// rebind to something that has all the calls, and forwards ti consumers...
	Global.console = {
	    
		platformConsole: platformConsole,
		
		// forwarding Fierbug functions...
		// from: http://getfirebug.com/logging
		// http://michaelsync.net/2007/09/09/firebug-tutorial-logging-profiling-and-commandline-part-i
		profile:  function profile() {
			if (platformConsole.profile)
				platformConsole.profile.apply(platformConsole, arguments)
		},

		profileEnd: function profileEnd() {
			if (platformConsole.profileEnd)
				platformConsole.profileEnd.apply(platformConsole, arguments)
		},

		time: function time() {
			if (platformConsole.time)
				platformConsole.time.apply(platformConsole, arguments)
		},

		timeEnd: function timeEnd() {
			if (platformConsole.timeEnd)
				platformConsole.timeEnd.apply(platformConsole, arguments)
		},
		
		trace: function trace() {
			if (platformConsole.trace)
				platformConsole.trace.apply(platformConsole, arguments)
		},
		
		
		// Nested grouping
		group: function group() {
			if (platformConsole.group)
				platformConsole.group.apply(platformConsole, arguments)
		},

		groupEnd: function groupEnd() {
			if (platformConsole.groupEnd)
				platformConsole.groupEnd.apply(platformConsole, arguments)
		},
		
		// Object inspection
		dir: function dir() {
			if (platformConsole.dir)
				platformConsole.dir.apply(platformConsole, arguments)
		},
		// end forwarding Fierbug functions
		
	    consumers: [ platformConsole], // new LogWindow() ],
	    
		warn: function warn() {
			var args = $A(arguments);
			this.consumers.forEach(function(c) { 
				if (c.warn) c.warn.apply(c, args); 
				else c.log("Warn: " + Strings.formatFromArray(args));
			});
		},
	    
		info: function info() {
			var args = $A(arguments);
			this.consumers.forEach(function(c) { 
				if (c.info) c.info.apply(c, args); 
				else c.log("Info: " + Strings.formatFromArray(args));
			});
		},
	    
		log: function log() {
			this.consumers.invoke('log', Strings.formatFromArray($A(arguments)));
		},
	    
		assert: function assert(expr, msg) {
			if (!expr) this.log("assert failed:" + msg);
		}
	}
	
	// WebCards
	// if(UserAgent.isChrome){//Google Chrome dose not support multiple Params for logging
	// 	var orignalWarn = platformConsole.warn;
	// 	platformConsole.warn = function(){
	// 		orignalWarn.apply(platformConsole,[Strings.formatFromArray($A(arguments))]);
	// 	};
	// 	
	// 	var orignalInfo = platformConsole.info;
	// 	platformConsole.info = function(){
	// 		orignalInfo.apply(platformConsole,[Strings.formatFromArray($A(arguments))]);
	// 	};
	// 	
	// 	var orignalLog = platformConsole.log;
	// 	platformConsole.log = function(){
	// 		orignalLog.apply(platformConsole,[Strings.formatFromArray($A(arguments))]);
	// 	};
	// }
	
    
})(); 

Object.extend(Global.window, {
	onerror: function(message, url, code) {
		console.log('in %s: %s, code %s', url, message, code);
	},
	/* commented out by Adam, don't want this at all, because it overwrites our own version
	onbeforeunload: function(evt) { 
		if (Config.askBeforeQuit) {
			var msg = "Lively Kernel data may be lost if not saved.";
			evt.returnValue = msg; 
			return msg;
		} else return null;
	}
	*/
	// onblur: function(evt) { console.log('window got blur event %s', evt); },
	// onfocus: function(evt) { console.log('window got focus event %s', evt); }
});


(function() { // override config options with options from the query part of the URL

    // may have security implications ...
    var query = Global.document.documentURI.split('?')[1];
    if (!query) return;

    var configOverrides = query.toQueryParams();
    for (var p in configOverrides) {
	if (Config.hasOwnProperty(p)) { // can't set unknown properties
	    // this is surprisingly convoluted in Javascript:
	    if ((typeof Config[p].valueOf()) === 'boolean') { 
		// make sure that "false" becomes false
		Config[p] = configOverrides[p].toLowerCase() == "true";
	    } else {
		Config[p] = configOverrides[p];
	    }
	} else {
	    console.log("ignoring unknown property " + p);
	}
    }
})();    


// ===========================================================================
// DOM manipulation (Browser and graphics-independent)
// ===========================================================================

Namespace =  {
    SVG : "http://www.w3.org/2000/svg", 
    LIVELY : UserAgent.usableNamespacesInSerializer ? "http://www.experimentalstuff.com/Lively"  : null, 
    XLINK : "http://www.w3.org/1999/xlink", 
    XHTML: "http://www.w3.org/1999/xhtml"
};

var Converter = {
    documentation: "singleton used to parse DOM attribute values into JS values",


    toBoolean: function toBoolean(string) {
		return string && string == 'true';
    },

    fromBoolean: function fromBoolean(object) {
	if (object == null) return "false";
	var b = object.valueOf();
	// this is messy and should be revisited
	return (b === true || b === "true") ? "true" : "false";
    },

    parseInset: function(string) {
	// syntax: <left>(,<top>(,<right>,<bottom>)?)?
	
	if (!string || string == "none") return null;
	try {
	    var box = string.split(",");
	} catch (er) {alert("string is " + string + " string? " + (string instanceof String)) }
	var t, b, l, r;
	switch (box.length) {
	case 1:
	    b = l = r = t = lively.data.Length.parse(box[0].strip());
	    break;
	case 2:
	    t = b = lively.data.Length.data.parse(box[0].strip());
	    l = r = lively.data.Length.data.parse(box[1].strip());
	    break;
	case 4:
	    t = lively.data.Length.parse(box[0].strip());
	    l = lively.data.Length.parse(box[1].strip());
	    b = lively.data.Length.parse(box[2].strip());
	    r = lively.data.Length.parse(box[3].strip());
	    break;
	default:
	    console.log("unable to parse padding " + padding);
	    return null;
	} 
        return Rectangle.inset(t, l, b, r);
    },

	wrapperAndNodeEncodeFilter: function(baseObj, key) {
		var value = baseObj[key];
		if (value instanceof lively.data.Wrapper) return value.uri();
		if (value instanceof Document || value instanceof Element || value instanceof DocumentType)
			return JSON.serialize({XML: Exporter.stringify(value)});
		return value;
	},

	wrapperAndNodeDecodeFilter:  function(baseObj, key) {
		var value = baseObj[key];
		// console.log("wrapperAndNodeDecodeFilter: " + baseObj + " key: " + key + " value: " + baseObj[key]);
		if (Object.isString(value)) {
			var uri = lively.data.FragmentURI.parse(value)
			if (uri) {
				// resolve uri to an object
				// Search the world, because we don't have an general URI resolver
				var obj = WorldMorph.current().resolveUriToObject(uri)
				if (obj)
					return obj;
				else
					return value;
			}
		}
		return Converter.nodeDecodeFilter(baseObj, key)
    },

    nodeEncodeFilter: function(baseObj, key) {
        var value = baseObj[key];
		if (!value) return value;
        if (!value.nodeType) return value;
        if (value.nodeType !== document.DOCUMENT_NODE && value.nodeType !== document.DOCUMENT_TYPE_NODE)
            return JSON.serialize({XML: Exporter.stringify(value)});
        throw new Error('Cannot store Document/DocumentType'); // to be removed
    },
    
    toJSONAttribute: function(obj) {
		return obj ? escape(JSON.serialize(obj, Converter.wrapperAndNodeEncodeFilter)) : "";
    },

    nodeDecodeFilter: function(baseObj, key) {
		var value = baseObj[key];
		if (!value || !Object.isString(value) || !value.include('XML')) return value;
		var unserialized = JSON.unserialize(value);
		if (!unserialized.XML) return value;
		// var xmlString = value.substring("XML:".length);
		// FIXME if former XML was an Element, it has now a new parentNode, seperate in Elements/Documents?
		//dbgOn(true);
		var node = new DOMParser().parseFromString(unserialized.XML, "text/xml");
        return document.importNode(node.documentElement, true);
    },

    fromJSONAttribute: function(str) {
		return str ?  JSON.unserialize(unescape(str), Converter.nodeDecodeFilter) : null;
    },
    
    needsJSONEncoding: function(value) {
		// some objects can be saved in as DOM attributes using their
		// .toString() form, others need JSON
		if (value instanceof Color) return false;
		var type = typeof value.valueOf();
		return type != "string" && type != "number"; 
    },

	quoteCDATAEndSequence: function(string) {
		var closeCDATASequence = "]]>";
		if (string.include(closeCDATASequence)) {
			console.log("Warning: quoted CDATA Sequence ] ] >")
			string = string.replace(closeCDATASequence, "\\]\\]\\>");
		};
		return string
	},

	// TODO parallels to preparePropertyForSerialization in scene.js
	// Why to we encodeProperties for Records at runtime and not at serialization time?
    encodeProperty: function(prop, propValue, isItem) {
		if (isItem) {
			var desc = LivelyNS.create("item");
		} else {
			var desc = LivelyNS.create("field", {name: prop});
		}
		if (Converter.isJSONConformant(propValue) || propValue instanceof Array) { // hope for the best wrt/arrays
		    // FIXME: deal with arrays of primitives etc?
		    var encoding;
		    if (propValue === null)
				encoding = NodeFactory.createText("null");
		    else switch (typeof propValue) {
		    	case "number":
		    	case "boolean":
					encoding = NodeFactory.createText(String(propValue));
					break;
		    	default:
					var jsonSource = JSON.serialize(propValue, Converter.wrapperAndNodeEncodeFilter);
					encoding = NodeFactory.createCDATA(this.quoteCDATAEndSequence(jsonSource));
		    }
		    desc.appendChild(encoding);
		    return desc;
		} 
	
		if (propValue && propValue.toLiteral) {
		    desc.setAttributeNS(null, "family", propValue.constructor.type);
		    desc.appendChild(NodeFactory.createCDATA(JSON.serialize(propValue.toLiteral())));
		    return desc;
		}
				
		if (propValue.nodeType) {
		    switch (propValue.nodeType) {
		    case document.DOCUMENT_NODE:
		    case document.DOCUMENT_TYPE_NODE:
			throw new Error('Cannot store Document/DocumentType'); // to be removed
		    default:
			desc.setAttributeNS(null, "isNode", true); // Replace with DocumentFragment
			desc.appendChild(document.importNode(propValue, true));
		    }
		    return desc;
		} 
		return null;
    },
    
    isJSONConformant: function(value) { // for now, arrays not handled but could be
        if (value instanceof Element && value.ownerDocument === document) return false;
        // why disallow all objects?
	// KP: because we don't know how to handle them up front, special cases handled bye encodeProperty
	// this makes simple objects like {a: 1} hard to serialize
	// fix for now: objects can determine by themselves if isJSONConformant should be true
        return value == null || value.isJSONConformant || (typeof value.valueOf()  !== 'object');
    }

};


var NodeFactory = {

    createNS: function(ns, name, attributes) {
	var element = Global.document.createElementNS(ns, name);
	return NodeFactory.extend(ns, element, attributes);
    },

    create: function(name, attributes) {
	//return this.createNS(Namespace.SVG, name, attributes);  // doesn't work
	var element = Global.document.createElementNS(Namespace.SVG, name);
	return NodeFactory.extend(null, element, attributes);
    },

    extend: function(ns, element, attributes) {
	if (attributes) {
	    for (var name in attributes) {
		if (!attributes.hasOwnProperty(name)) continue;
		element.setAttributeNS(ns, name, attributes[name]);
	    }
	}
	return element;
    },

    createText: function(string) {
	return Global.document.createTextNode(string);
    },
    
    createNL: function(string) {
	return Global.document.createTextNode("\n");
    },

    createCDATA: function(string) {
	return Global.document.createCDATASection(string);
    },

	CDATAType: function() {
		return Global.document.CDATA_SECTION_NODE;
	},
	
	TextType: function() {
		return Global.document.TEXT_NODE;
	}


};

XLinkNS = {
	create: function(href, doc) {
		var doc = doc || Global.document;
		var node = NodeFactory.createNS(null, 'script', {type: "text/ecmascript"});
		node.setAttribute('xlink:href', href);
		// XLinkNS.setHref(node, href); // does not seem to work
		return node;
	},
    setHref: function(node, href) {
	return node.setAttributeNS(Namespace.XLINK, "href", href);
    },
    
    getHref: function(node) {
	return node.getAttributeNS(Namespace.XLINK, "href");
    }
};

LivelyNS = {

	create: function(name, attributes) {
		return NodeFactory.createNS(Namespace.LIVELY, name, attributes);
	},

	getAttribute: function(node, name) {
		if (UserAgent.isOpera) return node.getAttribute(name); // Fix for Opera 10.10
		return node.getAttributeNS(Namespace.LIVELY, name);
	},

	removeAttribute: function(node, name) {
		return node.removeAttributeNS(Namespace.LIVELY, name);
	},

	setAttribute: function(node, name, value) {
		node.setAttributeNS(Namespace.LIVELY, name, value);
	},

	getType: function(node) {
		return node.getAttributeNS(Namespace.LIVELY, "type");
	},

	setType: function(node, string) {
		node.setAttributeNS(Namespace.LIVELY, "type", string);
	}
};

XHTMLNS = {

	create: function(name, attributes) {
		return NodeFactory.createNS(Namespace.XHTML, name, attributes);
	},

	getAttribute: function(node, name) {
		if (UserAgent.isOpera) return node.getAttribute(name); // Fix for Opera 10.10
		return node.getAttributeteNS(null, name);
	},

	removeAttribute: function(node, name) {
		return node.removeAttributeNS(null, name);
	},

	setAttribute: function(node, name, value) {
		node.setAttributeNS(null, name, value);
	},

	getType: function(node) {
		return node.getAttributeNS(Namespace.LIVELY, "type");
	},

	setType: function(node, string) {
		node.setAttributeNS(Namespace.LIVELY, "type", string);
	}
};
  
Class.addMixin(lively.data.DOMRecord, lively.data.Wrapper.prototype);
Class.addMixin(lively.data.DOMNodeRecord, lively.data.Wrapper.prototype);



if (window.shouldShowLoadingMessages) { console.log("Loaded basic DOM manipulation code"); }

// ===========================================================================
// Event handling foundations
// ===========================================================================

/**
  * @class Event: replacement Event class. (NOTE: PORTING-SENSITIVE CODE)
  * The code below rebinds the Event class to a LK substitute that wraps around 
  * the browser implementation.
  * For a detailed description of the Event class provided by browsers,
  * refer to, e.g., David Flanagan's book (JavaScript: The Definitive Guide).
  */

var Event = (function() {
    var tmp = Event; // note we're rebinding the name Event to point to a different class 

    var Event = Object.subclass('Event', {

	capitalizer: {
		mouseup: 'MouseUp', mousedown: 'MouseDown', mousemove: 'MouseMove', 
		mouseover: 'MouseOver', mouseout: 'MouseOut', mousewheel: 'MouseWheel',
		keydown: 'KeyDown', keypress: 'KeyPress', keyup: 'KeyUp',
		// touch and gesture stuff added by Adam
		touchstart: 'TouchStart', touchmove: 'TouchMove', touchend: 'TouchEnd', touchcancel: 'TouchCancel',
		gesturestart: 'GestureStart', gesturechange: 'GestureChange', gestureend: 'GestureEnd',
	},
	
	initialize: function(rawEvent) {
		this.rawEvent = rawEvent;
		this.type = this.capitalizer[rawEvent.type] || rawEvent.type;
		//this.charCode = rawEvent.charCode;

		// fix timeStamp, e.g in Opera
		this.timeStamp = this.rawEvent.timeStamp || new Date().getTime();

		this.prepareMousePoint();
		
		this.hand = null;

		// use event.timeStamp
		// event.msTime = (new Date()).getTime();
		this.mouseButtonPressed = false;
	},
	
	// added by Adam
	setHand: function(hand) {
	  this.hand = hand;
	  return this;
	},

	prepareMousePoint: function() {
		if (this.isMouseEvent())
			this.addMousePoint(this.rawEvent)
	},
	
  offset: function() {
  	// Rearranged this whole function to make it work right in both FireFox and Safari. -- Adam

  	// note that FF doesn't doesnt calculate offsetLeft/offsetTop early enough we don't precompute these values
  	var e = this.canvas();
  	// Look up the parentNode chain for a node that actually knows its offsetParent. Necessary because
  	// for some reason in FireFox not every node does. -- Adam
  	while (e && !e.offsetParent) { e = e.parentNode; }

  	var offsetX = 0;
  	var offsetY = 0; // Why the heck was this -3? -- Adam

		while (e) {
			offsetX += e.offsetLeft || 0; // || 0 added by Adam
			offsetY += e.offsetTop  || 0; // || 0 added by Adam
			e = e.offsetParent;
  	}

  	return pt(offsetX, offsetY);
  },
	
	addMousePoint: function(evtOrTouch) {
		var pos = pt(evtOrTouch.pageX || evtOrTouch.clientX, evtOrTouch.pageY || evtOrTouch.clientY);
		this.mousePoint = pos.subPt(this.offset());
		this.priorPoint = this.mousePoint;
	},
	
	isMouseEvent: function() {
		return Event.mouseEvents.include(this.rawEvent.type);
	},
	
	// touch and gesture stuff added by Adam
	isTouchEvent: function() {
		return Event.touchEvents.include(this.rawEvent.type);
	},
 	isGesture: function() { return this.touches().length > 1 },
	// see http://www.sitepen.com/blog/2008/07/10/touching-and-gesturing-on-the-iphone/
	touches: function() { return this.rawEvent.touches },
	targetTouches: function() { return this.rawEvent.targetTouches },
	changedTouches: function() { return this.rawEvent.changedTouches },
	
	simpleCopy: function() {
		return new Event(this.rawEvent);
	},

	canvas: function() {
		if (!UserAgent.usableOwnerSVGElement) {
			// so much for multiple worlds on one page
			return Global.document.getElementById("canvas");
		} else {
			return this.rawEvent.currentTarget.ownerSVGElement;
		}
	},

	stopPropagation: function() {
		this.rawEvent.stopPropagation();
	},

	preventDefault: function() {
		this.rawEvent.preventDefault();
    this.rawEvent.returnValue = false; // Added because I think it might help on Windows, though I'm really not sure. -- Adam, 2008
	},

	stop: function() {
		this.preventDefault();
		this.stopPropagation();
	},

	isAltDown: function() {
		return this.rawEvent.altKey;
	},

	isCommandKey: function() {
		// this is LK convention, not the content of the event
		if (Config.useAltAsCommand)
			return this.isAltDown();
		if (UserAgent.isWindows || UserAgent.isLinux )
			return this.isCtrlDown()
		if (UserAgent.isOpera) // Opera recognizes cmd as ctrl!!?
			return this.isCtrlDown()
		return this.isMetaDown()
	},

	isShiftDown: function() {
		return this.rawEvent.shiftKey;
	},

	isMetaDown: function() {
		return this.rawEvent.metaKey;
	},

	isCtrlDown: function() {
		return this.rawEvent.ctrlKey;
	},

	toString: function() {
		return Strings.format("#<Event:%s%s%s>",
			this.type,
			this.mousePoint ?  "@" + this.mousePoint : "",
			this.getKeyCode() || "");
	},

	setButtonPressedAndPriorPoint: function(buttonPressed, priorPoint) {
		this.mouseButtonPressed = buttonPressed;
		// if moving or releasing, priorPoint will get found by prior morph
		this.priorPoint = priorPoint; 
	},

	handlerName: function() {
		return "on" + this.type;
	},

	getKeyCode: function() {
		return this.rawEvent.keyCode;
	},

	getKeyChar: function() {
		if (this.type == "KeyPress") { // rk what's the reason for this test?
			var id = this.rawEvent.charCode || this.rawEvent.which;
			if (id > 63000) return ""; // Old Safari sends weird key char codes
			return id ? String.fromCharCode(id) : "";
		} else  {
			var code = this.rawEvent.which;
			return code && String.fromCharCode(code);
		}
	},

	wheelDelta: function() {
	    // FIXME: make browser-independent
	    return this.rawEvent.wheelDelta;
	},
	
	point: function() {
	    // likely origin of event, obvious for mouse events, the hand's position for
	    // keyboard events
	    return this.mousePoint || this.hand.getPosition();
	},
	
	isLeftMouseButtonDown: function() {
		return this.rawEvent.button === 0;
	},

	isMiddleMouseButtonDown: function() {
		return this.rawEvent.button === 1;
	},

	isRightMouseButtonDown: function() {
		return this.rawEvent.button === 2;
	}

    });

    Event.rawEvent = tmp;

    Object.extend(Event, {
		// copied from prototype.js:
		KEY_BACKSPACE: 8,
		KEY_TAB:       9,
		KEY_RETURN:   13,
		KEY_ESC:      27,
		KEY_LEFT:     37,
		KEY_UP:       38,
		KEY_RIGHT:    39,
		KEY_DOWN:     40,
		KEY_DELETE:   46,
		KEY_HOME:     36,
		KEY_END:      35,
		KEY_PAGEUP:   33,
		KEY_PAGEDOWN: 34,
		KEY_INSERT:   45,

		// not in prototype.js:
		KEY_SPACEBAR: 32,
		
		prepareEventSystem: function() {
		    var disabler = {    
				handleEvent: function(evt) { 	
			    	evt.preventDefault(); 
			    	return false;
				}
		    };
		    var canvas = avocado.transporter.livelyKernelInitializer.createCanvasIfNone(); // aaa used to say Global.document.getElementById("canvas") but better to create it if it's not there yet. -- Adam
			if (!canvas) return
		    canvas.addEventListener("dragstart", disabler, true);
		    canvas.addEventListener("selectstart", disabler, true);
			if (Config.suppressDefaultMouseBehavior)
				Global.document.oncontextmenu = Functions.False
		},
    });

    var basicMouseEvents =  ["mousedown", "mouseup", "mousemove", "mousewheel"];
    var extendedMouseEvents = [ "mouseover", "mouseout"];
    Event.mouseEvents = basicMouseEvents.concat(extendedMouseEvents);

    Event.keyboardEvents = ["keypress", "keyup", "keydown"];
    // touch and gesture stuff added by Adam
    Event.touchEvents = ["touchstart", "touchmove", "touchend", "touchcancel"];
    Event.gestureEvents = ["gesturestart", "gesturechange", "gestureend"];
    Event.basicInputEvents = basicMouseEvents.concat(Event.keyboardEvents, Event.touchEvents, Event.gestureEvents);

    return Event;
})();

function equals(leftObj, rightObj) {
    if (!leftObj && !rightObj) return true;
    if (!leftObj || !rightObj) return false;
    switch (leftObj.constructor) {
        case String:
	case Boolean:
	case Number:
            return leftObj == rightObj;
    };
    if (leftObj.isEqualNode)
        return leftObj.isEqualNode(rightObj);
    var cmp = function(left, right) {
	for (var value in left)
	    if (!(left[value] instanceof Function))
		return equals(left[value], right[value]);
    };
    return cmp(leftObj, rightObj) && cmp(rightObj, leftObj);
};


Object.subclass('Exporter', {
    documentation: "Implementation class for morph serialization",

    rootMorph: null,

	initialize: function(rootMorph) {
		this.rootMorph = rootMorph;
		(rootMorph instanceof Morph) || console.log("weird, root morph is " + rootMorph);
	},

	extendForSerialization: function(optSystemDictionary) {
		console.log("extendForSerialization " + optSystemDictionary)
		
		// decorate with all the extra needed to serialize correctly. Return the additional nodes, to be removed 
		var helperNodes = [];

		var exporter = this;

		lively.data.Wrapper.collectSystemDictionaryGarbage(this.rootMorph);	

		this.rootMorph.withAllSubmorphsDo(function() { 
			exporter.verbose && console.log("serializing " + this);
			this.prepareForSerialization(helperNodes, optSystemDictionary);			
			var nl = NodeFactory.createNL();
			this.rawNode.parentNode.insertBefore(nl, this.rawNode);
			helperNodes.push(nl);
		});
		return helperNodes;
	},

	removeHelperNodes: function(helperNodes) {
		for (var i = 0; i < helperNodes.length; i++) {
			var n = helperNodes[i];
			n.parentNode.removeChild(n);
		}
	},

	serialize: function(destDocument) {
		// model is inserted as part of the root morph.
		var helpers = this.extendForSerialization();
		var result = destDocument.importNode(this.rootMorph.rawNode, true);
		this.removeHelperNodes(helpers);
		return result;
	}
});

Object.extend(Exporter, {

	stringify: function(node) {
		return node ? new XMLSerializer().serializeToString(node) : null;
	},

	stringifyArray: function(nodes, conj) {
		return nodes.map(function(n) { return Exporter.stringify(n) }).join(conj);
	},

	shrinkWrapNode: function(node) {
		// FIXME deal with subdirectories: rewrite the base doc and change xlink:href for scripts
		var importer = new Importer();
		var newDoc = importer.getBaseDocument();
		importer.canvas(newDoc).appendChild(newDoc.importNode(node, true));
		return newDoc;
	},

	shrinkWrapMorph: function(morph) {
		var importer = new Importer();
		var newDoc = importer.getBaseDocument();
		if (!newDoc) 
			throw new Error('Can not continue serializing World beacause the base document is broken')
		newDoc.getElementsByTagName("title")[0].textContent = document.title; // persist the title
		// FIXME this should go to another place?
		this.addSystemDictionary(newDoc);
		importer.canvas(newDoc).appendChild(new Exporter(morph).serialize(newDoc));
		return newDoc;
	},
	
	addSystemDictionary: function(doc) {
		var dict = lively.data.Wrapper.dictionary;
		if (!dict) return;
		var preExisting = doc.getElementById(dict.id);
		if (preExisting)
			preExisting.parentNode.removeChild(preExisting);
		var newDict = dict.cloneNode(true);
		doc.getElementsByTagName('svg')[0].appendChild(doc.importNode(newDict, true));
	},

	saveDocumentToFile: function(doc, filename) {
		console.group("save document")
		if (!filename) return null;
		if (!filename.endsWith('.xhtml')) {
			filename += ".xhtml";
			console.log("changed url to " + filename + " for base " + URL.source);
		}

		var url = URL.source.withFilename(filename);
		
		var r = new WebResource(url);
		connect(r, 'status', this, 'showSaveStatus');
		
		// TODO add progress bar
		// connect(r, 'progress', WorldMorph.current(), 'alert', {converter: function(rpe) { return rpe.loaded }});
		
		r.beAsync().put(doc)
		
		return url;
	},

	showSaveStatus: function(status) {
		if (status.isSuccess()) {
			console.log("success publishing world at " + status.url + ", status " + status.code());
			console.timeEnd("save document")
			console.groupEnd("save document")
		} else {
			WorldMorph.current().alert("failure publishing world at " + status.url + ", status " + status.code());
		}
		console.groupEnd("save document")
	},
	
	saveNodeToFile: function(node, filename) {
		return this.saveDocumentToFile(this.shrinkWrapNode(node), filename);
	}

});

Object.subclass('Copier', {
	documentation: "context for performing deep copy of objects",

	wrapperMap: null,

	toString: function() { 
		return "#<Copier>"; 
	},

	initialize: function() {
		this.wrapperMap = {};
	},

	addMapping: function(oldId, newMorph) {
		dbgOn(!this.wrapperMap);
		this.wrapperMap[oldId] = newMorph; 
	},

	lookup: function(oldId) {
		return this.wrapperMap[oldId];
	},
	
	lookUpOrCopy: function(original) {
		if (!original) 
			return null;
		var replacement = this.lookup(original.id());
		if (!replacement) {
			// console.log("lookUpOrCopy: no replacement found for " + original.id());
		   	var replacement = original.copy(this);
			this.addMapping(original.id(), replacement);
		};
		return replacement
	},


	shallowCopyProperties: function(wrapper, other) {	
		for (var p in other) {
		    this.shallowCopyProperty(p, wrapper, other)
		} 
	},	

	shallowCopyProperty: function(property, wrapper, other) {
	    if (!(other[property] instanceof Function) 
			&& other.hasOwnProperty(property) 
			&& other.noShallowCopyProperties
			&& !other.noShallowCopyProperties.include(property)) {
			if (other[property] instanceof lively.data.Wrapper) {
			    var replacement = this.lookup(other[property].id());
			    wrapper[property] = replacement || other[property];
			} else  {			
				wrapper[property] = other[property];
			}
	    }
	},
	
	smartCopyProperty: function(property, wrapper, other) {
		// console.log("smartCopyProperty " + property + " " + wrapper + " from: " + other)
		var original = other[property];
		if (original) {
			if (Object.isArray(original)) {
				wrapper[property] = original.collect(function each(ea) { 
					return this.lookUpOrCopy(ea)}, this);
			} else {			
				wrapper[property] = this.lookUpOrCopy(original)
			};
		};
	}
}); 

// 'dummy' copier for simple objects
Copier.marker = Object.extend(new Copier(), {
    addMapping: Functions.Empty,
    lookup: Functions.Null
});

Copier.subclass('Importer', {
    documentation: "Implementation class for morph de-serialization",

    verbose: !!Config.verboseImport,
    
	toString: function() {
		return "#<Importer>";
	},

	initialize: function($super) {
		$super();
		this.scripts = [];
		this.models = [];
		this.patchSites = [];
	},

	canvas: function(doc) {
		// find the first "svg" element with id "canvas"
		var elements = doc.getElementsByTagName("svg");
		for (var i = 0; i < elements.length; i++) {
			var el = elements.item(i);
			if (el.getAttribute("id") == "canvas") {
				return el;
			}
		}
		console.log("canvas not found in document " + doc);
		return null;
	},

	getBaseDocument: function() {
		// FIXME memoize
		var webRes = new WebResource(URL.source).get()
		var status = webRes.status;
		if (!status.isSuccess()) {
			console.log("failure retrieving  " + URL.source + ", status " + status);
			return null;
		} else {
			var doc = webRes.contentDocument;
			console.log("problems to parse  " + URL.source);
			if (!doc)
				return null;
			this.clearCanvas(doc);
			return doc;
		}
	},

    
	canvasContent: function(doc) {
		var canvas = this.canvas(doc);
		var elements = [];
		for (var node = canvas.firstChild; node != null; node = node.nextSibling) {
			switch (node.localName) {
				case "g":
				elements.push(node);
				break;
			}
		}
		return elements;
	},

	clearCanvas: function(doc) {
		var canvas = this.canvas(doc);
		var node = canvas.firstChild;
		while (node) {
			var toRemove = node;
			node = node.nextSibling;
			if (toRemove.localName == "g") 
				canvas.removeChild(toRemove);
		}
	},

	startScripts: function(world) {
		this.verbose && console.log("start scripts %s in %s", this.scripts, world);
		// sometimes there are null values in this.scripts. Filter them out
		this.scripts.select(function(ea) {return ea}).forEach(function(s) { s.start(world); });
	},
    
    addPatchSite: function(wrapper, name, ref, optIndex) {
		this.patchSites.push([wrapper, name, ref, optIndex]);
    },
    
    importWrapperFromNode: function(rawNode) {
		///console.log('making morph from %s %s', node, LivelyNS.getType(node));
		// call reflectively b/c 'this' is not a Visual yet. 
		var wrapperType = lively.data.Wrapper.getEncodedType(rawNode);
	
		if (!wrapperType || !Class.forName(wrapperType)) {
			if (Config.silentFailOnWrapperClassNotFound) {
				console.log(Strings.format("ERROR: node %s (parent %s) cannot be a morph of %s",
		    		   	rawNode.tagName, rawNode.parentNode, wrapperType));
				return new Morph(this, rawNode)
			} else {
			    throw new Error(Strings.format("node %s (parent %s) cannot be a morph of %s",
			    	rawNode.tagName, rawNode.parentNode, wrapperType));	    
			}
		}

		return new (Class.forName(wrapperType))(this, rawNode);
		/*
		try {

		} catch (er) {
		    console.log("%s instantiating type %s from node %s", er, 
				wrapperType, Exporter.stringify(rawNode));
		    throw er;
		}*/
	},

    importWrapperFromString: function(string) {
		return this.importWrapperFromNode(this.parse(string));
    },

	parse: function(string) {
		var parser = new DOMParser();
		var xml = parser.parseFromString('<?xml version="1.0" standalone="no"?> ' + string, "text/xml");
		if (xml.documentElement.tagName == "html") {
			throw new Error("xml parse error: " + Exporter.stringify(xml.documentElement));
		} 
		return document.importNode(xml.documentElement, true);
	},

	importFromNodeList: function(nodes) {
		var morphs = [];
		for (var i = 0; i < nodes.length; i++) {
			var node = nodes[i];
			// console.log("found node " + Exporter.stringify(node));
			if (node.localName != "g")  continue;
			morphs.push(this.importWrapperFromNode(node.ownerDocument === Global.document ? 
				node : Global.document.importNode(node, true)));
		}
		return morphs;
	},

	finishImport: function(world) {
		this.patchReferences();
		this.hookupModels();
		this.runDeserializationHooks();
		try {
			this.startScripts(world);
		} catch (er) {
			console.log("scripts failed: " + er);
		}
	},

    patchReferences: function() {
		for (var i = 0, N = this.patchSites.length; i < N; i++) {
		    var site = this.patchSites[i];
		    var wrapper = site[0];
		    var name = site[1];
		    var ref = site[2];
		    var index = site[3];
		    var found;
		    if (index !== undefined) {
				if (!wrapper[name]) {
					wrapper[name] = [];
				} else if (!(wrapper[name] instanceof Array)) { 
					throw new Error('whoops, serialization problem?');
				}
				found = (wrapper[name])[index] = this.lookup(ref);
		    } else {
				found = wrapper[name] = this.lookup(ref);
		    }
			if (!found  && name === 'clip') {
				// last hope, not clean
				found = wrapper[name] = new lively.scene.Clip(this, Global.document.getElementById(ref));
				if (found) console.warn('Found reference somehow but not in the way it was intended to be found!!!')
			}
		    if (!found) {
				console.warn("no value found for field %s ref %s in wrapper %s", name, ref, wrapper);
		    } else {
				//console.log("found " + name + "=" + found + " and assigned to " + wrapper);
		    }
		}
    },

	hookupModels: function() {
		Properties.forEachOwn(this.wrapperMap, function each(key, wrapper) {
			if (wrapper.reconnectModel) {// instanceof View
				var m = wrapper.reconnectModel();
				m && console.log('connecting model on ' + wrapper + " model " + m);
			}
		});
	},

	runDeserializationHooks: function() {
		Properties.forEachOwn(this.wrapperMap, function each(key, wrapper) {
			if (wrapper.onDeserialize) {
				wrapper.onDeserialize();
			}
			// collect scripts
			if (wrapper.activeScripts) this.scripts = this.scripts.concat(wrapper.activeScripts);
		}, this);
	},


	loadWorldInSubworld: function(doc) {
		var nodes = this.canvasContent(doc);
		if (!nodes) {
			WorldMorph.current().alert('no morphs found');
			return null;
		}
		var world = new WorldMorph(WorldMorph.current().canvas());
		var morphs = this.importFromNodeList(nodes);

		morphs.forEach(function(morph) {
			if (morph instanceof WorldMorph) morph.submorphs.clone().forEach(function(m) { world.addMorph(m) });
			else world.addMorph(morph);
		});
	
		// post addition
		this.finishImport(world);

		var link = WorldMorph.current().reactiveAddMorph(new LinkMorph(world));
		link.addPathBack();
		return world;
	},

	loadWorldContentsInCurrent: function(doc) {
		var world = this.loadWorldContents(doc);
		// FIXME? scripts have started already ?
		world.submorphs.clone().forEach(function(m) { 
			WorldMorph.current().addMorph(m) 
		});
	},
    
	loadWorldContents: function(doc) { 
		// possibly doc === Global.document; 
		var world = null;
		var morphs = this.importFromNodeList(this.canvasContent(doc));

		if (!(0 in morphs)) 
			return null;

		var canvas = this.canvas(doc);

		if (morphs[0] instanceof WorldMorph) {
			world = morphs[0];	
			if (morphs.length > 1) console.log("more than one top level morph following a WorldMorph, ignoring remaining morphs");
		} else {
			// no world, create one and add all the serialized morphs to it.
			world = new WorldMorph(canvas);
			// this adds a the WorldMorph's <g> at the end of the list
			canvas.appendChild(world.rawNode);
			// the following will reparent all the existing morphs under the WorldMorph's <g>
			morphs.clone().forEach(function(m) { world.addMorph(m); });
		}
		this.finishImport(world);

		return world;
	}
});

Importer.marker = Object.extend(new Importer(), {
    addMapping: Functions.Empty,
    lookup: Functions.Null
});



// ===========================================================================
// Morph functionality
// ===========================================================================

Object.subclass('MouseHandlerForDragging', {

	handleMouseEvent: function(evt, targetMorph) {
		if (evt.type == "MouseDown") evt.hand.setMouseFocus(targetMorph);
		evt.hand.resetMouseFocusChanges();

		var handler = targetMorph[evt.handlerName()];
		if (handler) handler.call(targetMorph, evt, targetMorph);

		if (evt.type == "MouseUp") {
			// cancel focus unless it was set in the handler
			if (evt.hand.resetMouseFocusChanges() == 0) {
				evt.hand.setMouseFocus(null);
			}
		}
		return true; 
	},

    handlesMouseDown: Functions.False
});

Object.subclass('MouseHandlerForRelay', {

	initialize: function (target, eventSpec) {
		//  Send events to a different target, with different methods
		//    Ex: box.relayMouseEvents(box.owner, {onMouseUp: "boxReleased", onMouseDown: "boxPressed"})
		this.target = target;
		this.eventSpec = eventSpec || {onMouseDown: "onMouseDown", onMouseMove: "onMouseMove", onMouseUp: "onMouseUp"};
	},

	handleMouseEvent: function(evt, originalTarget) {
		if (evt.type == "MouseDown") evt.hand.setMouseFocus(originalTarget);
		evt.hand.resetMouseFocusChanges();

		var handler = this.target[this.eventSpec[evt.handlerName()]];
		if (handler) handler.call(this.target, evt, originalTarget);

		if (evt.type == "MouseUp") {
			// cancel focus unless it was set in the handler
			if (evt.hand.resetMouseFocusChanges() == 0) {
				evt.hand.setMouseFocus(null);
			}
		}
		return true; 
	},

    handlesMouseDown: Functions.True

});

// aaa - Added by Adam, not sure what I'm doing, just want a XenoMorph with clickable HTML links.
Object.subclass('MouseHandlerForDoingTheDefaultThing', {

	handleMouseEvent: function(evt, targetMorph) {
	  return false;
	},

    handlesMouseDown: Functions.True
});


lively.data.Wrapper.subclass('Morph', {

    documentation: "Base class for every graphical, manipulatable object in the system", 

	doNotSerialize: ['fullBounds'],

    // prototype vars
	name: '',
    rotation: 0.0,
    scalePoint: pt(1,1),

    style: {},

    focusHaloBorderWidth: 4,

    fishEye: false,        // defines if fisheye effect is used
    fisheyeScale: 1.0,     // set the default scaling to 1.0
    fisheyeGrowth: 1.0,    // up to fisheyeGrowth size bigger (1.0 = double size)
    fisheyeProximity: 0.5, // where to react wrt/ size (how close we need to be)

    keyboardHandler: null, //a KeyboardHandler for keyboard repsonse, etc
    layoutHandler: null, //a LayoutHandler for special response to setExtent, etc
    openForDragAndDrop: true, // Submorphs can be extracted from or dropped into me
    mouseHandler: MouseHandlerForDragging.prototype, //a MouseHandler for mouse sensitivity, etc
    noShallowCopyProperties: ['id', 'rawNode', 'shape', 'submorphs', 'defs', 'activeScripts', 'nextNavigableSibling', 'focusHalo', 'fullBounds', '__annotation__', '_poseManager'], // __annotation__ and _poseManager added by Adam
    isEpimorph: false, // temporary additional morph that goes away quickly, not included in bounds

    suppressBalloonHelp: Config.suppressBalloonHelp,

    nextNavigableSibling: null, // keyboard navigation

	internalInitialize: function(rawNode, shouldAssign) {
		this.rawNode = rawNode;
		this.submorphs = [];
		
    if (!avocado.shouldBreakCreatorSlotsInOrderToImprovePerformance) {
  		reflect(this).slotAt('rawNode'  ).beCreator(); // aaa - kind of a hack, added by Adam so that we can file out morphs
  		reflect(this).slotAt('submorphs').beCreator(); // aaa - kind of a hack, added by Adam so that we can file out morphs
    }
    
		this.owner = null;
		if (shouldAssign) {
			LivelyNS.setType(this.rawNode, this.getType());
			this.setId(this.newId());
		}
	},

	createRawNode: function() { return NodeFactory.create("g") },
	
    initialize: function(shape) {
		//console.log('initializing morph %s %s', initialBounds, shapeType);
		this.internalInitialize(this.createRawNode(), true);
		dbgOn(!shape.bounds);
		// we must make sure the Morph keeps its original size (wrt/fisheyeScale)
		if (this.fisheyeScale != 1) this.scalePoint = this.scalePoint.scaleBy(1 / this.fisheyeScale);
		this.origin = shape.origin();
		shape.translateBy(this.origin.negated());
		this.initializePersistentState(shape);
		this.initializeTransientState();
    },

	shallowCopy: function () {
		// Return a copy of this morph with no submorphs, but 
		//  with the same shape and shape attributes as this
		return new Morph(this.shape.copy()); 
	},

	duplicate: function () { 
		// Return a full copy of this morph and its submorphs, with owner == null
		var copy = this.copy(new Copier());
		copy.owner = null;
		return copy;
	},

	initializePersistentState: function(shape) {
		// a rect shape by default, will change later
		this.shape = shape;
		
		// aaa - kind of a hack, added by Adam so that we can file out morphs
		if (Global.reflect) {
		  var mir = reflect(this);
		  mir.slotAt('shape').beCreator();
		  mir.slotAt('fullBounds').setInitializationExpression('null');
		  mir.slotAt('pvtCachedTransform').setInitializationExpression('null');
		}
		
		this.rawNode.appendChild(this.shape.rawNode);
		if (this.styleClass) { // inherited from prototype
			var attr = this.styleClass.join(' ');
			this.rawNode.setAttribute("class", attr);
			// Safari needs the explicit assignment (perhaps the names have to be real stylesheets).
			this.rawNode.className.baseVal = attr;
		}
		this.applyStyle(this.style);
		return this;
	},

    // setup various things 
	initializeTransientState: function() { 
		this.fullBounds = null; // a Rectangle in owner coordinates
		// this includes the shape as well as any submorphs
		// cached here and lazily computed by bounds(); invalidated by layoutChanged()

		// this.created = false; // exists on server now
		// some of this stuff may become persistent
	},
    
	copySubmorphsFrom: function(copier, other) {
			
		// console.log("copy submorphs from " + other);
		if (other.hasSubmorphs()) { // deep copy of submorphs
			other.submorphs.forEach(function each(m) {
				if (m.isEpimorph || m.ignoreWhenCopying) {
					// console.log("ignore " + m)
					return; // ignore temp morphs
				};
				var copy = m.copy(copier);
				copier.addMapping(m.id(), copy);
				copy.owner = null;	// Makes correct transfer of transform in next addMorph
				this.addMorph(copy);
				if (copy.owner !== this)
					console.log("ERROR could not add: " + copy + " to " + this)
			}, this);
		};
	},
	
	copyAttributesFrom: function(copier, other) {
		for (var p in other) {
			if (/* Why exclude functions? -- Adam  other[p] instanceof Function || */ !other.hasOwnProperty(p) || this.noShallowCopyProperties.include(p))
				continue;

			if (other[p] instanceof Morph) {
				var replacement = (p === "owner") ? null : copier.lookup(other[p].id());
				if (replacement !== this[p] && this.submorphs.include(this[p])) {
					// when the morph is replaced from the attribute it probably should also removed from the submorphs
					// this should fix the problem with node creation in initializePersistentState
					this.removeMorph(this[p]);					
				}
				this[p] = replacement || other[p];
				// if(replacement)
				//	console.log("found no replacement for: " + other[p].id());
				// console.log("replace '"+ p +"' with morph: " + this[p].id())
				// an instance field points to a submorph, so copy
				// should point to a copy of the submorph
				continue;
			}

			if (other[p] instanceof lively.scene.Image) {
				this[p] = other[p].copy(copier);
				this.addWrapper(this[p]);
				continue
			}

			// TODO: move logic to bindings.js
			if (p == 'attributeConnections') {
				other[p].forEach(function(con) {
					if (!con.getTargetObj().id)
						throw new Error('tried to copy binding and target obj has no id!');
					var spec = {};
					if (con.converter) spec.converter = con.converter.toString();
					if (con.removeAfterUpdate) spec.removeAfterUpdate = con.removeAfterUpdate;
							
					connect(
						this,
						con.getSourceAttrName(),
						copier.lookup(con.getTargetObj().id()) || con.getTargetObj(),
						con.getTargetMethodName(),
						spec)
				}, this)
				continue;
			}

			if (!(other[p] instanceof lively.paint.Gradient)) {
				this[p] = other[p];
			}
			
			// aaa - hack to copy the _model and other sub-objects properly; in the long run, this whole
			// copying mechanism should be using deepCopyRecursingIntoCreatorSlots -- Adam
		  var otherSlot = reflect(other).slotAt(p);
		  if (otherSlot.equals(otherSlot.contents().probableCreatorSlot())) {
			  this[p] = avocado.deepCopier.create().recordOriginalAndCopy(other, this).copy(other[p]);
			}
			
		  // set the creator slot if necessary -- Adam
		  var creatorSlot = reflect(other[p]).theCreatorSlot();
		  if (creatorSlot && creatorSlot.name() === p && creatorSlot.holder().reflectee() === other) {
		    reflect(this).slotAt(p).beCreator();
			}

		} // shallow copy by default, note that arrays of Morphs are not handled
	},

	copyActiveScriptsFrom: function(copier, other) {
		if (other.activeScripts != null) { 
			for (var i = 0; i < other.activeScripts.length; i++) {
				var a = other.activeScripts[i];
				// Copy all reflexive scripts (messages to self)
				if (a.actor === other) {
					this.startStepping(a.stepTime, a.scriptName, a.argIfAny);
					// Note -- may want to startStepping other as well so they are sync'd
				}
			}
		}
	},

	copyModelFrom: function(copier, other) {
		// try to be clever with Relays
		if(other.formalModel && (this.formalModel.delegate instanceof Record)) {
			var replaceModel = copier.lookup(other.getModel().id());
			if (replaceModel) {
					this.connectModel(replaceModel.newRelay(this.formalModel.definition));
			}
		};

    // hack to make ButtonMorphs duplicatable; I think the right fix is to implement a deepCopy that uses creator slots -- Adam
		if (other.modelPlug && other.modelPlug.model.morph === other) {
			this.modelPlug = Object.shallowCopy(other.modelPlug);
			this.modelPlug.model = Object.shallowCopy(other.modelPlug.model);
			this.modelPlug.model.morph = this;
			reflect(this).slotAt('modelPlug').beCreator();
			reflect(this.modelPlug).slotAt('model').beCreator();
    }
    
    // same hack for TextMorphs and others that just have 'model' point right at the morph -- Adam
		if (other.modelPlug && other.modelPlug.model === other) {
			this.modelPlug = Object.shallowCopy(other.modelPlug);
			this.modelPlug.model = this;
			reflect(this).slotAt('modelPlug').beCreator();
	  }
	},

	copyFrom: function(copier, other) {
		this.internalInitialize(other.rawNode.cloneNode(false), true);
		copier.addMapping(other.id(), this);
		
		this.pvtSetTransform(this.getTransform());
		
		// creates new childNodes of rawNode, that may not be wanted
		this.initializePersistentState(other.shape.copy(copier));

		this.copySubmorphsFrom(copier, other);
		this.copyAttributesFrom(copier, other);
		this.copyModelFrom(copier, other);

		this.internalSetShape(other.shape.copy());
		this.origin = other.origin.copy();

		if (other.pvtCachedTransform) { 
			this.pvtCachedTransform = other.pvtCachedTransform.copy();
		} 
		
		this.initializeTransientState();
		this.copyActiveScriptsFrom(copier, other)
		
		// added by Adam to keep the world's _morphsByObject dictionary up-to-date
		if (other._model !== null && typeof(other._model) !== 'undefined') {
		  var world = this.world() || WorldMorph.current();
		  if (world.existingMorphFor(other._model) === other) {
  		  world.rememberMorphFor(this._model, this);
		  }
		}

		this.layoutChanged();
		return this; 
	},

	deserialize: function($super, importer, rawNode) {
		// FIXME what if id is not unique?
		$super(importer, rawNode);
	
		this.internalInitialize(rawNode, false);
		this.pvtSetTransform(this.getTransform());

		this.restoreFromSubnodes(importer);
		this.restorePersistentState(importer);    

		if (!this.shape) { 
			console.log("Error in Morph.deserialize(): I have no shape! Fall back to Rectangle!");
			var shape = new lively.scene.Rectangle(new Rectangle(0, 0, 100, 100));
			this.initializePersistentState(shape);
			this.applyStyle({fill: Color.red});
		};

		this.initializeTransientState();
		importer.verbose && console.log("deserialized " + this);
	},

	prepareForSerialization: function($super, extraNodes, optSystemDictionary) {	
		// this is the morph to serialize
		var fill = this.getFill();
		if (optSystemDictionary && fill instanceof lively.paint.Gradient) {
			var rawPropNode = optSystemDictionary.ownerDocument.getElementById(fill.id());
			if (rawPropNode) {
				// do nothing				
			} else {
				optSystemDictionary.appendChild(fill.rawNode.cloneNode(true));
			};
		};
		
		
		if (Config.useTransformAPI) {
			// gotta set it explicitly, it's not in SVG
			this.setTrait("transform", this.getTransform().toAttributeValue());
			// FIXME, remove?
		}
		return $super(extraNodes, optSystemDictionary);
	},
    
	restorePersistentState: function(importer) {
		var pointerEvents = this.getTrait("pointer-events");
		if (pointerEvents == "none") {
			this.ignoreEvents();
		} else if (pointerEvents) {
			console.log("can't handle pointer-events " + pointerEvents);
		}
		return; // override in subclasses
	},

	restoreFromSubnode: function(importer, node) {
		// Override me
	},

	restoreFromDefsNode: function(importer, node) {
	    // the only one handled here "code"
		var codeNodes = [];
    	if (!Config.skipChanges) { // Can be blocked by URL param 
        	var codes = node.getElementsByTagName("code");
        	for (var j = 0; j < codes.length; j++) { codeNodes.push(codes.item(j)) };
			if (codeNodes.length > 1) console.warn('More than one code node');
			// ChangeSet of World gets evaluated in main
    	}
	},

    restoreFromSubnodes: function(importer) {
        //  wade through the children
        var children = [];
        var helperNodes = [];
        
        for (var desc = this.rawNode.firstChild; desc != null; desc = desc.nextSibling) {
            if (desc.nodeType == Node.TEXT_NODE || desc.nodeType == Node.COMMENT_NODE) {
                if (desc.textContent == "\n") 
                    helperNodes.push(desc); // remove newlines, which will be reinserted for formatting
                continue; // ignore whitespace and maybe other things
            }
            var type = lively.data.Wrapper.getEncodedType(desc);
            // depth first traversal

			// WebCards...
		 	// if (type && !type.startsWith("anonymous_")) { //I have no idea what that mean

            if (type) {
                var wrapper = importer.importWrapperFromNode(desc);
                if (wrapper instanceof Morph) {
                    this.submorphs.push(wrapper); 
                    wrapper.owner = this;
                } else children.push(desc);
            } else {
                children.push(desc);
            }
        }

        for (var i = 0; i < children.length; i++) {
            var node = children[i];
            var shape = lively.scene.Shape.importFromNode(importer, node);
            if (shape) {
                this.shape = shape;
                continue;
            }
            switch (node.localName) {
                // nodes from the Lively namespace
            case "field": {
                // console.log("found field " + Exporter.stringify(node));
                helperNodes.push(node);
                this.deserializeFieldFromNode(importer, node);          
                break;
            }
            case "widget": {
                this.deserializeWidgetFromNode(importer, node);
                break;
            }
            case "array": {
                helperNodes.push(node);
                this.deserializeArrayFromNode(importer, node);
                break;
            }
            case "relay": {
                this.deserializeRelayFromNode(importer, node);
                break;
            }
            case "record": {
                this.deserializeRecordFromNode(importer, node);
                break;
            }
            case "defs": { 
				this.restoreFromDefsNode(importer, node);
                break;
            }
            default: {
                if (node.nodeType === Node.TEXT_NODE) {
                    console.log('text tag name %s', node.tagName);
                    // whitespace, ignore
                } else if (!this.restoreFromSubnode(importer, node)) {
                    console.warn('not handling %s, %s', node.tagName || node.nodeType, node.textContent);
                }
            }
            }
        } // end for

        for (var i = 0; i < helperNodes.length; i++) {
            var n = helperNodes[i];
            n.parentNode.removeChild(n);
        }
    },

	resolveUriToObject: function(uri) {
		if (this.id() == uri)
			return this;
		if (this.ownerWidget) {
			var result = this.ownerWidget.resolveUriToObject(uri)
			if (result)
				return result;
		};	
		for (var i=0; i < this.submorphs.length; i++) {
			var result = this.submorphs[i].resolveUriToObject(uri);
			if (result)
				return result;
		}
		return null
	},
	
	getName: function() { return this.name },
	setName: function(str) { this.name = str },
});

Morph.addMethods({	// tmp copy

	getStyleClass: function() {
		return this.styleClass || [];
	},

	setStyleClass: function(value) {
		var attr;
		if (value instanceof Array) {
			this.styleClass = value;
			attr = value.join(' ');
		} else {
			this.styleClass = [value];
			attr = String(value);
		}
		this.rawNode.setAttribute("class", attr);
	},

	canvas: function() {
		if (!UserAgent.usableOwnerSVGElement) {
			// so much for multiple worlds on one page
			return Global.document.getElementById("canvas");
		} else {
			return (this.rawNode && this.rawNode.ownerSVGElement) || Global.document.getElementById("canvas");
		}
	},

	setVisible: function(flag) { // FIXME delegate to sceneNode when conversion finished
		if (flag) this.rawNode.removeAttributeNS(null, "display");
		else this.rawNode.setAttributeNS(null, "display", "none");
		return this;
	},

	isVisible: function() { // FIXME delegate to sceneNode when conversion finished
		// Note: this may not be correct in general in SVG due to inheritance,
		// but should work in LIVELY.
		var hidden = this.rawNode.getAttributeNS(null, "display") == "none";
		return hidden == false;
	},

	applyFilter: function(filterUri) {// FIXME delegate to sceneNode when conversion finished
		if (filterUri) 
			this.rawNode.setAttributeNS(null, "filter", filterUri);
		else
		this.rawNode.removeAttributeNS(null, "filter");
	}
});

Morph.addMethods({  

    getOwnerWidget: function() {
		if(this.ownerWidget) {
			return this.ownerWidget
		};
		if (this.owner) {
			return this.owner.getOwnerWidget();
		}
		return undefined;
	}
});

// Functions for change management
Object.extend(Morph, {
    
	onLayoutChange: function(fieldName) { 
		return function layoutChangeAdvice(/* arguments*/) {
			var priorExtent = this.innerBounds().extent();
			this.changed();
			var args = $A(arguments);
			var proceed = args.shift();
			var result = proceed.apply(this, args);
			this.layoutChanged(priorExtent);
			this.changed(); 
			return result;
		}
	},

	fromLiteral: function(literal) {
		var morph = new Morph(literal.shape);
		if (literal.submorphs) {
			if (Object.isArray(literal.submorphs))
				morph.setSubmorphs(literal.submorphs);
			else throw new TypeError();
		}
		if (literal.transforms) {
			morph.setTransforms(literal.transforms);
		}
		return morph;
	}

});


// Extend Polylines and polygons to curves
Morph.addMethods({
	makeCurve: function() {
		//  Convert a polyline to a curve;  maybe a polygon to a blob  
		var verts = this.shape.vertices();
		var isClosed = this.shape instanceof lively.scene.Polygon;
		// Need closing vertext for closed curves
		if (verts.length < 2) return;
		if (isClosed && (!verts[0].eqPt(verts.last()))) verts = verts.concat([verts[0]])
		var current = verts[0];
		var ctrl = current;
		var controlPts = [];
		controlPts.push(ctrl);
		for (var i=1; i<verts.length; i++) {  // compute default control points
			ctrl = current.subPt(ctrl).addPt(current);
			controlPts.push(ctrl);
			current = verts[i];
		}
		// Fix first control point if we have 3 or more verts
		if (verts.length <= 3) controlPts[1] = verts[1].subPt(verts[2]).addPt(verts[1]);
		var morph = Morph.makeCurve(verts, controlPts, isClosed)
		this.world().addMorph(morph);
		morph.setPosition(this.position());
}
});

// Fill Garbage Collection on Serialization...
Morph.addMethods({
	collectAllUsedFills: function($super, result) {
		result = $super(result);
		var fill = this.getFill();
		if (fill instanceof lively.paint.Gradient)
			result.push(fill);
		if (this.submorphs) {
			this.submorphs.each(function(ea) {
				ea.collectAllUsedFills(result)
			}, this);
		}
		// do nothing
		return result
	}
});

// Functions for manipulating the visual attributes of Morphs
Morph.addMethods({

	setFill: function(fill) {
		this.shape.setFill(fill);
		this.changed();
		return this; // added by Adam
	},

  // added by Adam
	setFillBase: function(fillBase) {
	  return this.setFill(fillBase ? avocado.ui.defaultFillWithColor(fillBase) : null);
	},

	getFill: function() {
		return this.shape.getFill();
	},

	setBorderColor: function(newColor) {
		this.shape.setStroke(newColor);
		// this.changed();
	},

	getBorderColor: function() {
		return new Color(Importer.marker, this.shape.getStroke());
	},

	setBorderWidth: function(newWidth) {
		if (newWidth == null) newWidth = 0;
		var oldWidth = this.getBorderWidth();
		if (newWidth == oldWidth) return;

		// Opt: only notify change with the bigger of two bounds
		if (oldWidth > newWidth) this.changed();
		this.shape.setStrokeWidth(newWidth); 
		if (newWidth > oldWidth) this.changed();
	},

	getBorderWidth: function() {
		return this.shape.getStrokeWidth() || 0; // FIXME: fix defaults logic
	},

 	setBorderRadius: function(r) {//jd
    	this.shape.roundEdgesBy(r);
		this.changed();
    },

 	getBorderRadius: function() {
		return this.shape.getBorderRadius(); 
	},

	shapeRoundEdgesBy: function(r) {
		this.setBorderRadius(r);
	},

	getFillOpacity: function() { return this.shape.getFillOpacity(); }, // bug fix: didn't say "return" -- Adam

    setFillOpacity: function(op) {
	this.shape.setFillOpacity(op);
	this.changed(); // FIXME better use specific update
	return this; // added by Adam
},

    setStrokeOpacity: function(op) { 
	this.shape.setStrokeOpacity(op);
	this.changed(); // FIXME better use specific update
},

	getStrokeOpacity: function() { this.shape.getStrokeOpacity(); },

    setLineJoin: function(joinType) { this.shape.setLineJoin(joinType); },

	getLineJoin: function() { this.shape.getLineJoin(); }, 

    setLineCap: function(capType) { this.shape.setLineCap(capType); },

 	getLineCap: function() { this.shape.getLineCap(); },

	applyStyle: function(specs) { // note: use reflection instead?
		for (var i = 0; i < arguments.length; i++) {
			var spec = arguments[i];
			if(!spec) return;  // dbgOn(!spec);
			if (spec.borderWidth !== undefined) this.setBorderWidth(spec.borderWidth);
			if (spec.borderColor !== undefined) this.setBorderColor(spec.borderColor);
			if (spec.fill !== undefined) this.setFill(spec.fill);
			if (spec.opacity !== undefined) {
				this.setFillOpacity(spec.opacity);
				this.setStrokeOpacity(spec.opacity); 
			}
			if (spec.fillOpacity !== undefined) this.setFillOpacity(spec.fillOpacity);
			if (spec.strokeOpacity !== undefined) this.setStrokeOpacity(spec.strokeOpacity);

			if (this.shape.roundEdgesBy && spec.borderRadius !== undefined) { 
				this.shape.roundEdgesBy(spec.borderRadius);
			}
			if (spec.suppressGrabbing !== undefined) this.suppressGrabbing = spec.suppressGrabbing;
			if (spec.suppressHandles !== undefined) this.suppressHandles = spec.suppressHandles;
			
			// All this stuff added by Adam
			if (spec.openForDragAndDrop !== undefined) this.openForDragAndDrop = spec.openForDragAndDrop;
			if (spec.grabsShouldFallThrough !== undefined) this.grabsShouldFallThrough = spec.grabsShouldFallThrough;
			if (spec.horizontalLayoutMode !== undefined) this.horizontalLayoutMode = spec.horizontalLayoutMode;
			if (spec.verticalLayoutMode !== undefined) this.verticalLayoutMode = spec.verticalLayoutMode;
			if (spec.fillBase !== undefined) this.setFillBase(spec.fillBase);
			if (spec.shouldIgnoreEvents) this.ignoreEvents();
			if (spec.shouldIgnoreAllExceptDefaultEvents) this.ignoreAllExceptDefaultEvents();
			
			// This stuff added by Adam too.
			if (this._layout  && this._layout .adjustStyleSpec) { this._layout .applyStyle(spec); }
			if (this._stylist && this._stylist.adjustStyleSpec) { this._stylist.applyStyle(this, spec); }
		}
		return this;
	},

	makeStyleSpec: function() {
		// Adjust all visual attributes specified in the style spec
		var spec = { };
		spec.borderWidth = this.getBorderWidth();
		spec.borderColor = this.getBorderColor();
		spec.fill = this.getFill();
		if (this.shape.getBorderRadius) spec.borderRadius = this.shape.getBorderRadius() || 0.0;
		spec.fillOpacity = typeof this.shape.getFillOpacity() !== undefined ? this.shape.getFillOpacity() : 1.0;
		spec.strokeOpacity = typeof this.shape.getStrokeOpacity() !== undefined ?  this.shape.getStrokeOpacity() : 1.0;		

		// All this stuff added by Adam
		spec.openForDragAndDrop = this.openForDragAndDrop;
		spec.grabsShouldFallThrough = this.grabsShouldFallThrough;
		spec.horizontalLayoutMode = this.horizontalLayoutMode;
		spec.verticalLayoutMode = this.verticalLayoutMode;
		spec.shouldIgnoreEvents = !this.mouseHandler;

    // added by Adam
		if (this._layout  && this._layout .adjustStyleSpec) { this._layout.adjustStyleSpec(spec);  }
		if (this._stylist && this._stylist.adjustStyleSpec) { this._stylist.adjustStyleSpec(this, spec); }
		
		return spec;
	},

	applyStyleNamed: function(name) {
		var style = this.styleNamed(name);
		if (style)
			this.applyStyle(style);
		else
			console.warn("applyStyleNamed: no style named " + name)
	},

	styleNamed: function(name) {
		// Look the name up in the Morph tree, else in current world
		if (this.displayTheme) return this.displayTheme[name];
		if (this.owner) return this.owner.styleNamed(name);
		var world = WorldMorph.current();
		if (world && (this !== world)) return world.styleNamed(name);
		return DisplayThemes.lively[name]; // FIXME for onDeserialize, when no world exists yet
	},

	linkToStyles: function(styleClassList, optSupressApplication) {
		// Record the links for later updates, and apply them now
		this.setStyleClass(styleClassList);
		if (!optSupressApplication) this.applyLinkedStyles();
		return this;
	},

	applyLinkedStyles: function() {
		// Apply all the styles to which I am linked, in order
		var styleClasses = this.getStyleClass();
		if (!styleClasses) return;
		for (var i = 0; i < styleClasses.length; i++) {
			this.applyStyleNamed(styleClasses[i]); 
		}
	},

	// NOTE:  The following four methods should all be factored into a single bit of reshaping logic
	applyFunctionToShape: function() {  // my kingdom for a Smalltalk block!
		var args = $A(arguments);
		var func = args.shift();
		func.apply(this.shape, args);
		this.adjustForNewBounds();
	}.wrap(Morph.onLayoutChange('shape')),

	internalSetShape: function(newShape) {
		if (!newShape.rawNode) {
			console.log('newShape is ' + newShape);
			lively.lang.Execution.showStack();
		}

		this.rawNode.replaceChild(newShape.rawNode, this.shape.rawNode);
		this.shape = newShape;
		reflect(this).slotAt('shape').beCreator(); // aaa - kind of a hack, added by Adam so that we can file out morphs
		this.adjustForNewBounds();
	},

	setShape: function(newShape) {
		this.internalSetShape(newShape);
	}.wrap(Morph.onLayoutChange('shape')),

	reshape: function(partName, newPoint, lastCall) {
		try {
			var result = this.shape.reshape(partName,newPoint,lastCall); 
			
			// added by Adam
      this.horizontalLayoutMode = this.verticalLayoutMode = avocado.LayoutModes.Rigid;
      this.minimumExtentMayHaveChanged();
      
			return result;
		} finally {
			// FIXME: consider converting polyline to polygon when vertices merge.
			this.adjustForNewBounds();
		}
	}.wrap(Morph.onLayoutChange('shape')),

	setVertices: function(newVerts) {
		// particular to polygons
		this.shape.setVertices(newVerts);
		this.adjustForNewBounds();
	}.wrap(Morph.onLayoutChange('shape')),

});

Object.subclass('LayoutManager', {

    setBounds: function(target, newRect) {
		// DI: Note get/setBounds should be deprecated in favor of get/setExtent and get/setPosition
		// This is so that layout management can move things around without triggering redundant or
		// recursive calls on adjustForNewBounds(q.v.)

		// All calls on morph.setBounds should be converted to two calls as above (or just one if,
		// eg, only the extent or position is changing).

		// Of course setBounds remains entirely valid as a message to the *shape* object and, 
		// in fact, shape.setBounds() will have to be called from both setPosition and setExtent
		// but adjustForNewBounds will only need to be called from setExtent.

		// Finally, there is an argument for calling layoutChanged from setPosition and setExtent,
		// since the caller must do it otherwise.  This would simplify things overall.

		// DI:  Note that there is an inconsistency here, in that we are reading and comparing
		// the full bounds, yet if we set extent, it only affects the shape (ie, innerBounds)
	
		var priorBounds = target.bounds();

		if (!newRect.topLeft().eqPt(priorBounds.topLeft())) {  // Only set position if it changes
		    target.setPosition(newRect.topLeft());
		}
		if (!newRect.extent().eqPt(priorBounds.extent())) {  // Only set extent if it changes
		    // FIXME some shapes don't support setFromRect
		    target.shape.setBounds(newRect.extent().extentAsRectangle());
	 	    target.adjustForNewBounds();
		}
    },

	setExtent: function(target, newExtent) {
		target.setBounds(target.getPosition().extent(newExtent));
	},

	setPosition: function(target, newPosition) {
		if (!newPosition)
			return;
		var delta = newPosition.subPt(target.getPosition());
		target.translateBy(delta);
		return delta;
	},

	// Hack by Adam to allow avoiding creating new Points. -- Adam
	setPositionXY: function(target, newX, newY) {
		var oldPosition = target.getPosition();
		target.translateByXY(newX - oldPosition.x, newY - oldPosition.y);
	},

    layoutChanged: function(target) {
	
    },

    beforeAddMorph: function(supermorph, submorph, isFront) {  // isFront -> general spec of location?
    },

    removeMorph: function(supermorph, submorph) {
		// new behavior:
		supermorph.layoutChanged();
    },

	layout: function(supermorph) {
		// subclass responsibility
	},

	leftMarginOf: function(morph) {
		return morph.margin ? morph.margin.left() : 0;
	},

	rightMarginOf: function(morph) {
		return morph.margin ? morph.margin.right() : 0;
	},

	topMarginOf: function(morph) {
		return morph.margin ? morph.margin.top() : 0;
	},

	bottomMarginOf: function(morph) {
		return morph.margin ? morph.margin.bottom() : 0;
	},

    rightPaddingOf: function(morph) {
		return morph.padding ? morph.padding.right() : 0;
    },

	leftPaddingOf: function(morph) {
		return morph.padding ? morph.padding.left() : 0;
	},

	topPaddingOf: function(morph) {
		return morph.padding ? morph.padding.top() : 0;
	},

	bottomPaddingOf: function(morph) {
		return morph.padding ? morph.padding.bottom() : 0;
	}
    
});

LayoutManager.subclass('HorizontalLayout',  { // alignment more than anything

	beforeAddMorph: function(supermorph, submorph, isFront) {
		if (submorph.isEpimorph) return;

		// runs before submorph is added
		var dx = this.leftMarginOf(submorph);
		var dy;
		var last = supermorph.topSubmorph();

		if (!last) {
			dx += this.leftPaddingOf(supermorph);
			dy =  this.topPaddingOf(supermorph);
			submorph.align(submorph.bounds().topLeft(), pt(dx, dy));
		} else {
			dx += this.rightMarginOf(last);
			dy = 0;
			submorph.align(submorph.bounds().topLeft(), last.bounds().topRight());
			submorph.translateBy(pt(dx, dy));
		}
	},
	
	layout: function(supermorph) {
		var x = this.leftPaddingOf(supermorph);
		var y =  this.topPaddingOf(supermorph);
		var submorphs = supermorph.visibleSubmorphs();
		for(var i=0; i < submorphs.length; i++) {
			var submorph = submorphs[i];
			x += this.leftMarginOf(submorph)
			submorph.align(submorph.bounds().topLeft(), pt(x, y));
			x += submorph.bounds().width;
			x += this.rightMarginOf(submorph);
		}
	},
});


LayoutManager.subclass('VerticalLayout',  { // alignment more than anything

	beforeAddMorph: function(supermorph, submorph, isFront) {
		if (submorph.isEpimorph) return;
		// runs before submorph is added
		var dx;
		var dy = this.topMarginOf(submorph);
		var last = supermorph.topSubmorph();

		if (!last) {
			dx = this.leftPaddingOf(supermorph);
			dy += this.topPaddingOf(supermorph);
			submorph.align(submorph.bounds().topLeft(), pt(dx, dy));
		} else {
			dx = 0;
			dy += this.bottomMarginOf(last);
			submorph.align(submorph.bounds().topLeft(), last.bounds().bottomLeft());
			//submorph.translateBy(pt(dx, dy));
		}
	},

	layout: function(supermorph) {
		var x = this.leftPaddingOf(supermorph);
		var y =  this.topPaddingOf(supermorph);
		var submorphs = supermorph.visibleSubmorphs();
		for(var i=0; i < submorphs.length; i++) {
			var submorph = submorphs[i];
			y += this.topMarginOf(submorph)
			submorph.align(submorph.bounds().topLeft(), pt(x, y));
			y += submorph.bounds().height;
			y += this.bottomMarginOf(submorph);
		}
	},

});

Morph.addMethods({
    
	layoutManager: new LayoutManager(), // singleton

	// Simple hack until the layout manager can relayout
	relayout: function() {
		if (this.layoutManager) {
			this.layoutManager.layout(this)
		}	
	},

	setBounds: function(newRect) {
		if (!newRect) return;
		this.layoutManager.setBounds(this, newRect);
	}.wrap(Morph.onLayoutChange('shape')),

	setExtent: function(newExtent) {
		this.layoutManager.setExtent(this, newExtent);
		return this; // added by Adam;
	},

	getExtent: function(newRect) { return this.shape.bounds().extent() },

	containsPoint: function(p) { 
		// p is in owner coordinates
		if (!this.bounds().containsPoint(p)) return false;
		return this.shape.containsPoint(this.relativize(p)); 
	},

	containsWorldPoint: function(p) { // p is in world coordinates
		if (this.owner == null) return this.containsPoint(p);
		return this.containsPoint(this.ownerLocalize(p)); 
	},

	fullContainsPoint: function(p) { // p is in owner coordinates
		return this.bounds().containsPoint(p); 
	},

	fullContainsWorldPoint: function(p) { // p is in world coordinates
		// Changed all uses of owner.localize to ownerLocalize. -- Adam
		// Commented out the following line because ownerLocalize works fine now for WorldMorphs. -- Adam
		// if (this.owner == null) return this.fullContainsPoint(p);
		return this.fullContainsPoint(this.ownerLocalize(p)); 
	},

	addNonMorph: function(node) {
		if (node instanceof lively.data.Wrapper) throw new Error("add rawNode, not the wrapper itself");
		return this.rawNode.insertBefore(node, this.shape && this.shape.rawNode.nextSibling);
	},

	addWrapper: function(w) {
		if (w && w.rawNode) {
			this.addNonMorph(w.rawNode);
			return w;
		} else return null;
	},

	addPseudoMorph: function(pseudomorph) {
		if (pseudomorph instanceof Global.PseudoMorph) {
			return this.addMorph(pseudomorph);
		} else 
			throw new Error(pseudomorph + " is not a PseudoMorph");
	},

});

// Submorph management functions
Morph.addMethods({ 

    addMorph: function(morph, shouldNotForceLayoutRejiggering) { return this.addMorphFrontOrBack(morph, true, shouldNotForceLayoutRejiggering) }, // shouldNotForceLayoutRejiggering added by Adam

	addMorphAt: function(morph, position) {
		var morph = this.addMorphFrontOrBack(morph, true);
		morph.setPosition(position);
		return morph;
	},

    addMorphFront: function(morph) { return this.addMorphFrontOrBack(morph, true) },

    addMorphBack: function(morph) { return this.addMorphFrontOrBack(morph, false) },

	addMorphFrontOrBack: function(m, isFront, shouldNotForceLayoutRejiggering) { // shouldNotForceLayoutRejiggering added by Adam
		console.assert(m instanceof Morph, "not an instance");
		if (m.owner) {
			var tfm = m.transformForNewOwner(this);
			m.owner.removeMorph(m); // KP: note not m.remove(), we don't want to stop stepping behavior
			m.setTransform(tfm); 
			// FIXME transform is out of date
			// morph.setTransform(tfm); 
			// m.layoutChanged(); 
		} 
		this.layoutManager.beforeAddMorph(this, m, isFront);
		this.insertMorph(m, isFront);
		m.changed();
		m.layoutChanged();
		this.layoutChanged();
    if (!shouldNotForceLayoutRejiggering) { this.forceLayoutRejiggeringIfNecessaryAfter('addMorph', m); } // added by Adam
		return m;
	},
	
	bringToFront: function() {
		if (!this.owner)
			return;
		if (this.owner.topSubmorph() === this)
			return;
		var owner = this.owner;
		this.remove();
		owner.addMorphFront(this)
	},

	setSubmorphs: function(morphs) {
		console.assert(morphs instanceof Array, "not an array");
		if (morphs != null) {
			this.submorphs = [].concat(morphs);
			reflect(this).slotAt('submorphs').beCreator(); // aaa - kind of a hack, added by Adam so that we can file out morphs
			this.submorphs.forEach(function (m) { 
				if (m.owner) {
					var tfm = m.transformForNewOwner(this);
					m.owner.removeMorph(m);
					m.setTransform(tfm); 
				} 
				this.rawNode.appendChild(m.rawNode); 
				m.owner = this;
				m.changed();
				m.layoutChanged();
			}, this);
		}
		this.layoutChanged();
	},

    indexOfSubmorph: function(m) {
		if (this.submorphs.length == 0) return -1;  // no submorphs at all
		for (var i=0; i<this.submorphs.length; i++) 
			if (this.submorphs[i] === m) return i;
    	return -1;  // not there
	},

	getInsertPositionFor: function(m, isFront) {
		if (this.submorphs.length == 0) return null; // if no submorphs, append to nodes
		return isFront ? this.submorphs.last().rawNode.nextSibling : this.submorphs.first().rawNode;
	},
	
	insertMorph: function(m, isFront) { // low level, more like Node.insertBefore?
		var insertionPt = this.getInsertPositionFor(m, isFront); // the last one, so drawn last, so front
		this.rawNode.insertBefore(m.rawNode, insertionPt);
		if (isFront)
			this.submorphs.pushAndAdjustCreatorSlots(m); // aaa fileout hack -- Adam
		else
			this.submorphs.unshiftAndAdjustCreatorSlots(m); // aaa fileout hack -- Adam
		m.owner = this;
		return m;
	},
	
	removeMorph: function(m, shouldNotForceLayoutRejiggering) {// FIXME? replaceMorph() with remove as a special case   // shouldNotForceLayoutRejiggering added by Adam

		var index = this.submorphs.indexOf(m);
		if (index < 0) {
			m.owner !== this && console.log("%s has owner %s that is not %s?", m, m.owner, this);
			return null;
		}

		m.removeRawNode();
		var spliced = this.submorphs.spliceAndAdjustCreatorSlots(index, 1); // aaa fileout hack -- Adam
		if (spliced instanceof Array) spliced = spliced[0];
		if (m !== spliced) {
			console.log("invariant violated removing %s, spliced %s", m, spliced);
		}

		// cleanup, move to ?
		m.owner = null;
		m.setHasKeyboardFocus(false);

		this.layoutManager.removeMorph(this, m);
    if (!shouldNotForceLayoutRejiggering) { this.forceLayoutRejiggeringIfNecessaryAfter('removeMorph', m); } // added by Adam
		return m;
    },

	removeAllMorphs: function() {
		this.changed();
		this.submorphs.invoke('removeRawNode');
		this.submorphs.clear();
		this.layoutChanged(); 
	},

	hasSubmorphs: function() {
		return this.submorphs.length != 0;
	},

	remove: function() {
		// Note this is the only removal method that stops stepping fo the morph structure
		if (!this.owner) return null;  // already removed

		this.stopAllStepping();
		this.changed();
		this.owner.removeMorph(this);

    this.detachArrowEndpoints(); // added by Adam

		return this;
	},

	withAllSubmorphsDo: function(func, rest) {
		// Call the supplied function on me and all of my submorphs by recursion.
		var args = $A(arguments);
		args.shift();
		func.apply(this, args);
		for (var i = 0; i < this.submorphs.length; i++) {
			this.submorphs[i].withAllSubmorphsDo(func, rest);
		}
	},

	invokeOnAllSubmorphs: function(selector, rest) {
		var args = $A(arguments);
		args.shift();
		var func = this[selector];
		func.apply(this, args);
		for (var i = 0; i < this.submorphs.length; i++)
		this.submorphs[i].invokeOnAllSubmorphs(selector, rest);
	},

	topSubmorph: function() {
		// the morph on top is the last one in the list
		return this.visibleSubmorphs().last();
	},

	visibleSubmorphs: function() {
		return this.submorphs.reject(function(ea) {return ea instanceof SchedulableAction})
	},

	getMorphNamed: function (name) {
		for (var i = 0; i < this.submorphs.length; i++) {
			var morph = this.submorphs[i];
			if (morph.getName() === name) return morph;
		}
		for (var i = 0; i < this.submorphs.length; i++)  {
			var morph = this.submorphs[i].getMorphNamed(name);
			if (morph) return morph;
		}
		return null;
	},

	// morph gets an opportunity to shut down when WindowMorph closes 
	shutdown: function() {
		this.remove();
	},

	okToDuplicate: function() {
	  // Changed by Adam to check the model.
	  if (typeof(this._model) !== 'undefined' && this._model !== null && typeof(this._model.okToDuplicate) === 'function') {
	    return this._model.okToDuplicate();
	  } else {
  	  return true;
	  }
  },

});

// Morph bindings to its parent, world, canvas, etc.
Morph.addMethods({

	world: function() {
		return this.owner ? this.owner.world() : null;
	},

	validatedWorld: function() {
		// Return the world that this morph is in, checking that it hasn't been removed
		if (this.owner == null) return null;
		if (this.owner.indexOfSubmorph(this) < 0) return null;
		return this.owner.validatedWorld();
	},

	openInWorld: function(loc) {
        WorldMorph.current().addMorph(this);
        loc && this.setPosition(loc);
    },
	
	toString: function() {
		try {
			return Strings.format("%s(%s)", this.rawNode && this.id() || "" , 
			this.shape ? "[" + this.shape.bounds().toTuple() + "]" : "");
		} catch (e) {
			//console.log("toString failed on %s", [this.id(), this.getType()]);
			return "#<Morph?{" + e + "}>";
		}
	},

	inspect: function() {
		try {
			return this.toString();
		} catch (err) {
			return "#<inspect error: " + err + ">";
		}
	},

    // Morph coordinate transformation functions

    // SVG has transform so renamed to getTransform()
    getTransform: function() {
		if (this.pvtCachedTransform) return this.pvtCachedTransform;
	
		if (Config.useTransformAPI) {
		    var impl = this.rawNode.transform.baseVal.consolidate();
		    this.pvtCachedTransform = new lively.scene.Similitude(impl ? impl.matrix : null); // identity if no transform specified
		} else {
		    // parse the attribute: by Dan Amelang
		    var s = this.rawNode.getAttributeNS(null, "transform");
		    //console.log('recalculating transform from ' + s);
		    var matrix = null;
		    var match = s && s.match(/(\w+)\s*\((.*)\)/);
		    if (match) {
			matrix = this.canvas().createSVGMatrix();
			var args = match[2].split(/(?:\s|,)+/).
			map(function(n) { return parseFloat(n) || 0; });
			switch (match[1]) {
			case 'matrix':
			    matrix.a = args[0]; matrix.b = args[1];
			    matrix.c = args[2]; matrix.d = args[3];
			    matrix.e = args[4]; matrix.f = args[5];
			    break;
			case 'translate':
			    matrix = matrix.translate(args[0], args[1] || 0); // may be just one arg
			    break;
			case 'scale':
			    matrix = matrix.scaleNonUniform(args[0], args[1] || 1.0);
			    break;
			case 'rotate':
			    // FIXME check:
			    matrix = matrix.translate(-args[1], -args[2]).rotate(args[0]).translate(args[1], args[2]);
			    console.log('made ' + matrix + ' from ' + args);
			    break;
			case 'skewX':
			    matrix = matrix.skewX(args[0]);
			    break;
			case 'skewY':
			    matrix = matrix.setSkewY(args[0]);
			    break;
			}
		    }
		    this.pvtCachedTransform = new lively.scene.Similitude(matrix);
		}
		return this.pvtCachedTransform;
    },

	pvtSetTransform: function(tfm) {
		this.origin = tfm.getTranslation();
		this.rotation = tfm.getRotation().toRadians();
		this.scalePoint = tfm.getScalePoint();
		// we must make sure the Morph keeps its original size (wrt/fisheyeScale)
		if (this.fisheyeScale != 1) this.scalePoint = this.scalePoint.scaleBy(1 / this.fisheyeScale);
		this.transformChanged();
	},

	setTransforms: function(array) {
		// FIXME update origin/rotation/scale etc?
		// collapse the transforms and apply the result?
		lively.scene.Node.prototype.setTransforms.call(this, array);
		this.transformChanged();
	},

    setTransform: function(tfm) { this.pvtSetTransform(tfm); }.wrap(Morph.onLayoutChange('transform')),

	transformToMorph: function(other) {
		// getTransformToElement has issues on some platforms
		dbgOn(!other);
		if (Config.useGetTransformToElement) {
			return this.rawNode.getTransformToElement(other.rawNode);
		} else {
			var tfm = this.getGlobalTransform();
			var inv = other.getGlobalTransform().createInverse();
			//console.log("own global: " + tfm + " other inverse " + inv);
			tfm.preConcatenate(inv);
			//console.log("transforming " + this + " to " + tfm);
			return tfm;
		}
	},

	getGlobalTransform: function() {
		var globalTransform = new lively.scene.Similitude();
		var world = this.world();
		// var trace = [];
		for (var morph = this; morph != null; morph = morph.owner) { // changed morph != world to morph != null, to allow world-scaling -- Adam
			globalTransform.preConcatenate(morph.getTransform());
			// trace.push(globalTransform.copy());
		}
		// console.log("global transform trace [" + trace + "] for " + this);
		return globalTransform;
	},

  // Hacked to allow callers to avoid creating the Point object. -- Adam
	translateBy: function(delta) {
	  return this.translateByXY(delta.x, delta.y);
  },
	translateByXY: function(x, y) {
		this.changed();
		this.origin = this.origin.addXY(x, y);
		// this.layoutChanged();
		// Only position has changed; not extent.  Thus no internal layout is needed
		this.transformChanged();
		if (this.fullBounds != null) this.fullBounds = this.fullBounds.translatedByXY(x, y);
		// DI: I don't think this can affect owner.  It may increase fullbounds
		//     due to stickouts, but not the bounds for layout...
		if (this.owner /* && this.owner !== this.world() */ && !this.isEpimorph) this.owner.layoutChanged(); 
		this.changed();
		return this; 
	},

	setRotation: function(theta) { // in radians
		this.rotation = theta;
		// layoutChanged will cause this.transformChanged();
	}.wrap(Morph.onLayoutChange('rotation')),
    
	setScale: function(scale/*:float*/) { 
		// While scalePoint carries both x- and y-scaling,
		//    getScale() and setScale() allow the use of simple, er, scalars
		this.setScalePoint(pt(scale, scale));
		return this; // added by Adam
	},

	setScalePoint: function(sp) { 
		this.scalePoint = sp;
		// layoutChanged will cause this.transformChanged();
	}.wrap(Morph.onLayoutChange('scale')),

	gettranslation: function() { 
		return this.getTransform().getTranslation(); 
	},

	getRotation: function() { 
		// Note: the actual transform disambiguates scale and rotation as though scale.x > 0
		var rot = this.getTransform().getRotation().toRadians(); 
		if (this.scalePoint.x >= 0) return rot;

		// if scale.x is negative, then we have to decode the difference
		if (rot < 0) return rot + Math.PI;
		return rot - Math.PI;
	},

	getScale: function() {
		return this.getTransform().getScale(); 
	},

	moveBy: function(delta) {
		this.translateBy(delta);
	},

	rotateBy: function(delta) {
		this.setRotation(this.getRotation()+delta);
	},

	scaleBy: function(factor) {
		// Perform a linear scaling (based on x scale) by the given factor
		this.setScale(this.getScale()*factor);
	},
	beClipMorph: function() {
		// For simple morphs (rectangles, ellipses, polygons) this will cause all submorphs
		// to be clipped to the shape of this morph.
		// Note: the bounds function should probably be copied from ClipMorph as
		//		part of this mutation
		var defs = this.rawNode.appendChild(NodeFactory.create('defs'));
		this.clip = new lively.scene.Clip(this.shape);
		defs.appendChild(this.clip.rawNode);
		this.clip.applyTo(this);
		this.isClipMorph = true;
	},

	throb: function() {
		this.scaleBy(this.getScale() <= 1 ? 2 : 0.9);
	},

	align: function(p1, p2) {
		return this.translateBy(p2.subPt(p1)); 
	},

    centerAt: function(p) {
		return this.align(this.bounds().center(), p); 
    },

	getCenter: function() { return this.bounds().center() },

	moveOriginBy: function(delta) {
		// This method changes the origin (and thus center of rotation) without changing any other effect
		// To center a rectangular morph, use m.moveOriginBy(m.innerBounds().center())
		this.origin = this.origin.addPt(delta);
		var deltaNegated = delta.negated();
		this.shape.translateBy(deltaNegated);
		this.submorphs.forEach(function (ea) { ea.translateBy(deltaNegated); });
	},

	// Animated moves for, eg, window collapse/expand
	animatedInterpolateTo: function(destination, nSteps, msPer, callBackFn, finalScale) {
		if (nSteps <= 0) return;
		var loc = this.position();
		var delta = destination.subPt(loc).scaleBy(1 / nSteps);
		var scaleDelta = finalScale ? (this.getScale() - finalScale) / nSteps : 0;
		// console.log("scaleDelta = " + scaleDelta);
		var path = [];
		for (var i = 1; i<=nSteps; i++) { loc = loc.addPt(delta); path.unshift(loc); }
		this.animatedFollowPath(path, msPer, callBackFn, scaleDelta);
    },

    animatedFollowPath: function(path, msPer, callBackFn, scaleDelta) {
		var spec = {path: path.clone(), callBack: callBackFn, scaleDelta: scaleDelta};
		spec.action = this.startStepping(msPer, 'animatedPathStep', spec);	
    },


	animatedPathStep: function(spec, scaleDelta) {
		if (spec.path.length >= 1){
			this.setScale(this.getScale()-spec.scaleDelta);
			this.setPosition(spec.path.pop());
		}
		if (spec.path.length >= 1) return
		//spec.action.stop(this.world()); //JD: out
		this.stopSteppingScriptNamedAndRemoveFromSubmorphs('animatedPathStep');//JD: delte script out of activeScripts, neede for deserialization
		spec.callBack.call(this);
	},

    // toggle fisheye effect on/off
	toggleFisheye: function() { 
		// if fisheye is true, we need to scale the morph to original size
		if (this.fishEye) {
			this.setScale(this.getScale() / this.fisheyeScale);
			this.setFisheyeScale(1.0);
		}
		// toggle fisheye
		this.fishEye = !this.fishEye;
	},

	// sets the scaling factor for the fisheye between 1..fisheyeGrowth
	setFisheyeScale: function (newScale) {
		// take the original centerpoint
		var p = this.bounds().center();

		this.fisheyeScale = newScale;
		this.pvtCachedTransform = null;
		this.layoutChanged();  
		this.changed();

		// if the fisheye was on move the fisheye'd morph by the difference between 
		// original center point and the new center point divided by 2
		if (this.fishEye) {
			// (new.center - orig.center)/2
			var k = this.bounds().center().subPt(p).scaleBy(.5).negated();
			if (!pt(0,0).eqPt(k)) {
				this.setPosition(this.position().addPt(k));
				this.layoutChanged();  
				this.changed();
			}
		}
	},

    // Experimental radial "black hole" scrolling feature: When
    // an object comes close enough to the "event horizon" (specified
    // by 'towardsPoint'), the object is zoomed into the black hole.
    // Negative 'howMuch' values are used to "collapse" the display, 
    // while positive values expand and restore the display back to its 
    // original state.  For further information, see  
    // Sun Labs Technical Report SMLI TR-99-74, March 1999.
	moveRadially: function(towardsPoint, howMuch) {
		var position = this.getPosition();
		var relativePt = position.subPt(towardsPoint);
		var distance = towardsPoint.dist(position);
		if (!this.inBlackHole) this.inBlackHole = 0;

		// The object disappears entirely when it is less than 5 pixels away
		// The 'inBlackHole' counter keeps track of how many levels deep
		// the object is in the black hole, allowing the display to be
		// restored correctly.
		if (distance <= 5) {
			if (howMuch < 0) {
				this.inBlackHole++;
				this.setScale(0);
			} else {
				this.inBlackHole--;            
			}
		} 

		if (this.inBlackHole == 0) {
			// Start shrinking the object when it is closer than 200 pixels away
			if (distance > 5 && distance < 200) this.setScale(distance/200);
			else if (distance >= 200 && this.getScale() != 1) this.setScale(1);

			// Calculate new location for the object
			var theta = Math.atan2(relativePt.y, relativePt.x);
			var newDistance = distance + howMuch;
			if (newDistance < 0) newDistance = 1;    
			var newX = newDistance * Math.cos(theta);
			var newY = newDistance * Math.sin(theta);
			this.setPosition(towardsPoint.addPt(pt(newX,newY)));
		}
	}
});

Morph.addMethods({     // particle behavior

	bounceInOwnerBounds: function() {
		this.bounceInBounds(this.owner.innerBounds());
	},
	
	bounceInBounds: function(ob) {
		// typcially ob = this.owner.innerBounds()
		// Bounce by reversing the component of velocity that put us out of bounds
		if (!this.velocity) return;  // Can't bounce without a velocity vector

		// We take care to only reverse the direction if it's wrong,
		//	but we move in any case, since we might be deeply out of bounds
		var b = this.bounds();
		if (b.x < ob.x) {
			if (this.velocity.x < 0) this.velocity = this.velocity.scaleByPt(pt(-1, 1));
			this.moveBy(this.velocity);
		}
		if (b.maxX() > ob.maxX()) {
			if (this.velocity.x > 0) this.velocity = this.velocity.scaleByPt(pt(-1, 1));
			this.moveBy(this.velocity);
		}
		if (b.y < ob.y) {
			if (this.velocity.y < 0) this.velocity = this.velocity.scaleByPt(pt(1, -1));
			this.moveBy(this.velocity);
		}
		if (b.maxY() > ob.maxY()) {
			if (this.velocity.y > 0) this.velocity = this.velocity.scaleByPt(pt(1, -1));
			this.moveBy(this.velocity);
		}
	},
	
	stepByVelocities: function() {
		if (this.velocity) this.moveBy(this.velocity);
		if (this.angularVelocity) this.rotateBy(this.angularVelocity);
	},
	
	stepAndBounce: function() {  // convenience for tile scripting
		this.stepByVelocities();
		this.bounceInOwnerBounds();
	}
});


Morph.addMethods({     // help handling

	getHelpText: Functions.Null,  // override to supply help text

	showHelp: function(evt) {

		if (this.suppressBalloonHelp) return false;
		if (this.owner instanceof HandMorph) return false;
		var helpText = this.getHelpText();
		if (!helpText) return false;

		// Create only one help balloon at a time
		if (this.helpBalloonMorph && !this.helpBalloonMorph.getPosition().eqPt(evt.point())) {
			this.helpBalloonMorph.setPosition(this.window().localize(evt.point()));
			return false;
		} else {
			var width = Math.min(helpText.length * 20, 260); // some estimate of width.
			var window = this.window();
			var pos = window.localize(evt.point());
			this.helpBalloonMorph = new TextMorph(pos.addXY(10, 10).extent(pt(width, 20)), helpText);
			window.addMorph(this.helpBalloonMorph.beHelpBalloonFor(this));
			return true;
		}
	},

	hideHelp: function() {
		if (!this.helpBalloonMorph)  
			return;
		this.helpBalloonMorph.remove();
		delete this.helpBalloonMorph;
	}

});



// Morph mouse event handling functions
Morph.addMethods({

	// KP: equivalent of the DOM capture phase
	// KP: hasFocus is true if the receiver is the hands's focus (?)
	captureMouseEvent: function Morph$captureMouseEvent(evt, hasFocus) {
		// Dispatch this event to the frontmost receptive morph that contains it
		// Note boolean return for event consumption has not been QA'd
		// if we're using the fisheye... 
		if (this.fishEye) {
			// get the distance to the middle of the morph and check if we're 
			// close enough to start the fisheye
			var size = Math.max(this.bounds().width, this.bounds().height);

			var dist = evt.mousePoint.dist(this.bounds().center()) / this.fisheyeProximity;
			if (dist <= size) {
				// the fisheye factor is between 1..fisheyeGrowth
				this.setFisheyeScale(1 + this.fisheyeGrowth * Math.abs(dist/size - 1));
			} else {
				// just a precaution to make sure fisheye scaling isn't 
				// affecting its surrounding any more
				this.setFisheyeScale(1.0);
			}
		}
		if (hasFocus) return this.mouseHandler.handleMouseEvent(evt, this);

		if (!evt.priorPoint || !this.fullContainsWorldPoint(evt.priorPoint)) return false;

		if (this.hasSubmorphs()) {
			// If any submorph handles it (ie returns true), then return
			for (var i = this.submorphs.length - 1; i >= 0; i--) {
				if (this.submorphs[i].captureMouseEvent(evt, false)) return true;
			}
		}
		if (this.mouseHandler == null)
			return false;

		if (!evt.priorPoint || !this.shape.containsPoint(this.localize(evt.priorPoint))) 
			return false;


		return this.mouseHandler.handleMouseEvent(evt, this); 
	},


	areEventsIgnored: function() {
		return this.getTrait("pointer-events") == "none";
	},

	ignoreEvents: function() { // will not respond nor get focus
		this.mouseHandler = null;
		this.setTrait("pointer-events", "none");
		return this;
	},

	enableEvents: function() {
		this.mouseHandler = MouseHandlerForDragging.prototype;
		this.removeTrait("pointer-events");
		return this;
	},

  // added by Adam
	ignoreAllExceptDefaultEvents: function() {
    this.mouseHandler = MouseHandlerForDoingTheDefaultThing.prototype; // needed to make normal HTML events work, like clicking on links
		this.removeTrait("pointer-events");
		return this;
	},

	relayMouseEvents: function(target, eventSpec) {
		this.mouseHandler = new MouseHandlerForRelay(target, eventSpec); 
	},

	handlesMouseDown: function(evt) {
	  if (this._eventHandler && typeof(this._eventHandler.onMouseDown) === 'function') { return true; } // added by Adam
		if (this.mouseHandler == null || evt.isCommandKey()) return false;	//default behavior
		if (this.shouldAllowSelecting()) { return true; } // added by Adam
		if (evt.isDoubleClick() && this.handlesDoubleClick()) { return true; } // added by Adam
		return this.mouseHandler.handlesMouseDown(); 
	},

  runAvocadoEventHandler: function (handlerMethodName, evt) {
    // aaa hack added by Adam, this'll be overwritten later when the Avocado code is loaded
  },
  
	onMouseDown: function(evt) {
		if (!(this instanceof WorldMorph) && this.checkForDoubleClick(evt)) { return true; } // Added by Adam
		this.hideHelp();
		if (this.shouldAllowSelecting()) { this.makeSelection(evt); } // Added by Adam
    return this.runAvocadoEventHandler('onMouseDown', evt); // added by Adam
	}, //default behavior

  onMouseMove: function(evt, hasFocus) { //default behavior
     // why does LK not by default check okToBeGrabbedBy(evt)? -- Adam
      if (evt.mouseButtonPressed && this==evt.hand.mouseFocus && ((this.owner && this.owner.openForDragAndDrop) || this.okToBeGrabbedBy(evt))) {
          this.moveBy(evt.mousePoint.subPt(evt.priorPoint));
      } // else this.checkForControlPointNear(evt);
      if (!evt.mouseButtonPressed) this.checkForControlPointNear(evt);
      return this.runAvocadoEventHandler('onMouseMove', evt); // added by Adam
  },

	onMouseUp: function(evt) {
    return this.runAvocadoEventHandler('onMouseUp', evt); // added by Adam
	}, //default behavior

	//onKeyWhatever stuff added by Adam - I guess if the methods aren't there they don't get called, but I want them here so I can call my own event handler
	onKeyDown: function(evt) {
    return this.runAvocadoEventHandler('onKeyDown', evt); // added by Adam
	},
	onKeyPress: function(evt) {
    return this.runAvocadoEventHandler('onKeyPress', evt); // added by Adam
	},
	onKeyUp: function(evt) {
    return this.runAvocadoEventHandler('onKeyUp', evt); // added by Adam
	},
	
	considerShowHelp: function(oldEvt) {
		// if the mouse has not moved reasonably
		var hand = oldEvt.hand;
		if (!hand) return; // this is not an active world so it doesn't have a hand
		else if (oldEvt.mousePoint && hand.getPosition().dist(oldEvt.mousePoint) < 10) // oldEvt.mousePoint existence check added by Adam
		this.showHelp(oldEvt);
	},

	delayShowHelp: function(evt) {
		var scheduledHelp = new SchedulableAction(this, "considerShowHelp", evt, 0);
		if (this.world())
			this.world().scheduleForLater(scheduledHelp, Config.ballonHelpDelay || 1000, false);
	},

	onMouseOver: function(evt) {
		this.delayShowHelp(evt);
		try {
			// Highlight morphs when you can drop something on them. -- Adam
			if (typeof(this.beHighlighted) === 'function') {
			  var ms = evt.hand.submorphs.select(function(m) { return this.okToReceiveDrop(m); }.bind(this));
				if (ms.size() > 0) {
					this.showPotentialDrops(ms, evt);
				}
			}

      return this.runAvocadoEventHandler('onMouseOver', evt); // added by Adam
		} catch (ex) {
			console.log("Exception in onMouseOver for " + this + ": " + ex);
		}
	},
	
	// Added by Adam
	showPotentialDrops: function(potentialDrops, evt) {
		this.beHighlighted();
	},
	
	// Added by Adam
	hidePotentialDrops: function(evt) {
		this.beUnhighlighted();
	},

	onMouseOut: function(evt) { 
		this.hideHelp();

		// Highlight morphs when you can drop something on them. -- Adam
		if (typeof(this.beUnhighlighted) === 'function') {
			this.hidePotentialDrops();
		}

    return this.runAvocadoEventHandler('onMouseOut', evt); // added by Adam
	}, 

	onMouseWheel: function(evt) {
		if (!this.world()) return false;
		return this.world().onMouseWheel(evt);
	},

	takesKeyboardFocus: Functions.False,

	setHasKeyboardFocus: Functions.False, // no matter what, say no

	requestKeyboardFocus: function(hand) {
		if (this.takesKeyboardFocus()) {
			if (this.setHasKeyboardFocus(true)) {
				hand.setKeyboardFocus(this);
				return true;
			}
		}
		return false;
	},

	relinquishKeyboardFocus: function(hand) {
		hand.setKeyboardFocus(null);
		return this.setHasKeyboardFocus(false); 
	},

	onFocus: function(hand) {
		this.addFocusHalo();
	},

	onBlur: function(hand) {
		this.removeFocusHalo();
	},

	removeFocusHalo: function() {
		if (!this.focusHalo) return false;
		//this.focusHalo.removeRawNode();
		this.focusHalo.remove();
		this.focusHalo = null;
		return true;
	},

	focusHaloInset: 2,

	focusStyle: {
		fill: null, 
		borderColor: Color.blue,
		strokeOpacity: 0.3
	},

	adjustFocusHalo: function() {
		this.focusHalo.setBounds(this.localBorderBounds().expandBy(this.focusHaloInset));
	},

	addFocusHalo: function() {
		if (this.focusHalo || this.focusHaloBorderWidth <= 0) return false;
		this.focusHalo = Morph.makeRectangle(this.localBorderBounds().expandBy(this.focusHaloInset));
		this.focusHalo.name = "FocusHalo";
		this.focusHalo.isEpimorph = true;  // Do this before adding the halo
		this.addMorph(this.focusHalo);
		this.focusHalo.applyStyle(this.focusStyle);
		this.focusHalo.setBorderWidth(this.focusHaloBorderWidth);
		this.focusHalo.setLineJoin(lively.scene.LineJoins.Round);
		this.focusHalo.ignoreEvents();
		return true;
	}

});


// Morph grabbing and menu functionality
Morph.addMethods({

	checkForControlPointNear: function(evt) {
		if (this.suppressHandles) return false; // disabled
		if (this.owner == null) return false; // cant reshape the world
		if (this.hasHandles()) return false; // handles already on - no rollovers
		var partName = this.shape.partNameNear(this.localize(evt.point()));
		if (partName == null) return false;

		var loc = this.shape.partPosition(partName);
		var handle = this.makeHandle(loc, partName, evt);
		if (!handle) return false;  // makeHandle variants may return null

		this.addMorph(handle);  
		handle.showHelp(evt);
		if (evt.hand.mouseFocus instanceof HandleMorph) evt.hand.mouseFocus.remove();
		evt.hand.setMouseFocus(handle);
		return true; 
	},
addAllHandles: function(evt) {
		if (this.suppressHandles) return false; // disabled
		if (this.owner == null) return false; // can't reshape the world
		var partNames = this.shape.allPartNames();  // Array of name
		for (var i=0; i<partNames.length; i++) {
			var loc = this.shape.partPosition(partNames[i]);
			var handle = this.makeHandle(loc, partNames[i], evt);
			handle.mode = 'reshape';
			handle.showingAllHandles = true;
			handle.rollover = false; 
			handle.isEpimorph = false;  // make bounds grow so feels click outside target
			this.addMorph(handle);  
		}
		if (evt.hand.mouseFocus instanceof HandleMorph) evt.hand.mouseFocus.remove();
	},
	
	hasHandles: function(h) { return this.submorphs.any(function (m) { return m instanceof HandleMorph }); },
	
	removeAllHandlesExcept: function(h) {
		var removals = [];
		this.submorphs.forEach(function (m) { if (m !== h && m instanceof HandleMorph) removals.push(m); });
		removals.forEach(function (m) { m.remove(); });
	},

	makeHandle: function(position, partName, evt) { // can be overriden
		var handleShape = Object.isString(partName) || partName >= 0 ? lively.scene.Rectangle : lively.scene.Ellipse;
		return new HandleMorph(position, handleShape, evt.hand, this, partName);
	},

    copySubmorphsOnGrab: false, // acts as a palette if true.
    

	suppressGrabbing: false,

    // May be overridden to preempt (by returning null) the default action of grabbing me
    // or to otherwise prepare for being grabbed or find a parent to grab instead
    okToBeGrabbedBy: function(evt) {
		if (this.suppressGrabbing)
			return null;
		
		// added by Adam
		if (this.owner && !this.owner.openForDragAndDrop)
		  return null;
		
		return this; 
    },

	editMenuItems: function(evt) { 
		return [];  // Overridden by, eg, TextMorph
	},

	showMorphMenu: function(evt) {
		if (evt.hand.lastMorphMenu && evt.hand.lastMorphMenu.owner) {
			evt.hand.lastMorphMenu.remove(); // cleanup old open menus
		};
		var menu = this.morphMenu(evt);
		var menuCaption = this.getName() ? this.getName() + ' - ' : '';
		menuCaption += Object.inspect(this).truncate();
		menu.openIn(this.world(), evt.point(), false, menuCaption); 
		evt.hand.lastMorphMenu = menu;
	},

	morphMenu: function(evt) { 
		var items = [
			["remove", this.remove],
			["drill", this.showOwnerChain.curry(evt)],
			["grab", this.pickMeUp.curry(evt)],
			["drag", this.dragMe.curry(evt)],
			["edit style", function() { new StylePanel(this).open()}],
			[((this.hasHandles()) ? "hide" : "show") + " all handles", function(evt) {
				if (this.hasHandles()) this.removeAllHandlesExcept(null);
					else this.addAllHandles(evt) }.bind(this) ],		
			["inspect", function(evt) { new SimpleInspector(this).openIn(this.world())}],
			["show class in browser", function(evt) { var browser = new SimpleBrowser(this);
				browser.openIn(this.world(), evt.point());
				browser.getModel().setClassName(this.getType());}]
			];
		if (this.okToDuplicate())
			items.unshift(["duplicate", this.copyToHand.curry(evt.hand)]);

		if (this.shape instanceof lively.scene.Polyline || this.shape instanceof lively.scene.Polygon)
			items.push( ["copy to curve", this.makeCurve]);

		if (this.getModel() instanceof SyntheticModel)
			items.push( ["show Model dump", this.addModelInspector.curry(this)]);

		var menu = new MenuMorph(items, this);

		menu.addLine();
		menu.addItem( ["world...", function() {this.world().showMorphMenu(evt)}.bind(this)]);

		menu.addLine();

		menu.addItems(this.subMenuItems(evt));
		return menu;
	},

	subMenuItems: function(evt) {
		var propertiesItems =  [
			["edit name...", function() { this.world().prompt('edit name', function(input) { this.setName(input) }.bind(this), this.getName()) }],
			["reset rotation", this.setRotation.curry(0)],
			["reset scaling", this.setScale.curry(1)],
			[((this.suppressGrabbing) ? "[] grabbing" : "[X] grabbing"), function(){this.suppressGrabbing = !this.suppressGrabbing}.bind(this)],
			[((this.suppressHandles) ? "[] handles" : "[X] handles"), function(){this.suppressHandles = !this.suppressHandles}.bind(this)],
			[((this._shouldAllowSelecting) ? "disallow selecting" : "allow selecting"), function(){this._shouldAllowSelecting = !this._shouldAllowSelecting; console.log("Just set _shouldAllowSelecting of " + reflect(this).inspect() + " to " + this._shouldAllowSelecting); }.bind(this)], // added by Adam
			[((this.fishEye) ? "turn fisheye off" : "turn fisheye on"), this.toggleFisheye],
			[(this.openForDragAndDrop ? "close DnD" : "open DnD"), this.toggleDnD.curry(evt.point())],
			// ["add button behavior", function() { this.addMorph(new ButtonBehaviorMorph(this)); }], // commented out by Adam - need the room in the menu
			[(this.copySubmorphsOnGrab ? "unpalettize" :  "palettize"), function() { this.copySubmorphsOnGrab = !this.copySubmorphsOnGrab; }]
		];
		var windowItems = [
			["put me in a window", this.putMeInAWindow.curry(this.position())], 
			["put me in a tab", this.putMeInATab.curry(this.position())],
			["put me in the open", this.putMeInTheWorld.curry(this.position())],
			["show Lively markup", this.addSvgInspector.curry(this)],
			["package", function(evt) {  // FIXME insert package morph in exactly the same position?
				new PackageMorph(this).openIn(this.world(), evt.point()); this.remove(); } ],
			["publish packaged ...", function() { this.world().prompt('publish as (.xhtml)', this.exportLinkedFile.bind(this)); }] 
		];
		return [
			['Properties', propertiesItems],
			// ['Window and World', windowItems] // commented out by Adam - don't want this stuff, and need to make room in the menu
		]
	},

    showPieMenu: function(evt) {
    	var menu, targetMorph = this;
		var items = [
			['undo (~)', function(evt) { PieMenuMorph.doUndo(); }],
			['duplicate (o-->o)', function(evt) {
				evt.hand.setPosition(menu.mouseDownPoint);
				menu.targetMorph.copyToHand(evt.hand);
				var theCopy = evt.hand.submorphs[0];
				PieMenuMorph.setUndo(function() { theCopy.remove(); });  // Why doesn't this work??
				}],
			['move (o-->)', function(evt) {
				var oldPos = targetMorph.getPosition();
				PieMenuMorph.setUndo(function() { targetMorph.setPosition(oldPos); });
				evt.hand.setPosition(menu.mouseDownPoint);
				evt.hand.addMorph(menu.targetMorph);
				if (menu.targetMorph instanceof SelectionMorph)  // Fixme:  This should be in SelectionMorph
					menu.targetMorph.selectedMorphs.forEach( function(m) { evt.hand.addMorph(m); });
				}],
			['scale (o < O)', function(evt) {
				var oldScale = targetMorph.getScale();
				PieMenuMorph.setUndo(function() { targetMorph.setScale(oldScale); });
				menu.addHandleTo(targetMorph, evt, 'scale');
				}],
			[((targetMorph.hasHandles()) ? "hide" : "show") + " all handles ([])", function(evt) {
				if (targetMorph.hasHandles()) targetMorph.removeAllHandlesExcept(null);
					else targetMorph.addAllHandles(evt) }],
			['delete (X)', function(evt) {
				var oldOwner = targetMorph.owner;
				PieMenuMorph.setUndo(function() { oldOwner.addMorph(targetMorph); });
				targetMorph.remove();
				}],
			['edit style (<>)', function() { new StylePanel(this).open()}],
			['rotate (G)', function(evt) {
				var oldRotation = targetMorph.getRotation();
				PieMenuMorph.setUndo(function() { targetMorph.setRotation(oldRotation); });
				menu.addHandleTo(targetMorph, evt, 'rotate');
				}]
		];
		menu = new PieMenuMorph(items, this, 0.5);
		menu.open(evt);
    },

	dragMe: function(evt) {
		var offset = this.getPosition().subPt(this.ownerLocalize(evt.point()));
		var mouseRelay= {
			captureMouseEvent: function(e) { 
				if (e.type == "MouseMove")  this.setPosition(this.ownerLocalize(e.hand.getPosition()).addPt(offset));
				if (e.type == "MouseDown" || e.type == "MouseUp")  e.hand.setMouseFocus(null); 
			}.bind(this),
		};
		evt.hand.setMouseFocus(mouseRelay);
	},

	putMeInAWindow: function(loc) {
		var c = this.immediateContainer();
		var w = this.world();
		var wm = new WindowMorph(this.windowContent(), this.windowTitle());
		// Position it so the content stays in place
		w.addMorphAt(wm, loc.subPt(wm.contentOffset));
		if (c) c.remove();
	},

	putMeInATab: function(loc) {
		var c = this.immediateContainer();
		var w = this.world();
		var wm = new TabbedPanelMorph(this.windowContent(), this.windowTitle());
		w.addMorphAt(wm, wm.getPosition());
		if (c) c.remove();
	},

	putMeInTheWorld: function(loc) {
		var c = this.immediateContainer();
		var loc = c ? c.position().addPt(c.contentOffset) : this.position();
		this.world().addMorphAt(this, loc);
		if (c) c.remove();
	},

	immediateContainer: function() { // Containers override to return themselves
		if (this.owner) return this.owner.immediateContainer();
		else return null;
	},

	windowContent: function() {
		return this; // Default response, overridden by containers
	},

	windowTitle: function() {
		return Object.inspect(this).truncate(); // Default response, overridden by containers
	},

	toggleDnD: function(loc) {
		// console.log(this + ">>toggleDnD");
		this.openForDragAndDrop = !this.openForDragAndDrop;
	},

	openDnD: function(loc) {
		this.openForDragAndDrop = true;
		return this; // Added by Adam to allow chaining
	},

	closeDnD: function(loc) {
		// console.log(this + ">>closeDnD");
		this.openForDragAndDrop = false;
		return this; // Added by Adam to allow chaining
	},

    closeAllToDnD: function(loc) {
        // console.log(this + ">>closeAllDnD");
        // Close this and all submorphs to drag and drop
        this.closeDnD(); 
        // make this recursive to give children a chance to interrupt...
        this.submorphs.forEach( function(ea) { ea.closeAllToDnD(); });
	return this; // Added by Adam to allow chaining
    },

	openAllToDnD: function() {
		// Open this and all submorphs to drag and drop
		this.withAllSubmorphsDo( function() { this.openDnD(); });
		return this; // Added by Adam to allow chaining
	},

	dropMeOnMorph: function(receiver) {
		receiver.addMorph(this); // this removes me from hand
	},

	pickMeUp: function(evt) {
		var offset = evt.hand.getPosition().subPt(evt.point());
		this.moveBy(offset);
		evt.hand.addMorphAsGrabbed(this);
	},

	notify: function(msg, loc) {
		if (!loc) loc = this.world().positionForNewMorph();
		new MenuMorph([["OK", 0, "toString"]], this).openIn(this.world(), loc, false, msg); 
	},

	showOwnerChain: function(evt) {
		var items = this.ownerChain().reverse().map(
			function(each) { 
				return [Object.inspect(each).truncate(), function(evt2) { each.showMorphMenu(evt) }]; 
			});
		new MenuMorph(items, this).openIn(this.world(), evt.point(), false, "Top item is topmost");
	},

	copyToHand: function(hand) {
		// Function.prototype.shouldTrace = true;
		var copy = this.copy(new Copier());
		// when copying submorphs, make sure that the submorph that becomes a top-level morph 
		// reappears in the same location as its original.
		console.log('copied %s', copy);
		copy.owner = null; // so following addMorph will just leave the tfm alone
		this.owner.addMorph(copy); // set up owner as the original parent so that...        
		hand.addMorph(copy);  // ... it will be properly transformed by this addMorph()
		copy.setPosition(copy.getExtent().scaleBy(-0.5)); // Grab it by the center. -- Adam, May 2010
		hand.showAsGrabbed(copy);
		// copy.withAllSubmorphsDo(function() { this.startStepping(null); }, null);
    copy.refreshContentOfMeAndSubmorphs(); // added by Adam
		return copy
	},

	shadowCopy: function(hand) {
		// This is currently an expensive and error-prone deep copy
		// Better would be a shallow copy unless there are submorphs outside bounds
		var copy;
		try {
		  // Yeah, let's put in a faster hack for now; we're having performance problems
		  // with grabbing complex morphs. -- Adam
		  //copy = this.copy(new Copier());
		  copy = new Morph(this.shape.copy());
		  copy.setPosition(this.getPosition());
		  copy.setScale(this.getScale());
		}
		catch (e) { copy = Morph.makeRectangle(this.bounds()); }
		copy.withAllSubmorphsDo( function() {
			if (this.fill || this.getFill()) this.setFill(Color.black);
			else this.setFill(null);
			if (this.getBorderColor()) this.setBorderColor(Color.black);
			this.setFillOpacity(0.3);
			this.setStrokeOpacity(0.3);
		});
		copy.owner = null; // so later addMorph will just leave the tfm alone
		return copy;
	},

	morphToGrabOrReceiveDroppingMorph: function(evt, droppingMorph) {
		return this.morphToGrabOrReceive(evt, droppingMorph, true);
	},

	morphToGrabOrReceive: function(evt, droppingMorph, checkForDnD) {
		// If checkForDnD is false, return the morph to receive this mouse event (or null)
		// If checkForDnD is true, return the morph to grab from a mouse down event (or null)
		// If droppingMorph is not null, then check that this is a willing recipient (else null)

		if (this.isEpimorph)
			return null;

		if (!this.fullContainsWorldPoint(evt.mousePoint)) return null; // not contained anywhere
		// First check all the submorphs, front first
		for (var i = this.submorphs.length - 1; i >= 0; i--) {
			var hit = this.submorphs[i].morphToGrabOrReceive(evt, droppingMorph, checkForDnD); 
			if (hit != null) { 
				return hit;  // hit a submorph
			}
		};

		// Check if it's really in this morph (not just fullBounds)
		if (!this.containsWorldPoint(evt.mousePoint)) return null;

		// If no DnD check, then we have a hit (unless no handler in which case a miss)
		if (!checkForDnD) return this.mouseHandler ? this : null;

		// On drops, check that this is a willing recipient
		if (droppingMorph != null) {
			return this.okToReceiveDrop(droppingMorph) ? this : null;
		} else {
			// On grabs, can't pick up the world or morphs that handle mousedown
			// DI:  I think the world is adequately checked for now elsewhere
			// else return (!evt.isCommandKey() && this === this.world()) ? null : this; 
			return this;
		}

	},

	morphToReceiveEvent: function(evt) {
		// This should replace morphToGrabOrReceive... in Hand where events
		// must be displatched to morphs that are closed to DnD
		return this.morphToGrabOrReceive(evt, null, false);
	},

	ownerChain: function() {
		// Return an array of me and all my owners
		// First item is, eg, world; last item is me
		if (!this.owner) return [this];
		var owners = this.owner.ownerChain();
		owners.push(this);
		return owners;
	},

	acceptsDropping: function(morph) { 
		return this.openForDragAndDrop && !(morph instanceof WindowMorph);
	}

});

Morph.subclass('PseudoMorph', {
    description: "This hack to make various objects serializable, despite not being morphs",
    
	initialize: function($super) {
		$super(new lively.scene.Group());
		this.setVisible(false);
	}

});

// TODO: Is this still used?
// Deprecated?
PseudoMorph.subclass('Invocation', {
    initialize: function($super, actor, scriptName, argIfAny) {
	$super();
	this.actor = actor;
	this.scriptName = scriptName;
	this.argIfAny = argIfAny; // better be primitive
    },

    exec: function Invocation$exec() {
	if (!this.actor) {
	    console.warn("no actor on script %s", this);
	    return null;
	}
	var func = this.actor[this.scriptName];
	if (func) {
	    return func.call(this.actor, this.argIfAny);
	} else {
	    //console.warn("no callback on actor %s", this.actor);
	    return null;
	}
    }

});


Invocation.subclass('SchedulableAction', {

	documentation: "Description of a periodic action",
	beVerbose: false,

	initialize: function($super, actor, scriptName, argIfAny, stepTime) {
		$super(actor, scriptName, argIfAny);
		this.stepTime = stepTime;
		this.ticks = 0;
	},

	toString: function() {
		return Strings.format("#<SchedulableAction[actor=%s,script=%s,arg=%s,stepTime=%s]>", 
		this.actor, this.scriptName, this.argIfAny, this.stepTime);
	},

	stop: function(world) {
		if (this.beVerbose) console.log("stopped stepping task %s", this);
		world.stopSteppingFor(this);
	},

	start: function(world) {
		if (this.beVerbose) console.log("started stepping task %s", this);
		world.startSteppingFor(this);
	},

	equalActorAndName: function(other) {
		if (!other) 
			return false;
		if (this === other) 
			return true;
		return (this.actor === other.actor) && (this.scriptName == other.scriptName)
	}
});

// Morph stepping/timer functions
Morph.addMethods({

    startSteppingScripts: function() { }, // May be overridden to start stepping scripts

	stopStepping: function() {
		if (!this.activeScripts) return;
		// ignore null values
		this.activeScripts.select(function (ea) { return ea }).invoke('stop', this.world());
		this.activeScripts = null;
	},
	
	stopSteppingScriptNamed: function(sName) {
		if (!this.activeScripts) return;
		this.activeScripts.select(function (ea) { return ea.scriptName == sName }).invoke('stop', this.world());
		this.activeScripts = this.activeScripts.select(function (ea) { return ea.scriptName !== sName });	
		if (this.activeScripts.length == 0) this.activeScripts = null;
	},

	startStepping: function(stepTime, scriptName, argIfAny) {
		if (!scriptName) 
			throw Error("Old code");
		var action = new SchedulableAction(this, scriptName, argIfAny, stepTime);
		this.addActiveScript(action);
		action.start(this.world());
		return action;
	},

	addActiveScript: function(action) {
		// Every morph carries a list of currently active actions (alarms and repetitive scripts)
		if (!this.activeScripts) this.activeScripts = [action];
		else this.activeScripts.push(action);
		if (!action.rawNode.parentNode) 
			this.addMorph(action);
		return this;
		// if we're deserializing the rawNode may already be in the markup
	},

    stopAllStepping: function() {  // For me and all my submorphs 
		this.withAllSubmorphsDo( function() { this.stopStepping(); });
    },

    suspendAllActiveScripts: function() {  // For me and all my submorphs
		this.withAllSubmorphsDo( function() { this.suspendActiveScripts(); });
    },

	suspendActiveScripts: function() {
		if (this.activeScripts) { 
			this.suspendedScripts = this.activeScripts.clone();
			this.stopStepping();
		}
	},

	resumeAllSuspendedScripts: function() {
		var world = WorldMorph.current();
		this.withAllSubmorphsDo( function() {
			if (this.suspendedScripts) {
				// ignore null values
				this.suspendedScripts.select(function (ea) { return ea }).invoke('start', world);
				this.activeScripts = this.suspendedScripts;
				this.suspendedScripts = null;
			}
		});
	}

});

// Morph bounds, coordinates, moving and damage reporting functions
Morph.addMethods({ 
    
    // bounds returns the full bounding box in owner coordinates of this morph and all its submorphs
	bounds: function(ignoreTransients, ignoreTransform) {
		if (this.fullBounds != null) return this.fullBounds;

		var tfm = this.getTransform();
		var fullBounds = this.localBorderBounds(ignoreTransform ? null : tfm);

		var subBounds = this.submorphBounds(ignoreTransients);
		if (subBounds != null) {
			// could be simpler when no rotation...
			fullBounds = fullBounds.union(tfm.transformRectToRect(subBounds));
		}

		if (fullBounds.width < 3 || fullBounds.height < 3) {
			// Prevent Horiz or vert lines from being ungrabable
			fullBounds = fullBounds.expandBy(3); 
		}
		this.fullBounds = fullBounds;
		return fullBounds; 
	},
    
	submorphBounds: function(ignoreTransients) {
		var subBounds = null;
		for (var i = 0; i < this.submorphs.length; i++) {
			var m = this.submorphs[i];
			if ((ignoreTransients && m.isEpimorph))
				continue;
			if (!m.isVisible()) {
				continue;
			}
			subBounds = subBounds == null ? m.bounds(ignoreTransients) : subBounds.union(m.bounds(ignoreTransients));
		}
		return subBounds;
	},
    
    // innerBounds returns the bounds of this morph only, and in local coordinates
    innerBounds: function() { 
		return this.shape.bounds();
    },
    
	localBorderBounds: function(optTfm) {
		// defined by the external edge of the border
		// if optTfm is defined, transform the vertices first, then take the union
		dbgOn(!this.shape);
		var bounds = optTfm ? Rectangle.unionPts(this.shape.vertices().invoke('matrixTransform', optTfm)) : this.shape.bounds();

		var borderMargin = this.getBorderWidth()/2;
		// double border margin for polylines to account for elbow protrusions
		if (this.shape.hasElbowProtrusions) borderMargin = borderMargin*2 + 1;
		bounds = bounds.expandBy(borderMargin);
		return bounds;
	},
    
    
    /** 
      * mapping coordinates in the hierarchy
      * @return [Point]
      */

    // map local point to world coordinates
    worldPoint: function(pt) { 
		return pt.matrixTransform(this.transformToMorph(this.world())); 
    },

	// map owner point to local coordinates
	relativize: function(pt) { 
		if (!this.owner) { 
			throw new Error('no owner; call me after adding to a morph? ' + this);
		}
		try {
			return pt.matrixTransform(this.owner.transformToMorph(this)); 
		} catch (er) {
			// console.info("ignoring relativize wrt/%s", this);
			return pt;
		}
	},

    // map owner rectangle to local coordinates
    relativizeRect: function(r) { 
		return rect(this.relativize(r.topLeft()), this.relativize(r.bottomRight()));
    },

    // map world point to local coordinates
	localize: function(pt) {
		if (pt == null) console.log('null pt');   
		if (this.world() == null) {
			// console.log('ERROR in '+  this.id() +' localize: '+ pt + ' this.world() is null');   
			// printStack();
			return pt;
		}
		return pt.matrixTransform(this.world().transformToMorph(this));
	},

    // map local point to owner coordinates
	localizePointFrom: function(pt, otherMorph) {   
		try {
			return pt.matrixTransform(otherMorph.transformToMorph(this));
		} catch (er) {
			// lively.lang.Execution.showStack();
			console.log("problem " + er + " on " + this + " other " + otherMorph);
			return pt;
		}
	},

  // added by Adam
  ownerLocalize: function(pt) {
		if (! this.owner) { return pt; }
    return this.owner.localize(pt);
  },
  
    transformForNewOwner: function(newOwner) {
		return new lively.scene.Similitude(this.transformToMorph(newOwner));
    },

	changed: function() {
		// Note most morphs don't need this in SVG, but text needs the 
		// call on bounds() to trigger layout on new bounds
		if(this.owner) this.owner.invalidRect(this.bounds());

    if (this._changeNotifier) { this._changeNotifier.notifyAllObservers(); } // Added by Adam
	},

	invalidRect: function() {
		// Do nothing (handled by SVG).  Overridden in canvas.
    },

    layoutOnSubmorphLayout: function(submorph) {
		// override to return false, in which case layoutChanged() will not be propagated to
		// the receiver when a submorph's layout changes. 
		return true;
    },

	transformChanged: function() {
		var scalePt = this.scalePoint;
		if (this.fisheyeScale != 1) scalePt = scalePt.scaleBy(this.fisheyeScale);
		this.pvtCachedTransform = new lively.scene.Similitude(this.origin, this.rotation, scalePt);
		this.pvtCachedTransform.applyTo(this.rawNode);
		if (this._cachedVisibleBounds) { this._cachedVisibleBounds = null; } // added by Adam
	},

	layoutChanged: function Morph$layoutChanged() {
		// layoutChanged() is called whenever the cached fullBounds may have changed
		// It invalidates the cache, which will be recomputed when bounds() is called
		// Naturally it must be propagated up its owner chain.
		// Note the difference in meaning from adjustForNewBounds()
		// KP: the following may or may not be necessary:

		this.transformChanged(); // DI: why is this here?
		if(! this.fullBounds) return;  // already called

		this.fullBounds = null;
		if (this.owner && this.owner.layoutOnSubmorphLayout(this) && !this.isEpimorph) {     // May affect owner as well...
			this.owner.layoutChanged();
		}
		this.layoutManager.layoutChanged(this);
	},

	adjustForNewBounds: function() {
		// adjustForNewBounds() is called whenever the innerBounds may have changed in extent
		//  -- it should really be called adjustForNewExtent --
		// Depending on the morph and its layoutManager, it may then re-layout its
		// submorphs and, in the process, propagate the message down to leaf morphs (or not)
		// Of course a change in innerBounds implies layoutChanged() as well,
		// but, for now, these are called separately.
		// NB:  Because some morphs may re-lay themselves out in response to adjustForNewBounds()
		// adjustForNewBounds() *must never be called from* a layout operation;
		// The layout process should only move and resize submorphs, but never change the innerBounds

		// If this method is overridden by a subclass, it should call super as well
		if (this.focusHalo) this.adjustFocusHalo();
		
		if (this._layout && this._layout.adjustForNewBounds) { this._layout.adjustForNewBounds(this); } // added by Adam
	},

	position: function() { // Deprecated -- use getPosition
		return this.shape.bounds().topLeft().addPt(this.origin); 
	},

	getPosition: function() {
		return this.shape.bounds().topLeft().addPt(this.origin); 
	},

	setPosition: function(newPosition) {
		this.layoutManager.setPosition(this, newPosition);
		return this; // added by Adam
	},
	
	// Hack by Adam to allow avoiding creating new Points. -- Adam
	setPositionXY: function(newX, newY) {
		this.layoutManager.setPositionXY(this, newX, newY);
  }

});

// Inspectors for Morphs
Morph.addMethods({

	addSvgInspector: function() {
		var xml = Exporter.stringify(new Exporter(this).serialize(Global.document));
		var txt = this.world().addTextWindow({
			content: xml,
			title: "XML dump", 
			position: this.world().positionForNewMorph(null, this)
		});
		txt.innerMorph().xml = xml; // FIXME a sneaky way of passing original text.
	},

	addModelInspector: function() {
		var model = this.getModel();
		if (model instanceof SyntheticModel) {
			var variables = model.variables();
			var list = [];
			for (var i = 0; i < variables.length; i++) {
				var varName = variables[i];
				list.push(varName + " = " + model.get(varName));
			}
			this.world().addTextListWindow({
				content: list,
				title: "Simple Model dump",
				position: this.world().positionForNewMorph(null, this)
			});
		}
	}
});


// Morph factory methods for creating simple morphs easily
Object.extend(Morph, {

	makeLine: function(verts, lineWidth, lineColor) {
		// make a line with its origin at the first vertex
		// Note this works for simple lines (2 vertices) and general polylines
		verts = verts.invoke('subPt', verts[0]);
		var shape = new lively.scene.Polyline(verts);
		var morph = new Morph(shape);
		morph.setBorderWidth(lineWidth);
		morph.setBorderColor(lineColor);
		morph.setFill(null);
		return morph;
	},

	makeCircle: function(location, radius, lineWidth, lineColor, fill) {
		// make a circle of the given radius with its origin at the center
		var morph = new Morph(new lively.scene.Ellipse(location, radius));
		morph.setBorderWidth(lineWidth);
		morph.setBorderColor(lineColor);
		morph.setFill(fill || Color.blue);
		return morph;
	},

	makeEllipse: function(bounds, lineWidth, lineColor, fill) {
		// make a circle first (a bit wasteful)
		var morph = this.makeCircle(bounds.center(), 0, lineWidth, lineColor, fill);
		morph.setBounds(bounds);
		morph.moveOriginBy(morph.innerBounds().center())
		return morph;
	},

	makeRectangle: function(/**/) {
		var morph;
		switch (arguments.length) {
			case 1: // rectangle
			if (!(arguments[0] instanceof Rectangle)) throw new TypeError(arguments[0] + ' not a rectangle');
			morph = new Morph(new lively.scene.Rectangle(arguments[0]));
			break;
			case 2: // location and extent
			morph = new Morph(new lively.scene.Rectangle(arguments[0].extent(arguments[1])));
			break;
			case 4: // x,y,width, height
			morph = new Morph(new lively.scene.Rectangle(new Rectangle(arguments[0], arguments[1], arguments[2], arguments[3])));
			break;
			default:
			throw new Error("bad arguments " + arguments);
		}
		return morph.applyStyle({borderWidth: 1, borderColor: Color.black, fill: Color.blue});
	},

	makePolygon: function(verts, lineWidth, lineColor, fill) {
		var morph = new Morph(new lively.scene.Polygon(verts));
		morph.setBorderWidth(lineWidth);
		morph.setBorderColor(lineColor);
		morph.setFill(fill);
		return morph;
		//return morph.applyStyle({fill: fill, borderWidth: lineWidth, borderColor: lineColor});
	},

	makeStar: function(position) {
		var makeStarVertices = function(r,center,startAngle) {
			var vertices = [];
			var nVerts = 10;
			for (var i=0; i <= nVerts; i++) {
				var a = startAngle + (2*Math.PI/nVerts*i);
				var p = Point.polar(r,a);
				if (i%2 == 0) p = p.scaleBy(0.39);
				vertices.push(p.addPt(center)); 
			}
			return vertices; 
		}
		var morph = Morph.makePolygon(makeStarVertices(50,pt(0,0),0), 1, Color.black, Color.yellow);
		morph.setPosition(position);
		return morph
	},
	makeCurve: function(verts, ctrls, closed) {
		// Make up a new quadratic spline from the supplied vertices and control points.
		// ctrls[i] is the ctrl point for segment from verts[i-1] to verts[i].  (ctrls[0] is never used)
		if (verts.length < 2) return;
		// console.log("verts = " + Object.inspect(verts));
		// console.log("ctrls = " + Object.inspect(ctrls));
		var g = lively.scene;
		var cmds = [];
		cmds.push(new g.MoveTo(true, verts[0].x,  verts[0].y));
		for (var i=1; i<verts.length; i++) {
			cmds.push(new g.QuadCurveTo(true, verts[i].x, verts[i].y, ctrls[i].x, ctrls[i].y));
		}
		var morph = new Morph(new g.Path(cmds));
		if (closed) morph.applyStyle({ fill: Color.red, borderWidth: 1, borderColor: Color.black});
			else morph.applyStyle({ fill: null, borderWidth: 3, borderColor: Color.red});
		return morph;
},


	makeHeart: function(position) {
		var g = lively.scene;
		var shape = new g.Path([
			new g.MoveTo(true, 0,  0),
			new g.CurveTo(true, 48.25, -5.77),
			new g.CurveTo(true, 85.89, 15.05),
			new g.CurveTo(true, 61.36, 32.78),
			new g.CurveTo(true, 53.22, 46.00),
			new g.CurveTo(true, 25.02, 68.58),
			new g.CurveTo(true, 1.03,  40.34),
			new g.CurveTo(true, 0,  0),
		]);
		var morph = new Morph(shape);
		morph.applyStyle({ fill: Color.red, borderWidth: 3, borderColor: Color.red});
		morph.setPosition(position);
		morph.rotateBy(3.9);
		return morph
	}
});

// View trait
ViewTrait = {
    connectModel: function(plugSpec, optKickstartUpdates) {
	// FIXME what if already connected, 
	if (plugSpec instanceof Relay) {
	    // new style model
	    this.formalModel = plugSpec;
	    // now, go through the setters and add notifications on model
	    if (plugSpec.delegate instanceof Record) 
		plugSpec.delegate.addObserversFromSetters(plugSpec.definition, this, optKickstartUpdates);
	    return;
	} else if (plugSpec instanceof Record) {
	    this.formalModel = plugSpec;
	    plugSpec.addObserversFromSetters(plugSpec.definition, this, optKickstartUpdates);
	    return;
	}
	// connector makes this view pluggable to different models, as in
	// {model: someModel, getList: "getItemList", setSelection: "chooseItem"}
	var newPlug = (plugSpec instanceof ModelPlug) ? plugSpec : new ModelPlug(plugSpec);
	
	var model = newPlug.model;
	if (!(model instanceof Model) && !this.checkModel(newPlug))
	    console.log("model " + model +  " is not a Model, view " + this);

	this.modelPlug = newPlug;
	reflect(this).slotAt('modelPlug').beCreator(); // aaa hack for morph-saving -- Adam

	if (model.addDependent) { // for mvc-style updating
	    model.addDependent(this);
	} 
	return this;
    },

    relayToModel: function(model, optSpec, optKickstart) {
	return this.connectModel(Relay.newInstance(optSpec || {}, model), optKickstart);
    },

    reconnectModel: function() {
	if (this.formalModel instanceof Relay) {
	    // now, go through the setters and add notifications on model
	    //alert('delegate ' + this.formalModel.delegate);
	    if (this.formalModel.delegate instanceof Record)  {
		this.formalModel.delegate.addObserversFromSetters(this.formalModel.definition, this);
	    }
	} else if (this.formalModel instanceof Record) {
	    this.formalModel.addObserversFromSetters(this.formalModel.definition, this);
	} //else alert('formal model ' + this.formalModel);
    },

    checkModel: function(plugSpec) {
	// For non-models, check that all supplied handler methods can be found
	var result = true;
	Properties.forEachOwn(plugSpec, function(modelMsg, value) {
	    if (modelMsg == 'model') return;
	    var handler = plugSpec.model[value];
	    
	    if (!handler || !(handler instanceof Function)) {
		// console.log
		alert("Supplied method name, " + value + " does not resolve to a function.");
		result = false;
	    }
	});
	return result;
    },

    disconnectModel: function() {
	var model = this.getModel();
	if (model && model.removeDependent) { // for mvc-style updating
	    model.removeDependent(this);
	} 
    },

    getModel: function() {
	var plug = this.getModelPlug();
	if (plug) return plug.model;
	else return this.getActualModel();
    },

    getActualModel: function() {
	return this.formalModel instanceof Relay ? this.formalModel.delegate : this.formalModel;
    },
    
    getModelPlug: function() { 
	var plug = this.modelPlug;
	return (plug && plug.delegate) ?  plug.delegate : plug;
    },

    getModelValue: function(functionName, defaultValue) {
	// functionName is a view-specific message, such as "getList"
	// The model plug then provides a reference to the model, as well as
	// the specific model accessor for the aspect being viewed, say "getItemList"
	// Failure at any stage will return the default value.
	// TODO: optionally verify that variable name is listed in this.pins
	if (this.formalModel) {  
	    // snuck in compatiblitiy with new style models
	    var impl = this.formalModel[functionName];
	    return impl ? impl.call(this.formalModel) : defaultValue;
	}
	
	var plug = this.getModelPlug();
	if (plug == null || plug.model == null || functionName == null) return defaultValue;
	var func = plug.model[plug[functionName]];
	if (func == null) return defaultValue;
	return func.call(plug.model); 
    },

    setModelValue: function(functionName, newValue) {
	// functionName is a view-specific message, such as "setSelection"
	// The model plug then provides a reference to the model, as well as
	// the specific model accessor for the aspect being viewed, say "chooseItem"
	// Failure at any stage is tolerated without error.
	// Successful sets to the model supply not only the newValue, but also
	// a reference to this view.  This allows the model's changed() method
	// to skip this view when broadcasting updateView(), and thus avoid
	// needless computation for a view that is already up to date.
	// TODO: optionally verify that variable name is listed in this.pins
	if (this.formalModel) { 
	    // snuck in compatiblitiy with new style models
	    var impl = this.formalModel[functionName];
	    return impl && impl.call(this.formalModel, newValue);
	}
	var plug = this.getModelPlug();
	if (plug == null || plug.model == null || functionName == null) return null;
	var func = plug.model[plug[functionName]];
	if (func == null) return null;
	func.call(plug.model, newValue, this);
	return plug[functionName];
    },

    updateView: function(aspect, controller) {
	// This method is sent in response to logic within the model executing
	//     this.changed(aspect, source)
	// The aspect used is the name of the get-message for the aspect
	// that needs to be updated in the view (and presumably redisplayed)
	// All actual view morphs will override this method with code that
	// checks for their aspect and does something useful in that case.
    }
};

Object.subclass('View', ViewTrait, {

    initialize: function(modelPlug) {
	if (modelPlug)
	    this.connectModel(modelPlug);
    },

    getType: function() { // convenience
	return this.constructor.getOriginal().type;
    },

    toString: function() {
	return "#<" + this.getType() + ">";
    }

});

Morph.addMethods(ViewTrait);


// ===========================================================================
// MVC model support
// ===========================================================================

/**
  * @class Model
  * An MVC style model class that allows changes to be automatically
  * propagated to multiple listeners/subscribers/dependents. 
  */ 

// A typical model/view relationship is set up in the following manner:
//        panel.addMorph(m = newTextListPane(new Rectangle(200,0,200,150)));
//        m.connectModel({model: this, getList: "getMethodList", setSelection: "setMethodName"});
// The "plug" object passed to connectModel() points to the model, and converts from
// view-specific messages like getList() and setSelection() to model-specific messages
// like getMethodList() and setMethodName.  This allow a single model to have, eg,
// several list views, each viewing a different list aspect of the model.

// A number of morphs are used as views, or "widgets".  These include TextMorph,
// ListMorph, ButtonMorph, SliderMorph, etc.  Each of these morphs uses the above
// plug mechanism to get or set model values and to respond to model changes.
// these are documented in Morph.getModelValue, setModelValue, and updateView

Object.subclass('Model', {

    initialize: function(dep) { 
	// Broadcasts an update message to all dependents when a value changes.
	this.dependents = (dep != null) ? [dep] : [];
    },

    addDependent: function (dep) { 
	this.dependents.push(dep); 
    },

    removeDependent: function (dep) {
	var ix = this.dependents.indexOf(dep);
	if (ix < 0) return;
	this.dependents.splice(ix, 1); 
    },

    changed: function(varName, source) {
	// Broadcast the message "updateView" to all dependents
	// If source (a dependent) is given, we skip it (already updated)
	// If varName is not given, then null will be the aspect of the updateView()
	//console.log('changed ' + varName);
	for (var i = 0; i < this.dependents.length; i++) {
	    if (source !== this.dependents[i]) {
		// console.log('updating %s for name %s', this.dependents[i], varName);
		this.dependents[i].updateView(varName, source);
	    } 
	} 
    },

    toString: function() {
	return Strings.format("#<Model:%s>", this.dependents);
    },

    // test?
    copyFrom: function(copier, other) {
	this.dependents = [];
	other.dependents.forEach(function(dep) { this.dependents.push(copier.lookup(dep.id())) }, this);
    }

});

lively.data.Wrapper.subclass('ModelPlug', { // obsolete with CheapListMorph?
    documentation: "A 'translation' from view's variable names to model's variable names",

    initialize: function(spec) {
	var props = [];
	Properties.forEachOwn(spec, function(p) {
	    this[p] = spec[p];
	    props.push(p);
	}, this);
    },
    
    toString: function() {
	var pairs = [];
	Properties.forEachOwn(this, function(p, value) { if (p != 'model') pairs.push(p + ":" + value) });
	return "#<ModelPlug{" + pairs.join(',') + "}>";
    },

    serialize: function(modelId) {
	var rawNode = LivelyNS.create("modelPlug", {model: modelId});
	Properties.forEachOwn(this, function(prop, value) {
	    switch (prop) {
	    case 'model':
	    case 'rawNode':
		break;
	    default:
		rawNode.appendChild(LivelyNS.create("accessor", {formal: prop, actual: value}));
	    }
	}, this);
	return rawNode;
    },

    inspect: function() {
	return JSON.serialize(this);
    },

    deserialize: function(importer, rawNode) {
	for (var acc = rawNode.firstChild; acc != null;  acc = acc.nextSibling) {
	    if (acc.localName != 'accessor') continue;
	    this[LivelyNS.getAttribute(acc, "formal")] = LivelyNS.getAttribute(acc, "actual");
	}
    }
});


Model.subclass('SyntheticModel', {
    documentation: "A stereotyped model synthesized from a list of model variables",

    initialize: function($super, vars) {
	$super(null);
	if (!(vars instanceof Array)) 
	    throw new Error("wrong argument to SyntheticModel: " + vars);
	for (var i = 0; i < vars.length; i++) {
	    var v = vars[i];
	    if (v.startsWith('-') || v.startsWith('+')) 
		v = v.slice(1);
	    this.addVariable(v, null);
	}
    },

    makeGetter: function(name) {
	// functional programming is fun!
	
	return function() { 
	    return this[name]; 
	};
    },

    makeSetter: function(name) {
	return function(newValue, v) { 
	    this[name] = newValue; 
	    this.changed(this.getterName(name), v); 
	};
    },

    addVariable: function(varName, initialValue) {
	this[varName] = initialValue;
	this[this.getterName(varName)] = this.makeGetter(varName);
	this[this.setterName(varName)] = this.makeSetter(varName);
    },

    getterName: function(varName) {
	return "get" + varName;
    },

    get: function(varName) {
	var method = this[this.getterName(varName)];
	if (!method) throw new Error(this.getterName(varName) + " not present ");
	return method.call(this, varName);
    },

    setterName: function(varName) {
	return "set" + varName;
    },

    set: function(varName, value) {
	var method = this[this.setterName(varName)]
	if (!method) throw new Error(this.setterName(varName) + " not present");
	return method.call(this, varName, value);
    },

    makePlugSpecFromPins: function(pinList) {
	var spec = { model: this};
	pinList.forEach(function(decl) {
	    if (!decl.startsWith('-')) { // not read-only
		var stripped = decl.startsWith('+') ? decl.slice(1) : decl;
		spec[this.setterName(stripped)] = this.setterName(stripped);
	    }
	    if (!decl.startsWith('+')) { // not write-only
		var stripped = decl.startsWith('-') ? decl.slice(1) : decl;
		spec[this.getterName(stripped)] = this.getterName(stripped);
	    }
	}, this);
	return spec;
    },

    makePlugSpec: function() {
	// make a plug of the form {model: this, getVar1: "getVar1", setVar1: "setVar1" .. }
	var spec = {model: this};
	this.variables().forEach(function(v) { 
	    var name = this.getterName(v);
	    spec[name] = name;
	    name = this.setterName(v);
	    spec[name] = name;
	}, this);
	return spec;
    },

    variables: function() {
	return Properties.own(this).filter(function(name) { return name != 'dependents'});
    }
});


Morph.addMethods({

	exportLinkedFile: function(filename) {
		var url;
		if (Global["WikiNavigator"] && WikiNavigator.current) {
			var nav = WikiNavigator.current;
			url = WikiNavigator.fileNameToURL(filename);
			nav.interactiveSaveWorld(url);
		} else {
			url = WorldMorph.current().saveWorld(filename);
		}
		if (url) this.world().reactiveAddMorph(new ExternalLinkMorph(url));
		return url;
	}

});


// ===========================================================================
// World-related widgets
// ===========================================================================

// A unique characteristics of the Morphic graphics system is that
// all the objects (morphs) live in a "world" that is shared between 
// different objects and even between different users.  A world can
// contain a large number of different applications/widgets, much like
// in an operating system a folder can contain a lot of files.  Worlds
// can be linked to each other using LinkMorphs.  As a consequence,
// the entire system can contain a large number of worlds, each of
// which contains a large number of simultaneously running applications
// and widgets. 

Morph.subclass("PasteUpMorph", {

    documentation: "used for layout, most notably the world and, e.g., palettes",

    initialize: function($super, bounds, shapeType) {
        return $super(bounds, shapeType);
    },
    
	captureMouseEvent: function PasteUpMorph$captureMouseEvent($super, evt, hasFocus) {
		if (evt.type == "MouseDown" && this.onMouseDown(evt)) return;
		if (evt.type == "MouseWheel" && this.onMouseWheel(evt)) return;
		$super(evt, hasFocus); 
	},

	onMouseDown: function PasteUpMorph$onMouseDown($super, evt) {  //default behavior is to grab a submorph
		$super(evt);
		var m = this.morphToReceiveEvent(evt);
		if (false && m instanceof HandleMorph) { // Verify handles work with pie menus, then delete
			m.onMouseDown(evt);  // fixme
			return true;
		}
		if (Config.usePieMenus) {
			if (m.handlesMouseDown(evt)) return false;
			m.showPieMenu(evt, m);
			return true;
		}
		if (m == null) { 
			this.makeSelection(evt); 
			return true; 
		} else if (!evt.isCommandKey() && evt.isLeftMouseButtonDown()) {
			if (m === this.world()) { 
				this.makeSelection(evt); 
				return true; 
			} else if (m.handlesMouseDown(evt)) 
				return false;
		}
		evt.hand.grabMorph(m, evt);
		return true; 
	},


	bounds: function($super, ignoreTransients, ignoreTransform) {
		return $super(ignoreTransients, true);
	},
	
	onMouseWheel: function(evt) {
		if (!evt.isCommandKey()) return false;
		evt.preventDefault();

		var oldScale = this.getScale();
		var wheelDelta = evt.wheelDelta();
		var minScale = 0.1, maxScale = 50;
		if (oldScale < minScale && wheelDelta < 0) return false;
		if (oldScale > maxScale && wheelDelta > 0) return false;
		var scaleDelta = 1 + evt.wheelDelta() / 10000;
		this.scaleBy(scaleDelta);

		// actually this should be a layoutChanged but implementing
		// layoutChanged in WorldMorph is expensive since it is always called when a
		// submorph's layout is changed (owner chain propagation)
		this.resizeCanvasToFitWorld();
		
		// Zoom into/out of the current mouse position:
		// p is the current mouse position. If we wouldn't move the window the new mouse pos would be scaledP.
		// We calculate the vector from scaledP to p and scale that by the current scale factor
		// We end up with a vector that can be used to scroll the screen to zoom in/out
		var p = evt.point();
		var scaledP = p.scaleBy(1/scaleDelta);
		var translatedP = p.subPt(scaledP).scaleBy(this.getScale());
		window.scrollBy(translatedP.x, translatedP.y)

		return true
	},
	
    okToBeGrabbedBy: function(evt) {
        // Paste-ups, especially the world, cannot be grabbed normally
        return null; 
    },

	makeSelection: function(evt) {	//default behavior is to grab a submorph
		if (this.world().currentSelection != null) this.world().currentSelection.removeOnlyIt();
		
		var m = new SelectionMorph(evt.point().asRectangle());
		this.world().currentSelection = m;
		
		this.world().addMorph(m);
		var handle = new HandleMorph(pt(0,0), lively.scene.Rectangle, evt.hand, m, "bottomRight");
		handle.setExtent(pt(0, 0));
    handle.focusHaloBorderWidth = 0; // added by Adam; the halo looks weird
		handle.mode = 'reshape';
		m.addMorph(handle);
		evt.hand.setMouseFocus(handle);
		evt.hand.setKeyboardFocus(handle);
	},


    
});

(function initDisplayThemes() {
namespace('lively.Text');

if (!Global.DisplayThemes)
	Global.DisplayThemes = {};

DisplayThemes['lively'] = using(lively.paint).link({
	styleName: 'lively',
	raisedBorder: { // conenience grouping
		//borderWidth: 2,
		borderColor: {$:"LinearGradient", 
			stops: [{$:"Stop", offset: 0, color: Color.lightGray}, 
					{$:"Stop", offset: 1, color: Color.darkGray.darker(3)}],
			vector: lively.paint.LinearGradient.SouthEast
		}
	},
	titleBar: { 
		borderRadius: 8, 
		borderWidth: 2, 
		bordercolor: Color.black,
		fill: {$:"LinearGradient", 
			stops: [{$:"Stop", offset: 0.0, color: Color.primary.blue.lighter()},
					{$:"Stop", offset: 0.5, color: Color.primary.blue},
					{$:"Stop", offset: 1.0, color: Color.primary.blue.lighter(2)}], 
			vector: lively.paint.LinearGradient.SouthNorth 
		}
	},
	slider: { 
		borderColor: Color.black, 
		borderWidth: 1, 
		fill: {$: "LinearGradient", 
			stops: [{$:"Stop", offset: 0, color: Color.primary.blue.lighter(2)},
					{$:"Stop", offset: 1, color: Color.primary.blue}]
		}
	},
	button: { 
		borderColor: Color.neutral.gray, 
		borderWidth: 0.3, borderRadius: 4,
		fill: {$:"LinearGradient", 
			stops: [{$:"Stop", offset:0, color:Color.darkGray}, 
					{$:"Stop", offset:1, color: Color.darkGray.lighter(2)}],
			vector: lively.paint.LinearGradient.SouthNorth }
	},
	widgetPanel: { 
		borderColor: Color.blue, 
		borderWidth: 4, 
		borderRadius: 16,
		fill: Color.blue.lighter(), opacity: 0.4
	},
	clock: { 
		borderColor: Color.black, borderWidth: 4,
		fill: {$:"RadialGradient", 
			stops: [{$:"Stop", offset: 0, color:Color.primary.blue.lighter(2)}, 
					{$:"Stop", offset: 1, color:Color.primary.blue.lighter()} ]}
	},
	panel: {
		fill: Color.primary.blue.lighter(2), 
		borderWidth: 2, 
		borderColor: Color.black
	},
	link: {
		borderColor: Color.green, 
		borderWidth: 1, 
		fill: Color.blue
	},
	helpText: { 
		borderRadius: 15, 
		fill: Color.primary.yellow.lighter(3), 
		fillOpacity: .8
	},
	fabrik: {
		borderColor: Color.gray.darker(), 
		borderWidth: 1.0 , 
		borderRadius: 2,
		fill: Color.gray, 
		opacity: 1
	},
	world: {
		fill: {	$:"LinearGradient", 
			stops: [{$:"Stop", offset: 0.00, color: Color.primary.blue.lighter()},
					{$:"Stop", offset: 0.25, color: Color.primary.blue},
					{$:"Stop", offset: 0.50, color: Color.primary.blue.lighter()},
					{$:"Stop", offset: 0.75, color: Color.primary.blue},
					{$:"Stop", offset: 1.00, color: Color.primary.blue} ]}

	}
})

})() // initDisplayThemes


PasteUpMorph.subclass("WorldMorph", {
    
    documentation: "A Morphic world (a visual container of other morphs)",
    fill: Color.primary.blue,
    defaultExtent: pt(1280, 1024),
	styleClass: ['world'],
	
    // Default theme for the theme manager    

	initialize: function($super, canvas, backgroundImageId) {
		var bounds = Rectangle.fromElement(canvas);
		// sometimes bounds has zero dimensions (when reloading thes same page, timing issues?
		// in Firefox bounds may be 1x1 size?? maybe everything should be run from onload or sth?
		if (bounds.width < 2) {
			bounds.width = this.defaultExtent.x;
		}

		if (bounds.height < 2) {
			bounds.height = this.defaultExtent.y;
		}

		if (backgroundImageId) {
			var background = NodeFactory.create("use");
			XLinkNS.setHref(background, backgroundImageId);
			this.addNonMorph(background);
		}
		$super(new lively.scene.Rectangle(bounds));

		this.setDisplayTheme(this.displayTheme); // apply display theme

		//gradient.rawNode.setAttributeNS(null, "gradientTransform", "translate(0, -0.1) skewY(10)");		     
		this.enterCount = 0;
	},

	doNotSerialize: ['hands', 'scheduledActions', 'lastStepTime', 'mainLoop', 'worldId', 'secondTick', 'currentScript', 'currentSelection' ],

    initializeTransientState: function($super) {
        $super();
        this.hands = [];
		
		var theme = DisplayThemes[Config.defaultDisplayTheme];
		if (!theme)
			console.log('ERROR: could not find Theme ' + Config.defaultDisplayTheme)
		this.displayTheme = theme; // set display them without applying it
		
		this.withAllSubmorphsDo( function() { this.layoutChanged(); });  // Force installation of transforms

        this.scheduledActions = [];  // an array of schedulableActions to be evaluated
        this.lastStepTime = (new Date()).getTime();
        this.mainLoopFunc = this.doOneCycle.bind(this).logErrors('Main Loop');
        this.mainLoop = Global.setTimeout(this.mainLoopFunc, 30);
        this.worldId = ++WorldMorph.worldCount;

        return this;
    },

	collectAllUsedFills: function($super, usedFills) {
		usedFills = $super(usedFills);
		Properties.forEachOwn(this.displayTheme,  function(ea) {
			var style = this[ea]
			if (style && (style.fill  instanceof lively.paint.Gradient)) {
				usedFills.push(style.fill);
			} 
		}.bind(this.displayTheme))
		return usedFills
	},
    
	remove: function() {
		if (!this.rawNode.parentNode) return null;  // already removed
		this.stopStepping();
		this.removeRawNode();
		return this;
	},

	// called by insertMorph to determine the rawNode after the new inserted morph
	getInsertPositionFor: function(m, isFront) {
		if (this.submorphs.length == 0) return this.hands.length > 0 ? this.hands[0].rawNode : null;
		return isFront ? this.submorphs.last().rawNode.nextSibling : this.submorphs.first().rawNode;
	},
	
	toggleNativeCursor: function(flag) {
		this.canvas().setAttributeNS(null, "cursor", flag ? "auto" : "none");
	},

	resizeCanvasToFitWorld: function() {
		var canvas = this.canvas();
		if (!canvas) return;
		this.transformChanged();
		this.fullBounds = null;
		if (canvas.clientWidth != this.bounds().width)
			canvas.setAttribute("width", this.bounds().width + canvas.offsetLeft * this.getScale());
		if (canvas.clientHeight != this.bounds().height)
			canvas.setAttribute("height", this.bounds().height + canvas.offsetTop * this.getScale());
	},

	displayOnCanvas: function(canvas) {
		// this.remove();
		if (this.rawNode.parentNode !== canvas) canvas.appendChild(this.rawNode);
		var hand = this.addHand(new HandMorph(true));
		WorldMorph.currentWorld = this; // this conflicts with mutliple worlds
		reflect(WorldMorph).slotAt('currentWorld').beCreator(); // aaa - kind of a hack, added by Adam so that we can file out morphs
		if (Config.resizeScreenToWorldBounds)
			this.resizeCanvasToFitWorld(this);
		this.onEnter(); 

		this.enterCount ++;
	},

  // added by Adam
  ownerLocalize: function(pt) {
		if (pt == null) console.log('null pt in ownerLocalize');   
		return pt.matrixTransform(this.getTransform());
  },
    
	addHand: function(hand) {
		if (this.hands.length > 0 && !this.hands.first())
			this.hands.shift(); // FIXME: Quick bugfix. When deserializing the world the hands.first() is sometimes undefined
		this.hands.push(hand);
		hand.owner = this;
		hand.registerForEvents(this);
		hand.registerForEvents(hand);
		hand.layoutChanged();

		Event.keyboardEvents.forEach(function(each) {
			document.documentElement.addEventListener(each, hand, hand.handleOnCapture);
		});

		this.rawNode.appendChild(hand.rawNode);
		return hand;
	},
    
	removeHand: function(hand) {
		hand.setMouseFocus(null); // cleanup, just in case
		hand.setKeyboardFocus(null); // cleanup (calls blur(), which will remove the focus halo)
		hand.removeRawNode();
		hand.unregisterForEvents(this);
		hand.unregisterForEvents(hand);

		Event.keyboardEvents.forEach(function(each) {
			document.documentElement.removeEventListener(each, hand, hand.handleOnCapture);
		});

		this.hands.splice(this.hands.indexOf(hand), 1);
	},


    toggleBalloonHelp: function() {
        Morph.prototype.suppressBalloonHelp = !Morph.prototype.suppressBalloonHelp;
    },

    toggleDebugBackground: function() {
        // Debug background is transparent, so that we can see the console
        // if it is not otherwise visible
        Config.useDebugBackground = !Config.useDebugBackground;
        this.shape.setFillOpacity(Config.useDebugBackground ? 0.8 : 1.0);
    },

    chooseDisplayTheme: function(evt) { 
        var themes = DisplayThemes;
        var target = this; // trouble with function scope
        var themeNames = Properties.own(themes);
        var items = themeNames.map(
            function(each) { return [each, target, "setDisplayTheme", themes[each]]; });
        var menu = new MenuMorph(items, this);
        menu.openIn(this.world(), evt.point());
    },
    
    setDisplayTheme: function(styleDict) { 
        this.displayTheme = styleDict;
        this.withAllSubmorphsDo( function() { this.applyLinkedStyles(); });
    },
    
    restart: function() {
        window.location && window.location.reload();
    },

    
    layoutChanged: function() {
	// do nothing
    },

    layoutOnSubmorphLayout: function() {
	return false;
    },
    
    world: function() { 
        return this; 
    },
    
    validatedWorld: function() { 
        return this; 
    },
    
    firstHand: function() {
        return this.hands[0];
    },
    
    moveBy: function(delta) { // don't try to move the world
    },
    
    //  *** The new truth about ticking scripts ***
    //  A morph may have any number of active scripts
    //  Each is activated by a call such as
    //      this.startStepping(50, "rotateBy", 0.1);
    //  Note that stepTime is in milliseconds, as are all lower-level methods
    //  The arguments are: stepTime, scriptName, argIfAny
    //  This in turn will create a SchedulableAction of the form
    //  { actor: aMorph, scriptName: "rotateBy", argIfAny: 0.1, stepTime: 50, ticks: 0 }
    //  and this action will be both added to an array, activeScripts in the morph,
    //  and it will be added to the world's scheduledActions list, which is an array of
    //  tuples of the form [msTimeToRun, action]
    //  The ticks field is used to tally ticks spent in each schedulableAction --
    //  It is incremented on every execution, and it is multiplied by 0.9 every second
    //  Thus giving a crude 10-second average of milliseconds spent in this script
    //  every 10 seconds.  The result is divided by 10 in the printouts.
    //
    //  The message startSteppingScripts can be sent to morphs when they are placed in the world.
    //  It is intended that this may be overridden to start any required stepping.
    //  The message stopStepping will be sent when morphs are removed from the world.
    //  In this case the activeScripts array of the morph is used to determine exactly what
    //  scripts need to be unscheduled.  Note that startSteppingScripts is not sent
    //  automatically, whereas stopStepping is.  We know you won't forget to 
    //  turn your gadgets on, but we're more concerned to turn them off when you're done.

    scheduleForLater: function(action, delayInMs, removePrior) {
        if (removePrior) this.stopSteppingFor(action, true);  // unschedule earlier
        this.scheduleAction(new Date().getTime() + delayInMs, action);
    },
    
    startSteppingFor: function(action) {
        if (!action.scriptName)
	    throw new Error("old code");
        // New code for stepping schedulableActions
        this.stopSteppingFor(action, true);  // maybe replacing arg or stepTime
        this.scheduleAction(new Date().getTime(), action);
    },
    
    stopSteppingFor: function(action, fromStart) { // should be renamed to unschedule()
        // fromStart means it is just getting rid of a previous one if there,
	    // so not an error if not found

        if (this.currentScript === action) {
		    // Not in queue; just prevent it from being rescheduled
		    this.currentScript = null;
		    return;
		};

		this.scheduledActions = this.scheduledActions.reject(function(ea) {
			var eaAction = ea[1]
			return action.equalActorAndName(eaAction)
		})
    },

 	stopSteppingScriptNamedAndRemoveFromSubmorphs: function(sName) {
		if (!this.activeScripts) return;
		var all =this.activeScripts.select(function (ea) { return ea.scriptName == sName });
		all.invoke('stop', this.world());
		all.each(function(ea) {this.removeMorph(ea);}.bind(this));//remove
		this.activeScripts = this.activeScripts.select(function (ea) { return ea.scriptName !== sName });	
		if (this.activeScripts.length == 0) this.activeScripts = null;
    },
    
    validateScheduler: function() {
        // inspect an array of all the actions in the scheduler.  Note this
        // is not the same as scheduledActions which is an array of tuples with times
	var list = this.scheduledActions.clone();  // shorthand
        for (var i = 0; i < list.length; i++) {
            var actn = list[i][1];
            if (actn.actor instanceof Morph && actn.actor.validatedWorld() !== this) {
                this.stopSteppingFor(actn)
            }
        }
    },

    inspectScheduledActions: function() {
        // inspect an array of all the actions in the scheduler.  Note this
        // is not the same as scheduledActions which is an array of tuples with times
        new SimpleInspector(this.scheduledActions.map(function(each) { return each[1]; })).open();
    },

    doOneCycle: function WorldMorph$doOneCycle(world) {
        // Process scheduled scripts

        // Run through the scheduledActions queue, executing those whose time has come
        // and rescheduling those that have a repeatRate
        // Note that actions with error will not get rescheduled
        // (and, unless we take the time to catch here, will cause all later 
        // ones in the queue to miss this tick.  Better less overhead, I say
        // DI: **NOTE** this needs to be reviewed for msClock rollover
        // -- also note we need more time info for multi-day alarm range
        // When we do this, I suggest that actions carry a date and msTime
        // and until their day is come, they carry a msTime > a day
        // That way they won't interfere with daily scheduling, but they can
        // still be dealt with on world changes, day changes, save and load.
	var msTime = new Date().getTime();
	var timeOfNextStep = Infinity;
        var list = this.scheduledActions;  // shorthand
        var timeStarted = msTime;  // for tallying script overheads
	while (list.length > 0 && list[list.length - 1][0] <= msTime) {
            var schedNode = list.pop();  // [time, action] -- now removed
            var action = schedNode[1];
            this.currentScript = action; // so visible from stopStepping
            lively.lang.Execution.resetDebuggingStack();  // Reset at each tick event
	    try {
                action.exec();
            } catch (er) {
                console.warn("error on actor %s: %s", action.actor, er);
                dbgOn(true);
                lively.lang.Execution.showStack();
		timeStarted = new Date().getTime();
		continue;
            }
            // Note: if error in script above, it won't get rescheduled below (this is good)
	    
            // Note: stopStepping may set currentScript to null so it won't get rescheduled
            if (this.currentScript && action.stepTime > 0) {
                var nextTime = msTime + action.stepTime;
                this.scheduleAction(nextTime, action)
            }
            this.currentScript = null;

            var timeNow = new Date().getTime();
            var ticks = timeNow - timeStarted;
            if (ticks > 0) action.ticks += ticks;  // tally time spent in that script
            timeStarted = timeNow;
        }
	//  Generate a mouseMove if any ticking scripts have run so that
	//  simulations can respond where, eg, a morph moves under the mouse
	//  DI:  This is *only* needed for the slide-keyboard-under-mouse demo (very cool)
	//	Uses extra cycles, though, and currently fails in Opera
	if(Config.nullMoveAfterTicks) { // set this true in localConfig for the demo
		var myHand = this.firstHand();
		if (myHand) myHand.makeANullMove();
	}
        if (list.length > 0) timeOfNextStep = Math.min(list[list.length-1][0], timeOfNextStep);

        // Each second, run through the tick tallies and mult by 0.9 to 10-sec "average"
        if (!this.secondTick) this.secondTick = 0;
        var secondsNow = Math.floor(msTime / 1000);
        if (this.secondTick != secondsNow) {
            this.secondTick = secondsNow;
            var tallies = {};
            for (var i=0; i<list.length; i++) {
                var action = list[i][1];
                tallies[action.scriptName] = action.ticks;
                action.ticks *= 0.9 // 10-sec decaying moving window
            }
            if (Config.showSchedulerStats && secondsNow % 10 == 0) {
                console.log('New Scheduler length = ' + this.scheduledActions.length);
                console.log('Script timings...');  // approx ms per second per script
                for (var p in tallies) console.log(p + ': ' + (tallies[p]/10).toString());
            }
        }
        this.lastStepTime = msTime;
        this.setNextStepTime(timeOfNextStep);
    },

    setNextStepTime: function(timeOfNextStep) {
        if (timeOfNextStep == Infinity) { // didn't find anything to cycle through
            this.mainLoop = null; 
        } else {
            this.mainLoop = Global.setTimeout(this.mainLoopFunc, timeOfNextStep - this.lastStepTime);
        }
    },

    kickstartMainLoop: function() {
        // kickstart the timer (note arbitrary delay)
        this.mainLoop = Global.setTimeout(this.mainLoopFunc, 10);
    },

    scheduleAction: function(msTime, action) { 
        // Insert a SchedulableAction into the scheduledActions queue

        var list = this.scheduledActions;  // shorthand
        for (var i=list.length-1; i>=0; i--) {
            var schedNode = list[i];
            if (schedNode[0] > msTime) {
                list.splice(i+1, 0, [msTime, action]);
                if (!this.mainLoop) this.kickstartMainLoop();
                return; 
            }
        }
        list.splice(0, 0, [msTime, action]);
        if (!this.mainLoop) this.kickstartMainLoop();
    },

    onEnter: function() {},
    onExit: function() {},

    /**
     * override b/c of parent treatement
     */
    relativize: function(pt) { 
        return pt;
        //return pt.matrixTransform(this.rawNode.parentNode.getTransformToElement(this.rawNode)); 
    },
    
	openURLasText: function(url, title) {
		// FIXME: This should be moved with other handy services like confirm, notify, etc		
		var pane = this.addTextWindow({content: "fetching ... ", title: title});
		var r = new WebResource(url);
		lively.bindings.connect(r, 'content', pane.innerMorph(), 'setTextString');
		r.beAsync().get();
		
	},

	viewport: function() {
		try {
			return Rectangle.ensure(this.canvas().viewport);
			} catch (er) { // FF doesn't implement viewport ?
			return this.shape.bounds();
		}
	},

	alert: function(varargs) {
		var message = Strings.formatFromArray($A(arguments));
		var openDialog = function() {
			alert(message)
		};
		this.setStatusMessage(message, Color.red, undefined, openDialog, undefined, "alert: ")
	}.logErrors('alert'),

	prompt: function(message, callback, defaultInput) {
    // aaa: LK's prompt dialog thing seems (as of Feb. 2009) to be broken.
    // I doubt it's hard to fix, but for now I don't wanna get distracted by it. -- Adam
    callback.call(window, prompt(message, defaultInput));
    return;

		var model = Record.newPlainInstance({Message: message, Input: defaultInput || "", Result: null});
		model.addObserver({ 
			onResultUpdate: function(value) { 
				if (value == true && callback) callback.call(Global, model.getInput());
			}
		});
		var dialog = new PromptDialog(model.newRelay({Message: "-Message", Result: "+Result", Input: "Input"}));
		var window = dialog.openIn(this, pt(0,0));
		window.setPosition(this.positionForNewMorph(window));
	},

    editPrompt: function(message, callback, defaultInput) {
		var dialog = new PromptDialogMorph();
		dialog.title = message;
		dialog.setText(defaultInput);
		dialog.callback = callback;
		dialog.openIn(this, this.positionForNewMorph(dialog));
    },

	confirm: function(message, callback) {
		var model = Record.newPlainInstance({Message: message, Result: null});
		model.addObserver({ 
			onResultUpdate: function(value) { 
				if (value && callback) callback.call(Global, value);
			}});
		var dialog = new ConfirmDialog(model.newRelay({Message: "-Message", Result: "+Result"}));
		var window = dialog.openIn(this, pt(0,0));
		window.setPosition(this.positionForNewMorph(window));
		return dialog;
	},
    
	addFramedMorph: function(morph, title, optLoc, optSuppressControls) {
		var displ = pt(5, 5);
		return this.addMorphAt(
			new WindowMorph(morph, title, optSuppressControls), 
			optLoc || this.positionForNewMorph(morph).subPt(displ));
	},

	addTextWindow: function(spec) {
		// FIXME: typecheck the spec 
		if (Object.isString(spec.valueOf())) spec = {content: spec}; // convenience
		var extent = spec.extent || pt(500, 200);
		var pane = this.internalAddWindow(
				newTextPane(extent.extentAsRectangle(), spec.content || ""),
				spec.title, spec.position);
		if (spec.acceptInput !== undefined) pane.innerMorph().acceptInput = spec.acceptInput;
		if (spec.plug) pane.connectModel(spec.plug, true);
		return pane;
	},

	addTextListWindow: function(spec) {
		// FIXME: typecheck the spec 
		if (spec instanceof Array) spec = {content: spec }; // convenience
		var content = spec.content;
		if (!content) content = "";
		if (!(content instanceof Array)) content = [content];
		var extent = spec.extent || pt(500, Math.min(300, content.length * TextMorph.prototype.fontSize * 1.5));
		var rec = extent.extentAsRectangle();
		var pane = this.internalAddWindow(newTextListPane(rec, content), spec.title, spec.position);
		if (spec.plug) pane.connectModel(spec.plug, true);
		return pane;
	},

	internalAddWindow: function(pane, titleSpec, posSpec) {
		var pos = (posSpec instanceof Point) ? posSpec : undefined;
		pane.setBorderWidth(2);  pane.setBorderColor(Color.black);
		var win = this.addFramedMorph(pane, String(titleSpec || ""), pos || this.firstHand().position().subPt(pt(5, 5)));
		if (posSpec == "center") {
			win.align(win.bounds().center(), this.viewport().center());
		}
		return pane;
	},


	addMorphFrontOrBack: function($super, m, front) {
		var oldTop = this.topWindow();
		var result = $super(m, front);
		if (!front || !(m instanceof WindowMorph)) return result;
		// if adding a new window on top, then make it active
		if (oldTop) oldTop.titleBar.highlight(false);
		m.takeHighlight();
		return result;
	},

	topWindow: function() {
		for (var i= this.submorphs.length - 1; i >= 0; i--) {
			var sub = this.submorphs[i];
			if (sub instanceof WindowMorph) return sub;
		}
		return null;
	},

	positionForNewMorph: function(newMorph, relatedMorph) {
		// this should be much smarter than the following:
		if (relatedMorph)
			return relatedMorph.bounds().topLeft().addPt(pt(5, 0));
		var pos = this.firstHand().getPosition();
		if (!newMorph) return pos;
		var viewRect = this.windowBounds();
		var newMorphBounds = pos.extent(newMorph.getExtent());
		if (viewRect.containsRect(newMorphBounds)) return pos;
		return viewRect.center().subPt(newMorphBounds.extent().scaleBy(0.5));
	},

	reactiveAddMorph: function(morph, relatedMorph) { 	// add morph in response to a user action, make it prominent
		return this.addMorphAt(morph, this.positionForNewMorph(morph, relatedMorph));
	},
    
    resizeByUser: function() {
      var world = this;
      var cb = function(newSizePtLiteral) {
    	  try {
    	    var newPoint = eval(newSizePtLiteral);
    	    basicResize(world, world.canvas(), newPoint.x, newPoint.y);
        } catch(e) {
    	    world.alert('Wrong input ' +  newSizePtLiteral);
  		  }
    	};
    	world.prompt('Enter extent', cb, world.bounds().bottomRight().toString());
    },

	addProgressBar: function(optPt) {
		var center = optPt || this.windowBounds().center()
		var progressBar = new ProgressBarMorph(new Rectangle(0,0, 450, 30))
		this.addMorph(progressBar);
		progressBar.align(progressBar.bounds().center(), center);
		progressBar.ignoreEvents();
		return progressBar
	},

});

// Give Feedback on Saving
WorldMorph.addMethods({

	promptAndSaveWorld: function() {
		this.prompt("world file (.xhtml)", function(filename) {
			var start = new Date().getTime();	
			this.exportLinkedFile(filename);
			var time = new Date().getTime() - start;
			this.setStatusMessage("world save as " + filename + " in " + time + "ms", Color.green, 3)	
		}.bind(this)); 
	},

	saveWorld: function(optURL) {
		optURL = optURL || URL.source.filename()
		var start = new Date().getTime();
		this.removeHand(this.firstHand());
		var url = Exporter.saveDocumentToFile(Exporter.shrinkWrapMorph(this.world()), optURL);
		this.addHand(new HandMorph(true));
		var time = new Date().getTime() - start;
		this.setStatusMessage("world saved to " + optURL + " in " + time + "ms", Color.green, 3)
		return url;
	},
	
	windowBounds: function() {
		var topLeft = pt(Global.pageXOffset, Global.pageYOffset);
		var width = Math.min(
			Global.document.documentElement.clientWidth * 1/this.world().getScale(),
			WorldMorph.current().getExtent().x);
		var height = Math.min(
			Global.document.documentElement.clientHeight * 1/this.world().getScale(),
			WorldMorph.current().getExtent().y)
		return topLeft.extent(pt(width, height))
	},
	
	visibleBounds: function() {
		var windowBounds = this.windowBounds();
		var worldBounds = this.shape.bounds(); // use shape so no stick-outs are included
		var upperLeft = pt(Math.max(windowBounds.x, worldBounds.x), Math.max(windowBounds.y, worldBounds.y));
		var lowerRight = pt(Math.min(windowBounds.width, worldBounds.width), Math.min(windowBounds.height, worldBounds.height));
		return upperLeft.extent(lowerRight);
	},

	setStatusMessage: function(msg, color, delay, callback, optStyle, messageKind) {
		if (!this._statusMorphContainer) {
			this._statusMorphContainer = new StatusMessageContainer();
			this.addMorph(this._statusMorphContainer);
			this._statusMorphContainer.startUpdate();		
		};
		var container = this._statusMorphContainer;
		container.align(container.bounds().topRight(), this.visibleBounds().topRight());
		container.name = "statusMorphContainer";
		container.bringToFront();
		container.addStatusMessage(msg, color, delay, callback, optStyle, messageKind);
	},	
});

/**
 *	WorldMorph Menu 
 *
 *  Question: Should features register itself in the menu, 
 *  or should the menu give an overview of available features 
 *  and load the modules on demand?
 */
WorldMorph.addMethods({
	morphMenu: function($super, evt) { 
		var menu = $super(evt);
		menu.keepOnlyItemsNamed(["inspect", "edit style"]);
		menu.addItems([['reset scale', function(evt) { var w = evt.hand.world(); w.setScale(1); w.resizeCanvasToFitWorld() }]]);

    // This world-navigation feature is usually very annoying, though occasionally very useful.
    // Keep it off by default until we find a non-annoying UI for it. -- Adam
    var navOn = this.shouldSlideIfClickedAtEdge;
    menu.addItem(["turn " + (navOn ? 'off' : 'on') + " world navigation", function(evt) {
      this.shouldSlideIfClickedAtEdge = !navOn;
    }.bind(this)]);
		
		menu.addLine();
		menu.addItems(this.subMenuItems(evt));
		menu.addLine();
		menu.addItems([
			["New subworld (LinkMorph)", function(evt) { evt.hand.world().addMorph(new LinkMorph(null, evt.point()));}],  
			["External link", function(evt) { evt.hand.world().addMorph(new ExternalLinkMorph(URL.source, evt.point()));}],
			["authenticate for write access", function() {
				new NetRequest().put(URL.source.withFilename('auth'));
				// sometimes the wikiBtn seems to break after an authenticate
				if (Config.showWikiNavigator) WikiNavigator.enableWikiNavigator(true); }],
			["publish world as ... ", function() { this.promptAndSaveWorld()}]
		]);
		if (Global.URL && (URL.source.filename() != "index.xhtml") ) { // Global. avoids an error if Network.js not loaded
			// save but only if it's not the startup world
			menu.addItem(["save current world to current URL", function() { 
				menu.remove(); 
				this.saveWorld();
			}]);
		}
		if(Config.debugExtras) {
			menu.addItem(["arm profile for next mouseDown", function() {evt.hand.armProfileFor("MouseDown") }]);
			menu.addItem(["arm profile for next mouseUp", function() {evt.hand.armProfileFor("MouseUp") }]);
		}
		menu.addItem(["resize world", this.resizeByUser]);
		menu.addItem(["restart system", this.restart]);
		return menu;
	},
	
	simpleMorphsSubMenuItems: function(evt) {
		var world = this.world();
		return [
			["Line", function(evt) { 
				var p = evt.point(); 
				var m = Morph.makeLine([p, p.addXY(60, 30)], 2, Color.black);
				world.addMorph(m);
				m.setPosition(evt.point())}],
			["Connector", function(evt) { 
				require('lively.Connector').toRun(function() {
					var m = Morph.makeConnector(evt.point())
					world.addMorph(m);
					m.setGlobalEndPos(evt.point().addXY(60, 30))
				})}],
			["Rectangle", function(evt) { world.addMorph(Morph.makeRectangle(evt.point(), pt(60, 30)));}],
			["Ellipse", function(evt) { world.addMorph(Morph.makeCircle(evt.point(), 25)); }],
			["TextMorph", function(evt) { 
				var text = new TextMorph(evt.point().extent(pt(120, 10)), "This is a TextMorph");
				world.addMorph(text);}],
			["Star",function(evt) { world.addMorph(Morph.makeStar(evt.point()))}],
			["Heart", function(evt) { world.addMorph(Morph.makeHeart(evt.point()))}],
			["Marker", function(evt) {world.addMorph(new MarkerMorph(evt.point().extent(pt(100, 100))))}]
		];
	},

	complexMorphsSubMenuItems: function(evt) {
		var world = this.world();
		return [
			["SliderMorph", function(evt) { world.addMorph(Widget.makeSlider(evt.point().extent(pt(120, 40))))}],
			["ButtonMorph", function(evt) { world.addMorph(new ScriptableButtonMorph(evt.point().extent(pt(70, 30))))}],
			["ProgressBarMorph", function(evt) { world.addMorph(new ProgressBarMorph(evt.point().extent(pt(70, 30))))}],
			["ScaleMorph", function(evt) { world.addMorph(new ScaleMorph(evt.point().extent(pt(70, 30))))}],
			["Clock", function(evt) {
				require('lively.Examples').toRun(function() {
					var m = world.addMorph(new ClockMorph(evt.point(), 50));
					m.startSteppingScripts();
					ChangeSet.current().addWorldRequirement('lively.Examples')
				})}],
			["FabrikClock", function(evt) {
				require('lively.Fabrik').toRun(function() {
					var clock = new FabrikClockWidget();
					var morph = clock.buildView();
					world.addMorph(morph);
					morph.setPosition(evt.point());
					morph.startSteppingScripts(); }); }],
			["Text Window", function(evt) { 
				WorldMorph.current().addTextWindow("Editable text"); }],
			["Piano Keyboard", function(evt) {
				require('lively.Examples').toRun(function() {
					var m = new PianoKeyboard(evt.point());
					m.scaleBy(1.5);	 m.rotateBy(-Math.PI*2/12);
					world.addMorph(m); }); }],
			["Kaleidoscope", function(evt) {
				require('lively.Examples').toRun(function() {
					var kal = WorldMorph.current().addMorph(new SymmetryMorph(300, 7)); 
					kal.startUp(); }) } ],
			["Image Morph", function(evt) {
				world.prompt('Enter image URL', function(urlString) {
					var img = new ImageMorph(evt.point().extent(pt(100,100)), urlString);
					img.openInWorld() }) }],
			["Video Morph", function(evt) {
				VideoMorph.openAndInteractivelyEmbed(evt.point()) }],
			["Layout Demo", function(evt) {
				require('lively.GridLayout').toRun(function() {
					GridLayoutMorph.demo(evt.hand.world(), evt.point()); }); }],
			["Effects demo (FF only)", function(evt) { require('lively.demofx').toRun(Functions.Empty); }],
			["PresentationPage", function(evt) { 
				require('lively.Presentation').toRun(function(){
					world.addMorph(new lively.Presentation.PageMorph(new Rectangle(0,0,800,600)))
				}); 
			}],
			// ["Duplicator Panel", function(evt) { 
			// 	require('lively.Graffle').toRun(function(){
			// 		world.addMorph(Morph.makeDefaultDuplicatorPanel(evt.point()))
			// 	}); 
			// }], 
			["FileUpload Morph", function(evt) { 
				require('lively.FileUploadWidget').toRun(function(){
					var morph = new FileUploadMorph();
					world.addMorph(morph)
					morph.setPosition(evt.point());
				}); 
			}],
		];
	},
	
	toolSubMenuItems: function(evt) {
		var world = this.world();
		var toolMenuItems = [
//			["Class Browser", function(evt) { new SimpleBrowser().openIn(world, evt.point()); }],
			["System code browser", function(evt) { require('lively.ide').toRun(function(unused, ide) {new ide.SystemBrowser().openIn(world)})}],
			["Local code Browser", function(evt) { require('lively.ide').toRun(function(unused, ide) {new ide.LocalCodeBrowser().openIn(world)})}],
			["Wiki code Browser", function(evt) { require('lively.ide', 'lively.LKWiki').toRun(function(unused, ide) {
				var cb = function(input) {
					var repo = new URL(input);
					new ide.WikiCodeBrowser(repo).open()
				};
				world.prompt('Wiki base URL?', cb, URL.source.getDirectory().toString());
				})}],
			["Switch System browser directory...", function(evt) { require('lively.ide').toRun(function(unused, ide) {
				var cb = function(input) {
					if (!input.endsWith('/')) input += '/';
					ide.startSourceControl().switchCodeBase(new URL(input));
				};
				world.prompt('Enter System browser directory (URL)', cb, URL.source.getDirectory().toString());
				})}],				
			["File Browser", function(evt) { new FileBrowser().openIn(world) }],
			["Object Hierarchy Browser", function(evt) { new ObjectBrowser().openIn(world); }],	
			["Enable profiling", function() {
					Config.debugExtras = true;
					lively.lang.Execution.installStackTracers(); }],
			["Console", function(evt) {world.addFramedMorph(new ConsoleWidget(50).buildView(pt(800, 100)), "Console"); }],
			["TestRunner", function(evt) { require('lively.TestFramework').toRun(function() { new TestRunner().openIn(world) }) }],
			["OMetaWorkspace", function(evt) { require('lively.Ometa').toRun(function() { new OmetaWorkspace().openIn(world); }) }],
			["Call Stack Viewer", function(evt) { 
			if (Config.debugExtras) lively.lang.Execution.showStack("use viewer");
			else new StackViewer(this).openIn(world); }],	  
			["FrameRateMorph", function(evt) {
				var m = world.addMorph(new FrameRateMorph(evt.point().extent(pt(160, 10)), "FrameRateMorph"));
				m.startSteppingScripts(); }],
			["EllipseMaker", function(evt) {
				var m = world.addMorph(new EllipseMakerMorph(evt.point()));
				m.startSteppingScripts(); }],
			["XHTML Browser", function(evt) { 
				var xeno = new XenoBrowserWidget('sample.xhtml');
				xeno.openIn(world); }],
			["Viewer for latest file changes", function(evt) {
			var cb = function(input) {
				require('lively.LKWiki').toRun(function(u,m) {
					var url = new URL(input);
					console.log(url);
					new LatestWikiChangesList(url).openIn(world);
			}); }
				world.prompt('Url to observe', cb, URL.source.getDirectory().toString()); 
			}]
		];

		if (Config.debugExtras) { var index = -1;
			for (var i=0; i<toolMenuItems.length; i++) if (toolMenuItems[i][0] == "Enable profiling") index = i;
				if (index >= 0) 
					toolMenuItems.splice(index, 1,
						["-----"],
						["Profiling help", function(evt) { this.openURLasText( URL.common.project.withRelativePath(
							"/trac/wiki/ProfilingHelp?format=txt"), "Profiling help"); }],
						["Arm profile for next mouseDown", function() {evt.hand.armProfileFor("MouseDown") }],
						["Arm profile for next mouseUp", function() {evt.hand.armProfileFor("MouseUp") }],
						["Disable profiling", function() {
							Config.debugExtras = false;
							lively.lang.Execution.installStackTracers("uninstall");	 }],
						["-----"]);
		};
		return toolMenuItems
	},

	scriptingSubMenuItems: function(evt) {
		var world = this.world();
		return [
			["TileScriptingBox", function(evt) { require('lively.TileScripting').toRun(function() {new lively.TileScripting.TileBox().openIn(world); }) }],
			["Fabrik Component Box", function(evt) { require('lively.Fabrik').toRun(function() { Fabrik.openComponentBox(world); }) }],
			["Webcards with name", function(evt) { require('apps.Webcards').toRun(function(){
					var sds = new SimpleDataStore(pt(600, 300));
					world.prompt("Name of stack:", sds.openStackWithName.bind(sds));
					world.addFramedMorph(sds, 'WebCards', pt(333, 222));
				}); 
			}],
         
		];
	},

	preferencesSubMenuItems: function(evt) {
		var world = this.world();
		return [
			[(Config.usePieMenus ? "don't " : "") + "use pie menus",
					  function() { Config.usePieMenus = !Config.usePieMenus; }],
			["choose display theme...", this.chooseDisplayTheme],
			[(Morph.prototype.suppressBalloonHelp ? "enable balloon help" : "disable balloon help"),
					  this.toggleBalloonHelp],
			[(HandMorph.prototype.useShadowMorphs ? "don't " : "") + "show drop shadows",
			  function () { HandMorph.prototype.useShadowMorphs = !HandMorph.prototype.useShadowMorphs}],
			[(Config.showGrabHalo ? "don't " : "") + "show bounds halos",
			  function () { Config.showGrabHalo = !Config.showGrabHalo}],
			[HandMorph.prototype.applyDropShadowFilter ? "don't use filter shadows" : "use filter shadows (if supported)",
			  function () { HandMorph.prototype.applyDropShadowFilter = !HandMorph.prototype.applyDropShadowFilter}],
			[(Config.useDebugBackground ? "use normal background" : "use debug background"),
					  this.toggleDebugBackground]
		];
	},

	helpSubMenuItems: function(evt) {
		var world = this.world();
		return	[
			["Connect documentation", function(evt) {
				require('lively.bindings').toRun(function() {
					world.openURLasText(new URL("http://lively-kernel.org/trac/wiki/ConnectHelp?format=txt"), "Connect documentation");
				})
			}],
			["Command key help", function(evt) {
				this.openURLasText(new URL("http://lively-kernel.org/trac/wiki/CommandKeyHelp?format=txt"), "Command key help"); }]
		];
	},
	
	subMenuItems: function(evt) {
		//console.log("mouse point == %s", evt.mousePoint);
		return [
			['Simple morphs', this.simpleMorphsSubMenuItems(evt)],
			['Complex morphs', this.complexMorphsSubMenuItems(evt)],
			['Tools', this.toolSubMenuItems(evt)],
			['Scripting', this.scriptingSubMenuItems(evt)],
			['Preferences', this.preferencesSubMenuItems(evt)],
			['Help', this.helpSubMenuItems(evt)]];
	},
	
	showPieMenu: function(evt) {
		var beTouchFn;
		if (UserAgent.isTouch) {
			if (Config.touchBeMouse) {
				// If we were in mouse mode; switch back to touch
				beTouchFn = function(e) {
					//ClipboardHack.ensurePasteBuffer().blur();
					Config.touchBeMouse = false; // currently not used
					// evt.hand.lookTouchy()
				};
			} else {
				// Otherwise, switch to mouse mode now (we just clicked in world)
				// ClipboardHack.ensurePasteBuffer().focus();
				Config.touchBeMouse = true; // currently not used
				// evt.hand.lookNormal()
				return;
			}
		}
		var menu, targetMorph = this;
		var items = [
			['make selection ([NE])', function(evt) { targetMorph.makeSelection(evt); }],
			['make selection ([SE])', function(evt) { targetMorph.makeSelection(evt); }],
			['make selection ([SW])', function(evt) { targetMorph.makeSelection(evt); }],
			((UserAgent.isTouch) ? ['use touch ((O))', beTouchFn]
				: ['make selection ([NW])', function(evt) { targetMorph.makeSelection(evt); }])
			];
		menu = new PieMenuMorph(items, this, 0, beTouchFn);
		menu.open(evt);
	}
 
})

Object.extend(WorldMorph, {    
    worldCount: 0,
    
    currentWorld: null,
    
    current: function() {
        return WorldMorph.currentWorld;
    }

    
});



/**
 * @class HandMorph
 * Since there may be multiple users manipulating a Morphic world
 * simultaneously, we do not want to use the default system cursor.   
 */ 

Morph.subclass("HandMorph", {
    
    documentation: "Defines a visual representation for the user's cursor.",
    applyDropShadowFilter: !!Config.useDropShadow,
    dropShadowFilter: "url(#DropShadowFilter)",
    useShadowMorphs: Config.useShadowMorphs,

    shadowOffset: pt(5,5),
    handleOnCapture: true,
    logDnD: Config.logDnD,
    grabHaloLabelStyle: {fontSize: Math.floor((Config.defaultFontSize || 12) *0.85), padding: Rectangle.inset(0)},

    initialize: function($super, local) {
        $super(new lively.scene.Polygon([pt(0,0), pt(10, 8), pt(4,9), pt(8,16), pt(4,9), pt(0, 12)]));
		this.applyStyle({fill: local ? Color.primary.blue : Color.primary.red, borderColor: Color.black, borderWidth: 1});
	
        this.isLocal = local;

        this.keyboardFocus = null;
        this.mouseFocus = null;
		this.mouseFocusChanges_ = 0; // count mouse focus changes until reset
        this.mouseOverMorph = null;
        this.lastMouseEvent = null;
        this.lastMouseDownPoint = pt(0,0);
        this.lastMouseDownEvent = null;
        this.hasMovedSignificantly = false;
        this.grabInfo = null;
        
        this.mouseButtonPressed = false;

        this.keyboardFocus = null; 

        this.priorPoint = null;
        this.owner = null;
		this.boundMorph = null; // surrounds bounds
		this.layoutChangedCount = 0; // to prevent recursion on layoutChanged
		
		this.setTrait("pointer-events", "none"); // added by Adam, needed to make HTML links clickable in XenoMorphs, hope it doesn't screw anything else up
		
		// added by Adam - I don't like seeing the hand morph, especially on a touch device
		this.setFill(null);
		this.setBorderWidth(0);
		this.setBorderColor(null);
		
        return this;
    },

  isHand: true, // added by Adam
  
	id: function() {
		if (!this.rawNode) {
			return undefined
		}
		return this.rawNode.getAttribute("id");
	},

    lookNormal: function(morph) {
        this.shape.setVertices([pt(0,0), pt(10, 8), pt(4,9), pt(8,16), pt(4,9), pt(0, 12)]);
    },
lookTouchy: function(morph) {
	// Make the cursor look polygonal to indicate touch events go to pan/zoom
	var n = 5, r = 10, theta = 2*Math.PI/n;
	var verts = [0, 1, 2, 3, 4, 0].map(function(i) { return Point.polar(r, i*theta).addXY(20,0) });
	this.shape.setVertices(verts);
    },


    lookLinky: function(morph) {
        this.shape.setVertices([pt(0,0), pt(18,10), pt(10,18), pt(0,0)]);
    },

	lookLikeAnUpDownArrow: function() {
		//       /\
		//     /_ _\
		//     _||_
		//    \   /
		//     \/
		var verts = [
			pt(8.0,0.0), pt(16.0,8.0), pt(12.0,8.0), pt(12.0,16.0), pt(16.0,16.0),
			pt(8.0,24.0), pt(0.0,16.0), pt(4.0,16.0), pt(4.0,8.0), pt(0.0,8.0)
		];
		this.shape.setVertices(verts);
	},

    registerForEvents: function(morph) {
        Event.basicInputEvents.forEach(function(name) { 
            morph.rawNode.addEventListener(name, this, this.handleOnCapture);}, this);
    },
    
    unregisterForEvents: function(morph) {
        Event.basicInputEvents.forEach(function(name) { 
            morph.rawNode.removeEventListener(name, this, this.handleOnCapture);}, this);
    },
    
    resetMouseFocusChanges: function() {
		var result = this.mouseFocusChanges_;
		this.mouseFocusChanges_ = 0;
		return result;
    },

    // added by Adam
    getMouseFocus:    function() { return this.mouseFocus    || null; },
    getKeyboardFocus: function() { return this.keyboardFocus || null; },
    
    setMouseFocus: function(morphOrNull) {
        //console.log('setMouseFocus: ' + morphOrNull);
		this.mouseFocus = morphOrNull;
		// this.setFill(this.mouseFocus ? Color.primary.blue.lighter(2) : Color.primary.blue);
		this.mouseFocusChanges_ ++;
    },
    
    setKeyboardFocus: function(morphOrNull) {
        if (this.keyboardFocus === morphOrNull) return;

        if (this.keyboardFocus != null) {
            // console.log('blur %s', this.keyboardFocus);
            this.keyboardFocus.onBlur(this);
            this.keyboardFocus.setHasKeyboardFocus(false);
        }
        
        this.keyboardFocus = morphOrNull; 
        
        if (this.keyboardFocus) {
            this.keyboardFocus.onFocus(this);
        }
    },
    
    world: function() {
        return this.owner;
    },

	// this is the DOM Event callback
	handleEvent: function HandMorph$handleEvent(rawEvt) {
		var evt = new Event(rawEvt);
		evt.hand = this;
		// console.log("event type = " + rawEvt.type);

		lively.lang.Execution.resetDebuggingStack();
		switch (evt.type) {
			case "MouseWheel":
			case "MouseMove":
			case "MouseDown":
			case "MouseUp":
				this.handleMouseEvent(evt);
				break;
			// touch and gesture stuff added by Adam
			case "TouchStart":
			case "TouchMove":
			case "TouchEnd":
			case "TouchCancel":
				this.handleTouchEvent(evt);
				break;
			case "GestureStart":
			case "GestureChange":
			case "GestureEnd":
				this.handleGestureEvent(evt);
				break;
			case "KeyDown":
			case "KeyPress": 
			case "KeyUp":
				this.handleKeyboardEvent(evt);
				break;
			default:
				console.log("unknown event type " + evt.type);
		}
		evt.stopPropagation();
		return;
		//return evt; // for touch development FIXME remove
	}.logErrors('Event Handler'),

    armProfileFor: function(evtType) { 
		this.profileArmed = evtType;  // either "MouseDown" or "MouseUp"
    },

	makeANullMove: function() {
		// Process a null mouseMove event -- no change in x, y
		// Allows simulations to respond where, eg, a morph moves under the mouse
		// Note: Fabrik generates also Mouse events with newFakeMouseEvent; to be merged
		var last = this.lastMouseEvent;
		if (!last) return;
		var nullMove = new Event(last.rawEvent);
		nullMove.type = "MouseMove";
		nullMove.hand = this;
		// console.log("last = " + Object.inspect(this.lastMouseEvent));
		// console.log("null = " + Object.inspect(nullMove));
		this.reallyHandleMouseEvent(nullMove);
		this.lastMouseEvent = last;  // Restore -- necess??
	},

	handleMouseEvent: function HandMorph$handleMouseEvent(evt) {
		if(!Config.debugExtras || !this.profileArmed || this.profileArmed != evt.type) {
			// Profile not armed or event doesnt match
			return this.reallyHandleMouseEvent(evt);
		}
		// Run profile during handling of this event
		this.profileArmed = null;  // Only this once
		var result;
		lively.lang.Execution.trace(function() { result = this.reallyHandleMouseEvent(evt) }.bind(this), this.profilingOptions );
		return result;
	},

	reallyHandleMouseEvent: function HandMorph$reallyHandleMouseEvent(evt) { 
		// console.log("reallyHandleMouseEvent " + evt + " focus " +  this.mouseFocus);
		
		// var rawPosition = evt.mousePoint;
		var world = this.owner;
		evt.mousePoint = evt.mousePoint.matrixTransform(world.getTransform().createInverse()); // for scaling
		evt.setButtonPressedAndPriorPoint(this.mouseButtonPressed, 
					  this.lastMouseEvent ? this.lastMouseEvent.mousePoint : null);
		//-------------
		// mouse move
		//-------------
		if (evt.type == "MouseMove" || evt.type == "MouseWheel") { // it is just a move
			this.setPosition(evt.mousePoint);
			
			if(evt.isShiftDown())
				this.alignToGrid();
			
			this.updateGrabHalo();
			
			if (evt.mousePoint.dist(this.lastMouseDownPoint) > 10) { 
				this.hasMovedSignificantly = true;
			}
			
			var shouldEnablePanningExperiment = true; // added by Adam
      if (shouldEnablePanningExperiment && world && evt.type == "MouseMove" && evt.isShiftDown() && evt.isMetaDown()) { // aaa or maybe it should just be Meta?
        if (this._panningStartPoint) {
          var v = this._panningStartPoint.subPt(evt.mousePoint);
          // console.log("Panning by " + v + "; start point was " + this._panningStartPoint + " and current mouse point is " + evt.mousePoint);
          world.slideBy(v);
        }
        this._panningStartPoint = evt.mousePoint;
        return true;
      } else {
        this._panningStartPoint = null;
      }
		  
			if (this.mouseFocus) { // if mouseFocus is set, events go to that morph
				this.mouseFocus.captureMouseEvent(evt, true);
			} else if (world) {
				var receiver = world.morphToReceiveEvent(evt);
				// console.log("found receiver: " + receiver)
				if (this.checkMouseOverAndOut(receiver, evt)) {	 // mouseOverMorph has changed...
					if (!receiver || !receiver.canvas()) return false;	// prevent errors after world-switch
					// Note if onMouseOver sets focus, it will get onMouseMove
					if (this.mouseFocus) this.mouseFocus.captureMouseEvent(evt, true);
					else if (!evt.hand.hasSubmorphs()) world.captureMouseEvent(evt, false); 
				} else if (receiver) {
					// gestureHandler stuff added by Adam, want to use Moousture for gestures
					if (UserAgent.isTouch && receiver.gestureHandler) {
						receiver.gestureHandler(evt.rawEvent);
					}
					receiver.captureMouseEvent(evt, false);
				}
			}
			this.lastMouseEvent = evt;
			return true;
		} 

	
		//-------------------
		// mouse up or down
		//-------------------
		if (!evt.mousePoint.eqPt(this.position())) { // Only happens in some OSes
			// and when window wake-up click hits a morph
			this.moveBy(evt.mousePoint.subPt(this.position())); 
		}

		this.mouseButtonPressed = (evt.type == "MouseDown") || (UserAgent.isTouch && evt.isTouchEvent());  // aaa - touch stuff added by Adam, not sure this is the right place for it
		this.setBorderWidth(this.mouseButtonPressed ? 2 : 1);
		evt.setButtonPressedAndPriorPoint(this.mouseButtonPressed, this.lastMouseEvent ? this.lastMouseEvent.mousePoint : null);
	
		if (this.mouseFocus != null) {
			if (this.mouseButtonPressed) {
				this.mouseFocus.captureMouseEvent(evt, true);
				this.lastMouseDownPoint = evt.mousePoint; 
			} else {
				this.mouseFocus.captureMouseEvent(evt, true);
			}
		} else {
			if (this.hasSubmorphs() && (evt.type == "MouseDown" || this.hasMovedSignificantly)) {
				// If laden, then drop on mouse up or down
				var m = this.topSubmorph();
				var receiver = world.morphToGrabOrReceiveDroppingMorph(evt, m);

				// Changed to make the morph go back if the drop fails. -- Adam
				if (receiver) {
					this.dropMorphsOn(receiver);
				} else {
					this.dropMorphsOn(world);
					if (m.shouldRevertAfterFailedDrop) {
						var previousOwner    = this.grabInfo[0];
						var previousPosition = this.grabInfo[1];
						m.ensureIsInWorld(world, previousPosition, true, true, false, function() {
							previousOwner.addMorph(m);
						});
					}
				}

				// aaa - not really sure this is a good idea, but I want double-click to work for putting back grabbed morphs -- Adam
				if (evt.isDoubleClick()) { m.onDoubleClick(evt); }
			} else {
				// console.log("hand dispatching event %s to owner %s", evt, this.owner);
				// This will tell the world to send the event to the right morph
				// We do not dispatch mouseup the same way -- only if focus gets set on mousedown
				if (evt.type == "MouseDown") world.captureMouseEvent(evt, false);
			}
			if (evt.type == "MouseDown") {
				this.lastMouseDownPoint = evt.mousePoint;
				this.lastMouseDownEvent = evt;
				this.hasMovedSignificantly = false; 
			}
		}
		this.lastMouseEvent = evt; 
		return true;
	},
	
    checkMouseUpIsInClickTimeSpan: function(mouseUpEvent) {
		// console.log("checkMouseUpIsInClickTimeSpan " + this.lastMouseDownEvent.timeStamp )
		if (!this.lastMouseDownEvent || !mouseUpEvent)
			return false;
		return (mouseUpEvent.timeStamp - this.lastMouseDownEvent.timeStamp) < (400)
	},

    checkMouseOverAndOut: function(newMouseOverMorph, evt) {
		if (newMouseOverMorph === this.mouseOverMorph) return false;

		// if over a new morph, send onMouseOut, onMouseOver
		if (this.mouseOverMorph) this.mouseOverMorph.onMouseOut(evt);
		this.mouseOverMorph = newMouseOverMorph;
		// console.log('msOverMorph set to: ' + Object.inspect(this.mouseOverMorph));
		if (this.mouseOverMorph) this.mouseOverMorph.onMouseOver(evt);
		return true;
	},
	
	// touch and gesture stuff added by Adam
	handleTouchEvent: function HandMorph$handleTouchEvent(evt) {
	  // console.log("handleTouchEvent of type " + evt.type);

    // aaa - WRONG, don't hard-code to use just the first touch
		var touch = evt.changedTouches()[0];
		if (!touch) { console.warn('Cannot setup touch event because cannot find touch!'); } else { evt.mousePoint = pt(touch.pageX || touch.clientX, touch.pageY || touch.clientY).subPt(evt.offset()); }

	  var world = this.world();
	  
		this.setPosition(evt.mousePoint);
		
		var touchedMorph = world.morphToReceiveEvent(evt);
		if (touchedMorph !== this._mostRecentlyTouchedMorph) {
		  if (this._mostRecentlyTouchedMorph) { this._mostRecentlyTouchedMorph.runAvocadoEventHandler('onTouchOut', evt); }
		  this._mostRecentlyTouchedMorph = touchedMorph;
		  if (this._mostRecentlyTouchedMorph) { this._mostRecentlyTouchedMorph.runAvocadoEventHandler('onTouchOver', evt); }
		}
    
		if (evt.type === "TouchStart") {
		  this.lastMouseDownEvent = evt;
		  this.hasMovedSignificantly = false;
		  
			if (touchedMorph && ((touchedMorph.owner && touchedMorph.owner.openForDragAndDrop) || touchedMorph.okToBeGrabbedBy(evt))) {
        this.grabMorph(touchedMorph, evt);
			}
		  
		  setTimeout(function() {
		    if (this.lastMouseDownEvent == evt) { // the user hasn't lifted his finger yet
  		    if (! this.hasMovedSignificantly) {
  		      // aaa - make this a "long touch" event and call some method on the _eventHandler or something
  		      this.dropMorphsOn(world);
    				var touchedMorph = world.morphToReceiveEvent(evt);
    				touchedMorph.showContextMenu(evt);
  		    }
		    }
		  }.bind(this), 750);

      if (touchedMorph) { touchedMorph.runAvocadoEventHandler('onTouchStart', evt); }
		} else if (evt.type === "TouchEnd") {
		  this.lastMouseDownEvent = null;
		  this.hasMovedSignificantly = false;
      this.dropMorphsOn(world);

      if (touchedMorph) { touchedMorph.runAvocadoEventHandler('onTouchEnd', evt); }
		} else if (evt.type === "TouchMove") {
			if (evt.mousePoint.dist(this.lastMouseDownEvent.mousePoint) > 10) { 
				this.hasMovedSignificantly = true;
			}

      if (touchedMorph) { touchedMorph.runAvocadoEventHandler('onTouchMove', evt); }
		} else if (evt.type === "TouchCancel") {
		  this.lastMouseDownEvent = null;
		  this.hasMovedSignificantly = false;
      this.dropMorphsOn(world); // aaa - should actually return them to their previous positions or something

      if (touchedMorph) { touchedMorph.runAvocadoEventHandler('onTouchCancel', evt); }
	  }
		
		evt.preventDefault();
  },

	handleGestureEvent: function HandMorph$handleGestureEvent(evt) {
	  // console.log("Got to handleGestureEvent, evt.type is " + evt.type + "; now what?");
		evt.preventDefault();
  },

    layoutChanged: function($super) {
		this.layoutChangedCount ++;
		try {
			$super();
			if (this.layoutChangedCount == 1) {
				Config.showGrabHalo && this.updateGrabHalo();
			}
		} finally {
			this.layoutChangedCount --;
		}
    },


    showAsGrabbed: function(grabbedMorph) {
		// At this time, there are three separate hand-effects:
		//  1. applyDropShadowFilter, if it works, will cause the graphics engine to put a nice
		//	   gaussian blurred drop-shadow on morphs that are grabbed by the hand
		//  2. showGrabHalo will cause a halo object to be put at the end of the hand's
		//	   submorph list for every grabbed morph (has property 'morphTrackedByHalo')
		//  3. useShadowMorphs will cause a shadowCopy of each grabbed morph to be put
		//	   at the end of the hand's submorph list (has property 'isHandMorphShadow')
		// So, if everything is working right, the hand's submorph list looks like:
		//	front -> Mc, Mb, Ma, Ha, Sa, Hb, Sb, Hc, Sc <- back [note front is last ;-]
		// Where M's are grabbed morphs, H's are halos if any, and S's are shadows if any

        if (this.applyDropShadowFilter) grabbedMorph.applyFilter(this.dropShadowFilter); 

		if (Config.showGrabHalo) {
		    var bounds = grabbedMorph.bounds(true);
		    var halo = this.addMorphBack(Morph.makeRectangle(bounds).applyStyle({fill: null, borderWidth: 0.5 }));
		    halo.morphTrackedByHalo = grabbedMorph;
		    halo.shape.setStrokeDashArray(String([3,2]));
		    halo.setLineJoin(lively.scene.LineJoins.Round);
		    halo.ignoreEvents();

		    var idLabel = new TextMorph(pt(20,10).extentAsRectangle(), String(grabbedMorph.id())).beLabel();
		    idLabel.applyStyle(this.grabHaloLabelStyle);
		    halo.addMorph(idLabel);
		    idLabel.align(idLabel.bounds().bottomLeft(), halo.innerBounds().topRight());
	    
		    var pos = grabbedMorph.getPosition();
		    var posLabel = new TextMorph(pt(20, 10).extentAsRectangle(), "").beLabel();
		    posLabel.applyStyle(this.grabHaloLabelStyle);
		    halo.positionLabel = halo.addMorph(posLabel);

			this.updateGrabHalo();
		}
        if (this.useShadowMorphs) {
			var shadow = grabbedMorph.shadowCopy();
			shadow.isHandMorphShadow = true;
			this.addMorphBack(shadow);
			shadow.moveBy(pt(8, 8));
		}
    },

    showAsUngrabbed: function(grabbedMorph) {
		if (this.applyDropShadowFilter) grabbedMorph.applyFilter(null);
    },
    
    alignToGrid: function() {
        if(!Config.showGrabHalo) return;
        var grid = function(a) {
            return a - (a % (Config.alignToGridSpace || 5))
		};
		this.submorphs.forEach(function(halo) {
		    if (halo.morphTrackedByHalo) { // this is a tracking halo
	        	if (!halo.orgSubmorphPosition)
			    halo.orgSubmorphPosition = halo.morphTrackedByHalo.getPosition();
			var oldPos = this.worldPoint(halo.orgSubmorphPosition);
			var gridPos = pt(grid(oldPos.x), grid(oldPos.y));
			halo.morphTrackedByHalo.setPosition(this.localize(gridPos));
		    }
		}.bind(this));
    },

    updateGrabHalo: function Morph$updateGrabHalo() {
		// Note there may be several grabHalos, and drop shadows as well
		// See the comment in showAsGrabbed 
		this.submorphs.forEach(function(halo) {
		    if (halo.morphTrackedByHalo) { // this is a tracking halo
				halo.setBounds(halo.morphTrackedByHalo.bounds(true).expandBy(3));
				if (halo.positionLabel) {
				    var pos = this.worldPoint(halo.morphTrackedByHalo.getPosition());
				    var posLabel = halo.positionLabel;
				    posLabel.setTextString(pos.x.toFixed(1) + "," + pos.y.toFixed(1));
				    posLabel.align(posLabel.bounds().bottomCenter(), halo.innerBounds().topLeft());
				}
		    }
		}.bind(this));
    },

	grabMorph: function(grabbedMorph, evt) { 
		if (evt.isShiftDown() && (evt.isAltDown() || evt.isMetaDown())) {
			grabbedMorph.dragMe(evt);
			return;
		}
		if (evt.isShiftDown() || (grabbedMorph.owner && grabbedMorph.owner.copySubmorphsOnGrab == true)) {
			if (!grabbedMorph.okToDuplicate()) return;
			grabbedMorph.copyToHand(this);
			return;
		}
		if (evt.isCommandKey() || evt.isRightMouseButtonDown() || evt.isMiddleMouseButtonDown()) {
			grabbedMorph.showMorphMenu(evt);
			return;
		}
		// Give grabbed morph a chance to, eg, spawn a copy or other referent
		grabbedMorph = grabbedMorph.okToBeGrabbedBy(evt);
		if (!grabbedMorph) return;

		if (grabbedMorph.owner && !grabbedMorph.owner.openForDragAndDrop) return;

		if (this.keyboardFocus && grabbedMorph !== this.keyboardFocus) {
			this.keyboardFocus.relinquishKeyboardFocus(this);
		}
		// console.log('grabbing %s', grabbedMorph);
		// Save info for cancelling grab or drop [also need indexInOwner?]
		// But for now we simply drop on world, so this isn't needed
		this.grabInfo = [grabbedMorph.owner, grabbedMorph.position()];
		if (this.logDnD) console.log('%s grabbing %s', this, grabbedMorph);
		this.addMorphAsGrabbed(grabbedMorph);
		// grabbedMorph.updateOwner(); 
		this.changed(); //for drop shadow
	},
    
    addMorphAsGrabbed: function(grabbedMorph) { 
        this.addMorph(grabbedMorph);
		this.showAsGrabbed(grabbedMorph);
    },
    
    dropMorphsOn: function(receiver) {
		if (receiver !== this.world()) 
			this.unbundleCarriedSelection();
		if (this.logDnD) 
			console.log("%s dropping %s on %s", this, this.topSubmorph(), receiver);
		this.carriedMorphsDo( function(m) {
			m.dropMeOnMorph(receiver);
			this.showAsUngrabbed(m);
		});
		this.shadowMorphsDo( function(m) { m.stopAllStepping(); });
		this.removeAllMorphs() // remove any shadows or halos
    },

    carriedMorphsDo: function(func) {
		// Evaluate func for only those morphs that are being carried,
		// as opposed to, eg, halos or shadows
		this.submorphs.clone().reverse().forEach(function(m) {
		    if (!m.morphTrackedByHalo && !m.isHandMorphShadow) func.call(this, m);
		}.bind(this));
    },

    shadowMorphsDo: function(func) { 
		// Evaluate func for only those morphs that are shadows,
		this.submorphs.clone().reverse().forEach(function(m) {
		    if (m.isHandMorphShadow) func.call(this, m);
		}.bind(this));
    },

    unbundleCarriedSelection: function() {
        // Unpack the selected morphs from a selection prior to drop or jump to other world
        if (!this.hasSubmorphs() || !(this.topSubmorph() instanceof SelectionMorph)) return;
        var selection = this.topSubmorph();
        for (var i=0; i<selection.selectedMorphs.length; i++) {
            this.addMorph(selection.selectedMorphs[i])
        }
        selection.removeOnlyIt();
    },

    moveSubmorphs: function(evt) {
        var world = this.world();
	
        // Display height is returned incorrectly by many web browsers.
        // We use an absolute Y-value instead. 
        var towardsPoint = pt(world.bounds().center().x, 350);

        switch (evt.getKeyCode()) {
        case Event.KEY_LEFT:
            this.submorphs.invoke('moveBy', pt(-10,0));
            evt.stop();
            return true;
        case Event.KEY_RIGHT:
            // forget the existing selection
            this.submorphs.invoke('moveBy', pt(10, 0));
            evt.stop();
            return true;
        case Event.KEY_UP:
            this.submorphs.invoke('moveBy', pt(0, -10));
            evt.stop();
            return true;
        case Event.KEY_DOWN:
            this.submorphs.invoke('moveBy', pt(0, 10));
            evt.stop();
            return true;

            // Experimental radial scrolling feature
            // Read the comments near method Morph.moveRadially()
        case Event.KEY_PAGEUP:
        case 65: // The "A" key
	    world.submorphs.invoke('moveRadially', towardsPoint, 10);
            this.moveRadially(towardsPoint, 10);            
            evt.stop();
            return true;
        case Event.KEY_PAGEDOWN:
        case 90: // The "Z" key
	    world.submorphs.invoke('moveRadially', towardsPoint, -10);
            this.moveRadially(towardsPoint, -10);            
            evt.stop();
            return true;
        }
        
        return false;
    },

    transformSubmorphs: function(evt) {
		var fun = null;
		switch (evt.getKeyChar()) {
			case '>':
				fun = function(m) { m.setScale(m.getScale()*1.1) };
				break;
			case '<':
				fun = function(m) { m.setScale(m.getScale()/1.1) };
				break;
			case ']':
				fun = function(m) { m.setRotation(m.getRotation() + 2*Math.PI/16) };
				break;
			case '[':
				fun = function(m) { m.setRotation(m.getRotation() - 2*Math.PI/16) };
				break;
		}
		if (fun) {
			this.submorphs.forEach(fun);
			evt.stop();
			return true;
		} else return false;
	},

	isKeyDown: function(character) {
		if (!this.keysDown)
			return false;
		return this.keysDown[character]
	},
	
	forgetKeyDown: function(evt) {
		if (!this.keysDown)
			return;
		this.keysDown[evt.getKeyChar()] = false;
		// hack, around weired events when command is pressed
		if (evt.getKeyCode() == 91) {
			// console.log("clear keydown list...")
			this.keysDown = {};
		
		};
	},

	rememberKeyDown: function(evt) {
		if (!this.keysDown) {
			this.keysDown = {};
		};
 		//console.log("remember KeyDown " + evt.getKeyChar())
		this.keysDown[evt.getKeyChar().toUpperCase()] = true;
	},

    handleKeyboardEvent: function(evt) {
  		// console.log("event: " + evt )
      
		if(evt.type == "KeyUp") {
 			this.forgetKeyDown(evt);			
		};
    
    // Experimenting with a menu idea that I learned from Richard Kulisz. -- Adam
    // http://www.c2.com/cgi/wiki?WheelMenu
    if (avocado.ui && avocado.ui.shouldEnableMouseFreeMenuExperiment) {
      if (evt.isAltDown()) {
        if (evt.getKeyCode() === 18) { // I think this means no other key is pressed, just Alt -- Adam
          evt.mousePoint = this.getPosition();
          var receiver = this.world().morphToReceiveEvent(evt);
          receiver.showContextMenu(evt);
          return;
        }
      }
      if (evt.isCtrlDown()) {
        if (evt.getKeyCode() === 17) { // I think this means no other key is pressed, just Ctrl -- Adam
          evt.mousePoint = this.getPosition();
          var receiver = this.world().morphToReceiveEvent(evt);
          receiver.showMorphMenu(evt);
          return;
        }
      }
    }
      
      
        if (this.hasSubmorphs())  {
            if (evt.type == "KeyDown" && this.moveSubmorphs(evt)) return;
            else if (evt.type == "KeyPress" && this.transformSubmorphs(evt)) return;
        }
		var consumed = false;
        // manual bubbling up b/c the event won't bubble by itself
		var world = this.world();
        for (var responder = this.keyboardFocus || world; responder != null; responder = responder.owner || world) {
			if (responder.takesKeyboardFocus()) {
                var handler = responder[evt.handlerName()];
                if (handler) {
                    if (handler.call(responder, evt)) {
						consumed = true;
                        break; // event consumed?		
					}
                }
            }
			if (responder == world) break;
        }

		if (!consumed) {
			// console.log("not consumed " + evt)
			// the single command key evt 
			if (evt.isCommandKey())
				ClipboardHack.selectPasteBuffer();			
				
			// remember key down for mouse events
			if(evt.type == "KeyPress") {
				this.rememberKeyDown(evt);
			};
		};
		this.blockBrowserKeyBindings(evt);
    },
	
    blockBrowserKeyBindings: function(evt) {
		switch (evt.getKeyCode()) {
			case Event.KEY_SPACEBAR: // [don't] scroll
		    	// stop keypress but don't try to stop preceeding keydown,
		    	// which would prevent keypress from firing and being handled by Text etc
		    	if (evt.type == "KeyPress") evt.stop();
		    	break;
		    case Event.KEY_BACKSPACE: // [don't] go to the previous page 
		    	evt.stop();
		    	break;
			case 22:
			case 3:
			case 24:
				if (evt.isCtrlDown() && evt.type == "KeyPress") 
					evt.preventDefault(); // ctrl+x, ctrl+c, or ctrl+v pressed
				break;
			}
		switch (evt.getKeyChar()) {
			case "[":
			case "]":
		    	if (evt.isMetaDown() && evt.type == "KeyPress") {
					// Safari would want to navigate the history
					evt.preventDefault();
					break;
		    }
		}	
    },

	bounds: function($super) {
		// account for the extra extent of the drop shadow
		// FIXME drop shadow ...
		return this.shadowMorph ? $super().expandBy(this.shadowOffset.x) : $super();
	},

	getInsertPositionFor: function(m, isFront) {
		if (this.submorphs.length == 0) return this.shape.rawNode;
		return isFront ? this.submorphs.last().rawNode : this.submorphs.first().rawNode;
	},

    toString: function($super) { 
        var superString = $super();
        var extraString = Strings.format(", local=%s,id=%s", this.isLocal, this.id());
        if (!this.hasSubmorphs()) 
			return superString + ", an empty hand" + extraString;
        return Strings.format("%s, a hand carrying %s%s", superString, this.topSubmorph(), extraString);
    },

	removeIndicatorMorph: function() {
		if (!this.indicatorMorph)
			return;
		this.indicatorMorph.remove();
		this.indicatorMorph = undefined;
	},

	ensureIndicatorMorph: function() {
		if (this.indicatorMorph)
			return this.indicatorMorph;
		var morph = new TextMorph(new Rectangle(0,0,100,20));
		morph.setPosition(this.shape.bounds().bottomRight().addPt(pt(-5,-5)))
		morph.ignoreEvents();
		morph.isEpimorph = true;
		morph.setBorderWidth(0);
		morph.setFill(null);
		this.indicatorMorph = morph;
		this.addMorph(morph);
		return morph
	},

	hasSubmorphs: function() {
		if (this.submorphs.length == 0)
			return false;
		else
			return this.submorphs.reject(function(ea) {return ea.isEpimorph}).length != 0;
	},
});

WorldMorph.addMethods({

	takesKeyboardFocus: Functions.True,
	
	onKeyDown: function(evt) {
		// console.log("WorldMorph onKeyDown " + this + " ---  " + evt + " char: " + evt.getKeyChar() )		
		return ClipboardHack.tryClipboardAction(evt, this);
	},
	
	onKeyPress: function(evt) {
		// do nothing
		// console.log("World onKeyPress " + evt + " char: " + evt.getKeyChar())
		return false;
	},

	onKeyUp: function(evt) {
		// do nothing
		// console.log("World onKeyUp " + evt + " char: " + evt.getKeyChar())
		return false
	},

	/* Actions */
	
	copySelectionAsXMLString: function() {
		if (!this.currentSelection) {
			console.log("WorldMorph: don't know what to copy")
			return
		}
		var selectedMorphs = this.currentSelection.selectedMorphs
		if (selectedMorphs.length == 0) {
			console.log("WorldMorph: selection is empty")
			return 
		};
		
		var copier = new Copier();
		var doc = new ClipboardCopier().createBaseDocument();
		var worldNode = doc.childNodes[0].childNodes[0];
		
		var container = new Morph.makeRectangle(new Rectangle(0,0,10,10));
		container.isSelectionContainer = true;
				
		selectedMorphs.each(function(ea) {
			container.addMorph(ea.copy(copier));
		})
		
		var systemDictionary =	container.rawNode.appendChild(NodeFactory.create("defs"));
		systemDictionary.setAttribute("id", "SystemDictionary");
		
		worldNode.appendChild(container.rawNode);
		var exporter = new Exporter(container);
		var helpers = exporter.extendForSerialization(systemDictionary);
		var result = Exporter.stringify(container.rawNode);
		exporter.removeHelperNodes(helpers);
	
		return result
	},

	pasteDestinationMorph: function() {
		return this;
	},

	doCopy: function() {
		var source = this.copySelectionAsXMLString();
		TextMorph.clipboardString = source;
	},
	
	doPaste: function() {
		if (TextMorph.clipboardString) {
			// console.log("paste morphs...")
			this.pasteFromSource(TextMorph.clipboardString);
		}
	},
	
	calcTopLeftOfPoints: function(points) {
		var min_x;
		var min_y;
		points.each(function(ea) {
			if (!min_x || ea.x < min_x)
				min_x = ea.x;
			if (!min_y || ea.y < min_y)
				min_y = ea.y;
		});
		return pt(min_x, min_y)
	},
	
	pastePosition: function() {
		var pos = this.hands.first().lastMouseDownPoint;
		if (!pos || pos.eqPt(pt(0,0)))
			pos = this.hands.first().getPosition();
		return pos
	},
	
	calcPasteOffsetFrom: function(morphs) {
		if(morphs.length == 0)
			return;
		var topLeft = this.calcTopLeftOfPoints(morphs.collect(function(ea) {return ea.getPosition()}))		
		return this.pastePosition().subPt(topLeft);
	},
	
	// similarities to Fabrik >> pasteComponentFromXMLStringIntoFabrik
	// TODO refactor
	pasteFromSource: function(source){
		var copier = new ClipboardCopier();
		var morphs = copier.loadMorphsWithWorldTrunkFromSource(source);
		if (morphs.length == 0) {
			var pos = this.pastePosition();
			var textMorph = new TextMorph(new Rectangle(pos.x,pos.y,200,100), source);
			this.addMorph(textMorph);
			return;
		}
		// unpack potential selection morph
		if(morphs[0] && morphs[0].isSelectionContainer) {
			morphs = morphs[0].submorphs
		};
		var copier = new Copier();
		var offset = this.calcPasteOffsetFrom(morphs);
		morphs.each(function(ea) {
			var copy = ea.copy(copier);
			this.pasteDestinationMorph().addMorph(copy)
			if (offset) {
				copy.moveBy(offset)
			}	
		}, this)
	},

	doCut: function() {
		console.log("cut selection")
		this.doCopy();
 		if (this.currentSelection) 
			this.currentSelection.remove();
	},
})

Morph.subclass('LinkMorph', {

    documentation: "two-way hyperlink between two Lively worlds",
    helpText: "Click here to enter or leave a subworld.\n" +
        "Use menu 'grab' to move me.  Drag objects\n" +
        "onto me to transport objects between worlds.",
    openForDragAndDrop: false,
    suppressHandles: true,
	style: {
		borderColor: Color.black, 
		fill: lively.lang.let(lively.paint, function(g) { 
			return new g.RadialGradient([new g.Stop(0, Color.blue.lighter()) , new g.Stop(0.5, Color.blue), 
			new g.Stop(1, Color.blue.darker())], pt(0.4, 0.2))})
	},
    
	initialize: function($super, otherWorld, initialPosition) {
		// In a scripter, type: world.addMorph(new LinkMorph(null))

		// Note: Initial position can be specified either as a rectangle or point.
		// If no position is specified, place the icon in the lower left corner
		// of the screen.
		initialPosition = initialPosition || WorldMorph.current().bounds().bottomLeft().addXY(50, -50);
		$super(new lively.scene.Ellipse(initialPosition, 25));
		var bounds = this.shape.bounds();

		// Make me look a bit like a world
		[new Rectangle(0.15,0,0.7,1), new Rectangle(0.35,0,0.3,1), new Rectangle(0,0.3,1,0.4)].forEach(function(each) {
			// Make longitude / latitude lines
			var lineMorph = new Morph(new lively.scene.Ellipse(bounds.scaleByRect(each)));
			lineMorph.applyStyle({fill: null, borderWidth: 1, borderColor: Color.black}).ignoreEvents();
			this.addMorph(lineMorph);
		}, this);

		if (!otherWorld) {
			this.myWorld = this.makeNewWorld(this.canvas());
			this.addPathBack();
		} else {
			this.myWorld = otherWorld;
		}
		return this;
	},
    
	makeNewWorld: function(canvas) {
		return new WorldMorph(canvas);
	},
    
	addPathBack: function() {
		var pathBack = new LinkMorph(WorldMorph.current(), this.bounds().center());

		pathBack.setFill(lively.lang.let(lively.paint, function(gfx) {
			return new gfx.RadialGradient([new gfx.Stop(0, Color.orange), 
			new gfx.Stop(0.5, Color.red), 
			new gfx.Stop(1, Color.red.darker(2))],
			pt(0.4, 0.2));
		}));

		this.myWorld.addMorph(pathBack);
		return pathBack;
	},
    
	onDeserialize: function() {
		//if (!this.myWorld) 
		this.myWorld = WorldMorph.current(); // a link to the current world: a reasonable default?
	},

	handlesMouseDown: function(evt) {
		return true; 
	},

	onMouseDown: function(evt) {
		this.enterMyWorld(evt); 
		return true; 
	},

	morphMenu: function($super, evt) { 
		var menu = $super(evt);
		menu.addItem(["publish linked world as ... ", function() { 
		this.world().prompt("world file (.xhtml)", this.exportLinkedFile.bind(this)); }]);
		menu.replaceItemNamed("package", ["package linked world", function(evt) {
			new PackageMorph(this.myWorld).openIn(this.world(), this.bounds().topLeft()); this.remove()} ]);
		return menu;
	},

	enterMyWorld: function(evt) { // needs vars for oldWorld, newWorld
		carriedMorphs = [];

		// Save, and suspend stepping of, any carried morphs
		evt.hand.unbundleCarriedSelection();
		evt.hand.carriedMorphsDo( function (m) {
			m.suspendAllActiveScripts();
			carriedMorphs.splice(0, 0, m);
			evt.hand.shadowMorphsDo( function(m) { m.stopAllStepping(); });
			evt.hand.showAsUngrabbed(m);
		});
		evt.hand.removeAllMorphs();
		this.hideHelp();
		this.myWorld.changed();
		var oldWorld = WorldMorph.current();
		oldWorld.onExit();    
		// remove old hands
		oldWorld.hands.clone().forEach(function(hand) { 
			oldWorld.removeHand(hand);
		});

		if (Config.suspendScriptsOnWorldExit) {
			oldWorld.suspendAllActiveScripts();
		}

		var canvas = oldWorld.canvas();
		oldWorld.remove(); // some SVG calls may stop working after this point in the old world.

		console.log('left world %s through %s', oldWorld, this);

		// display world first, then add hand, order is important!
		var newWorld = this.myWorld;
		if (newWorld.owner) {
			console.log("new world had an owner, removing");
			newWorld.remove();
		}

		newWorld.displayOnCanvas(canvas);  // Becomes current at this point

		if (Config.suspendScriptsOnWorldExit) { 
			newWorld.resumeAllSuspendedScripts();
		}

		carriedMorphs.forEach(function(m) {
			var hand = newWorld.firstHand();
			m.resumeAllSuspendedScripts();
			hand.addMorphAsGrabbed(m);
		});

		if (Config.showThumbnail) {
			var scale = 0.1;
			if (newWorld.thumbnail) {
				console.log("disposing of a thumbnail");
				newWorld.thumbnail.remove();
			}
			newWorld.thumbnail = Morph.makeRectangle(Rectangle.fromElement(canvas));
			newWorld.thumbnail.setPosition(this.bounds().bottomRight());
			newWorld.addMorph(newWorld.thumbnail);
			newWorld.thumbnail.setScale(scale);
			newWorld.thumbnail.addMorph(oldWorld);
		}

		if (carriedMorphs.length > 0) newWorld.firstHand().emergingFromWormHole = true; // prevent re-entering
	},
    
	onMouseOver: function($super, evt) {
		if (evt.hand.hasSubmorphs()) { // if hand is laden enter world bearing gifts
			if (!evt.hand.emergingFromWormHole) this.enterMyWorld(evt);
		} else {
			$super(evt);
		}
	},

	onMouseOut: function($super, evt) {
		evt.hand.emergingFromWormHole = false;
		$super(evt);
	},

	getHelpText: function() {
		return this.helpText;
	},
	
	addLabel: function(text) {
		var label = new TextMorph(pt(110, 25).extentAsRectangle(), text).applyStyle({borderRadius: 10, borderWidth: 2});
		this.addMorph(label);
		label.align(label.bounds().leftCenter(), this.shape.bounds().rightCenter().addXY(5, 0));
		label.linkToStyles(['raisedBorder']);
		return label;
	},
    
});

LinkMorph.subclass('ExternalLinkMorph', {

    documentation: "A link to a different web page, presumably containing another LK",

    style: { borderColor: Color.black, fill: new lively.paint.RadialGradient([new lively.paint.Stop(0, Color.green), 
									     new lively.paint.Stop(1, Color.yellow)])},
    
    initialize: function($super, url, position) {
		$super(null, position || pt(0, 0));
		this.url = url;
		this.win = null; // browser window
    },

    makeNewWorld: Functions.Null, 
    
    addPathBack: Functions.Null,

	enterMyWorld: function(evt) {
		if (evt.isCommandKey()) {
			this.world().confirm("Leave current runtime to enter another page?", function (answer) {
				if (answer) Global.location = this.url.toString();
				else console.log("cancelled loading " + this.url);
			});
		} else {
			if (this.win && !this.win.closed) this.win.focus();
			else this.win = Global.window.open(this.url);
		}
	},
    
    getHelpText: function() {
		return "Click to enter " + this.url;
    },

	morphMenu: function($super, evt) { 
		var menu = $super(evt);
		menu.addItem(["set link target...", function() {
			this.world().prompt("Set new target file", function(answer) {
				this.url = URL.source.withFilename(answer);
			}.bind(this), URL.source.toString());
		}]);
		return menu;
	}
    
});

 function interactiveEval(text) {
    // FIXME for compatibility, load jQuery for some interactive conveniences
	// ECMAScript 3rd edition, section 12.4: 
	// Note that an ExpressionStatement cannot start with an opening curly brace because that might make it ambiguous with a Block.
	//text = '(' + text + ')'; // workaround for that issue
	return eval(text);
 }

// for Fabrik
Morph.addMethods({
    isContainedIn: function(morph) {
        if (!this.owner)
            return false;
        if (this.owner === morph)
            return true;
        else
            return this.owner.isContainedIn(morph)
    },
});

// For driving a Car... 
Morph.addMethods({

	moveForwardBy: function(amount) {
		var nose = pt(1,0)
		var dir = nose.matrixTransformDirection(this.getTransform()).normalized();
		this.moveBy(dir.scaleBy(amount))
	},

	// TODO: There is a bug in Safari (the matrix multiplication is the wrong way around)
	// that is not taken into account here....
	rotateAround: function(angle, center) {
		var tfm = new lively.scene.Similitude().toMatrix();
		tfm = tfm.translate(center.x, center.y);
		tfm = tfm.rotate(angle)		
		tfm = tfm.translate( -center.x, -center.y);	
		var oldTfm = this.getTransform().toMatrix();
		var newTfm = oldTfm.multiply(tfm);
		this.setTransform(new lively.scene.Similitude(newTfm));
	},

	turnBy: function(angle) {
		this.rotateAround(angle, this.shape.bounds().center())		
	}
})


// for Fabrik
HandMorph.addMethods({
    changed: function($super, morph) {
        $super();
        this.globalPosition = this.getPosition();
        this.submorphs.forEach(function(ea){
            // console.log("changed "+ ea);
            ea.changed("globalPosition", this.getPosition());
        }, this);
    }
});

Morph.subclass('BoxMorph', {

    documentation: "Occupies a rectangular area of the screen, can be laid out",

    // FIXME: this doesn't account properly for border width
    // the CSS box model, see http://www.w3.org/TR/REC-CSS2/box.html    
    padding: new Rectangle(0, 0, 0, 0), // between morph borders and its content (inwards)
    margin: new Rectangle(0, 0, 0, 0), // between morph border and its 

    initialize: function($super, initialBounds) {
		$super(new lively.scene.Rectangle(initialBounds || this.defaultBounds)); // defaultBounds added by Adam
    },
        // ??
    innerBounds: function() { 
        return this.shape.bounds().insetByRect(this.padding);
    },

	applyStyle: function($super, spec) { // no default actions, note: use reflection instead?
		$super(spec);
		if (!spec) {
			throw new TypeError('spec is undefined in applyStyle');		
		}
		if (spec.padding !== undefined) {
			if (!(spec.padding instanceof Rectangle)) 
				throw new TypeError(spec.padding + ' not a Rectangle');
			this.padding = spec.padding;
		}
		return this; // added by Adam, I think it's just a bug that this was omitted
	}

});

BoxMorph.subclass('ContainerMorph', {
    documentation: "Box morph whose shape grows to contain all its submrphs",

	initialize: function($super,rect) {
		$super(rect);//new Rectangle(0,0,0,0));
	},

    initializeTransientState: function($super) {
        $super();
        this.priorExtent = this.innerBounds().extent();
    },

	addMorph: function($super, m, isFront) {
		var ret = $super(m, isFront);
		this.shape.setBounds(this.submorphBounds(true).outsetByRect(this.padding));
		return ret;
	},

	adjustForNewBounds: function ($super) {
		// borrowed from PanelMorph
		// Compute scales of old submorph extents in priorExtent, then scale up to new extent
		$super();
		var newExtent = this.innerBounds().extent();
		var scalePt = newExtent.scaleByPt(this.priorExtent.invertedSafely());
		this.submorphs.forEach(function(sub) {
			sub.setPosition(sub.getPosition().scaleByPt(scalePt));
			sub.setExtent(sub.getExtent().scaleByPt(scalePt));
		});
		this.priorExtent = newExtent;
	},

    
});


ClipboardHack = {
	ensurePasteBuffer: function() {
		// Return a reference to a text element to serve as our proxy for communication
		//   with the OS about text such as cut/paste, or iPad keyboard input
		if (UserAgent.isMozilla && UserAgent.fireFoxVersion) return;
		var buffer = document.getElementById("copypastebuffer");
		if (buffer) return buffer;

		// Not there yet -- create a new one
		buffer = document.createElement("textarea");
		buffer.setAttribute("cols","1");
		buffer.setAttribute("rows","1");
		buffer.setAttribute("id","copypastebuffer");
		// buffer.setAttribute("style","position:absolute;z-index: -400;left:0px; top:1px; width:1px; height:1px;");
		if (UserAgent.isTouch) { // hack to test text input on iPad
			buffer.setAttribute("style","position:fixed;z-index: 5;left:0px; top:0px; width:100px; height:30px;");
		} else {
			// the Clipboard buffer needs a minimum width, otherwise it will scroll the page on the first paste
			buffer.setAttribute("style","position:fixed;z-index: -5;left:0px; top:0px; width:50px; height:1px;");
		}
		buffer.textContent = "NoText";
		var outerBody = Global.document.body || Global.parent.document.body;
		outerBody.appendChild(buffer);
		return buffer;
	},
	
	selectPasteBuffer: function() {
		var buffer = this.ensurePasteBuffer();
		if (buffer) buffer.select();
	},
	
	invokeKeyboard: function() {
	 		if (!UserAgent.isTouch) return;
			var buffer = this.ensurePasteBuffer();
			if (buffer) buffer.focus();
	},
	
	tryClipboardAction: function(evt, target) {
        // Copy and Paste Hack that works in Webkit/Safari
        if (!evt.isMetaDown() && !evt.isCtrlDown()) return false;
		this.selectPasteBuffer();
        var buffer = this.ensurePasteBuffer();
        if(!buffer) return false;
        if (evt.getKeyChar().toLowerCase() === "v" || evt.getKeyCode() === 22) {		
            buffer.onpaste = function() {
				TextMorph.clipboardString = event.clipboardData.getData("text/plain");
                if(target.doPaste) {
                  target.doPaste();
                  event.preventDefault(); // added by Adam, otherwise it pastes twice
                }
            };
        	buffer.focus();
        	return true;
        };
        if (evt.getKeyChar().toLowerCase() === "c" || evt.getKeyCode() === 3) {
			if(target.doCopy) target.doCopy();
			buffer.textContent = TextMorph.clipboardString;
			buffer.select();
        	buffer.focus();
        	return true;
        };
        if (evt.getKeyChar().toLowerCase() === "x" || evt.getKeyCode() === 24) {
			if (target.doCut) target.doCut();
			buffer.textContent = TextMorph.clipboardString;
			buffer.select();
        	buffer.focus();
        	return true;
        };
		// console.log('Clipboard action not successful');
		return false;
    },

}

Global.basicResize = function(world, canvas, newWidth, newHeight) {
	canvas.setAttribute("width", newWidth);
	canvas.setAttribute("height", newHeight);
	world.setExtent(pt(newWidth, newHeight));
	world.fullBounds = new Rectangle(0, 0, newWidth, newHeight);
};

window.onresize = function(evt) {
	if (!Config.onWindowResizeUpdateWorldBounds) return; 
	var h = document.getElementsByTagName('html')[0];
    var world = WorldMorph.current();
	if (!world) {
		console.log("Error: No world to resize.")
		return;
	}		
	// Todo: get rid of the arbitrary offset without getting scrollbars
	var canvas = world.rawNode.parentNode;
    var newWidth = h.clientWidth - 4;
    var newHeight = h.clientHeight-  4;
};

Global.$morph = function getMorphNamedShortcut(name) { return WorldMorph.current().getMorphNamed(name) };

// Helper method with GUI stuff, so it can't go into Helper.js
Global.inspect = function(inspectee) {
	var world = WorldMorph.current();
	new SimpleInspector(inspectee).openIn(world, world.hands.first().getPosition());
};

Object.subclass('ClipboardCopier', {
	
	copySelectionAsXMLString: function(component) {
		var componentCopy = component.copy(new Copier());
		var copy = componentCopy.panel;		
		var doc = this.createBaseDocument();
		var worldNode = doc.childNodes[0].childNodes[0];
		worldNode.appendChild(copy.rawNode);
		var exporter = new Exporter(copy);
		// todo: what about the SystemDictionary
		var helpers = exporter.extendForSerialization();
		var result = Exporter.stringify(copy.rawNode);
		exporter.removeHelperNodes(helpers);
		return result
	},
	
	createBaseDocument: function(source) {
		return new DOMParser().parseFromString('<?xml version="1.0" standalone="no"?>' +
			'<svg xmlns="http://www.w3.org/2000/svg" id="canvas">' +
                '<g type="WorldMorph" id="1:WorldMorph" transform="matrix(1 0 0 1 0 0)" fill="rgb(255,255,255)">'+
                    '<rect x="0" y="0" width="800" height="600"/>' +          
                    source  +
                '</g>'+ 
            '</svg>', /* "text/xml" */ "application/xml");
	},

	loadMorphsWithWorldTrunkFromSource: function(source) {
    	var xml = this.createBaseDocument(source);
		var systemDictionary = xml.getElementById("SystemDictionary");
		var globalSystemDictionary = lively.data.Wrapper.prototype.dictionary();
		if(systemDictionary) {
			$A(systemDictionary.childNodes).each(function(ea) {
				var result = lively.data.FragmentURI.getElement(ea.id);
				
				// TODO: give the element a new id and map it, is there an implemnentation laying around somewhere here?
				if(!result) 
					globalSystemDictionary.appendChild(ea.cloneNode(true))
			})
		}
		var world = new Importer().loadWorldContents(xml);
		return world.submorphs
    },	
});


if (window.shouldShowLoadingMessages) { console.log('loaded Core.js'); }
avocado.transporter.module.onLoadCallbacks["lk/Core"] = 'done';

avocado.transporter.module.onLoadCallbacks["lk/Text"] = function() {};
/*
 * Copyright (c) 2006-2009 Sun Microsystems, Inc.
 *
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * Text.js.  Text-related functionality.
 */

module('lively.Text').requires().toRun(function(thisModule) {
        
Object.subclass('lively.Text.CharacterInfo', {
    // could simply use Point as extent.
    documentation: "simple printable info about a character's extent",

    initialize: function(width, height) {
	this.width = width;
	this.height = height;
    },

    toString: function() {
	return this.width + "x" + this.height;
    }

});


Object.subclass('lively.Text.Font', {

    documentation: "representation of a font",
    baselineFactor: 0.80,
    
    initialize: function(family/*:String*/, size/*:Integer*/, style/*:String*/){
        this.family = family;
        this.size = size;
        this.style = style ? style : 'normal';
        this.extents = null;
        // this.extents = this.computeExtents(family, size);
    },
    computeExtents: function(family, size) {
	// Note: this gets overridden depending on the environment.
        return [];
    },
    getSize: function() {
        return this.size;
    },

    getBaselineHeight: function() { // the distance between the top of the glyph to the baseline.
	return this.size * this.baselineFactor;
    },

    getFamily: function() {
        return this.family;
    },

    toString: function() {
        return this.family + " " + this.getSize();
    },

 	getCharWidth: function(charString) {
        var code = charString.charCodeAt(0);
        if (!this.extents) this.extents = this.computeExtents(this.family, this.size, this.style);
			var w = this.extents[code] ? this.extents[code].width : 4;
        if (isNaN(w)) {
            console.warn('getCharWidth: no width for ' + charString);
	    return 4;  // don't crash
        }
		return w * 1;
    },

    getCharHeight: function(charString) {
        var code = charString.charCodeAt(0);
        if (!this.extents) this.extents = this.computeExtents(this.family, this.size);
        return this.extents[code] ? this.extents[code].height : 12;
    },

    applyTo: function(wrapper) {
	var rawNode = wrapper.rawNode;
        rawNode.setAttributeNS(null, "font-size", this.getSize());
        rawNode.setAttributeNS(null, "font-family", this.getFamily());
        if (this.style == 'bold' || this.style == 'bold-italic') rawNode.setAttributeNS(null, "font-weight", 'bold');
        if (this.style == 'italic' || this.style == 'bold-italic') rawNode.setAttributeNS(null, "font-style", 'italic');
        //if (this.style == 'normal') {
	//    rawNode.setAttributeNS(null, "font-style", 'normal');
	//    rawNode.setAttributeNS(null, "font-weight", 'normal');
	//}
        // if (this.getSize() == 18 || this.style == 'bold' || this.style == 'italic') 
	//	console.log("applying " + this.getSize() + this.style);
    }

});
    

Object.extend(thisModule.Font, {
	fontCache: {},
	forFamily: function(familyName, size, style) {
		var cache = this.fontCache
		var styleKey = 'n';
		if (style == 'bold') styleKey = 'b';
		if (style == 'italic') styleKey = 'i';
		if (style == 'bold-italic') styleKey = 'bi';
		var key  = familyName + ":" + size + ":" + styleKey ;
		var entry = cache[key];
		if (entry) 
			return entry;
		try { 
			entry = new thisModule.Font(familyName, size, style);
		} catch(er) {
			console.log("%s when looking for %s:%s", er, familyName, size);
			return null;
		}
		cache[key] = entry;
		return entry;
	}
});
    
    
if (Config.fakeFontMetrics) { 
    
    thisModule.Font.addMethods({
        // wer're faking here, b/c native calls don't seem to work
        computeExtents: function(family, size) {
	    // adapted from the IE port branch
            var extents = [];
            for (var i = 33; i < 255; i++) {
		var ch = String.fromCharCode(i);
		switch (ch) {
                case 'i': case 'I': case 'l': case 't': case '.': case ',': case '\'':
                    //extents[i] = new thisModule.CharacterInfo(size*0.245, size);
		    extents[i] = new thisModule.CharacterInfo(size*0.345, size);
		    break;
		case 'M': case 'm': case 'W': case 'B': 
		case 'w': case 'S': case 'D': case 'A': case 'H': case 'C': case 'E':
                    extents[i] = new thisModule.CharacterInfo(size*0.820, size);
		    break;
		default:
                    extents[i] = new thisModule.CharacterInfo(size*0.505, size);
		    break;
                }
            }
            return extents;
        }
    });
    
} else if (Config.fontMetricsFromHTML)  {
    
thisModule.Font.addMethods({
 	computeExtents: function (family, size, style) {
	        var extents = [];
	        var body = null;
	        var doc; // walk up the window chain to find the (X)HTML context
	        for (var win = window; win; win = win.parent) {
	            doc = win.document;
	            var bodies = doc.documentElement.getElementsByTagName('body');
	            if (bodies && bodies.length > 0) {
	                body = bodies[0];
	                break;
	            }
	        }

	        if (!body) return [];

	        function create(name) {
	            // return doc.createElement(name);
	            return doc.createElementNS(Namespace.XHTML, name);
	        }
			// body = document.body
	        var d = body.appendChild(create("div"));

	        d.style.kerning    = 0;
	        d.style.fontFamily = family;
	        d.style.fontSize   = size + "px";
			if (style) {
				d.style.fontWeight = style;
			}
	        var xWidth = -1;
	        var xCode = 'x'.charCodeAt(0);
	        for (var i = 33; i < 255; i++) {
	            var sub = d.appendChild(create("span"));
	            sub.appendChild(doc.createTextNode(String.fromCharCode(i)));
	            extents[i] = new lively.Text.CharacterInfo(sub.offsetWidth,  sub.offsetHeight);
	            if (i == xCode) xWidth = extents[i].width;
	        }

	        if (xWidth < 0) { 
	            throw new Error('x Width is ' + xWidth);
	        }

	        if (d.offsetWidth == 0) {
	            console.log("timing problems, expect messed up text for font %s", this);
	        }

	        // handle spaces
	        var sub = d.appendChild(create("span"));
	        sub.appendChild(doc.createTextNode('x x'));

	        var spaceWidth = sub.offsetWidth - xWidth*2;
	        // console.log("font " + this + ': space width ' + spaceWidth + ' from ' + sub.offsetWidth + ' xWidth ' + xWidth);  // commented out because it's annoying -- Adam

	        // tjm: sanity check as Firefox seems to do this wrong with certain values
	        if (spaceWidth > 100) {    
	            extents[(' '.charCodeAt(0))] = new lively.Text.CharacterInfo(2*xWidth/3, sub.offsetHeight);
	        } else {
	            extents[(' '.charCodeAt(0))] = new lively.Text.CharacterInfo(spaceWidth, sub.offsetHeight);
	        }

	        //d.removeChild(span);
	        body.removeChild(d);
	        return extents;
	    }
});
} else if (Config.fontMetricsFromSVG)  {
    
thisModule.Font.addMethods({
    
    computeExtents: function(family, size) {
        var extents = [];
	var canvas = document.getElementById("canvas");
	var text = canvas.appendChild(document.createElementNS(Namespace.SVG, "text"));
	text.setAttributeNS(null, "font-size", size);
	text.setAttributeNS(null, "font-family", family);

	//text.setAttributeNS(null, "y", "100");
	var b = 33;
	var string = "";
	for (var i = b; i < 255; i++) {
	    string += String.fromCharCode(i);
	}
	text.appendChild(document.createTextNode(string));
	for (var i = b; i < 255; i++) {
	    var end = text.getEndPositionOfChar(i - b);
	    var start = text.getStartPositionOfChar(i - b);
	    var ext = text.getExtentOfChar(i - b);
	    extents[i] = new thisModule.CharacterInfo(end.x - start.x, start.y - ext.y);
	}
        canvas.removeChild(text);
	return extents;
    }
    
});

}    
    
lively.data.Wrapper.subclass('lively.Text.TextWord', {

    documentation: "represents a chunk of text which might be printable or might be whitespace",

    isWhite: false,
    isNewLine: false,
    isTab: false,

    initialize: function(offset, length) {
	this.startIndex = offset;
	this.stopIndex  = offset;
	this.length = length;
	this.shouldRender = true;
	this.bounds = null;
	this.rawNode = null;
    },

    adjustAfterEdits: function(delta, Ydelta) {
	this.startIndex += delta;
	this.stopIndex += delta;
	if (Ydelta != 0) {
		if (this.bounds) this.bounds = this.bounds.withY(this.bounds.y + Ydelta);
		if (this.rawNode) this.rawNode.setAttributeNS(null, "y",
												Number(this.rawNode.getAttributeNS(null, "y")) + Ydelta );
	}
    },

    deserialize: function(importer, rawNode) {
        this.rawNode = rawNode;
    },
    
    adjustAfterComposition: function(textString, deltaX, paddingX, baselineY) {
	// Align the text after composition
        if (deltaX != 0) this.bounds = this.bounds.withX(this.bounds.x + deltaX);
	if (paddingX != 0 && this.isSpaces()) this.bounds = this.bounds.withWidth(this.bounds.width + paddingX);
	if (this.rawNode != null) {
	    this.replaceRawNodeChildren(NodeFactory.createText(textString.substring(this.startIndex, this.getStopIndex() + 1))); 
            this.rawNode.setAttributeNS(null, "x", this.bounds.x);
	    this.rawNode.setAttributeNS(null, "y", baselineY);
	}
    },
    
    allocRawNode: function() {
	this.rawNode = NodeFactory.create("tspan");
	// aaa slow? reflect(this).slotAt('rawNode').beCreator(); // aaa hack for morph-saving -- Adam
    },
    
    compose: function(textLine, startLeftX, topLeftY, rightX) {
	// compose a word between startLeftX and rightX, stopping if the width or string width is exceeded
	// return true if we bumped into the width limit while composing

	this.font = textLine.currentFont;  // Cache for canvas display
	this.bounds = new Rectangle(startLeftX, topLeftY, undefined, this.font.getSize());
        var leftX = startLeftX;
	
        // get the character bounds until it hits the right side of the compositionWidth
        for (var i = this.startIndex; i < textLine.textString.length && i < this.getNextStartIndex(); i++) {
            var rightOfChar = leftX + textLine.getCharWidthAt(i);
	    if (rightOfChar >= rightX) {
		// Hit right bounds -- wrap at word break if possible
		if (i > this.startIndex)  {
		    this.stopIndex = i - 1;
		    this.bounds.width = leftX - startLeftX;
		} else {
		    this.stopIndex = this.startIndex;
		    this.bounds.width = rightOfChar - startLeftX;
		}
                return true;
            }
	    leftX = rightOfChar;
        }
        // Reached the end of text
        this.stopIndex = i - 1;
	this.bounds.width = rightOfChar - startLeftX;
	return false;
    },
    
    // accessor function
    getStopIndex: function() {
        return this.stopIndex;
    },

    getNextStartIndex: function() {
	return this.startIndex + this.length;
    },

    getContent: function(string) {
	return string.substring(this.startIndex, this.stopIndex);
    },

    indexForX: function(textLine, x) {
	if (this.rawNode == null) {
	    var virtualSpaceSize = this.bounds.width / this.length;
	    var spacesIn = Math.floor((x - this.bounds.x) / virtualSpaceSize);
	    return this.startIndex + spacesIn;
	} else {
	    var leftX = this.bounds.x;
	    for (var j = this.startIndex; j < (this.startIndex + this.length); j++) {
		var rightX = leftX + textLine.getCharWidthAt(j);
		if (x >= leftX && x <= rightX) break;
		leftX = rightX;
	    }
	    return j;
	}
	return this.startIndex; // failsafe
    },
    
    getBounds: function(textLine, stringIndex) {
    	// get the bounds of the character at stringIndex
	// DI: change order of this if, and dont test for getBounds
	if (this.rawNode) {
	    var leftX = this.bounds.x;
	    for (var j = this.startIndex; j <= stringIndex; j++) {
		var rightX = leftX + textLine.getCharWidthAt(j);
		if (j >= stringIndex) break;
		leftX = rightX;
	    }
	    return this.bounds.withX(leftX).withWidth(rightX - leftX);
	} else {
	    if (this.isSpaces()) {
		var virtualSpaceSize = this.bounds.width / this.length;
		var b = this.bounds.withWidth(virtualSpaceSize);
		b.x += virtualSpaceSize * (stringIndex - this.startIndex);
		return b;
	    } else {
		return this.bounds;
	    }
	}
    },

    isSpaces: function() {
        return this.isWhite && !this.isTab && !this.isNewLine;
    },
    
    // clone a chunk only copying minimal information
    
    
    // string representation
    toString: function() {
        var lString = "TextWord start: " + this.startIndex +
            " length: " + this.length +
            " isWhite: " + this.isWhite +
            " isNewLine: " + this.isNewLine +
            " isTab: " + this.isTab;
        if (this.bounds == null) {
            lString += " null bounds";
        } else {
            lString += " @(" + this.bounds.topLeft() + ")(" + this.bounds.extent() + ")";
        }
        return lString;
    },
    
    // create a chunk representing whitespace (typically space characters)
    asWhite: function() {
        this.isWhite = true;
        return this;
    },
    
    // create a chunk representing a newline   
    asNewLine: function() {
        this.isWhite = true;
        this.isNewLine = true;
        this.length = 1;
        return this;
    },
    
    // create a chunk representing a tab
    asTab: function() {
        this.isWhite = true;
        this.isTab = true;
        this.length = 1;
        return this;
    }
});



Object.subclass('lively.Text.TextLine', {
    documentation: 'renders lines composed of words and whitespace',

    lineHeightFactor: 1.2, // multiplied with the font size to set the distance between the lines, 
    // semantics analogous to CSS 
    
    whiteSpaceDict: {' ': true, '\t': true, '\r': true, '\n': true},
    
    // create a new line
    initialize: function(textString, textStyle, startIndex, topLeft, font, defaultStyle) {
        this.textString = textString;
        this.textStyle = textStyle;
        this.startIndex = startIndex;
        this.overallStopIndex = textString.length - 1;
        this.topLeft = topLeft;
        this.currentFont = font;
	this.alignment = 'left';
        this.defaultStyle = defaultStyle;  // currently unused 
	// Should probably call adoptStyle(defaultStyle) here
	//	this.adoptStyle(defaultStyle);
	this.spaceWidth = font.getCharWidth(' ');
        this.tabWidth = this.spaceWidth * 4;
        this.chunks = null;  //  Will be an array after compose
        reflect(this).slotAt('chunks').setInitializationExpression('null'); // added by Adam, needed for morph-saving
    },
    
	adjustAfterEdits: function(newTextString, newTextStyle, delta, Ydelta) {
		// tag: newText
		this.textString = newTextString;
		this.textStyle = newTextStyle;
		this.startIndex += delta;
		this.overallStopIndex += delta;
		if (Ydelta != 0) this.topLeft.y += Ydelta;

		// Need to run through all chunks, as well
		for (var i = 0; i < this.chunks.length; i++) this.chunks[i].adjustAfterEdits(delta, Ydelta);
	},

    lineHeight: function() {
	return this.lineHeightFactor * this.currentFont.getSize();
    },
    
    isWhiteSpace: function(c) {
	// is the character 'c' what we consider to be whitespace? (private) 
	// return this.whiteSpaceDict[c];
	return (c == ' ' || c == '\t' || c == '\r' || c == '\n');
    },
    
    isNewLine: function(c) {
	// is the character 'c' what we consider to be a newline? (private)
	return (c == '\r' || c == '\n');
    },
    
    endsWithNewLine: function() {
	// Does this line end with a newLine character?
	return this.chunks.last().isNewLine;
    },
    
    baselineY: function() {
	return this.topLeft.y + this.currentFont.getBaselineHeight();
    },

    interline: function() {
	return (this.lineHeightFactor - 1) * this.currentFont.getSize();
    },

    getCharWidthAt: function(index) {
	return this.currentFont.getCharWidth(this.textString.charAt(index));
    },

    compose: function(compositionWidth, chunkStream) {
		// tag: newText
	// compose a line of text, breaking it appropriately at compositionWidth
	// nSpaceChunks is used for alignment in adjustAfterComposition
	this.nSpaceChunks = 0; 
	var lastBounds = this.topLeft.extent(pt(0, this.currentFont.getSize())); 
	var runningStartIndex = this.startIndex;
	var nextStyleChange = (this.textStyle) ? 0 : this.textString.length;
	this.chunks = new Array();

//	console.log("this.textString = /" + this.textString + "/, len = " + this.textString.length);
	var hasStyleChanged = false;
	var lastNonWhite = null;
        for (var i=0; true; i++) {
            var c = chunkStream.nextChunk();
			if (c == null) break;
//		console.log(i.toString() + ": " + c);
			this.chunks.push(c);
//		console.log("c.startIndex = " + c.startIndex + ", nextStyleChange = " + nextStyleChange);

	    if (c.startIndex >= nextStyleChange) {
			hasStyleChanged = true;
			// Don't bother to change style at line breaks
			if (!c.isNewLine) this.adoptStyle(this.textStyle.valueAt(c.startIndex), c.startIndex); 
			nextStyleChange = c.startIndex + this.textStyle.runLengthAt(c.startIndex);
	    }
		if (c.isWhite) {  // Various whitespace chunks...
			c.bounds = lastBounds.withX(lastBounds.maxX());

			if (c.isNewLine) {
				c.bounds.width = (this.topLeft.x + compositionWidth) - c.bounds.x;
				runningStartIndex = c.getNextStartIndex();
				break;
			}
			this.nSpaceChunks ++ ;  // DI: shouldn't this only be incase of spaces (ie, not tabs)?
			if (c.isTab) {
				var tabXBoundary = c.bounds.x - this.topLeft.x;
				c.bounds.width = Math.floor((tabXBoundary + this.tabWidth) / this.tabWidth) * this.tabWidth - tabXBoundary;
			} else {
				var spaceIncrement = this.spaceWidth;
				c.bounds.width = spaceIncrement * c.length;
			}
			runningStartIndex = c.getNextStartIndex();

	} else {  // Not whitespace...
		c.allocRawNode(); 
		lastNonWhite = c;

		if (hasStyleChanged) {
			// once we notice one change, we will reapply font-size to chunk
			this.currentFont.applyTo(c);
			if (this.localColor) {
				var colorSpec = this.localColor;
				if (!(colorSpec instanceof Color)) colorSpec = Color[colorSpec]; // allow color names
				if (colorSpec instanceof Color) c.rawNode.setAttributeNS(null, "fill", String(colorSpec));
			}
		}
		var didLineBreak = c.compose(this, lastBounds.maxX(), this.topLeft.y, this.topLeft.x  + compositionWidth);
		if (didLineBreak) {  // This chunk ran beyond compositionWidth
			if (i == 0) {  // If first chunk, then have to trim it
				runningStartIndex = c.getStopIndex() + 1;
			} else {
				// Otherwise, drop it entirely, to be rendered on next line
				runningStartIndex = c.startIndex;
				this.chunks.pop();
			}
			this.nSpaceChunks-- ;  // This makes last interior space no longer interior
			break;
		}
		runningStartIndex = c.getNextStartIndex();
	}
	lastBounds = c.bounds;
	}
	this.overallStopIndex = runningStartIndex - 1;
	
	// aaa hack for morph-saving; use the annotator directly because this is called often so don't want to make a bunch of unnecessary mirrors -- Adam
	//this.chunks.makeAllCreatorSlots();
  //annotator.annotationOf(this.chunks).setCreatorSlot('chunks', this);
  // aaa this whole thing is slow, maybe we don't need it?
    },
    
    adoptStyle: function(emph, charIx) {
	var fontFamily = this.currentFont.getFamily();
	var fontSize = this.currentFont.getSize();
	var fontStyle = 'normal';
	this.localColor = null;
	this.alignment = 'left';
	Properties.forEachOwn(emph, function(p, v) {
	    if (p == "family") fontFamily = v;
	    if (p == "size")  fontSize = v;
	    if (p == "style") fontStyle = v;
	    if (p == "color") this.localColor = v;
	    if (p == "align") this.alignment = v;
	}.bind(this));
	// console.log("adoptStyle/Font.forFamily" + fontFamily + fontSize + fontStyle + "; index = " + charIx);
	this.currentFont = thisModule.Font.forFamily(fontFamily, fontSize, fontStyle);
        this.spaceWidth = this.currentFont.getCharWidth(' ');
        this.tabWidth = this.spaceWidth * 4;
    },
    
    getStopIndex: function() {
	// accessor function (maybe delete - kam)
        return this.overallStopIndex;
    },
    
    // after this line, where do we start from?
    getNextStartIndex: function() {
        return this.overallStopIndex + 1;
    },
    
    // accessor function
    getTopY: function() {
        return this.topLeft.y;
    },

    // get the bounds of the character at stringIndex
    getBounds: function(stringIndex) {
	for (var i = 0; i < this.chunks.length; i++) {
		var c = this.chunks[i];
		if (stringIndex >= c.startIndex && stringIndex < c.getNextStartIndex()) 
		return c.getBounds(this, stringIndex);
        }
        return null;
    },
    
    // find the pointer into 'textString' for a given X coordinate in character metric space
    indexForX: function(x) {
        for (var i = 0; i < this.chunks.length; i++) {
            var c = this.chunks[i];
	    if (x >= c.bounds.x && x <= c.bounds.maxX()) return c.indexForX(this, x);
        }
        return 0; // should not get here unless rightX is out of bounds
    },
    
    // return a boolean if this line contains this pointer into 'textString'
    containsThisIndex: function(index) {
        return this.startIndex <= index && index <= this.getStopIndex();
    },
testForIndex: function(index) {
	// Return -1, 0 or +1 depending on whether this index is in 
	//        a previous line, this line, or a later line
	if (index < this.startIndex) return -1;
	if (index > this.overallStopIndex) return +1;
	return 0;  
    },
testForY: function(y) {
	// Return -1, 0 or +1 depending on whether this y value is in 
	//        a previous line, this line, or a later line
	if (y < this.getTopY()) return -1;
	if (y >= (this.getTopY() + this.lineHeight())) return +1;
	return 0;  
    },



    adjustAfterComposition: function(textString, compositionWidth) {

	// Align the text after composition
	var deltaX = 0;
	var paddingX = 0;
	var spaceRemaining = 0;
	var lastIndex = this.chunks.length-1;  // Index of last character chunk
	if (this.chunks[lastIndex].isNewLine) lastIndex = Math.max(lastIndex-1, 0);

	if (this.alignment != 'left') {
	    spaceRemaining =  (this.topLeft.x + compositionWidth) - this.chunks[lastIndex].bounds.maxX();
	    if (this.alignment == 'right') deltaX = spaceRemaining;
	    if (this.alignment == 'center') deltaX = spaceRemaining / 2;
	    if (this.alignment == 'justify' && (this.overallStopIndex !=  this.textString.length-1)
		&& !(this.chunks.last().isNewLine)) {
		//  Distribute remaining space over the various space chunks
		var nSpaces = this.nSpaceChunks;
		paddingX = spaceRemaining / Math.max(1, nSpaces); 
	    }
	}
	var baselineY = this.baselineY();
        for (var i = 0; i <= lastIndex; i++) {
	    this.chunks[i].adjustAfterComposition(textString, deltaX, paddingX, baselineY);
            if (this.chunks[i].isSpaces()) deltaX += paddingX;
        }
    },
    
    render: function(textContent) {
	// render each word contained in the line
        for (var i = 0; i < this.chunks.length; i++) {
            if (this.chunks[i].rawNode && this.chunks[i].shouldRender) {
                textContent.rawNode.appendChild(this.chunks[i].rawNode);
            }
        }
    },
    
    removeRawNodes: function(textContent) {
	// remove all rawNodes held by the line
	for (var i = 0; i < this.chunks.length; i++)
		this.chunks[i].removeRawNode();
    },
    
    setTabWidth: function(w, asSpaces) {
        this.tabWidth = asSpaces ? w * this.spaceWidth : w;
    },

    toString: function() {
	// string representation
        var lString = "textString: (" + this.textString + ")" +
            " startIndex: " + this.startIndex +
            " overallStopIndex: " + this.overallStopIndex +
            " topLeft: " + Object.inspect(this.topLeft) +
            " spaceWidth: " + this.spaceWidth;
        return lString;
    }
    
});

// in the future, support multiple locales
var Locale = {

    charSet: CharSet,
    //KP: note that this depends heavily on the language, esp if it's a programming language
    selectWord: function(str, i1) { // Selection caret before char i1
        var i2 = i1 - 1;
        if (i1 > 0) { // look left for open backets
            if(str[i1-1] == "\n" || str[i1-1] == "\r") return this.findLine(str, i1, 1, str[i1-1]);
	    var i = this.charSet.leftBrackets.indexOf(str[i1-1]);
            if (str[i1 - 1] == "*" && (i1-2 < 0 || str[i1-2] != "/")) 
                i = -1; // spl check for /*
            if (i >= 0) {
                var i2 = this.matchBrackets(str, this.charSet.leftBrackets[i], this.charSet.rightBrackets[i], i1 - 1, 1);
                return [i1, i2 - 1]; 
            } 
        }
        if (i1 < str.length) { // look right for close brackets
            if(str[i1] == "\n" || str[i1] == "\r") return this.findLine(str, i1, -1, str[i1]);
            var i = this.charSet.rightBrackets.indexOf(str[i1]);
            if (str[i1]== "*" && (i1+1 >= str.length || str[i1+1] != "/")) 
                i = -1; // spl check for */
            if (i >= 0) {
                i1 = this.matchBrackets(str, this.charSet.rightBrackets[i], this.charSet.leftBrackets[i],i1,-1);
                return [i1+1, i2]; 
            } 
        }

		// is a '//' left of me?
		if (str[i1-1] === '/' && str[i1-2] === '/') {
			while (i2+1<str.length && str[i2+1] !== '\n' && str[i2+1] !== '\r') { i2++ }
			return [i1, i2];
		}

		// inside of whitespaces?
		var myI1 = i1;
		var myI2 = i2;
		while (myI1-1 >= 0 && this.isWhiteSpace(str[myI1-1])) {
			myI1 --;
		}
		while (myI2 < str.length && this.isWhiteSpace(str[myI2+1])) {
		    myI2 ++;
		}
		if (myI2-myI1 >= 1) return [myI1, myI2];
	
        var prev = (i1<str.length) ? str[i1] : "";
	while (i1-1 >= 0 && (this.charSet.alphaNum.include(str[i1-1]) || this.periodWithDigit(str[i1-1], prev))) {
            prev = str[i1-1];
	    i1 --;
        }
	while (i2+1 < str.length && (this.charSet.alphaNum.include(str[i2+1]) || this.periodWithDigit(str[i2+1], prev))) {
            prev = str[i2+1];
	    i2 ++;
	}
        return [i1, i2]; 
    },

	isWhiteSpace: function(c) {
		return c === '\t' || c === ' ';
	},

    periodWithDigit: function(c, prev) { // return true iff c is a period and prev is a digit
        if (c != ".") return false;
        return "0123456789".indexOf(prev) >= 0;
    },

    findLine: function(str, start, dir, endChar) { // start points to a CR or LF (== endChar)
        var i = start;
        while ((dir < 0) ? i - 1 >= 0 : i + 1 < str.length ) {
            i += dir;
            if (str[i] == endChar) return dir>0 ? [start, i] : [i+1, start];
        }
        return dir>0 ? [start+1, str.length-1] : [0, start];
    },

    matchBrackets: function(str, chin, chout, start, dir) { 
        var i = start;
        var depth = 1;
        while ((dir < 0) ? i - 1 >= 0 : i + 1 < str.length ) {
            i += dir;
            if (str[i] == chin && chin != chout) depth++;
            if (str[i] == chout) depth--;
            if (depth == 0) return i; 
        }
        return i; 
    }
    
};


thisModule.WrapStyle = Class.makeEnum([ 
    "Normal",  // fits text to bounds width using word wrap and sets height
    "None", // simply sets height based on line breaks only
    "Shrink" // sets both width and height based on line breaks only
]);

Morph.subclass('TextSelectionMorph', {

    documentation: "Visual representation of the text selection",
    style: {
      // changed the fill -- Adam
      fill: new lively.paint.LinearGradient([new lively.paint.Stop(0, Color.blue),
                                             new lively.paint.Stop(1, Color.blue.lighter())],
                                             lively.paint.LinearGradient.SouthNorth),
      borderWidth: 0,
      borderRadius: 1,
      textColor: Color.white // textColor added by Adam
    },
    isEpimorph: true,
    
    initialize: function($super) {
	$super(new lively.scene.Group());
	this.applyStyle({fill: null, borderWidth: 0});
	this.ignoreEvents();
    },

    // Added by Adam
    totalArea: function() {
	return this.submorphs.inject(0, function(sum, m) {
		if (m.shape.area) {
			return m.shape.area();
		} else {
			console.log("Don't know how to calculate area of " + m.shape.constructor.type);
			return m.bounds().area();
		}
	});
    },

    addRectangle: function(rect) {
	var m = this.addMorph(Morph.makeRectangle(rect));
	//m.applyStyle(this.style); // modified by Adam to make the cursor dark enough to see
	var area = this.totalArea();
	var baseColor = Color.blue;
	var color = area < 50 ? baseColor.darker() : baseColor.lighter(2);
	var style = {fill: color, borderWidth: 0, borderRadius: 1};
	m.applyStyle(style);
	m.ignoreEvents();
    },

    undraw: function() {
	this.removeAllMorphs();
    }
});

Object.subclass('lively.Text.ChunkStream', {

    documentation: "Parses a string with style into chunks of text or white space",
    
    whiteSpaceDict: {/* aaa slow? ' ': true, '\t': true, */ '\r': true, '\n': true},

    initialize: function(str, style, stringIndex) {
		this.str = str;
		this.style = style;
		this.stringIndex = stringIndex;
   },

    nextChunk: function() {
	// look at str starting at stringIndex and return the next appropriate chunk
	// Note: if style is not null, then break at style changes as well as other chunk boundaries

	if (this.stringIndex >= this.str.length) return null;

	var nextChar = this.str[this.stringIndex];
	var chunkSize = 1; // default is one character long
	if (this.whiteSpaceDict[nextChar]) {
		if (nextChar == '\r' || nextChar == '\n') {
			return new lively.Text.TextWord(this.stringIndex++).asNewLine(); }
		if (nextChar == '\t') {
			return new lively.Text.TextWord(this.stringIndex++).asTab(); }
		var chunkSize = this.chunkLengthForSpaces(this.str, this.stringIndex);
		var chunk = new lively.Text.TextWord(this.stringIndex, chunkSize).asWhite();
		this.stringIndex += chunkSize ;
		return chunk;
	}
	var chunkSize = this.chunkLengthForWord(this.str, this.stringIndex);
	if(this.style) {  // if style breaks within this chunk, shorten chunk to end at the break
		var styleSize = this.style.runLengthAt(this.stringIndex);  // length remaining in run
		if (styleSize < chunkSize) chunkSize = styleSize;
	}	
	var chunk = new lively.Text.TextWord(this.stringIndex, chunkSize);
	this.stringIndex += chunkSize;
	return chunk;
    },

chunkLengthForSpaces: function(str, index) {
	// we found a space at str[index];  return the corresponding chunk length
	// Note:  This and ...ForWord should probably be inline, and they can start at index+1
	// Further note:  Both might be faster with a regex
	// Dominant stats would be 1 space only, and typically 4-5 characters
		for (var i = index; i < str.length; i++)
			if (str[i] != ' ') return i - index;
		return i - index;
    },

chunkLengthForWord: function(str, index) {
	// we found a non-blank at str[index];  return the corresponding chunk length
	for (var i = index; i < str.length; i++)
	    if (this.whiteSpaceDict[str[i]])  return i - index;
	return i - index;
    }
});


BoxMorph.subclass('TextMorph', {
	
	documentation: "Container for Text",
	doNotSerialize: ['charsTyped', 'charsReplaced', 'delayedComposition', 'focusHalo', 'lastFindLoc', /* 'lines', aaa removed by Adam, slightly confused */ 'priorSelection', 'previousSelection', 
		'selectionRange', 'selectionPivot','typingHasBegun', 'undoSelectionRange', 'undoTextString', '_statusMorph'],

	// these are prototype variables
	fontSize:	Config.defaultFontSize	 || 12,
	fontFamily: Config.defaultFontFamily || 'Helvetica',
	textColor: Color.black,
	backgroundColor: Color.veryLightGray,
	style: { borderWidth: 1, borderColor: Color.black},
	padding: Rectangle.inset(6, 4),
	wrap: thisModule.WrapStyle.Normal,

	maxSafeSize: 200000,  // actually ran into this limit; increased it by a factor of 10 -- Adam, August 2010
	tabWidth: 4,
	tabsAsSpaces: true,
	noShallowCopyProperties: Morph.prototype.noShallowCopyProperties.concat(['textContent', 'lines', 'textSelection']),
	locale: Locale,
	acceptInput: true, // whether it accepts changes to text KP: change: interactive changes
	autoAccept: false,
	isSelecting: false, // true if last onmousedown was in character area (hit>0)
	selectionPivot: null,  // index of hit at onmousedown
	lineNumberHint: 0,
	hasKeyboardFocus: false,
	useChangeClue: false,

	formals: {
		Text: { byDefault: ""},
		Selection: { byDefault: ""},
		History: {byDefault: "----"},
		HistoryCursor: {byDefault: 0},
		DoitContext: {byDefault: null}
	},
	
	initializeTransientState: function($super) {
		$super();
		this.selectionRange = [0, -1]; // null or a pair of indices into textString
		this.priorSelection = [0, -1];	// for double-clicks
		// note selection is transient
		this.lines = null;//: TextLine[]
		
		// aaa not sure whether this is a hack or not -- Adam
		this.doNotSerialize.forEach(function(attrName) {
  		reflect(this).slotAt(attrName).setInitializationExpression('undefined');
		}.bind(this));
		reflect(this).slotAt('selectionRange').setInitializationExpression('[0, -1]'); 
		reflect(this).slotAt('priorSelection').setInitializationExpression('[0, -1]'); 
	
		if (this.isInputLine) {	 // for discussion, see beInputLine...
			this.beInputLine(this.historySize)
		}

	},

	initializePersistentState: function($super, shape) {
		$super(shape);
		this.textContent = this.addWrapper(new lively.scene.Text());
		reflect(this).slotAt('textContent').beCreator(); // added by Adam to make morph-saving work
		this.resetRendering();
		// KP: set attributes on the text elt, not on the morph, so that we can retrieve it
		this.applyStyle({fill: this.backgroundColor, borderWidth: this.borderWidth, borderColor: this.borderColor});
		this.initializeTextSelection();
	},

	initializeTextSelection: function() {
		this.textSelection = this.addMorphBack(new TextSelectionMorph());
		// The TextSelection must be beneath the Text, shift rawNode around
		this.rawNode.insertBefore(this.textSelection.rawNode, this.shape.rawNode.nextSibling);
	},

	restoreFromSubnode: function($super, importer, rawNode) {
		if ($super(importer, rawNode)) return true;
		if (rawNode.localName == "text") {
			this.textContent = new lively.scene.Text(importer, rawNode);   
  		reflect(this).slotAt('textContent').beCreator(); // added by Adam to make morph-saving work
			this.fontFamily = this.textContent.getFontFamily();
			this.fontSize = this.textContent.getFontSize();
			this.font = thisModule.Font.forFamily(this.fontFamily, this.fontSize);
			this.textColor = new Color(Importer.marker, this.textContent.getFill());
			return true;
		} 
		return false;
	},

	restorePersistentState: function($super, importer) {
		$super(importer); // FIXME legacy code, remove the whole method
		var attr = this.rawNode.getAttributeNS(null, "stored-style");
		if (attr) {
			var styleInfo = Converter.fromJSONAttribute(attr);
			this.textStyle = new RunArray(styleInfo.runs, styleInfo.values); 
		}
	},

	initialize: function($super, rect, textString, useChangeClue) {
		this.textString = textString || "";
		// rk 4/16/09 added two lines below as a bugfix for searching code with alt+w
		// in rev 2764 a changed call was added to setFill which causes an error
		this.selectionRange = [0, -1]; // null or a pair of indices into textString
		this.priorSelection = [0, -1];
		$super(rect);
		// KP: note layoutChanged will be called on addition to the tree
		// DI: ... and yet this seems necessary!
		if (this.textString instanceof thisModule.Text) {
			this.textStyle = this.textString.style;
			this.textString = this.textString.string || "";
		}
		if (this.textString === undefined) alert('initialize: ' + this);
		this.useChangeClue = useChangeClue == true;
		this.addChangeClue(useChangeClue);
		this.layoutChanged();
		return this;
	},
	
	prepareForSerialization: function($super, extraNodes, optSystemDictionary) {
		if (this.textSelection) {
			this.textSelection.remove();
			delete this.textSelection;
		}
		return $super(extraNodes, optSystemDictionary);
	},

	onDeserialize: function() {
		// the morph gets lost when it is not hung into the dom 
		// FIXME perhaps change to hide / visible mechanism 
		if (this.useChangeClue && !this.changeClue)
			this.addChangeClue(true);
	},
	
	acceptsDropping: function() {
		// using text morphs as containers feels extremly weired, especially when the fill 
		// and bounds are not visible like in the wiki
		// Is there a demo or other rules that needs that behavior? 
		// rk: I find it often convenient to enable that behavior, e.g. when composing
		// morphs for a class diagram. I think we should turn it on by default and provide
		// an easy to reach menu option to disable it
		return false
	}, 
	
	remove: function($super) {
		var hand = this.world() && this.world().firstHand();
		if (hand && hand.keyboardFocus === this)
			this.relinquishKeyboardFocus(hand);
		return $super();
	},
	
	bounds: function($super, ignoreTransients, hasBeenRendered) {
		// tag: newText
		if (this.fullBounds != null) return this.fullBounds;
		if (this.shouldNotRender) return $super(ignoreTransients);

		// Note: renderAfterReplacement calls this preemptively to set fullBounds
		//	  by calling fitText and all, but without re-rendering...
		if (!hasBeenRendered) this.resetRendering();
		this.fitText(); // adjust bounds or text for fit 
		this.drawSelection("noScroll");
		return $super(ignoreTransients);
	},

	setTextColor: function(color) {
		this.textColor = color;
		this.layoutChanged();
		this.changed();
		return this; // added by Adam
	},
	
	getTextColor: function() {
		return this.textColor;
	},

	applyStyle: function($super, spec) { // no default actions, note: use reflection instead?
		$super(spec);
		if (spec.wrapStyle !== undefined) {
			if (spec.wrapStyle in thisModule.WrapStyle) this.setWrapStyle(spec.wrapStyle);
			else console.log("unknown wrap style " + spec.wrapStyle);
		}
		if (spec.fontSize !== undefined) {
			this.setFontSize(spec.fontSize);
		}
		if (spec.textColor !== undefined) {
			this.setTextColor(spec.textColor);
		}
		
		// Added by Adam so that we can make the menu font size bigger without taking up huge amounts of space on padding.
		if (spec.padding !== undefined) {
		  this.padding = spec.padding;
		}
		
		// Added by Adam
		if (spec.fontFamily !== undefined) {
		  this.setFontFamily(spec.fontFamily);
		}
		return this;
	},

	applyStyleDeferred: function(styleSpec) {
		// tag: newText
		// Use of this method should minimize multiple renderings of text due to applyStyle
		this.shouldNotRender = true;  // suppresses attempts to render text in bounds()
		try {this.applyStyle(styleSpec); }
			catch (e) { this.shouldNotRender = false; }
		this.shouldNotRender = false;
	},
	
	makeStyleSpec: function($super, spec) {
		var spec = $super();
		if (this.wrap != TextMorph.prototype.wrap) {
			spec.wrapStyle = this.wrap;
		}
		if (this.getFontSize() !== TextMorph.prototype.fontSize) {
			spec.fontSize = this.getFontSize();
		}
		if (this.getFontFamily() !== TextMorph.prototype.fontFamily) {
			spec.fontFamily = this.getFontFamily();
		}

		if (this.textColor !== TextMorph.prototype.textColor) {
			spec.textColor = this.textColor;
		}
		return spec;
	},
	
	setWrapStyle: function(style) {
		if (!(style in thisModule.WrapStyle)) { 
			console.log("unknown style " + style + " in " + thisModule.WrapStyle);
			return; 
		}
		if (style == TextMorph.prototype.wrap) {
			delete this.wrap;
		} else {
			this.wrap = style;
		}
		return this; // added by Adam
	},
	
	beLabel: function(styleMods) {
		// Note default style is applied first, then any additional specified
		this.applyStyleDeferred({borderWidth: 0, borderColor: null, fill: null, wrapStyle: thisModule.WrapStyle.Shrink, fontSize: 12, padding: Rectangle.inset(0)});
		if (styleMods) this.applyStyleDeferred(styleMods);
		this.ignoreEvents();
		// this.isAccepting = false;
		this.layoutChanged();
		this.okToBeGrabbedBy = Functions.Null;
		return this;
	},

	beListItem: function() {
		// specify padding, otherwise selection will overlap
		this.applyStyleDeferred({borderWidth: 0, fill: null, wrapStyle: thisModule.WrapStyle.None, padding: Rectangle.inset(4, 0)});
		this.ignoreEvents();
		this.suppressHandles = true;
		this.acceptInput = false;
		this.okToBeGrabbedBy = Functions.Null;
		this.focusHaloBorderWidth = 0;
		this.drawSelection = Functions.Empty;
		return this;
	},
	
	nextHistoryEntry: function() {
		var history = this.getHistory();
		if (!history || history.length == 0) return "";
		var current = this.getHistoryCursor();
		current = (current + 1) % history.length;
		this.setHistoryCursor(current);
		return history[current];
	},
	
	previousHistoryEntry: function() {
		var history = this.getHistory();
		if (!history || history.length == 0) return "";
		var current = this.getHistoryCursor();
		current = (current + history.length - 1) % history.length;
		this.setHistoryCursor(current);
		return history[current];
	},
	
	saveHistoryEntry: function(text, historySize) {
		if (!historySize || !text) return;
		var history = this.getHistory();
		if (!history) history = [];
		history.push(text);
		history.length > historySize && history.unshift();
		this.setHistory(history);
		this.setHistoryCursor(history.length);
	},
	
	beInputLine: function(historySize) {
		this.isInputLine = true; // remeber to resetup after deserialization
		this.historySize = historySize;
		// should this behavior variation not go into a subclass (or COP layer ;-)) 
		// to make it less vulnerable for serialization? 
		this.onKeyDown = function(evt) {
			switch (evt.getKeyCode()) {
				case Event.KEY_DOWN: 
					historySize && this.setTextString(this.nextHistoryEntry());
					this.setNullSelectionAt(this.textString.length);
					evt.stop();
					return true;
				case Event.KEY_UP: 
					historySize && this.setTextString(this.previousHistoryEntry());
					this.setNullSelectionAt(this.textString.length);
					evt.stop();
					return true;
				case Event.KEY_RETURN:
					historySize && this.saveHistoryEntry(this.textString, historySize);
					this.saveContents(this.textString);
					evt.stop();
					return true;
				default:
					return Class.getPrototype(this).onKeyDown.call(this, evt);
			}
		};
		this.suppressGrabbing = true;
		this.onTextUpdate = function(newValue) {
			TextMorph.prototype.onTextUpdate.call(this, newValue);
			this.setSelectionRange(0, this.textString.length); 
		}
		return this;
	},

	beHelpBalloonFor: function(targetMorph) {
		this.relayMouseEvents(targetMorph, 
			{onMouseDown: "onMouseDown", onMouseMove: "onMouseMove", onMouseUp: "onMouseUp"});
		// some eye candy for the help
		this.linkToStyles(['helpText']);
		this.setWrapStyle(thisModule.WrapStyle.Shrink);
		this.openForDragAndDrop = false; // so it won't interfere with mouseovers
		return this;
	},

	subMenuItems: function($super, evt) {
		var items = $super(evt);
		items.unshift(["Text functions" , this.editMenuItems(evt)]);
		return items;
	},

	editMenuItems: function(evt) {
	// Add a first item for type-in if it's an iPad or similar device...
	return [
		["cut (x)", this.doCut.bind(this)],
		["copy (c)", this.doCopy.bind(this)],
		["paste (v)", this.doPaste.bind(this)],
		["replace next (m)", this.doMore.bind(this)],
		["exchange (e)", this.doExchange.bind(this)],
		["undo (z)", this.doUndo.bind(this)],
		["find (f)", this.doFind.bind(this)],
		["find next (g)", this.doFindNext.bind(this)],
		["find source (F)", this.doSearch.bind(this)],
		["do it (d)", this.doDoit.bind(this)],
		["print it (p)", this.doPrintit.bind(this)],
		["inspect it (I)", this.doInspect.bind(this)],
		["print it (p)", this.doPrintit.bind(this)],
		["accept changes (s)", this.doSave.bind(this)],
		["color (o)", this.colorSelection.bind(this)],
		["make link (u)", this.linkifySelection.bind(this)],
		["help", this.doHelp.bind(this)],

		// Typeface		
		["make italic (i)", (function(){this.emphasizeBoldItalic({style: 'italic'})}).bind(this)],
		["make bold (b)",  (function(){this.emphasizeBoldItalic({style: 'bold'})}).bind(this)],		

		["eval as JavaScript code", function() { this.boundEval(this.textString); }],
		["eval as Lively markup", function() { 
			var importer = new Importer();
			var txt = this.xml || this.textString;
			// console.log('evaluating markup ' + txt);
			var morph = importer.importFromString(txt);
			this.world().addMorph(morph);
			importer.finishImport(this.world()); }],
		["save as ...", function() { 
			this.world().prompt("save as...", function(filename) {
				if (!filename) return;
				var req = new NetRequest({model: new NetRequestReporter(), setStatus: "setRequestStatus"});
				req.put(URL.source.withFilename(filename), this.xml || this.textString);
				}.bind(this));
			}]
		]
	},

	// TextMorph composition functions
	textTopLeft: function() { 
		if (!(this.padding instanceof Rectangle)) console.log('padding is ' + this.padding);
		return this.shape.bounds().topLeft().addPt(this.padding.topLeft()); 
	},
	
	ensureRendered: function() { // created on demand and cached
		// tag: newText
		if (this.ensureTextString() == null) return null;
//		  if (!this.textContent.rawNode.firstChild)	 this.renderText(this.textTopLeft(), this.compositionWidth());
		if (!this.lines)  this.renderText(this.textTopLeft(), this.compositionWidth());
		return this.textContent; 
	},

	resetRendering: function() {
		// tag: newText
		this.textContent.replaceRawNodeChildren(null);
		this.textContent.setFill(this.textColor);
		this.font = thisModule.Font.forFamily(this.fontFamily, this.fontSize);
		this.font.applyTo(this.textContent);
		this.lines = null;
		this.lineNumberHint = 0;
	},

	renderAfterReplacement: function(replacementHints) {
		// tag: newText
		// DI:	The entire text composition scheme here should be replaced by something simpler
		// However, until that time, I have put in added logic to speed up editing in large bodies of text.
		//	We look at the lines of text as follows...
		//
		//		A:	Lines preceding the replacement, and that are unchanged
		//			Note that a preceding line can be affected if it has word-break spillover
		//		B:	Lines following A, including the replacement, and up to C
		//		C:	Lines following the replacement, and that are unchanged, except for Y-position

		if (Config.useOldText) return this.composeAfterEdits();	 // In case of emergency
		var test = false && this.textString.startsWith("P = new");	// Check out all the new logic in this case
		if (test) for (var i=0; i < this.lines.length; i++) console.log("Line " + i + " = " + [this.lines[i].startIndex, this.lines[i].getStopIndex()]);
		if (test) console.log("Last line y before = " + this.lines.last().topLeft.y);

		// The hints tell what range of the prior text got replaced, and how large was the replacement
		var selStart = replacementHints.selStart;  // JS substring convention: [1,2] means str[1] alone
		var selStop = replacementHints.selStop;
		var repLength = replacementHints.repLength;
		var repStop = selStart + repLength;
		var delta =	 repLength - (selStop+1 - selStart);  // index in string after replacement rel to before
		if (test) console.log(", selStart = " + selStart + ", selStop = " + selStop + ", repLength = " + repLength + ", repStop = " + repStop + ", delta = " + delta);

		var compositionWidth = this.compositionWidth();

		// It is assumed that this textMorph is still fully rendered for the text prior to replacement
		// Thus we can determine the lines affected by the change
		var lastLineNoOfA = Math.max(this.lineNumberForIndex(selStart) - 1, -1);  // -1 means no lines in A
		if (lastLineNoOfA >= 0 && !this.lines[lastLineNoOfA].endsWithNewLine()) lastLineNoOfA-- ;
		if (test) console.log("Replacing from " + selStart + " in line " + this.lineNumberForIndex(selStart) + " preserving lines 0 through " + lastLineNoOfA);

		var testEarlyEnd = function (lineStart) {
			//	Brilliant test looks for lines that begin at the same character as lineStart, thus indicating
			//	a line at which we can stop composing, and simply reuse the prior lines after updating
			if (lineStart <= repStop) return false;	 // Not beyond the replacement yet
			var oldLineNo = this.lineNumberForIndex(lineStart - delta);	 // --- do we need to check < 0 here?
			if (oldLineNo < 0) return false;
			var match = (this.lines[oldLineNo].startIndex + delta) == lineStart;
			if (test) console.log("At index " + lineStart + ", earlyEnd returns " + match);
			return match 
		}

		var oldFirstLine = this.lines[lastLineNoOfA+1];	 // The first line that may change
		// Note: do we need font at starting index??
		var newLines = this.composeLines(oldFirstLine.startIndex, oldFirstLine.topLeft, compositionWidth, this.font, testEarlyEnd.bind(this));
		for (var i = 0; i < newLines.length; i++) newLines[i].render(this.textContent);
		if (test) console.log("Size of lines before = " + (lastLineNoOfA+1));
		if (test) console.log("Size of new lines = " + newLines.length);
		if (test) console.log("stopIndex = " + newLines.last().getStopIndex() + ", overall last = " + (this.textString.length-1));

		var lastLineInB = newLines.last();
		if (lastLineInB && lastLineInB.getStopIndex() < this.textString.length-1) {
			//	Composition stopped before the end, presumably because of our brilliant test
			var firstLineNoInC = this.lineNumberForIndex(lastLineInB.getNextStartIndex() - delta);
			if (test) console.log("lineNumberForIndex(" + (lastLineInB.getNextStartIndex() - delta) + ") = " + firstLineNoInC); 
			var firstLineInC = this.lines[firstLineNoInC];
			var Ydelta = lastLineInB.topLeft.y + lastLineInB.lineHeight() - firstLineInC.topLeft.y;
			if (test) console.log ("lastLineInB.topLeft.y / lastLineInB.lineHeight() / firstLineInC.topLeft.y");
			if (test) console.log (lastLineInB.topLeft.y + " / " + lastLineInB.lineHeight() + " / " + firstLineInC.topLeft.y);

			//	Update the remaining old lines, adjusting indices and Y-values as well
			for (var i = firstLineNoInC; i < this.lines.length; i++)
			this.lines[i].adjustAfterEdits(this.textString, this.textStyle, delta, Ydelta);
			if (test) console.log("Size of lines after = " + (this.lines.length-firstLineNoInC));
			newLines = newLines.concat(this.lines.slice(firstLineNoInC));
			//	Release rawNodes for the deleted lines (just up to firstLineNoInC)
			for (var i = lastLineNoOfA+1; i < firstLineNoInC; i++)
			this.lines[i].removeRawNodes();
		} else {
			//	Release rawNodes for the deleted lines (all beyond lastLineNoOfA)
			for (var i = lastLineNoOfA+1; i < this.lines.length; i++)
			this.lines[i].removeRawNodes();
		}
		//	Update the textString reference in lines retained before the replacement
		for (var i = 0; i <= lastLineNoOfA; i++) 
		this.lines[i].adjustAfterEdits(this.textString, this.textStyle, 0, 0);

		this.lines = this.lines.slice(0, lastLineNoOfA+1).concat(newLines);
		this.lines.makeAllCreatorSlots(); // aaa hack for morph-saving -- Adam
		reflect(this).slotAt('lines').beCreator(); // aaa hack for morph-saving -- Adam

		if (test) for (var i=0; i < this.lines.length; i++) console.log("Line " + i + " = " + [this.lines[i].startIndex, this.lines[i].getStopIndex()]);
		if (test) console.log("Last line y after = " + this.lines.last().topLeft.y);

		this.bounds(null, true);  // Call bounds now to set fullBounds and avoid re-rendering
	},

	ensureTextString: function() { 
		// may be overrridden
		return this.textString; 
	}, 

	// return the bounding rectangle for the index-th character in textString	 
	getCharBounds: function(index) {
	  // Factored out getCharBoundsWithoutCopying, need it as an optimization. -- Adam
		// KP: note copy to avoid inadvertent modifications
	  var bounds = this.getCharBoundsWithoutCopying(index);
		if (bounds) {
		  console.log("Copying bounds");
		  return bounds.copy();
		} else {
		  return bounds;
		}
	},

	getCharBoundsWithoutCopying: function(index) {
		// tag: newText
		this.ensureRendered();
		if (!this.lines) return null;
		var line = this.lineForIndex(index);
		var bounds = line == null ? null : line.getBounds(index);
		if (bounds) { return bounds; }
		return null;
	},

	// compose the lines if necessary and then render them
	renderText: function(topLeft, compositionWidth) {
		// tag: newText
		// Note:  This seems to be a spacer for one-line texts, as in a list of texts,
		//	  not an interline spacing for lines in a paragraph.
		var defaultInterline = (lively.Text.TextLine.prototype.lineHeightFactor - 1) * this.font.getSize();

		this.lines = this.composeLines(0, topLeft.addXY(0, defaultInterline/2), compositionWidth, this.font);
		// aaa slow?   this.lines.makeAllCreatorSlots(); // aaa hack for morph-saving -- Adam
		// aaa slow?   reflect(this).slotAt('lines').beCreator(); // aaa hack for morph-saving -- Adam
		for (var i = 0; i < this.lines.length; i++) this.lines[i].render(this.textContent);
	},

	composeLines: function(initialStartIndex, initialTopLeft, compositionWidth, font, testEarlyEnd) {
		// tag: newText
		// compose and return in an array, lines in the text beginning at initialStartIndex
		//	console.log("composeLines(" + initialStartIndex + "): " + this.textString.substring(0,10) + "...");
		// if (this.textString.startsWith("funct") && initialStartIndex == 0) lively.lang.Execution.showStack();
		var lines = new Array();
		var startIndex = initialStartIndex;
		var stopIndex = this.textString.length - 1;
		var chunkStream = new lively.Text.ChunkStream(this.textString, this.textStyle, startIndex);
		var topLeft = initialTopLeft;
		while (startIndex <= stopIndex) {
			var line = new lively.Text.TextLine(this.textString, this.textStyle, 
				startIndex, topLeft, font, new TextEmphasis({}));
			line.setTabWidth(this.tabWidth, this.tabsAsSpaces);
			line.compose(compositionWidth, chunkStream);
			line.adjustAfterComposition(this.textString, compositionWidth);
			startIndex = line.getNextStartIndex();
			chunkStream.stringIndex = startIndex;
			topLeft = topLeft.addXY(0, line.lineHeight());
			lines.push(line);
			if (testEarlyEnd && testEarlyEnd(startIndex)) break
		}
		return lines;
	},

	lineNumberSearch: function(lineFunction) {
		// A linear search, starting at the same place as last time.
		if (!this.lines) return -1;
		var lineNo = this.lineNumberHint;
		if (! lineNo || lineNo < 0 || lineNo >= this.lines.length) lineNo = 0;

		while (lineNo >= 0 && lineNo < this.lines.length) {
			var test = lineFunction(this.lines[lineNo]);
			if (test == 0) {this.lineNumberHint = lineNo;  return lineNo; }
			if (test < 0) lineNo--;
			else lineNo++;
		}
		return -1;
	},

	// find what line contains the index 'stringIndex'
	lineNumberForIndex: function(stringIndex) {
		return this.lineNumberSearch( function(line) { return line.testForIndex(stringIndex); });	},

	lineForIndex: function(stringIndex) {
		return this.lines[this.lineNumberForIndex(stringIndex)];
	},

	// find what line contains the y value in character metric space
	lineNumberForY: function(y) {
		return this.lineNumberSearch( function(line) { return line.testForY(y); });	   
	},

	lineForY: function(y) {
		var i = this.lineNumberForY(y);
		if (i < 0) return null;
		return this.lines[i];
	},
	
	hit: function(x, y) {
		var line = this.lineForY(y);
		return line == null ? -1 : line.indexForX(x); 
	},

	setTabWidth: function(width, asSpaces) {
		this.tabWidth = width;
		this.tabsAsSpaces = asSpaces;
	},

	compositionWidth: function() {
		var padding = this.padding;
		if (this.wrap == thisModule.WrapStyle.Normal) return this.shape.bounds().width - padding.left() - padding.right();
		else return 9999; // Huh??
	},

	// DI: Should rename fitWidth to be composeLineWrap and fitHeight to be composeWordWrap
	fitText: function() { 
		if (this.wrap == thisModule.WrapStyle.Normal) 
			this.fitHeight();
		else 
			this.fitWidth();
		
		return this; // added by Adam
	},
	
	adjustScale: function () {
		// Experimenting to see if I can make a TextMorph that reduces its own scale
		// as it gains text. -- Adam
		var maxSpace = this._maxSpace;
		if (maxSpace) {
    	var e = this.getExtent();
  	  this.setScale(Math.max(0.4, Math.min(1, maxSpace.x / e.x, maxSpace.y / e.y)));
		}
	},

	lineHeight: function() {
		return this.font.getSize() * lively.Text.TextLine.prototype.lineHeightFactor;
	},

	fitHeight: function() { //Returns true iff height changes
		// Wrap text to bounds width, and set height from total text height
		if (!this.textString || this.textString.length <= 0) return;
		var jRect = this.getCharBoundsWithoutCopying(this.textString.length - 1);

		if (jRect == null) { 
			console.log("char bounds is null"); 
			return; 
		}

		// console.log('last char is ' + jRect.inspect() + ' for string ' + this.textString);
		var maxY = Math.max(this.lineHeight(), jRect.maxY());

		var padding	 = this.padding;
		if (this.shape.bounds().maxY() == maxY + padding.top()) 
			return; // No change in height	// *** check that this converges

		var bottomY = padding.top() + maxY;

		var oldBounds = this.shape.bounds();
		this.shape.setBounds(oldBounds.withHeight(bottomY - oldBounds.y))

		this.adjustForNewBounds();
	},

	fitWidth: function() {
		// Set morph bounds based on max text width and height

		var jRect = this.getCharBoundsWithoutCopying(0);
		if (jRect == null) { 
			// console.log("fitWidth failure on TextMorph.getCharBounds"); // commented out because it's very annoying -- Adam, June 2011
			var s = this.shape;
			s.setBounds(s.bounds().withHeight(this.lineHeight()));
			return; 
		}

		var x0 = jRect.x;
		var y0 = jRect.y;
		var maxX = jRect.maxX();  
		var maxY = jRect.maxY();

		// DI: really only need to check last char before line breaks...
		// ... and last character
		var s = this.textString;
		var iMax = s.length - 1;
		for (var i = 0; i <= iMax; i++) {
			var c = this.textString[Math.min(i+1, iMax)];
			if (i == iMax || c == "\n" || c == "\r") {
				jRect = this.getCharBoundsWithoutCopying(i);
				if (jRect == null) { console.log("null bounds at char " + i); return false; }
				if (jRect.width < 100) { // line break character gets extended to comp width
					maxX = Math.max(maxX, jRect.maxX());
					maxY = Math.max(maxY, jRect.maxY()); 
				}
			}
		}

		// if (this.innerBounds().width==(maxX-x0) && this.innerBounds().height==(maxY-y0)) return;
		// No change in width *** check convergence
		var padding = this.padding;
		var bottomRight = padding.topLeft().addXY(maxX,maxY);


		// DI: This should just say, eg, this.shape.setBottomRight(bottomRight);
		var b = this.shape.bounds();
		if (this.wrap == thisModule.WrapStyle.None) {
			this.shape.setBounds(b.withHeight(bottomRight.y - b.y));
		} else if (this.wrap == thisModule.WrapStyle.Shrink) {
			this.shape.setBounds(b.withBottomRight(bottomRight));
		}

	},

	showsSelectionWithoutFocus: Functions.False, // Overridden in, eg, Lists
	
	getTextSelection: function() {
		if (!this.textSelection) {
			this.initializeTextSelection();
		}
		return this.textSelection
	},
	
	removeTextSelection: function() {
		if (!this.textSelection) {
			return
		}
		this.textSelection.remove();
		delete this.textSelection;
	},

	selectionStyle: function() {
		// This is just a way into the lively.Text namespace; not an access to this selectionMorph
		return TextSelectionMorph.prototype.style
	},

	undrawSelection: function() {
		if (!this.textSelection) return
		this.textSelection.undraw(); 
	},

	drawSelection: function(noScroll) { // should really be called buildSelection now
		if (!this.showsSelectionWithoutFocus() && this.takesKeyboardFocus() && !this.hasKeyboardFocus) {
			return;
		}

		this.undrawSelection();
		var selection = this.getTextSelection();

		var jRect;
		if (this.selectionRange[0] > this.textString.length - 1) { // null sel at end
			jRect = this.getCharBoundsWithoutCopying(this.selectionRange[0]-1);
			if (jRect) {
				jRect = jRect.translatedBy(pt(jRect.width,0));
			}
		} else {
			jRect = this.getCharBoundsWithoutCopying(this.selectionRange[0]);
		}

		if (jRect == null) {
			if (this.textString.length > 0) {
				// console.log("text box failure in drawSelection index = " + this.selectionRange[0] + "text is: " + this.textString.substring(0, Math.min(15,this.textString.length)) + '...'); 
			}
			return;
		}

		var r1 = this.lineRect(jRect.withWidth(1));
		if (this.hasNullSelection()) {
			var r2 = r1.translatedBy(pt(-1,0)); 
		} else {
			jRect = this.getCharBoundsWithoutCopying(this.selectionRange[1]);
			if (jRect == null)	{
				return;
			}

			var r2 = this.lineRect(jRect);
			r2 = r2.translatedBy(pt(r2.width - 1, 0)).withWidth(1); 
		}

		if (this.lineNo(r2) == this.lineNo(r1)) {
			selection.addRectangle(r1.union(r2));
		} else { // Selection is on two or more lines
			var localBounds = this.shape.bounds();
			var padding = this.padding;
			r1 = r1.withBottomRight(pt(localBounds.maxX() - padding.left(), r1.maxY()));
			r2 = r2.withBottomLeft(pt(localBounds.x + padding.left(), r2.maxY()));
			selection.addRectangle(r1);
			selection.addRectangle(r2);

			if (this.lineNo(r2) != this.lineNo(r1) + 1) {
				// Selection spans 3 or more lines; fill the block between top and bottom lines
				selection.addRectangle(Rectangle.fromAny(r1.bottomRight(), r2.topLeft()));
			}
		}

		// scrolling here can cause circularity with bounds calc
		if (!noScroll) this.scrollSelectionIntoView();
	},

	lineNo: function(r) { //Returns the line number of a given rectangle
		return this.lineNumberForY(r.center().y);
	},
	
	lineRect: function(r) { //Returns a new rect aligned to text lines
		var line = this.lines[Math.min(Math.max(this.lineNo(r), 0), this.lines.length - 1)];
		return new Rectangle(r.x, line.getTopY() - line.interline()/2, r.width, line.lineHeight());
	},
	
	charOfPoint: function(localP) {	 //Sanitized hit function
		// DI: Nearly perfect now except past last char if not EOL
		// Note that hit(x,y) expects x,y to be in morph coordinates,
		// but y should have 2 subtracted from it.
		// Also getBnds(i) reports rectangles that need 2 added to their y values.
		// GetBounds(i) returns -1 above and below the text bounds, and
		// 0 right of the bounds, and leftmost character left of the bounds.
		var tl = this.textTopLeft();
		var px = Math.max(localP.x, tl.x); // ensure no returns of 0 left of bounds
		var px = Math.min(px, this.innerBounds().maxX()-1); // nor right of bounds
		var py = localP.y - 2;
		var hit = this.hit(px, py);
		var charIx = this.hit(px, py);
		var len = this.textString.length;

		// hit(x,y) returns -1 above and below box -- return 1st char or past last
		if (charIx < 0) return py < tl.y ? 0 : len;

		if (charIx == 0 && this.getCharBoundsWithoutCopying(len-1).topRight().lessPt(localP))
			return len;

		// It's a normal character hit
		// People tend to click on gaps rather than character centers...
		var cRect = this.getCharBoundsWithoutCopying(charIx);
		if (cRect != null && px > cRect.center().x) {
			return Math.min(charIx + 1, len);
		}
		return charIx;
	},
	
	// TextMorph mouse event functions 
	handlesMouseDown: function(evt) {
		// Do selecting if click is in selectable area
		if (evt.isCommandKey() || evt.isRightMouseButtonDown() || evt.isMiddleMouseButtonDown()) return false;
		var selectableArea = this.openForDragAndDrop ? this.innerBounds() : this.shape.bounds();
		return selectableArea.containsPoint(this.localize(evt.mousePoint)); 
	},

	onMouseDown: function(evt) {
		var link = this.linkUnderMouse(evt);
		if (link && !evt.isCtrlDown()) { // there has to be a way to edit links!
			console.log("follow link " + link)
			this.doLinkThing(evt, link);
			return true;
		}
		this.isSelecting = true;
		if (evt.isShiftDown()) {
			if (this.hasNullSelection())
				this.selectionPivot = this.selectionRange[0];
			this.extendSelectionEvt(evt);
		} else {
			var charIx = this.charOfPoint(this.localize(evt.mousePoint));
			this.startSelection(charIx);
		}
		this.requestKeyboardFocus(evt.hand);
		// ClipboardHack.selectPasteBuffer();
		return true; 
	},
	
	onMouseMove: function($super, evt) { 
		// console.log("mouse move " + evt.mousePoint)
		if (this.isSelecting) return this.extendSelectionEvt(evt);
		var link = this.linkUnderMouse(evt);
		// TODO refactor ito into HandleMorph
		// but this is a good place to evalutate what a mouse indicators should look like..
		if (link && this.containsPoint(evt.mousePoint)) { // there is onMouseMove after the onMouseOut
			if (evt.isCtrlDown()) {
				if (evt.hand.indicator != "edit") {
					evt.hand.indicator = "edit";
					evt.hand.lookNormal();
					evt.hand.removeIndicatorMorph();
					var morph = evt.hand.ensureIndicatorMorph();
					morph.setTextString("edit");
					morph.setTextColor(Color.red);
				}
			} else {
				if (evt.hand.indicator != link) {
					evt.hand.indicator = link;
					evt.hand.lookLinky();
					evt.hand.removeIndicatorMorph();
					var morph = evt.hand.ensureIndicatorMorph();
					morph.setTextString(link);
					morph.setExtent(pt(300,20));
					morph.setTextColor(Color.blue);
				}
			}
		} else {
			evt.hand.lookNormal();
			evt.hand.removeIndicatorMorph();
			evt.hand.indicator = undefined;			
		};
		return $super(evt);		   
	},

	onMouseOut: function($super, evt) {
		$super(evt);
		// console.log("mouse out " + evt.mousePoint)
		evt.hand.lookNormal();
		evt.hand.removeIndicatorMorph();
		evt.hand.indicator = undefined;
	},

	linkUnderMouse: function(evt) {	 
		// Return null or a link encoded in the text
		if (!this.textStyle) return null;
		var charIx = this.charOfPoint(this.localize(evt.mousePoint));
		return this.textStyle.valueAt(charIx).link;		  
	},
	
	doLinkThing: function(evt, link) { 
		// Later this should set a flag like isSelecting, so that we can highlight the 
		// link during mouseDown and then act on mouseUp.
		// For now, we just act on mouseDown
		evt.hand.lookNormal();
		evt.hand.setMouseFocus(null);
		evt.stop();	 // else weird things happen when return from this link by browser back button
		var url = URL.ensureAbsoluteURL(link);
		// add require to LKWiki.js here
		var wikiNav = Global['WikiNavigator'] && new WikiNavigator(url, null, -1 /*FIXME don't ask for the headrevision*/);
		var isExternalLink = url.hostname != document.location.hostname;
		var openInNewWindow = evt.isMetaDown();

		var followLink = function (answer) {
			Config.askBeforeQuit = false;
			if (!isExternalLink) {
				var queries = Object.extend(url.getQuery(), {date: new Date().getTime()});
				url = url.withQuery(queries);
			}
			if (openInNewWindow)
				Global.window.open(url.toString());
			else
				Global.window.location.assign(url.toString());
		};
		
		if (!Config.confirmNavigation) 
			return followLink();
		
		if (wikiNav && wikiNav.isActive() && !isExternalLink)
			wikiNav.askToSaveAndNavigateToUrl(this.world(), openInNewWindow);
		else
			this.world().confirm("Please confirm link to " + url.toString(), followLink);
	},	

	onMouseUp: function(evt) {
		this.isSelecting = false;

		// If not a repeated null selection then done after saving previous selection
		if ( (this.selectionRange[1] != this.selectionRange[0] - 1) ||
		(this.priorSelection[1] != this.priorSelection[0] - 1) ||
		(this.selectionRange[0] != this.priorSelection[0]) ) {
			this.previousSelection = this.priorSelection;
			ClipboardHack.invokeKeyboard();
			return;
		}

		// It is a null selection, repeated in the same place -- select word or range
		if (this.selectionRange[0] == 0 || this.selectionRange[0] == this.textString.length) {
			this.setSelectionRange(0, this.textString.length); 
		} else {
			this.selectionRange = this.locale.selectWord(this.textString, this.selectionRange[0]);
		}

		this.setSelection(this.getSelectionString());
		this.drawSelection(); 
			ClipboardHack.invokeKeyboard();
	},
	
	// TextMorph text selection functions

	startSelection: function(charIx) {	
		// We hit a character, so start a selection...
		// console.log('start selection @' + charIx);
		this.priorSelection = this.selectionRange;
		this.selectionPivot = charIx;
		this.setNullSelectionAt(charIx);

		// KP: was this.world().worldState.keyboardFocus = this; but that's an implicitly defined prop in Transmorph, bug?
		// KP: the following instead??
		// this.world().firstHand().setKeyboardFocus(this);
	},

	extendSelectionEvt: function(evt) { 
		var charIx = this.charOfPoint(this.localize(evt.mousePoint));
		// console.log('extend selection @' + charIx);
		if (charIx < 0) return;
		this.setSelectionRange(this.selectionPivot, charIx); 
	},
	
	selectionString: function() { // Deprecated
		return this.getSelectionString(); 
	},
	
	getSelectionString: function() {
		return this.textString.substring(this.selectionRange[0], this.selectionRange[1] + 1); 
	},
	
	getSelectionText: function() {
		return this.textStyle ? 
		this.getRichText().subtext(this.selectionRange[0], this.selectionRange[1] + 1)
		: new thisModule.Text(this.getSelectionString());
	},

	// FIXME integrate into model of TextMorph
	setRichText: function(text) {
		if (!(text instanceof lively.Text.Text)) throw dbgOn(new Error('Not text'));
		this.textStyle = text.style;
		this.setTextString(text.string);
	},
	
	getRichText: function() {
		return new thisModule.Text(this.textString, this.textStyle); 
	},

	replaceSelectionWith: function(replacement) { 
		if (! this.acceptInput) return;
		var strStyle = this.textStyle;
		var repStyle = replacement.style;
		var oldLength = this.textString.length;

		if (! this.typingHasBegun) { // save info for 'More' command
			this.charsReplaced = this.getSelectionString();
			this.lastFindLoc = this.selectionRange[0] + replacement.length;
		}

		var selStart = this.selectionRange[0];	// JS substring convention: [1,2] means str[1] alone
		var selStop = this.selectionRange[1];
		var repLength = replacement.asString().length;
		var replacementHints = {selStart: selStart, selStop: selStop, repLength: repLength};
		if (this.textString.length == 0) replacementHints = null;  // replacement logic fails in this case

		// Splice the style array if any	
		if (strStyle || repStyle) { 
			if (!strStyle) strStyle = new RunArray([oldLength],	 [new TextEmphasis({})]);
			if (!repStyle) repStyle = new RunArray([replacement.length], [strStyle.valueAt(Math.max(0, this.selectionRange[0]-1))]);
			var beforeStyle = strStyle.slice(0, selStart);
			var afterStyle = strStyle.slice(selStop+1, oldLength);
			this.textStyle = beforeStyle.concat(repStyle).concat(afterStyle);
		}		
		if (this.textStyle && this.textStyle.values.all(function(ea) {return !ea})) this.textStyle = null;

		// Splice the textString
		var before = this.textString.substring(0,selStart); 
		var after = this.textString.substring(selStop+1, oldLength);
		this.setTextString(before.concat(replacement.asString(),after), replacementHints);

		if(selStart == -1 && selStop == -1) {  // FixMe -- this shouldn't happen
			this.setSelectionRange(0,0); // symptom fix of typing into a "very empty" string
		};

		// Compute new selection, and display
		var selectionIndex = this.selectionRange[0] + replacement.length;
		this.startSelection(selectionIndex); 

		this.showChangeClue();		
	},

	setNullSelectionAt: function(charIx) { 
		this.setSelectionRange(charIx, charIx); 
	},
	
	hasNullSelection: function() { 
		return this.selectionRange[1] < this.selectionRange[0]; 
	},

	setSelectionRange: function(piv, ext) { 
		// console.log("setSelectionRange(" + piv + ", " + ext, ")")
		this.selectionRange = (ext >= piv) ? [piv, ext - 1] : [ext, piv - 1];
		this.setSelection(this.getSelectionString());
		this.drawSelection(); 
	this.typingHasBegun = false;  // New selection starts new typing
	},

	// TextMorph keyboard event functions
	takesKeyboardFocus: Functions.True,			// unlike, eg, cheapMenus
	
	setHasKeyboardFocus: function(newSetting) { 
		this.hasKeyboardFocus = newSetting;
		return newSetting;
	},
	
	onFocus: function($super, hand) { 
		$super(hand);
		this.drawSelection();
	},

	onBlur: function($super, hand) {
		$super(hand);
		if (!this.showsSelectionWithoutFocus()) this.undrawSelection();
	},

	onKeyDown: function(evt) {
		if (!this.acceptInput) return;

		// rk: With Mac OS 10.6 it's not sufficient to set the selection of the textarea
		// when doing tryClipboardAction. Hack of the hack for now: always set selection 
		// FIXME, other place Widgets, SelectionMorph>>reshape
		// ClipboardHack.selectPasteBuffer();
		
		var selecting = evt.isShiftDown();
		var selectionStopped = !this.hasNullSelection() && !selecting;
		var pos = this.getCursorPos(); // is selectionRange[0] or selectionRange[1], depends on selectionPivot
		var wordRange = evt.isMetaDown() ? this.locale.selectWord(this.textString, pos) : null;

		var textMorph = this;
		var moveCursor = function(newPos) {
			if (selecting) textMorph.extendSelection(newPos);
			else textMorph.startSelection(newPos);
			evt.stop();
			return true;
		};
		
		// A couple of Emacs key bindings that are ingrained in my fingers. -- Adam
		var shouldUseEmacsKeyBindings = true;
		if (shouldUseEmacsKeyBindings) {
			if (evt.isCtrlDown()) {
				var ch = String.fromCharCode(evt.getKeyCode());
				if      (ch === 'A') {return this.goToBeginningOfLine(evt);}
				else if (ch === 'E') {return this.goToEndOfLine(evt);}
				else if (ch === 'D') {return this.deleteForward(evt);}
			}
		}

		switch (evt.getKeyCode()) {
			case Event.KEY_HOME: { return this.goToBeginningOfLine(evt); } // extracted goToBeginningOfLine -- Adam
			case Event.KEY_END:  { return this.goToEndOfLine(      evt); } // extracted goToEndOfLine       -- Adam
			case Event.KEY_PAGEUP: {
				// go to start
				return moveCursor(0);
			}
			case Event.KEY_PAGEDOWN: {
				// go to start
				return moveCursor(this.textString.length);
			}
			case Event.KEY_LEFT: {
				if (selectionStopped) // if a selection exists but but selecting off -> jump to the beginning of the selection
					return moveCursor(this.selectionRange[0]);
				var newPos = evt.isMetaDown() && wordRange[0] != pos ? wordRange[0] : pos-1;
				newPos = Math.max(newPos, 0);
				return moveCursor(newPos);
			} 
			case Event.KEY_RIGHT: {
				if (selectionStopped) // if a selection exists but selecting off -> jump to the end of the selection
					return moveCursor(this.selectionRange[1]+1);
				newPos = evt.isMetaDown() && wordRange[1]+1 != pos ? wordRange[1]+1 : pos + 1;
				newPos = Math.min(this.textString.length, newPos);
				return moveCursor(newPos);
			}
			case Event.KEY_UP: {
				var lineNo = this.lineNumberForIndex(Math.min(pos, this.textString.length-1));
				if (lineNo <= 0) { // cannot move up
					evt.stop();
					return true;
				}
				var line = this.lines[lineNo];
				var lineIndex = pos - line.startIndex;
				var newLine = this.lines[lineNo - 1];
				var newPos = Math.min(newLine.startIndex + lineIndex, newLine.getStopIndex());
				return moveCursor(newPos);
			}
			case Event.KEY_DOWN: {
				var lineNo = this.lineNumberForIndex(pos);
				if (lineNo >= this.lines.length - 1) { // cannot move down
					evt.stop();
					return true;
				}
				var line = this.lines[lineNo];
				if (!line) {
						console.log('TextMorph finds no line ???');
						evt.stop();
						return true
				}
				var lineIndex = pos	 - line.startIndex;
				var newLine = this.lines[lineNo + 1];
				var newPos = Math.min(newLine.startIndex + lineIndex, newLine.getStopIndex());
				return moveCursor(newPos);
			}
			case Event.KEY_TAB: {
				this.replaceSelectionfromKeyboard("\t");
				evt.stop();
				return true;
			}
			case Event.KEY_BACKSPACE: { return this.deleteBackward(evt); } // extracted deleteBackward -- Adam
			case Event.KEY_DELETE:    { return this.deleteForward (evt); } // added deleteForward -- Adam
			case Event.KEY_RETURN: {
				this.replaceSelectionfromKeyboard("\n");
				evt.stop();
				return true;
			}
			case Event.KEY_ESC: {
				this.relinquishKeyboardFocus(this.world().firstHand());
				return true;
			}
		}

		
		if (ClipboardHack.tryClipboardAction(evt, this)) {
			return true;
		}

		if (evt.isCommandKey() ) {
			if (this.processCommandKeys(evt)) {
				evt.stop();
				return true;
			}
		}

		return false		
	},
      
      
      
	// A bunch of stuff extracted from onKeyDown so that I could reuse methods like goToBeginningOfLine. -- Adam
      
	eventIsSelecting: function(evt) {
		return evt.isShiftDown();
	},

	moveCursor: function(newPos, evt) {
		if (this.eventIsSelecting(evt)) this.extendSelection(newPos);
		else this.startSelection(newPos);
		evt.stop();
		return true;
        },
	
	goToBeginningOfLine: function(evt) {
		var line = this.lines[this.lineNumberForIndex(this.getCursorPos())] || this.lines.last(); //FIXME
		return this.moveCursor(line.startIndex, evt);
        },
	
	goToEndOfLine: function(evt) {
		// go to the end of the line
		var line = this.lines[this.lineNumberForIndex(this.getCursorPos())] || this.lines.last(); //FIXME
		var idx = line === this.lines.last() ? line.getStopIndex() + 1 : line.getStopIndex(); // FIXME!!!
		return this.moveCursor(idx, evt);
	},

	deleteForward: function(evt) {
		if (this.hasNullSelection()) this.selectionRange[1] = Math.max(0, this.selectionRange[0]);
		this.replaceSelectionfromKeyboard("");
		evt.stop(); // do not use for browser navigation
		return true;
	},

	deleteBackward: function(evt) {
		if (this.hasNullSelection()) this.selectionRange[0] = Math.max(-1, this.selectionRange[0]-1);
		this.replaceSelectionfromKeyboard("");
		if (this.charsTyped.length > 0) this.charsTyped = this.charsTyped.substring(0, this.charsTyped.length-1); 
		evt.stop(); // do not use for browser navigation
		return true;
	},




	onKeyPress: function(evt) {
		if (!this.acceptInput)
			return true;

		// Opera fix: evt.stop in onKeyPress does not seem to work
		var c = evt.getKeyCode()
		if (c === Event.KEY_BACKSPACE || c === Event.KEY_RETURN || c === Event.KEY_TAB) {
			evt.stop();
			return true;
		}
			
		
		if (!evt.isMetaDown()) {
			this.replaceSelectionfromKeyboard(evt.getKeyChar()); 
			evt.stop(); // done
			return true;
		}
		
		return false;
	},
	
	replaceSelectionfromKeyboard: function(replacement) {
		if (!this.acceptInput) return;		  

		if (this.typingHasBegun)  this.charsTyped += replacement;
			else  this.charsTyped = replacement;

		this.replaceSelectionWith(replacement);
		// Note:  typingHasBegun will get reset here by replaceSelection

		this.typingHasBegun = true;	 // For undo and select-all commands		
	},
	
	modifySelectedLines: function(modifyFunc) {
		// this function calls modifyFunc on each line that is selected
		// modifyFunc can somehow change the line
		// the selection grows/shrinks with the modifications
		var lines = this.getSelectionString().split('\n')
		// remember old sel because replace sets null selection
		var start = this.selectionRange[0], end = this.selectionRange[1]+1, addToSel = 0;
		for (var i = 0; i < lines.length; i++) {
			var result = modifyFunc(lines[i], i);
			var lengthDiff = result.length - lines[i].length;
			addToSel += lengthDiff;
			lines[i] = result;
		}
		var replacement = lines.join('\n');
		this.replaceSelectionWith(replacement);
		this.setSelectionRange(start, end + addToSel);
	},
	
	doCut: function() {
		TextMorph.clipboardString = this.getSelectionString(); 
		this.replaceSelectionWith("");
	},

	doCopy: function() {
		TextMorph.clipboardString = this.getSelectionString(); 
	},

	doPaste: function() {
		if (TextMorph.clipboardString) {
			var cleanString = TextMorph.clipboardString.replace(/\r\n/g, "\n");
			this.replaceSelectionfromKeyboard(cleanString);
		}
	},
	
	doSelectAll: function(fromKeyboard) {
		if (fromKeyboard && this.typingHasBegun) { // Select chars just typed
			this.setSelectionRange(this.selectionRange[0] - this.charsTyped.length, this.selectionRange[0]);
		} else { // Select All
			this.setSelectionRange(0, this.textString.length); 
		}
	},

	doMore: function() {
		if (this.charsReplaced) {
			this.searchForFind(this.charsReplaced, this.selectionRange[0]);
			if (this.getSelectionString() != this.charsReplaced) return;
			var holdChars = this.charsReplaced;	 // Save charsReplaced
			this.replaceSelectionWith(this.charsTyped); 
			this.charsReplaced = holdChars ;  // Restore charsReplaced after above
		}
	},

	doExchange: function() {
		var sel1 = this.selectionRange;
		var sel2 = this.previousSelection;

		var d = 1;	// direction current selection will move
		if (sel1[0] > sel2[0]) {var t = sel1; sel1 = sel2; sel2 = t; d = -1} // swap so sel1 is first
		if (sel1[1] >= sel2[0]) return; // ranges must not overlap

		var fullText = (this.textStyle) ? this.getRichText() : this.textString;
		var txt1 = fullText.substring(sel1[0], sel1[1]+1);
		var txt2 = fullText.substring(sel2[0], sel2[1]+1);
		var between = fullText.substring(sel1[1]+1, sel2[0]);

		var d1 = (txt2.size() + between.size());  // amount to move sel1
		var d2 = (txt1.size() + between.size());  // amount to move sel2
		var newSel = [sel1[0]+d1, sel1[1]+d1];
		var newPrev = [sel2[0]-d2, sel2[1]-d2];
		if (d < 0) { var t = newSel;  newSel = newPrev;	 newPrev = t; }
		var replacement = txt2.concat(between.concat(txt1));
		this.setSelectionRange(sel1[0], sel2[1]+1);	 // select range including both selections
		this.replaceSelectionWith(replacement);	 // replace by swapped text
		this.setSelectionRange(newSel[0], newSel[1]+1);
		this.previousSelection = newPrev;
		this.undoSelectionRange = d>0 ? sel1 : sel2;
	},

	doFind: function() {
		this.world() && this.world().prompt("Enter the text you wish to find...", 
			function(response) {
				return this.searchForFind(response, this.selectionRange[1]);
			}.bind(this),
			this.lastSearchString);
	},

	doFindNext: function() {
		if (this.lastSearchString)
		this.searchForFind(this.lastSearchString, this.lastFindLoc + this.lastSearchString.length);
	},
	
	doSearch: function() {
		var whatToSearch = this.getSelectionString();
		if (lively.Tools.SourceControl) {
			lively.Tools.SourceControl.browseReferencesTo(whatToSearch);
			return;
		};
		var msg = 'No SourceControl available.\nStart SourceControl?';
		WorldMorph.current().confirm(msg, function(answer) {
			if (!answer) return;
			require('lively.ide').toRun(function(unused, ide) {
				ide.startSourceControl().browseReferencesTo(whatToSearch);
			});
		});
	},
	
	doInspect: function() {
		console.log("do inspect")
		var s = this.pvtStringAndOffsetToEval();
		try {
			var inspectee = this.tryBoundEval(s.str, s.offset);
		} catch (e) {
			console.log("eval error in doInspect " + e)
		};
		if (inspectee) {
			try {
				new SimpleInspector(inspectee).openIn(this.world(), this.world().hands.first().getPosition())
			} catch(e) {
				this.setStatusMessage("could not open inspector on " + inspectee);
				console.log("Error during opending an inspector:"+ e);
			}
		}
	},
	
	pvtStringAndOffsetToEval: function() {
		var strToEval = this.getSelectionString(); 
		var offset = this.selectionRange[0];
		if (strToEval.length == 0) {
			strToEval = this.pvtCurrentLineString();
			offset = this.pvtCurrentLine().startIndex;
		}
		return {str: strToEval, offset: offset}
	},
	
	doDoit: function() {
		var s = this.pvtStringAndOffsetToEval();
		this.tryBoundEval(s.str, s.offset);
	},

	// eval selection or current line if selection is emtpy
	doPrintit: function() {
		var s = this.pvtStringAndOffsetToEval();
		this.tryBoundEval(s.str, s.offset, true);
		// this.replaceSelectionWith(" " + result);
		// this.setSelectionRange(prevSelection, prevSelection + result.length + 1);
	},

	doSave: function() {
		this.saveContents(this.textString); 
		this.hideChangeClue();
	},

	tryBoundEval: function (str, offset, printIt) {
		var result;
		try { 
			result = this.boundEval(str);
			if (printIt) {
				this.setNullSelectionAt(this.selectionRange[1] + 1);
				var prevSelection = this.selectionRange[0];
				var replacement = " " + result
				this.replaceSelectionWith(replacement);
				this.setSelectionRange(prevSelection, prevSelection + replacement.length);
			}
		} catch (e) {

			offset = offset || 0;
			var msg = "" + e + "\n" + 
				"Line: " + e.line + "\n" +
				(e.sourceURL ? ("URL: " + (new URL(e.sourceURL).filename()) + "\n") : "");
			if (e.stack) {
				// make the stack fit into status window
				var prefix = (new URL(Config.codeBase)).withRelativePartsResolved().toString()
				msg += e.stack.replace(new RegExp(prefix, "g"),"");
			}

			var world = WorldMorph.current();
			if (!world) {
				console.log("Error in " +this.id() + " bound eval: \n" + msg)
				return
			};

			world.setStatusMessage(
				msg,  
				Color.red, 5,
				function() {
					require('lively.Helper').toRun(function() { 
						alert('There was an errror\n' + printObject(e))
					})
				},
				{fontSize: 12, fillOpacity: 1}
			)
			if (e.expressionEndOffset) {
				// console.log("e.expressionBeginOffset " + e.expressionBeginOffset + "  offset=" + offset)
				this.setSelectionRange(e.expressionBeginOffset + offset, e.expressionEndOffset + offset);
			} else if (e.line) {
				var lineOffset = this.lineNumberForIndex(offset);
				// console.log("line: " + e.line + " offset: " + lineOffset)
				var line = this.lines[e.line + lineOffset - 1]
				if (line && line.startIndex) {
					// console.log(" set to  " + line.startIndex)
					this.setSelectionRange(line.startIndex, line.getStopIndex());
				}
			}
			this.setStatusMessage("" + e, Color.red); 
		}	
		return result;
	},

	doHelp: function() {
		WorldMorph.current().notify("Help is on the way...\n" +
		"...but not today.");
	},

	doUndo: function() {
		if (this.undoTextString) {
			var t = this.selectionRange;
			this.selectionRange = this.undoSelectionRange;
			this.undoSelectionRange = t;
			t = this.textString;
			this.setTextString(this.undoTextString);
			this.undoTextString = t;
		}
		if (this.undoTextStyle) {
			t = this.textStyle;
			this.textStyle = this.undoTextStyle;
			this.undoTextStyle = t;
		}
	},

	processCommandKeys: function(evt) {	 //: Boolean (was the command processed?)
		var key = evt.getKeyChar();
		// console.log('command ' + key);

		// ARRGH FIXME
		if (key == 'I' && evt.isShiftDown()) {
			this.doInspect(); return true; // Inspect
		};
		if (key == 'F' && evt.isShiftDown()) {
			this.doSearch(); return true; // (search in system source code), alternative for w
		};


		if (key) key = key.toLowerCase();
		switch (key) {
			case "a": { this.doSelectAll(true); return true; } // SelectAll
			case "x": { this.doCut(); return true; } // Cut
			case "c": { this.doCopy(); return true; } // Copy
			case "v": { this.doPaste(); return true; } // Paste
			case "m": { this.doMore(); return true; } // More (repeat replacement)
			case "e": { this.doExchange(); return true; } // Exchange
			case "f": { this.doFind(); return true; } // Find
			case "g": { this.doFindNext(); return true; } // Find aGain
			// case "w": { this.doSearch(); return true; } // Where (search in system source code)  // commented out because I want to close the window with cmd-w -- Adam
			case "d": { this.doDoit(); return true; } // Doit
			case "p": { this.doPrintit(); return true; } // Printit
			case "s": { this.doSave(); return true; } // Save

			// Typeface
			case "b": { this.emphasizeBoldItalic({style: 'bold'}); return true; }
			case "i": { this.emphasizeBoldItalic({style: 'italic'}); return true; }

			// Font Size
			// rk: prevents curly/square brackets on german keyboards
			// case "4": { this.emphasizeSelection({size: (this.fontSize*0.8).roundTo(1)}); return true; }
			// case "5": { this.emphasizeSelection({size: (this.fontSize*1).roundTo(1)}); return true; }
			// case "6": { this.emphasizeSelection({size: (this.fontSize*1.2).roundTo(1)}); return true; }
			// case "7": { this.emphasizeSelection({size: (this.fontSize*1.5).roundTo(1)}); return true; }
			// case "8": { this.emphasizeSelection({size: (this.fontSize*2.0).roundTo(1)}); return true; }

			// Text Alignment
			/* I don't understand why these are causing me trouble, but they are. I keep
			   hitting Cmd-r, intending to refresh the page, but instead the whole morph
			   disappears for some reason. -- Adam
			case "l": { this.emphasizeSelection({align: 'left'}); return true; }
			case "r": { this.emphasizeSelection({align: 'right'}); return true; }
			case "h": { this.emphasizeSelection({align: 'center'}); return true; }
			case "j": { this.emphasizeSelection({align: 'justify'}); return true; }
			*/

			case "u": { this.linkifySelection(evt); return true; }	// add link attribute
			case "o": { this.colorSelection(evt); return true; }  // a bit of local color

			case "z": { this.doUndo(); return true; }  // Undo
		}

		switch(evt.getKeyCode()) {
			// Font Size
			case 189/*alt+'+'*/: { this.emphasizeSelection({size: (this.fontSize*=0.8).roundTo(1)}); return true; }
			case 187/*alt+'-'*/: { this.emphasizeSelection({size: (this.fontSize*=1.2).roundTo(1)}); return true; }
			// indent/outdent selection
			case 221/*cmd+]*/: { this.indentSelection(); evt.stop(); return true }
			case 219/*cmd+]*/: { this.outdentSelection(); evt.stop(); return true }
			// comment/uncoment selection
			case 191 /*cmd+/*/: { this.addOrRemoveComment(); return true }
		}

		return false;
	},

	detectTextStyleInRange: function(range, styleName) {
		return this.textStyle.slice(range[0], range[1]).values.detect(function(ea){return ea[styleName]});
	},

	linkifySelection: function(evt) {
		var oldLink = ""
		if (this.textStyle) {
			var linkStyle = this.detectTextStyleInRange(this.selectionRange, 'link');
			if (linkStyle) {
				oldLink = linkStyle.link;
			}
		};
		this.world().prompt("Enter the link...",
				function(response) {
					/*if (!response.startsWith('http://'))
						response = URL.source.notSvnVersioned().withFilename(response).toString();*/
					this.emphasizeSelection( {color: "blue", link: response} );
				}.bind(this),oldLink);
	},

	colorSelection: function(evt) {
		var colors = ['black', 'brown', 'red', 'orange', 'yellow', 'green', 'blue', 'violet', 'gray', 'white'];
		var items = colors.map( function(c) {return [c, this, "setSelectionColor", c] }.bind(this));
		new MenuMorph(items, this).openIn(this.world(), evt.hand.position(), false, "Choose a color for this selection");
	},

	setSelectionColor: function(c, evt) {
		// Color parameter can be a string like 'red' or an actual color
		var color = c;
		if (c == 'brown') color = Color.orange.darker();
		if (c == 'violet') color = Color.magenta;
		if (c == 'gray') color = Color.darkGray;
		this.emphasizeSelection( {color: color} );
		this.requestKeyboardFocus(evt.hand);
	},
	
	indentSelection: function() {
		var tab = '\t';
		this.modifySelectedLines(function(line) { return line.length == 0 ? line : tab + line });
	},
	
	outdentSelection: function() {
		var tab = '\t', space = ' ';
		this.modifySelectedLines(function(line) {
			return (line.startsWith(space) || line.startsWith(tab)) ? line.substring(1,line.length) : line
		});
	},
	
	addOrRemoveComment: function() {
		var commentRegex = /^(\s*)(\/\/\s*)(.*)/;
		var spacesRegex = /^(\s*)(.*)/;
		var noSelection = this.hasNullSelection();

		if (noSelection) { // select the current line
			var line = this.pvtCurrentLine();
			this.startSelection(line.startIndex);
			this.extendSelection(line.getStopIndex());
		}

		this.modifySelectedLines(function(line) {
			var commented = commentRegex.test(line);
			if (commented)
				return line.replace(commentRegex, '$1$3')
			return line.replace(spacesRegex, '$1// $2')
		});
	},
	
	pvtCurrentLine: function() {
		var lineNumber =  this.lineNumberForIndex(this.selectionRange[1]);
		if (lineNumber == -1) lineNumber = 0; 
		return this.lines[lineNumber];
	},

	pvtCurrentLineString: function() {
		var line = this.pvtCurrentLine();
		return String(this.textString.substring(line.startIndex, line.getStopIndex() + 1));		 
	},
	
	// setFill: function(fill) {
	//    this.shape.setFill(fill);
	// },
});

TextMorph.addMethods({
	
	extendSelection: function(charIx) {
		if (charIx < 0) return;
		this.setSelectionRange(this.selectionPivot, charIx);
	},

	getCursorPos: function() {
		if (this.hasNullSelection())
			return this.selectionRange[0];
		if (this.selectionPivot === this.selectionRange[1]+1)
			return this.selectionRange[0]; // selection expands left
		if (this.selectionPivot === this.selectionRange[0])
			return this.selectionRange[1]+1; // selection expands right
		if (this.selectionPivot < this.selectionRange[1]+1 && this.selectionPivot > this.selectionRange[0])
			return this.selectionRange[0]; // selection pivot in middle of sel
		// console.log('Can\'t find current position in text');
		return this.selectionRange[0];
	},

});

Object.extend(TextMorph, {
	
	fromLiteral: function(literal) {
		var morph = new TextMorph(new Rectangle(0,0,0,0), literal.content || "");
		literal.textColor && morph.setTextColor(literal.textColor);
		literal.label && morph.beLabel();
		return morph;
	}


});
	
TextMorph.addMethods({ // change clue additions

	addChangeClue: function(useChangeClue) {
		if (!useChangeClue) return;
		this.changeClue = Morph.makeRectangle(1,1,5,5);
		this.changeClue.setBorderWidth(0);
		this.changeClue.setFill(Color.red);
		this.changeClue.ignoreEvents();
		this.changeClue.ignoreWhenCopying = true;
	},

	showChangeClue: function() {
		if (!this.changeClue) return;
		this.addMorph(this.changeClue);
	},

	hideChangeClue: function() {
		if (!this.changeClue) return;
		this.changeClue.remove();
	},

	hasUnsavedChanges: function() {
		// FIXME just another hack...
		return this.submorphs.include(this.changeClue);
	}
});

// TextMorph accessor functions
TextMorph.addMethods({

	emphasizeSelection: function(emph) {
		if (this.hasNullSelection()) return;
		this.emphasizeFromTo(emph, this.selectionRange[0], this.selectionRange[1]);
	},

	emphasizeBoldItalic: function(emph) {
		// Second assertion of bold or italic *undoes* that emphasis in the current selection
		if (this.hasNullSelection()) return;
		var currentEmphasis = this.getSelectionText().style.values[0];	// at first char
		if (currentEmphasis.style == null) return this.emphasizeSelection(emph);
		if (emph.style == 'bold' && currentEmphasis.style.startsWith('bold')) return this.emphasizeSelection({style: 'unbold'});
		if (emph.style == 'italic' && currentEmphasis.style.endsWith('italic')) return this.emphasizeSelection({style: 'unitalic'});
		this.emphasizeSelection(emph);
	},

	emphasizeAll: function(emph) {
		this.emphasizeFromTo(emph, 0, this.textString.length);
	},

	emphasizeFromTo: function(emph, from, to) {
		var txt = new lively.Text.Text(this.textString, this.textStyle);
		txt.emphasize(emph, from, to);
		this.textStyle = txt.style;
		this.composeAfterEdits();
	},

	pvtUpdateTextString: function(replacement, replacementHints) {
		// tag: newText
		// Note:  -delayComposition- is now ignored everyhere
		replacement = replacement || "";
		replacement 	
		if(!this.typingHasBegun) { 
			// Mark for undo, but not if continuation of type-in
			this.undoTextString = this.textString;
			this.undoSelectionRange = this.selectionRange;
			if (this.textStyle) this.undoTextStyle = this.textStyle.clone();
		}
		// DI: Might want to put the maxSafeSize test in clients
		dbgOn(!replacement.truncate);
		this.textString = replacement.truncate(this.maxSafeSize);
		this.composeAfterEdits(replacementHints);
	},
	
	composeAfterEdits: function(replacementHints) {
		// tag: newText
		var oneLiner = (this.lines == null) || (this.lines.length <= 1)

		// this.changed();	// Needed to invalidate old bounds in canvas
		// But above causes too much to happen; instead just do...
		this.invalidRect(this.innerBounds());  // much faster

		this.layoutChanged(); 

		// Note: renderAfterReplacement will call bounds pre-emptively to avoid re-rendering
		if (replacementHints) this.renderAfterReplacement(replacementHints);
			else this.lines = null;
		this.changed();	 // will cause bounds to be called, and hence re-rendering
		if (oneLiner) this.bounds();  // Force a redisplay
	},
	
	setStatusMessage: function(msg, color, delay) {
		console.log("status: " + msg)
		if (!this._statusMorph) {
			this._statusMorph = new TextMorph(pt(300,30).extentAsRectangle());
			this._statusMorph.applyStyle({borderWidth: 0, fill: Color.gray, fontSize: 16, fillOpacity: 1})
		}
		var statusMorph = this._statusMorph;
		statusMorph.textString = msg;
		this.world().addMorph(statusMorph);
		statusMorph.setTextColor(color || Color.black);
		statusMorph.ignoreEvents();
		try {
			var bounds = this.getCharBoundsWithoutCopying(this.selectionRange[0]);
			if (bounds) {
				var pos = bounds.bottomLeft();
			} else {
				pos = pt(0, 20);
			}
			statusMorph.setPosition(this.worldPoint(pos));
		} catch(e) {
			statusMorph.centerAt(this.worldPoint(this.innerBounds().center()));
			console.log("problems: " + e)
		};
		(function() { 
			// console.log("remove status")
			statusMorph.remove() }).delay(delay || 4);
	},
	
	pvtPositionInString: function(lines, line, linePos) {
		var pos = 0;
		for(var i=0; i < (line - 1); i++) {
			pos = pos + lines[i].length + 1
		}
		return pos + linePos
	},
		
	saveContents: function(contentString) {
		this.savedTextString = contentString;
		if (!this.modelPlug && !this.formalModel && !this.noEval) {
			this.tryBoundEval(contentString);
			this.world().changed(); 
			return; // Hack for browser demo
		} else if (!this.autoAccept) {
			this.setText(contentString, true);
	   }
	},

	acceptChanges: function() {	   
		this.textBeforeChanges = this.textString; 
	},
	
	boundEval: function(str) {	  
		// Evaluate the string argument in a context in which "this" may be supplied by the modelPlug
		var ctx = this.getDoitContext() || this;
		return (interactiveEval.bind(ctx))(str);
	},
	
	addOrRemoveBrackets: function(bracketIndex) {
		var left = this.locale.charSet.leftBrackets[bracketIndex];
		var right = this.locale.charSet.rightBrackets[bracketIndex];
		
		if (bracketIndex == 0) { left = "/*"; right = "*/"; }
	
		var i1 = this.selectionRange[0];
		var i2 = this.selectionRange[1];
		
		if (i1 - left.length >= 0 && this.textString.substring(i1-left.length,i1) == left &&
			i2 + right.length < this.textString.length && this.textString.substring(i2+1,i2+right.length+1) == right) {
			// selection was already in brackets -- remove them
			var before = this.textString.substring(0,i1-left.length);
			var replacement = this.textString.substring(i1,i2+1);
			var after = this.textString.substring(i2+right.length+1,this.textString.length);
			this.setTextString(before.concat(replacement,after));
			this.setSelectionRange(before.length,before.length+replacement.length); 
		} else { // enclose selection in brackets
			var before = this.textString.substring(0,i1);
			var replacement = this.textString.substring(i1,i2+1);
			var after = this.textString.substring(i2+1,this.textString.length); 
			this.setTextString(before.concat(left,replacement,right,after));
			this.setSelectionRange(before.length+left.length,before.length+left.length+replacement.length); 
		}
	},
	
	getFontFamily: function() {
		return this.font.getFamily();
	},
	
	setFontFamily: function(familyName) {
		this.fontFamily = familyName;
		this.font = thisModule.Font.forFamily(this.fontFamily, this.fontSize);
		this.layoutChanged();
		this.changed();
	},
	
	getFontSize: function() { return this.fontSize; },

	setFontSize: function(newSize) {
		if (newSize == this.fontSize && this.font)	// make sure this.font is inited
			return this; // make it return this -- Adam
		this.fontSize = newSize;
		this.font = thisModule.Font.forFamily(this.fontFamily, newSize);
		this.padding = Rectangle.inset(newSize/2 + 2, newSize/3);
		this.layoutChanged();
		this.changed();
		return this; // added by Adam
	},
	
	pvtReplaceBadControlCharactersInString: function(string) {
		var allowedControlCharacters = "\n\t\r"
		return $A(string).collect(function(ea){
			if (allowedControlCharacters.include(ea))
				return ea;
			if (ea.charCodeAt(0) < 32)	
				return '?'
			else		
				return ea }).join('')
	},

	setTextString: function(replacement, replacementHints) {
		replacement = this.pvtReplaceBadControlCharactersInString(replacement);
		if (Object.isString(replacement)) replacement = String(replacement); 
		if (this.autoAccept) this.setText(replacement);
		this.pvtUpdateTextString(replacement, replacementHints);
	},
	
	updateTextString: function(newStr) {
		this.pvtUpdateTextString(newStr);
		this.resetScrollPane(); 
	},
	
	resetScrollPane: function() {
		var sp = this.enclosingScrollPane();
		if (sp) {
			sp.scrollToTop();
		}
	},
	
	scrollSelectionIntoView: function() { 
		var sp = this.enclosingScrollPane();
		if (! sp) return;
		var selRect = this.getCharBoundsWithoutCopying(this.selectionRange[this.hasNullSelection() ? 0 : 1]);
    if (!selRect) { return; } // added by Adam, not sure it's right
    
    // added the scaling code -- Adam
    var scale = this.getScale();
    var scaledSelRect = new Rectangle(selRect.x * scale, selRect.y * scale, selRect.width * scale, selRect.height * scale);
    sp.scrollRectIntoView(scaledSelRect);
	},
	
	enclosingScrollPane: function() { 
		// Need a cleaner way to do this
		if (! (this.owner instanceof ClipMorph)) return null;
		var sp = this.owner.owner;
		if (! (sp instanceof ScrollPane)) return null;
		return sp;
	},

	onTextUpdate: function(string) {
		this.updateTextString(string);
		this.textBeforeChanges = string;
		this.hideChangeClue();
	},

	onSelectionUpdate: function(string) {
		this.searchForFind(string, 0);
	},
	
	updateView: function(aspect, controller) {
		var p = this.modelPlug;
		if (!p) return;

		if (aspect == p.getText	 || aspect == 'all') {
			this.onTextUpdate(this.getText());
		} else if (aspect == p.getSelection || aspect == 'all') {
			this.onSelectionUpdate(this.getSelection());
		}
	},
	
	onHistoryCursorUpdate: Functions.Empty,

	onHistoryUpdate: Functions.Empty,

	searchForFind: function(str, start) {
		this.requestKeyboardFocus(this.world().firstHand());
		var i1 = this.textString.indexOf(str, start);
		if (i1 < 0) i1 = this.textString.indexOf(str, 0); // wrap
		if (i1 >= 0) this.setSelectionRange(i1, i1+str.length);
		else this.setNullSelectionAt(0);
		this.lastSearchString = str;
		this.lastFindLoc = i1;
	}
	
});

Object.extend(TextMorph, {
	makeLabel: function(labelString, styleIfAny) {
		var label = new TextMorph(new Rectangle(0,0,200,100), labelString);
		label.beLabel(styleIfAny);
		return label;
	}
});

TextMorph.subclass('PrintMorph', {
    documentation: "TextMorph that converts its model value to string using toString(), and from a string using eval()",
    precision: 2,

    updateView: function(aspect, controller) {
        var p = this.modelPlug;
	if (!p) return;
        if (aspect == p.getValue || aspect == 'all') this.onValueUpdate(this.getValue());
    },

    onValueUpdate: function(value) {
	this.onTextUpdate(this.formatValue(value));
    },
    
    getValue: function() {
	if (this.formalModel && this.formalModel.getValue) return this.formalModel.getValue();
	else return this.getModelValue("getValue");
    },

    setValue: function(value) {
	if (this.formalModel && this.formalModel.setValue) 
	    return this.formalModel.setValue(value);
	else return this.setModelValue("setValue", value);
    },

    // overridable
    formatValue: function(value) {
	if (value && Object.isNumber(value.valueOf())) return String(value.toFixed(this.precision));
	else return value.toString();
    },
    
    getText: function() {
	return this.formatValue(this.getValue());
    },
    
    setText: function(newText) {
	var result = String(eval(newText));  // exceptions?
	return this.setValue(result);
    }

});

TextMorph.subclass('TestTextMorph', {
    // A class for testing TextMorph composition, especially hit, charOfPoint and getCharBounds
    // Set Config.showTextText = true, and then scale up the Pen.script by about 2x
    // It creates a rectangle at mouseDown, and then
    // while the mouse moves, it prints the index of the nearest character,
    // and adjusts the rectangle to display the bounds for that index.

    onMouseDown: function(evt) {
        this.isSelecting = true;
        this.boundsMorph = Morph.makeRectangle(0, 0, 0, 0);
	this.boundsMorph.applyStyle({fill: null, borderColor: Color.red});
        this.addMorph(this.boundsMorph);
        this.requestKeyboardFocus(evt.hand);
        this.track(evt);
        return true; 
    },
    track: function(evt) {
        var localP = this.localize(evt.mousePoint);
        var tl = this.textTopLeft();
        var px = Math.max(localP.x, tl.x); // ensure no returns of 0 left of bounds
        var px = Math.min(px, this.innerBounds().maxX());
        var py = localP.y - 2;
        var hit = this.hit(px, py);
        var charIx = this.charOfPoint(localP);
        console.log('localP = ' + localP + ' hit = ' + hit + ' charOfPoint = ' + charIx);  // display the index for the mouse point
        var jRect = this.getCharBounds(hit);
        if (jRect == null) {
            console.log("text box failure in drawSelection"); 
            return; 
        }
        console.log('rect = ' + jRect);
        this.boundsMorph.setBounds(jRect);  // show the bounds for that character
    },
    onMouseMove: function($super, evt) {  
        if (!this.isSelecting) return $super(evt);
        this.track(evt);
    },
    onMouseUp: function(evt) {
        this.isSelecting = false;
        this.boundsMorph.remove();
    }
});

BoxMorph.subclass('LabeledTextMorph', {

    documentation: "Morph that contains a small label and a TextMorph. Clips when TextMorphs grows larger than maxExtent",
    labelOffset: pt(5, 1),
    maxExtent: pt(500, 400),
    
    initialize: function($super, rect, labelString, textString, maxExtent) {
        $super(rect);
        if (maxExtent) this.maxExtent = maxExtent;
        
        /* configure the label */
        var label = new TextMorph(this.labelOffset.asRectangle(), labelString);
        label.beLabel({fontSize: 11, fill: Color.veryLightGray, padding: Rectangle.inset(1)});
        label.setBounds(label.bounds()); // set the bounds again, when padding is changed, otherwise they would be wrong
        this.addMorphFront(label);
        
        /* configure the text */
        var textPos = pt(0,label.getExtent().y/2);
        var text = new TextMorph(textPos.extent(rect.extent()), textString);
        text.applyStyle({wrapStyle: thisModule.WrapStyle.Normal, borderColor: Color.veryLightGray.darker().darker(),
                         padding: text.padding.withY(label.bounds().height / 2)});
        this.addMorphBack(text);
        text.composeAfterEdits = text.composeAfterEdits.wrap(function(proceed) {
            proceed();
            if (this.textHeight() < this.maxExtent().y) this.setToTextHeight(); // grow with the textMorph
            //else this.clipToShape();
        }.bind(this));
        
        
        /* configure this*/
        this.applyStyle({borderWidth: 0, fill: Color.veryLightGray});        
        this.label = label;
        this.text = text;
        [this, this.label, this.text].forEach(function() {
            this.suppressHandles = true;
            this.closeDnD();
        }, this);
        this.setExtent(textPos.addPt(text.getExtent())); // include the padding in own size
    },

    maxExtent: function() {
        return this.owner ? this.owner.innerBounds().extent() : this.maxExtent;
    },
    
    reshape: function($super, partName, newPoint, lastCall) {
        var priorPosition = this.getPosition();
        var priorExtent = this.getExtent();
	var result = $super(partName, newPoint, lastCall);
        if (lastCall && this.textHeight() < this.getExtent().y) this.setToTextHeight();
        var moveBy = this.getPosition().subPt(priorPosition);
        var extendBy = this.getExtent().subPt(priorExtent);
        this.label.setPosition(this.label.getPosition().addPt(moveBy));
        this.text.setPosition(this.text.getPosition().addPt(moveBy));
        this.text.setExtent(this.text.getExtent().addPt(extendBy));
	return result;
    },
    
    textHeight: function() {
        return this.label.getExtent().y/2 + this.text.getExtent().y;
    },
    
    setToTextHeight: function() {
        // FIXME minPt with maxExtent
        this.shape.setBounds(this.shape.bounds().withHeight(this.textHeight()));  
    },
     
    innerMorph: function() {
        return this.text;
    },
    
    adoptToBoundsChange: function(ownerPositionDelta, ownerExtentDelta) {
        var oldE = this.innerMorph().getExtent();
        this.innerMorph().setExtent(this.innerMorph().getExtent().addPt(ownerExtentDelta));
        var newE = this.innerMorph().getExtent();
        this.setExtent(this.getExtent().addPt(ownerExtentDelta.withY(0))); // only set width
        this.setToTextHeight();
        this.setPosition(this.getPosition().addPt(ownerPositionDelta));
    }
});

Object.subclass('RunArray', {
	// A run-coded array for storing text emphasis codes
	initialize: function(runs, vals) {
		this.runs = runs;  // An array with the length of each run
		this.values = vals;   // An array with the value at each run (an emphasis object)
		this.lastIndex = 0;  // A cache that allows streaming in linear time
		this.lastRunIndex = 0;  // Run index corresponding to lastIndex
	},

	valueAt: function(index) {
		var m = this.markAt(index);
		return this.values[m.runIndex];
	},

	runLengthAt: function(index) {
		var m = this.markAt(index);
		return this.runs[m.runIndex] - m.offset;
	},

	markAt: function(index) {
		// Returns a 'mark' with .runIndex and .offset properties
		// Cache not loaded, or past index -- start over
		var runIndex = 0;
		var offset = index;
		if (this.lastIndex && this.lastIndex <= index) {
			// Cache loaded and before index -- start there
			runIndex = this.lastRunIndex;
			offset = index-this.lastIndex;
		}
		while (runIndex < this.runs.length-1 && offset >= this.runs[runIndex]) {
			offset = offset - this.runs[runIndex];
			runIndex ++;
		}
		// OK, we're there.  Cache this state and call the function
		this.lastRunIndex = runIndex;
		this.lastIndex = index - offset;
		//console.log("index = " + index + "; runIndex = " + runIndex + "; offset = " + offset);
		//console.log("this.lastRunIndex = " + this.lastRunIndex + "; this.lastIndex  = " + this.lastIndex);
		return {runIndex: runIndex, offset: offset};
	},

	slice: function(start, beyondStop) {  // Just like Array.slice()
		var stop = beyondStop-1;
		// return the subrange from start to stop
		if (stop < start) return new RunArray([0], [null]);
		// Added "var" so that mStart and mStop and newRuns won't be globals. -- Adam
		var mStart = this.markAt(start);
		var mStop = this.markAt(stop);
		var newRuns;
		if (mStart.runIndex == mStop.runIndex) {
			newRuns = [mStop.offset - mStart.offset +1];
		} else {
			newRuns = this.runs.slice(mStart.runIndex, mStop.runIndex+1);
			newRuns[0] -= mStart.offset;
			newRuns[newRuns.length-1] = mStop.offset + 1;
		}
		return new RunArray(newRuns, this.values.slice(mStart.runIndex, mStop.runIndex + 1));
	},

	substring: function(start, beyondStop) {  // echo string protocol
		return this.slice(start, beyondStop);
	},

	concat: function(other) {  // Just like Array.concat()
		if (other.empty()) return new RunArray(this.runs, this.values);
		if (this.empty()) return new RunArray(other.runs, other.values);
		if (!this.equalValues(this.valueAt(this.length()-1),  other.valueAt(0))) {
			// DI: above test faster if use values directly
			// values differ at seam, so it's simple...
			return new RunArray(this.runs.concat(other.runs),
			this.values.concat(other.values));
		}
		var newValues = this.values.concat(other.values.slice(1));
		var newRuns = this.runs.concat(other.runs.slice(1));
		newRuns[this.runs.length-1] = this.runs[this.runs.length-1] + other.runs[0];
		return new RunArray(newRuns, newValues);
	},

	asArray: function() {
		var result = new Array(this.length());
		for (var i = 0; i<this.length(); i++) result[i] = this.valueAt(i);
		return result;
	},

	length: function() {
		var len = 0;
		this.runs.forEach(function(runLength) { len += runLength; });
		return len;
	},

	clone: function() {
		// OK to share vecause we never store into runs or values
		return new RunArray(this.runs, this.values);
	},
	empty: function() {
		return this.runs.length == 1 && this.runs[0] == 0;
	},

	mergeStyle: function(emph, start, stop) {
		// Note stop is end index, not +1 like slice
		if (start == null) return this.mergeAllStyle(emph);
		var newRun = this.slice(start, stop+1).mergeAllStyle(emph);
		if (start > 0) newRun = this.slice(0, start).concat(newRun);
		if (stop < this.length()-1) newRun = newRun.concat(this.slice(stop+1, this.length()));
		return newRun.coalesce();
	},
    
	mergeAllStyle: function(emph) {
		// Returns a new runArray with values merged with emph throughout
		var newValues = this.values.map(function(each) {return emph.merge(each); });
		// Note: this may cause == runs that should be coalesced
		// ...but we catch most of these in mergeStyle
		return new RunArray(this.runs, newValues).coalesce();
	},

	coalesce: function() {
		// Returns a copy with adjacent equal values coalesced
		// Uses extra slice to copy arrays rather than alter in place
		var runs = this.runs.slice(0);  // copy because splice will alter
		var values = this.values.slice(0);  // ditto
		var i = 0;
		while (i < runs.length-1) {
			if (this.equalValues(values[i], values[i+1]) ) {
				values.splice(i+1,1);
				var secondRun = runs[i+1];
				runs.splice(i+1,1);
				runs[i] += secondRun;
			} else i++;
		}
		return new RunArray(runs, values);
	},
    
	equalValues: function(s1, s2) {
		// values are style objs like {style: 'bold', fontSize: 14}
		if (typeof s1 == "number" && typeof s2 == "number") return s1 == s2;  // used for testing
		var match = true;
		Properties.forEachOwn(s1, function(p, v) {match = match && s2[p] == v});
		if (! match) return false;
		// Slow but sure...
		Properties.forEachOwn(s2, function(p, v) {match = match && s1[p] == v});
		return match;
	},

    toString: function() {
		return "runs = " + this.runs + ";  values = " + this.values;
    },

    toLiteral: function() {
		return {runs: this.runs.clone(), values: this.values.clone() }
    }
});

Object.extend(RunArray, {

    fromLiteral: function(literal) {
		return new RunArray(literal.runs, literal.values);
    },

	test: function(a) {
		var ra = new RunArray(a, a); // eg [3, 1, 2], [3, 1, 2]
		console.log("RunArray test for " + ra + " = " + ra.asArray());
		for (var i = 0; i < ra.length(); i++) {
			var m = ra.markAt(i);
			// console.log(i + ":  run = " + m.runIndex + ", offset = " + m.offset);
		}
		for (var i = 0; i <= ra.length(); i++) {
			// break into all possible pairs, join them, and check
			var ra1 = ra.slice(0, i);
			var ra2 = ra.slice(i, ra.length());
			var ra3 = ra1.concat(ra2);
			// console.log(i + ": " + ra1 + " || " + ra2 + " = " + ra3);
			for (var j = 0; i <= ra.length(); i++) {
				if (ra3.valueAt(j) != ra.valueAt(j)) console.log("***RunArray failing test***");
			}
		}
	}
});
//RunArray.test([3, 1, 2]);

    
Object.subclass('lively.Text.Text', {
    // Rich text comes to the Lively Kernel
	initialize: function(string, style) {
		this.string = string;
		if (style) {
			if (style instanceof TextEmphasis) this.style = new RunArray([string.length], [style]);
			else if (style instanceof RunArray) this.style = style;
			else this.style = new RunArray([string.length], [new TextEmphasis(style)]);
		} else {
			this.style = new RunArray([string.length], [new TextEmphasis({})]);
		}
	},
	emphasize: function (emph, start, stop) {
		// Modify the style of this text according to emph
		var myEmph = emph;
		if (! (emph instanceof TextEmphasis)) myEmph = new TextEmphasis(emph);
		this.style = this.style.mergeStyle(myEmph, start, stop);
		// console.log("Text.emphasized: " + this.style);
		return this;
	},
	emphasisAt: function(index) {
		return this.style.valueAt(index);
	},
	asString: function () { // Return string copy
		return this.string.substring(0);
	},
	size: function () {
		return this.string.length;
	},
	substring: function (start, stop) {
		// Return a substring with its emphasis as a Text
		return new thisModule.Text(this.string.substring(start, stop), this.style.slice(start, stop));
	},
	subtext: function (start, stop) {
		// Return a substring with its emphasis as a Text
		return new thisModule.Text(this.string.substring(start, stop), this.style.slice(start, stop));
	},
	concat: function (other) {
		// Modify the style of this text according to emph
		return new thisModule.Text(this.string.concat(other.string), this.style.concat(other.style));
	},
	toString: function() {
		return "Text for " + this.string + "<" + this.style + ">";
	},
	asMorph: function() {
		return new TextMorph(new Rectangle(0,0,200,100), this);
	},
});


Object.subclass('TextEmphasis', {
	initialize: function(obj) {
		Properties.forEachOwn(obj, function(p, v) {this[p] = v; }, this);
	},
	merge: function(other) {
		// this and other are style objs like {style: 'bold', fontSize: 14}
		// In case of overlapping properties, this shall dominate
		var result = new TextEmphasis(other);
		Properties.forEachOwn(this,
			function(p, v) {
				if (p != 'style') result[p] = v;
				else { // special handling of bold, italic
					var op = other[p];
					if (v == 'bold') result[p] = (op == 'italic' || op == 'bold-italic') ? 'bold-italic' : 'bold';
					if (v == 'italic') result[p] = (op == 'bold' || op == 'bold-italic') ? 'bold-italic' : 'italic';
					if (v == 'unbold') result[p] = (op == 'italic' || op == 'bold-italic') ? 'italic' : null;
					if (v == 'unitalic') result[p] = (op == 'bold' || op == 'bold-italic') ? 'bold' : null;
					if (result[p] == null) delete result.style
				}
			}
		); 
		return result;
	},
	toString: function() {
		var props = Properties.own(this).map(function(p) { return p + ": " + this[p]; }.bind(this));
		return "{" + props.join(", ") + "}";
	}
});



}.logCompletion("Text.js"));





avocado.transporter.module.onLoadCallbacks["lk/Text"] = 'done';

avocado.transporter.module.onLoadCallbacks["lk/Widgets"] = function() {};
/*
 * Copyright (c) 2006-2009 Sun Microsystems, Inc.
 *
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * Widgets.js.  This file defines the various graphical widgets
 * (morphs) that will be included in the system when it starts.
 */

//  Basic theory of widgets...
//  A widget is a view/controller morph, and it views some aspect of a model
//  Viewing is by way of "plugs" which use MVC-style viewing, and select some
//  aspect or aspects of the model to be viewed.

//  See the comments in Model, and the Model protocol in Morph (getModelValue(), etc)
//  The Inspector and Browser are fairly simple examples of this architecture in use.

// ===========================================================================
// Simple widgets
// ===========================================================================


module('lively.Widgets').requires('lively.Text').toRun(function(thisModule, text) {


BoxMorph.subclass('ButtonMorph', {
    
    documentation: "Simple button. Provides three connections: value, isActive, fire",
    focusHaloBorderWidth: 3, // override the default
    label: null,
    toggle: false, //if true each push toggles the model state 
    styleClass: ['button'],
    
    formals: ["Value", "IsActive"],
	connections: ['value', 'isActive', 'fire'],

	openForDragAndDrop: false,

    // A ButtonMorph is the simplest widget
    // It read and writes the boolean variable, this.model[this.propertyName]
	initialize: function($super, initialBounds) {
		this.baseFill = null;
		$super(initialBounds);
		this.value = false; // for connect()
		this.isActive = true;
		if (Config.selfConnect) {
			var model = Record.newNodeInstance({Value: this.value, IsActive: this.isActive});
			// this default self connection may get overwritten by, eg, connectModel()...
			this.relayToModel(model, {Value: "Value", IsActive: "IsActive"});
		}
		// Styling
		this.applyLinkedStyles();
		this.changeAppearanceFor(this.value);
		return this;
	},

    onDeserialize: function() {
        this.baseFill = this.shape.getFill();
        this.changeAppearanceFor(this.value);
    },

	setFill: function($super, fill) {
		$super(fill);
		this.baseFill = fill;
		this.initColor(); // be careful to not call setFill again...!
	},
	
	// FIXME interference with old model on connectModel/relayToModel???
	getIsActive: function() { return this.isActive },
	
	getValue: function() { return this.value },
	
	setIsActive: function(bool) {
		ModelMigration.set(this, 'IsActive', bool);
		this.isActive = bool;
	},
	
	setValue: function(bool) {
		ModelMigration.set(this, 'Value', bool);
		if (bool) updateAttributeConnection(this, 'fire');
		this.value = bool;
	},
	
	handlesMouseDown: function(evt) {
		return !evt.isCommandKey() && evt.isLeftMouseButtonDown();
	},
    
    onMouseDown: function(evt) {
      // factored out the wasJustPressedDown method because I want to call it for touch events too -- Adam
      return this.wasJustPressedDown(evt);
    },
    
    wasJustPressedDown: function(evt) {
		if (!this.getIsActive() && this.getIsActive() !== undefined) return;
        // this.requestKeyboardFocus(evt.hand); // commented out by Adam, because I don't like it
        if (!this.toggle) {
            this.setValue(true); 
            this.changeAppearanceFor(true); 
        } 
    },
    
	onMouseMove: Functions.Empty,
    
  onMouseUp: function(evt) {
    // factored out the wasJustReleasedUp method because I want to call it for touch events too -- Adam
    return this.wasJustReleasedUp(evt);
  },

	wasJustReleasedUp: function(evt) {
		if (!this.getIsActive() && this.getIsActive() !== undefined) return;
		var newValue = this.toggle ? !this.getValue() : false;
		this.setValue(newValue); 
		// the following should happen in response
		this.changeAppearanceFor(newValue); 
	},
	
	// added by Adam
	_eventHandler: {
	  onTouchStart: function (morph, evt) {
	    morph.wasJustPressedDown(evt);
	  },

	  onTouchEnd: function (morph, evt) {
	    morph.wasJustReleasedUp(evt);
	  },
	},
    
	changeAppearanceFor: function(value) {
		if(!this.lighterFill || !this.normalFill){
			this.initColor();
		}
		var fill = value ?  this.lighterFill : this.normalFill;
		this.shape.setFill(fill);
	},

  	initColor: function() {
    	var gfx = lively.paint;
    	
    	/* This code confuses me. -- Adam
        if (this.baseFill instanceof gfx.LinearGradient) {
            var base = this.baseFill.stops[0].color().lighter(0);
	    	this.normalFill =
				new gfx.LinearGradient([new gfx.Stop(0, base), new gfx.Stop(1, base.lighter())],
				gfx.LinearGradient.SouthNorth);       

            var base = this.baseFill.stops[0].color().lighter(1);
	    	this.lighterFill = 
				new gfx.LinearGradient([new gfx.Stop(0, base), new gfx.Stop(1, base.lighter())],
				gfx.LinearGradient.SouthNorth);

        } else if (this.baseFill instanceof gfx.RadialGradient) {
            var base = this.baseFill.stops[0].color().lighter(0);
            this.normalFill= new gfx.RadialGradient([new gfx.Stop(0, base.lighter()), new gfx.Stop(1, base)]);

             var base = this.baseFill.stops[0].color().lighter(1);
             this.lighterFill= new gfx.RadialGradient([new gfx.Stop(0, base.lighter()), new gfx.Stop(1, base)]);
        } else if (this.baseFill instanceof Color) {
        	this.normalFill = this.baseFill.lighter(0);
            this.lighterFill = this.baseFill.lighter(1);
        } else if (this.baseFill == null || this.baseFill == undefined) {
			this.lighterFill = null;
			this.normalFill = null;
		} else {
			throw new Error('unsupported fill type ' + this.baseFill);
		}
		*/

        if (this.baseFill) {
            this.normalFill  = this.baseFill;
            this.lighterFill = this.baseFill.lighter();
		}
	},

	applyStyle: function($super, spec) {
		$super(spec);
		this.baseFill = this.shape.getFill(); // we may change appearance depending on the value
		if (this.getActualModel()) {
			// otherwise getValue() will fail. Note that this can happen in deserialization
			// when themes are applied before the widget is hooked up to the model
			this.changeAppearanceFor(this.getValue());
		}
		return this; // added by Adam
	},

	updateView: function(aspect, controller) {
		var p = this.modelPlug;
		if (!p) return;
		if (aspect == p.getValue || aspect == 'all') 
			this.onValueUpdate(this.getValue());
	},

	onValueUpdate: function(value) {
		if (this.toggle) console.log("got updated with value " + value);
		this.changeAppearanceFor(value);
	},
	
	onIsActiveUpdate: function(isActive) {
		if (!this.label) return;
		this.label.applyStyle({ textColor: (isActive ? Color.black : Color.gray.darker()) });
	},


    takesKeyboardFocus: Functions.True,          // unlike, eg, cheapMenus
    
    setHasKeyboardFocus: Functions.K, 

    onKeyDown: function(evt) {
		if (!this.getIsActive() && this.getIsActive() !== undefined) return;
        switch (evt.getKeyCode()) {
        case Event.KEY_RETURN:
        case Event.KEY_SPACEBAR:
            this.setValue(true); 
            this.changeAppearanceFor(true);
            evt.stop();
            return true;
        }
        return false;
    },

    onKeyUp: function(evt) {
		if (!this.getIsActive() && this.getIsActive() !== undefined) return;
        var newValue = this.toggle ? !this.getValue() : false;
        switch (evt.getKeyCode()) {
        case Event.KEY_RETURN:
        case Event.KEY_SPACEBAR:
            this.changeAppearanceFor(newValue);
            this.setValue(newValue);
            evt.stop();
            return true;
        }
        return false;
    },

	setLabel: function(txt) {
		this.label && this.label.remove();
		this.label = TextMorph.makeLabel(txt).centerAt(this.innerBounds().center());
		this.addMorph(this.label);
		return this;
	},

	getLabel: function() {
		if (!this.label) 
			return '';
		return this.label.textString
	},

	buttonAction: function(funcOrSelector, target) {
		this.connectModel({
			setValue: 'action',
			model: {action: function(btnVal) {
				if (btnVal) return;
				Object.isString(funcOrSelector) ?
					target[funcOrSelector]() :
					funcOrSelector.apply(target);
			}}
		});
	}
});

Morph.subclass('ButtonBehaviorMorph', {
    
    documentation: "***under construction***",
    focusHaloBorderWidth: 3, // override the default
    normalBorderFill: null,
    mouseOverFill: Color.blue,
    mousePressedFill: Color.orange,
    mouseDownAction: function (evt) {},
    mouseUpAction: function (evt) {}, 

	initialize: function($super, targetMorph) {
		// A ButtonBehaviorMorph can be put over any morph or part of a morph
		// It can show a halo on rollover, and can act on mouseDown and mouseUp
		// At some point we'll unify this with ButtonMorph as a simplification
		// It should be possible to say
		//	<anyMorph>.addButtonBehavior({onMouseDown: function...})
		//	<anyMorph>.addButtonBehavior({onMouseUp: function...})
		// And it should be possible to say to either the morph or its behaviorMorph
		//	<eitherOne>.disableButtonBehavior()
		//	<eitherOne>.ebableButtonBehavior()

		console.log("new ButtonBehaviorMorph 1 " + Object.inspect(this.shape));
		$super(targetMorph.shape.copy());
		console.log("new ButtonBehaviorMorph 2 " + Object.inspect(this.shape));
		//this.setBounds(targetMorph.innerBounds());
		console.log("new ButtonBehaviorMorph 3 " + Object.inspect(this.shape));

		// Styling
		// this.linkToStyles(['buttonBehavior']);
		return this;
	},

    last: function () {}
});

ButtonMorph.subclass('ScriptableButtonMorph', {
	
	documentation: 'Takes a customizable script',

	initialize: function($super, initialBounds) {
		$super(initialBounds);
		this.scriptSource = '';
		return this;
	},

	setValue: function($super, value) {
		$super(value);
		if (value) this.doAction();
	},

	getSourceForEval: function() {
		return '(function() { ' + this.scriptSource + '\n})';
	},

	doAction: function() {
		try {
			var func = eval(this.getSourceForEval());
			func.apply(this, [] /*arg array*/);
		} catch(e) {
			var self = this;
			this.world().setStatusMessage(
				"ScriptButton: " + e + "\non line: " + e.line + "\nscript: \n" + this.scriptSource,  
				Color.red, 4,
				function() {
					var prompt = self.editScript();
					
					
					}
			)
			
			//throw e;
		}
	},

	morphMenu: function($super, evt) {
		var menu = $super(evt);
		menu.addLine();
		menu.addItem(["Edit script...", this.editScript]);
		menu.addItem(["Edit label...", this.editLabel]);
		return menu;  
	},

	editScript: function() {
		// var dialog = new PromptDialogMorph();
		// dialog.title = 'Edit script';
		// dialog.setText(this.scriptSource);
		// dialog.callback = function(input) { this.scriptSource = input }.bind(this);
		// dialog.openIn(this, WorldMorph.current().positionForNewMorph(dialog));
		// return dialog;
		this.world().editPrompt(
			'Edit script',
			function(input) { this.scriptSource = input }.bind(this),
			this.scriptSource)
	},
	
	editLabel: function() {
		this.world().prompt(
			'Edit label',
			function(input) { this.setLabel(input) }.bind(this),
			this.getLabel());
	},

});

BoxMorph.subclass("ImageMorph", {

	documentation: "Image container",
	style:{ borderWidth: 0, fill:Color.blue.lighter() },
	formals: ["-URL"],

	initialize: function($super, viewPort, url, disableScaling) {
		$super(viewPort);
		this.disableScaling = disableScaling; // for compatiblity with depricated usages of image morph
		this.image = new lively.scene.Image(url, viewPort.width, viewPort.height);
		// console.log("making an image from: " + url); // Tired of seeing this. -- Adam
		if (url) {
			this.addWrapper(this.image); // otherwise we didn't make a rawNode
			this.setURL(url) 
		}
		//this.setExtent(this.getExtent())
	},

	// FIXME:
	restoreFromSubnode: function($super, importer, node) /*:Boolean*/ {
		if ($super(importer, node)) return true;

		switch (node.localName) {
			case "image":
			case "use":
			this.image = new lively.scene.Image(importer, node);
			return true;
			default:
			console.log("got unhandled node " + node.localName + ", " + node.namespaceURI + " node " + node);
			return false;
		}
	},

	loadGraphics: function(localURL) {
		this.setFill(null);
		var node = this.image.loadUse(localURL);
		node && this.addNonMorph(node);
	},

	loadFromURL: function(url) {
		//this.setFill(this.background);
		var node = this.image.loadImage(url.toString());
		node && this.addNonMorph(node);
	},

	reload: function() {
		this.image.reload();
	},

	onURLUpdate: function(url) {
		this.loadFromURL(url);
	},

	updateView: function(aspect, controller) {
		var p = this.modelPlug;
		if (!p) return;
		if (aspect == p.getURL) {
			this.onURLUpdate(this.getURL());
		}
	},

	moveOriginBy: function($super, delta) {
		$super(delta);
		if (!this.image) return;
		this.image.setLengthTrait("x", (this.image.getLengthTrait("x") || 0) - delta.x);
		this.image.setLengthTrait("y", (this.image.getLengthTrait("y") || 0) - delta.y);
	},

	setOpacity: function(op) { this.image.setOpacity(op); },

	getOpacity: function(op) { return this.image.getOpacity(op); },

	originalImageSize: function(imgSrc) {
		var newImg = new Image();
		newImg.src = imgSrc;
		return pt(newImg.width, newImg.height)
	},
	
	
	setExtent: function($super, extent) {
		if (this.image && !this.disableScaling) {
			this.image.setWidth(extent.x)
			this.image.setHeight(extent.y)
		}
		return $super(extent); // "return" added by Adam
	},

	reshape: function($super, partName, newPoint, lastCall){
		if (partName)
			$super(partName, newPoint, lastCall);
		if (!this.disableScaling) {
			var extent = this.getExtent();
			if (this.originalExtent) {
				var ratio = this.originalExtent.y / this.originalExtent.x
				extent.y = extent.x * ratio
			};
			var oldPosition = this.getPosition(); // added "var" so it won't be global. -- Adam
			this.setExtent(extent);
			this.setPosition(oldPosition)
		}
 	},

	morphMenu: function($super, evt) {
		var menu = $super(evt);
		menu.addLine();
		menu.addItem(["Edit image src", this.editImageSrc]);
		return menu;  
	},

	getURL: function() {
		return this.image.getURL()
	},

	setURL: function(url) {
		var extent = this.originalImageSize(url);
		if (extent.eqPt(pt(0,0))) {
			extent = pt(10,10); // fall back // aaa - hack for now, to make the demo look OK -- Adam
		};
		this.originalExtent = extent;
		this.image.loadImage(url);
		this.setExtent(extent);
		this.reshape()
	},
	
	editImageSrc: function() {
		this.world().prompt(
			'Edit Image SRC',
			function(input) { this.setURL(input) }.bind(this),
			this.getURL());
	},
});

ButtonMorph.subclass("ImageButtonMorph", {

    documentation: "Button with an image",
    focusHaloBorderWidth: 0,

    initialize: function($super, initialBounds, normalImageHref, activatedImageHref) {
        this.image = new ImageMorph(new Rectangle(0, 0, initialBounds.width, initialBounds.height), normalImageHref, true);
        this.normalImageHref = normalImageHref;
        this.activatedImageHref = activatedImageHref;
        $super(initialBounds);
        this.addMorph(this.image);
        this.image.handlesMouseDown = Functions.True,
        this.image.relayMouseEvents(this);
    },
    
    changeAppearanceFor: function(value) {
        //console.log('changing on %s from %s to %s', value, this.activatedImageHref, this.normalImageHref);
        this.image.loadFromURL(value ? this.activatedImageHref : this.normalImageHref);
    }
    
});

BoxMorph.subclass("ClipMorph", {

    documentation: "A clipping window/view",
    // A clipMorph is like a window through which its submorphs are seen
    // Its bounds are strictly limited by its shape
    // Display of its submorphs are strictly clipped to its shape, and
    // (optionally) reports of damage from submorphs are also clipped so that,
    // eg, scrolling can be more efficient
    
    style: { fill: null, borderWidth: 0},
    
    initialize: function($super, initialBounds) {
		$super(initialBounds);
		this.setupClipNode();
		this.isClipMorph = true;
    },

	setupClipNode: function() {
		var defs = this.rawNode.appendChild(NodeFactory.create('defs'));
		this.clip = new lively.scene.Clip(this.shape);
		defs.appendChild(this.clip.rawNode);
		this.clip.applyTo(this);		
	},
	
	
	restoreFromDefsNode: function($super, importer, node) {
		$super(importer, node);
	    var clips = node.getElementsByTagName('clipPath');
	    if (clips.length > 0) {
			this.clip = new lively.scene.Clip(importer, clips.item(0));
 			this.clip.applyTo(this);
			importer.addMapping(this.clip.id(), this.clip);
	    }
    },

	setBounds: function($super, bnds) { // this reshapes
		$super(bnds);
		this.clip.setClipShape(this.shape);
	},

	bounds: function(ignoreTransients) {
		// intersection  of its shape and its children's shapes
		if (!this.fullBounds) {
			var tfm = this.getTransform();
			var bounds = this.shape.bounds();
			// ClipMorph bounds are independent of subMorphs
			this.fullBounds = tfm.transformRectToRect(bounds);
		}
		return this.fullBounds;
	},

	innerMorph: function() {
		this.submorphs.length != 1 && console.log("not a single inner morph");
		return this.submorphs.first();
	},

	layoutOnSubmorphLayout: function() {
		return false;
	},

	copyFrom: function($super, copier, other) {
		$super(copier, other);
		this.setupClipNode();
	}
});

   
// ===========================================================================
// Handles and selection widgets
// ===========================================================================

Morph.subclass('HandleMorph', {
    
    style: {fill: null, borderColor: Color.blue, borderWidth: 1},

    controlHelpText: "Drag to resize this object\n" + 
        "Alt+drag to rotate the object \n" +
        "Alt+shift+drag to scale the object \n" + 
        "Shift+drag to change border width ", 
    circleHelpText: "Drag to reshape the line\n" + 
        "Cmd+drag to rotate the object \n" +
        "Cmd+shift+drag to scale the object \n" + 
        "Shift+drag to change width ",
    maxHelpCount: 20,
    helpCount: 0,
    isEpimorph: true,
    
	initialize: function($super, location, shapeType, hand, targetMorph, partName) {
		$super(new shapeType(location.asRectangle().expandBy(5)));
		this.location = location;
		this.targetMorph = targetMorph;
		this.partName = partName; // may be a name like "topRight" or a vertex index
		this.initialScale = null;
		this.initialRotation = null; 
		this.mode = 'reshape';
		this.rollover = true;  // pops up near hangle locs, goes away if mouse rolls out
		this.showingAllHandles = false;  // all handles are shown, eg, on touch screens
		this.normalize();
		return this;
	},
    
	getHelpText: function() {
		return (this.shape instanceof lively.scene.Rectangle) ? this.controlHelpText : this.circleHelpText;
	},

	showHelp: function($super, evt) {
		if (this.helpCount > this.maxHelpCount) return false;
		var wasShown = $super(evt);
		if (wasShown) {
			HandleMorph.prototype.helpCount++;
		}
		return wasShown;
	},

	okToDuplicate: Functions.False,

	handlesMouseDown: function(evt) { return true },
onMouseDown: function(evt) {
		//console.log("handle down");
		evt.hand.setMouseFocus(this);
		this.hideHelp();
		if (this.showingAllHandles) this.targetMorph.removeAllHandlesExcept(this);  // remove other handles during reshape
		if (evt.isCommandKey()) this.mode = evt.isShiftDown() ? 'scale' : 'rotate';
		else if (evt.isShiftDown()) this.mode = 'borderWidth';
	},


	onMouseMove: function(evt) {
		if (!evt.mouseButtonPressed) {
			if (this.showingAllHandles) return;  // Showing all handles; just let mouse roll over
			if (this.rollover) {  // Mouse up: Remove handle if mouse drifts away
				if (this.owner && !this.bounds().expandBy(5).containsPoint(this.ownerLocalize(evt.mousePoint))) {
					evt.hand.setMouseFocus(null);
					this.hideHelp();
					this.remove();
				}
				return;
			}
		}
		if (!this.owner) { console.warn("Handle " + this + " has no owner in onMouseMove!" ); return; }
		//console.log("handle move");
		// When dragged, I drag the designated control point of my target
		this.align(this.bounds().center(), this.ownerLocalize(evt.mousePoint));
		var p0 = evt.hand.lastMouseDownPoint; // in world coords
		var p1 = evt.mousePoint;
		if (!this.initialScale) this.initialScale = this.targetMorph.getScale();
		if (!this.initialRotation) this.initialRotation = this.targetMorph.getRotation();
		var ctr = this.targetMorph.owner.worldPoint(this.targetMorph.origin);  //origin for rotation and scaling
		var v1 = p1.subPt(ctr); //vector from origin now
		var v0 = p0.subPt(ctr); //vector from origin at mousedown
		var d = p1.dist(p0); //dist from mousedown

		switch (this.mode) {  // Note mode is set in mouseDown
			case 'scale' :
				var ratio = v1.r() / v0.r();
				ratio = Math.max(0.1,Math.min(10,ratio));
				this.targetMorph.setScale(this.initialScale*ratio);
				break; 
			case 'rotate' :
				this.targetMorph.setRotation(this.initialRotation + v1.theta() - v0.theta());
				break; 
			case 'borderWidth' :
				this.targetMorph.setBorderWidth(Math.max(0, Math.floor(d/3)/2), true);
				break;
			case 'reshape' :
				this.handleReshape(this.targetMorph.reshape(this.partName, this.targetMorph.localize(evt.point()), false));
				break;
		}
	},
    
	onMouseUp: function(evt) {
		//console.log("handle up");
		if (!evt.isShiftDown() && !evt.isCommandKey() && !evt.isMetaDown()) {
			// last call for, eg, vertex deletion
			if (this.partName) this.targetMorph.reshape(this.partName, this.targetMorph.localize(evt.mousePoint), true); 
		}
		this.remove();
		if (this.showingAllHandles) this.targetMorph.addAllHandles(evt);
	},
    
	handleReshape: function(result) {
		if (typeof result == "boolean") {
			// polygon reshape returns a bool = true if close to another vertex (for merge) else false
			this.setBorderColor(result ? Color.red : Color.blue);
		} else {
			// insert-vertex handle has negative index; convert to normal handle after the insertion
			if (this.partName  < 0) this.partName = -this.partName;
			this.type = "rect"; // become a regular handle
		}
	},

	inspect: function($super) {
		return $super() + " on " + Object.inspect(this.targetMorph);
	},
    
	scaleFor: function(scaleFactor) {
		this.applyFunctionToShape(function(s) {
			this.setBounds(this.bounds().center().asRectangle().expandBy(5/s));
			this.setStrokeWidth(1/s); 
		}, scaleFactor);
	},
	
	normalize: function() {
		// if targetMorph is scaled, I'm scaled, too. This function will undo it so that
		// I appear not scaled
		// FIXME: Only handled scale of direct targetMorph/owner!!!
		// if (!this.targetMorph.owner) return
		var invertScale = this.getScale() / this.targetMorph.getScale()
		this.setScale(invertScale);
		var p = this.getCenter();
		this.align(p, this.location);
	}
    
});

BoxMorph.subclass("SelectionMorph", {
	documentation: 'selection "tray" object that allows multiple objects to be moved and otherwise ' + 
		'manipulated simultaneously',

	style: {borderWidth: 1, borderColor: Color.blue, fill: Color.secondary.blue, fillOpacity: 0.1 },

	removeWhenEmpty: true,

	openForDragAndDrop: false,

	takesKeyboardFocus: Functions.True, 
	
	initialize: function($super, viewPort, defaultworldOrNull) {
		$super(viewPort);
		this.originalPoint = viewPort.topLeft();
		this.reshapeName = "bottomRight";
		this.myWorld = defaultworldOrNull ? defaultworldOrNull : this.world();
		// this.shape.setStrokeDashArray([3,2]);
		return this;
	},

	initializeTransientState: function($super) {
		$super();
		this.selectedMorphs = [];
		this.initialSelection = true;
	},

	reshape: function($super, partName, newPoint, lastCall) {

		// rk: With Mac OS 10.6 it's not sufficient to set the selection of the textarea
		// when doing tryClipboardAction. Hack of the hack for now: always set selection 
		// FIXME, other place Text, TextMorph>>onKeyDown
		// ClipboardHack.selectPasteBuffer();
		
		// Initial selection might actually move in another direction than toward bottomRight
		// This code watches that and changes the control point if so
		var result;
		if (this.initialSelection) {
			var selRect = new Rectangle.fromAny(pt(0,0), newPoint);
			if (selRect.width*selRect.height > 30) {
				this.reshapeName = selRect.partNameNearest(Rectangle.corners, newPoint);
			}
			this.setExtent(pt(0, 0)) // dont extend until we know what direction to grow
			result = $super(this.reshapeName, newPoint, lastCall);
		} else {
			result = $super(partName, newPoint, lastCall);
		}
		this.selectedMorphs = [];
		this.owner.submorphs.forEach(function(m) {
			if (m !== this && this.bounds().containsRect(m.bounds())) this.selectedMorphs.push(m);
		}, this);
		this.selectedMorphs.reverse();
			
		if (lastCall) this.initialSelection = false;
		if (lastCall && this.selectedMorphs.length == 0 && this.removeWhenEmpty) {
			this.remove();
		};
		var world = this.world();
		if (world) {
			world.firstHand().setKeyboardFocus(this);
  		this.setScale(1 / world.getScale()); // added by Adam to make it look right when zoomed in or out
		};	
		return result;
	},

	morphMenu: function($super, evt) { 
		var menu = $super(evt);
		menu.keepOnlyItemsNamed(['duplicate', 'remove', 'reset rotation', 'reset scaling', 'inspect', 'edit style']);
		menu.removeItemNamed('---');
		menu.addLine();
		menu.addItem(["align vertically", this.alignVertically]);
		menu.addItem(["space vertically", this.spaceVertically]);
		menu.addItem(["align horizontally", this.alignHorizontally]);
		menu.addItem(["space horizontally", this.spaceHorizontally]);
		menu.addItem(["align to grid...", this.alignToGrid]);
		return menu;
	},
	
	remove: function() { 
		this.selectedMorphs.invoke('remove');
		this.removeOnlyIt();
	},
	
	removeOnlyIt: function() {
		if ( this.myWorld == null ) {
			this.myWorld = this.world();
		} 
		this.myWorld.currentSelection = null;
		// Class.getSuperPrototype(this).remove.call(this);
		Morph.prototype.remove.call(this);
	},
	
	// Note: the next four methods should be removed after we have gridding, i think (DI)
	alignVertically: function() { 
		// Align all morphs to same left x as the top one.
		var morphs = this.selectedMorphs.slice(0).sort(function(m,n) {return m.position().y - n.position().y});
		var minX = morphs[0].position().x;	// align to left x of top morph
		morphs.forEach(function(m) { m.setPosition(pt(minX,m.position().y)) });
	},

	alignHorizontally: function() { 
		var minY = 9999;
		this.selectedMorphs.forEach(function(m) { minY = Math.min(minY, m.position().y); });
		this.selectedMorphs.forEach(function(m) { m.setPosition(pt(m.position().x, minY)) });
	},
	
	spaceVertically: function() { 
		// Sort the morphs vertically
		var morphs = this.selectedMorphs.clone().sort(function(m,n) {return m.position().y - n.position().y});
		// Align all morphs to same left x as the top one.
		var minX = morphs[0].position().x;
		var minY = morphs[0].position().y;
		// Compute maxY and sumOfHeights
		var maxY = minY;
		var sumOfHeights = 0;
		morphs.forEach(function(m) {
			var ht = m.innerBounds().height;
			sumOfHeights += ht;
			maxY = Math.max(maxY, m.position().y + ht);
		});
		// Now spread them out to fit old top and bottom with even spacing between
		var separation = (maxY - minY - sumOfHeights)/Math.max(this.selectedMorphs.length - 1, 1);
		var y = minY;
		morphs.forEach(function(m) {
			m.setPosition(pt(minX, y));
			y += m.innerBounds().height + separation;
		});
	},

	spaceHorizontally: function() { 
		// Sort the morphs vertically
		var morphs = this.selectedMorphs.clone().sort(function(m, n) { 
			return m.position().x - n.position().x;
		});
		// Align all morphs to same left x as the top one.
		var minX = morphs[0].position().x;
		var minY = morphs[0].position().y;
		// Compute maxX and sumOfWidths
		var maxX = minY;
		var sumOfWidths = 0;
		morphs.forEach(function(m) {
			var wid = m.innerBounds().width;
			sumOfWidths += wid;
			maxX = Math.max(maxX, m.position().x + wid);
		}); // Now spread them out to fit old top and bottom with even spacing between
		var separation = (maxX - minX - sumOfWidths)/Math.max(this.selectedMorphs.length - 1, 1);
		var x = minX;
		morphs.forEach(function(m) {
			m.setPosition(pt(x, minY));
			x += m.innerBounds().width + separation;
		});
	},
 
	copyToHand: function(hand) { 
		this.selectedMorphs.invoke('copyToHand', hand);
	},
	
	setBorderWidth: function($super, width) { 
		if (!this.selectedMorphs)  $super(width);
		else this.selectedMorphs.invoke('withAllSubmorphsDo', function() { this.setBorderWidth(width)});
	},
	
	setFill: function($super, color) { 
		if (!this.selectedMorphs)  $super(color);
		else this.selectedMorphs.invoke('withAllSubmorphsDo', function() { this.setFill(color)});
	},
	
	setBorderColor: function($super, color) { 
		if (!this.selectedMorphs)  $super(color);
		else this.selectedMorphs.invoke('withAllSubmorphsDo', function() { this.setBorderColor(color)});
	},

	shapeRoundEdgesBy: function($super, r) { 
		if (!this.selectedMorphs) $super(r);
		else this.selectedMorphs.forEach( function(m) { if (m.shape.roundEdgesBy) m.shapeRoundEdgesBy(r); });
	},
	
	setFillOpacity: function($super, op) { 
		if (!this.selectedMorphs)  $super(op);
		else this.selectedMorphs.invoke('withAllSubmorphsDo', function() { this.setFillOpacity(op)});
	},
	
	setStrokeOpacity: function($super, op) { 
		if (!this.selectedMorphs) $super(op);
		else this.selectedMorphs.invoke('callOnAllSubmorphs', function() { this.setStrokeOpacity(op)});
	},

	setTextColor: function(c) { 
		if (!this.selectedMorphs) return;
		this.selectedMorphs.forEach( function(m) { if (m.setTextColor) m.setTextColor(c); });
	},

	setFontSize: function(c) { 
		if (!this.selectedMorphs) return;
		this.selectedMorphs.forEach( function(m) { if (m.setFontSize) m.setFontSize(c); });
	},

	setFontFamily: function(c) { 
		if (!this.selectedMorphs) return;
		this.selectedMorphs.forEach( function(m) { if (m.setFontFamily) m.setFontFamily(c); });
	},

	setRotation: function($super, theta) {
		for ( var i = 0; i < this.selectedMorphs.length; i++ ) {
			this.addMorph(this.selectedMorphs[i]);
		}
		$super(theta);
		for ( var i = 0; i < this.selectedMorphs.length; i++ ) {
			this.world().addMorph(this.selectedMorphs[i]);
		}
	},
	
	setScale: function($super, scale) {
		for (var i = 0; i < this.selectedMorphs.length; i++ ) {
			this.addMorph(this.selectedMorphs[i]);
		}
		$super(scale);
		for (var i = 0; i < this.selectedMorphs.length; i++ ) {
			this.world().addMorph(this.selectedMorphs[i]);
		}
	},
	
	shadowCopy: function(hand) {
		var copy = Morph.makeRectangle(this.bounds())  // Don't show selection's shadow in the hand
		copy.setFill(null);
		copy.setBorderWidth(0);
		return copy;
	},

	canRespondTo: function(methodName) {
		if (!this.selectedMorphs) return false;
		if (methodName == 'shapeRoundEdgesBy') return this.selectedMorphs.any( function(m) { return m.shape.roundEdgesBy instanceof Function; });
		return this.selectedMorphs.any( function(m) { return m[methodName] instanceof Function; });
	},

	okToBeGrabbedBy: function(evt) {
		this.selectedMorphs.forEach( function(m) { evt.hand.addMorphAsGrabbed(m); });
		return this;
	},	
});

// ===========================================================================
// Panels, lists, menus, sliders, panes, etc.
// ===========================================================================

BoxMorph.subclass('PanelMorph', {

    documentation: "a panel",

    initialize: function($super, extent/*:Point*/) {
        $super(extent.extentAsRectangle());
        this.lastNavigable = null;
    },

    initializeTransientState: function($super) {
        $super();
        this.priorExtent = this.innerBounds().extent();
    },

    takesKeyboardFocus: Functions.True, 

    onMouseDown: function(evt) {
        this.requestKeyboardFocus(evt.hand);
        return true;
    },    
    
	onKeyPress: function(evt) {
		switch (evt.getKeyCode()) {
			case Event.KEY_TAB: { 
				this.focusOnNext(evt);
				evt.stop();
				return true;
			}
		}
	},
    
    handlesMouseDown: Functions.False,

    focusOnNext: function(evt) {
        var current = evt.hand.keyboardFocus;
        if (current && current.nextNavigableSibling) {
            current.relinquishKeyboardFocus(evt.hand);
            current.nextNavigableSibling.requestKeyboardFocus(evt.hand);
        } 
    },

    addMorphFrontOrBack: function($super, m, front) {
        if (m.takesKeyboardFocus()) {
            if (this.lastNavigable) this.lastNavigable.nextNavigableSibling = m;
            this.lastNavigable = m;
        }
        return $super(m, front);
    },

	adjustForNewBounds: function ($super) {
		// Compute scales of old submorph extents in priorExtent, then scale up to new extent
		$super();
		var newExtent = this.innerBounds().extent();
		var scalePt = newExtent.scaleByPt(this.priorExtent.invertedSafely());
		this.submorphs.forEach(function(sub) {
			sub.setPosition(sub.getPosition().scaleByPt(scalePt));
			sub.setExtent(sub.getExtent().scaleByPt(scalePt));
		});
		this.priorExtent = newExtent;
	},
    
    onVisibleUpdate: function(state) {
		if (state == false) this.remove();
    },

	updateView: function(aspect, controller) {
		var plug = this.modelPlug;
		if (!plug) return;

		if (aspect == plug.getVisible || aspect == 'all') {
			this.onVisibleUpdate(this.getModelValue('getVisible', true));
		}
	}

});

Object.extend(PanelMorph, {

    makePanedPanel: function(extent, paneSpecs, optPanel) {
        // Generalized constructor for paned window panels
        // paneSpec is an array of arrays of the form...
        //     ['leftPane', newTextListPane, new Rectangle(0, 0, 0.5, 0.6)],
        // See example calls in, eg, SimpleBrowser.buildView() for how to use this
        var panel = optPanel || new PanelMorph(extent);
        panel.linkToStyles(['panel']);

        paneSpecs.forEach(function(spec) {
            var paneName = spec[0];
            var paneConstructor = spec[1];
            var paneRect = extent.extentAsRectangle().scaleByRect(spec[2]);
            // fix for mixed class vs. function initialization bug
            var pane = Class.isClass(paneConstructor) ? new paneConstructor(paneRect) : paneConstructor(paneRect);
            panel[paneName] = panel.addMorph(pane)
        });
        panel.suppressHandles = true;
        return panel;
    }

});

TextMorph.subclass("CheapListMorph", {
	doNotSerialize: ['itemList'],
    
    style: { borderColor: Color.black, borderWidth: 1 },

    maxSafeSize: 4e4,  // override max for subsequent updates
    formals: ["List", "Selection", "-DeletionConfirmation", "+DeletionRequest"],
    padding: Rectangle.inset(0, 0),
    
	initialize: function($super, initialBounds, itemList) {
		// itemList is an array of strings
		// Note:  A proper ListMorph is a list of independent submorphs
		// CheapListMorphs simply leverage Textmorph's ability to display
		// multiline paragraphs, though some effort is made to use a similar interface.
		// Bug: currently selection doesn't work right if items have leading spaces
		itemList = this.sanitizedList(itemList);
		var listText = itemList ? itemList.join("\n") : "";
		$super(initialBounds, listText);

		this.setWrapStyle(text.WrapStyle.None);
		this.itemList = itemList;
		// this default self connection may get overwritten by, eg, connectModel()...
		var model = new SyntheticModel(this.formals);
		this.modelPlug = new ModelPlug(model.makePlugSpec());
		this.setModelValue('setList', itemList);
		this.layoutChanged();
		return this;
	},

    sanitizedList: function(list) { // make sure entries with new lines don't confuse the list
        return list && list.invoke('replace', /\n/g, " ");
    },

//    setExtent: function(ignored) {
        // Defeat recomposition when reframing windows
        // May have deleterious side-effects
//    },

    onDeserialize: function() {
        this.layoutChanged();
    },

    restorePersistentState: function($super, importer) {
        $super(importer);
        this.itemList = this.textString.split('\n');
        this.setModelValue('setList', this.itemList);
    },
    
    takesKeyboardFocus: Functions.True,

    onKeyPress: Functions.Empty,

    onKeyDown: function(evt) {
        switch (evt.getKeyCode()) {
        case Event.KEY_UP: {
            var lineNo = this.selectedLineNo();
            if (lineNo > 0) {
                this.selectLineAt(this.selectionRange[0] - 2); 
                this.setSelection(this.itemList[lineNo - 1]); 
            } 
            evt.stop();
            break;
        }
        case Event.KEY_BACKSPACE: {
            // request deletion by setting a deletion request in the model
            // if model is subsequently updated with a "setDeletionConfirmation"
            // the selected item will be removed from the view.
            this.setModelValue("setDeletionRequest", this.itemList[this.selectedLineNo()]);
            evt.stop();
            break;
        }
        case Event.KEY_DOWN: {
            var lineNo = this.selectedLineNo();
            if (lineNo < this.itemList.length - 1) {
                this.selectLineAt(this.selectionRange[1] + 2); // skip the '\n' ?
                this.setSelection(this.itemList[lineNo + 1]); 
            } 
            evt.stop();
            break;
        }
        case Event.KEY_ESC: {
            this.relinquishKeyboardFocus(this.world().firstHand());
            evt.stop();
            break;
        }    
        case Event.KEY_SPACEBAR: { // FIXME this should be more general
            // avoid paging down
            evt.stop();
            return true;
        }
        }

    },

    onMouseDown: function(evt) {
        this.onMouseMove(evt); 
        this.requestKeyboardFocus(evt.hand);
    },

    onMouseMove: function(evt) {  
        if (!evt.mouseButtonPressed) return;

        var mp = this.localize(evt.mousePoint);

        if (!this.shape.bounds().containsPoint(mp)) this.selectLineAt(-1);
        else this.selectLineAt(this.charOfY(mp)); 
    },

    onMouseUp: function(evt) {
        this.emitSelection(); 
    },

    emitSelection: function() {
        if (this.hasNullSelection()) return this.setSelection(null);
        this.setSelection(this.itemList[this.selectedLineNo()]); 
    },

    charOfY: function(p) { // Like charOfPoint, for the leftmost character in the line
        return this.charOfPoint(pt(this.padding.left() + 1, p.y)); 
    },
    
    selectedLineNo: function() { // Return the item index for the current selection
        return this.lineNo(this.getCharBounds(this.selectionRange[0]));
    },
    
    showsSelectionWithoutFocus: Functions.True,

    drawSelection: function($super) {
        if (this.hasNullSelection()) { // Null sel in a list is blank
            this.getTextSelection().undraw();
        } else $super();
    },

    selectLineAt: function(charIx) {  
        this.selectionRange = (charIx == -1) ? [0,-1] : this.lineRange(this.textString, charIx);
        this.drawSelection(); 
    },
    
    lineRange: function(str, charIx) { // like selectWord, but looks for matching newLines 
        var i1 = charIx;
        while (i1>0 && str[i1-1] != '\n') i1--; // scan back to prior newline
        var i2 = i1;
        while (i2<str.length-1 && str[i2+1] != '\n') i2++; // and forward to next newline
        return [i1, i2];
    },
    
    lineRect: function($super, r) { //Menu selection displays full width
        var bounds = this.shape.bounds();
        return $super(new Rectangle(bounds.x + 2, r.y, bounds.width - 4, r.height)); 
    },
    
    updateList: function(newList) {
        newList = this.sanitizedList(newList);
        var priorItem = this.getSelection();
        this.itemList = newList;
        var listText = (newList == null) ? "" : newList.join("\n");
        this.updateTextString(listText);
        this.setSelectionToMatch(priorItem);
        this.emitSelection(); 
    },

    setSelectionToMatch: function(item) {
        var lineStart = -1; 
        var firstChar = 0;
        for (var i = 0; i < this.itemList.length; i++) {
            if (this.itemList[i] == item) {
                lineStart = firstChar; 
               break; 
            }
            firstChar += this.itemList[i].length + 1; 
        }
        this.selectLineAt(lineStart); 
    },

    updateView: function(aspect, controller) {
        var c = this.modelPlug;

        if (c) { // New style connect
            switch (aspect) {
            case this.modelPlug.getList:
            case 'all':
                this.updateList(this.getList(["----"]));
                return this.itemList; // debugging
            case this.modelPlug.getSelection:
                var selection = this.getSelection();
                if (this !== controller) this.setSelectionToMatch(selection);
                return selection; //debugging
            case this.modelPlug.getDeletionConfirmation: //someone broadcast a deletion
                if (this.getModelValue("getDeletionConfirmation") == true) {
                    // update self to reflect that model changed
                    var index = this.selectedLineNo();
                    var list = this.getList(["----"]);
                    list.splice(index, 1);
                    this.updateList(list);
                } 
                return null;
            }
        }
    },

    getSelection: function() {
        if (this.modelPlug) return this.getModelValue('getSelection', null);
    },

    setSelection: function(item) {
        if (this.modelPlug) this.setModelValue('setSelection', item); 
    }

});

BoxMorph.subclass("TextListMorph", {

	documentation: "A list that uses TextMorphs to display individual items",
	style: { borderColor: Color.black, borderWidth: 1, fill: Color.white},
	formals: ["List", "Selection", "-Capacity", "-ListDelta", "-DeletionConfirmation", "+DeletionRequest"],
	defaultCapacity: 50,
	highlightItemsOnMove: false,

	layoutManager: new VerticalLayout(), // singleton is OK
	
	initialize: function($super, initialBounds, itemList, optPadding, optTextStyle) {
		// itemList is an array of strings
		this.baseWidth = initialBounds.width;
		var height = Math.max(initialBounds.height, itemList.length * TextMorph.prototype.fontSize);
		initialBounds = initialBounds.withHeight(height);
		if (optPadding) this.padding = optPadding;
		$super(initialBounds);
		this.itemList = itemList;
		this.selectedLineNo = -1;
		this.selection = null; // for connect
		this.textStyle = optTextStyle;
		this.generateSubmorphs(itemList);
	
		if (Config.selfConnect) { // self connect logic, not really needed 
			var model = Record.newNodeInstance({List: [], Selection: null, Capacity: this.defaultCapacity, 
				ListDelta: [], DeletionConfirmation: null, DeletionRequest: null});
			this.relayToModel(model, {List: "List", Selection: "Selection", Capacity: "-Capacity", 
				ListDelta: "-ListDelta",
				DeletionConfirmation: "-DeletionConfirmation", DeletionRequest: "+DeletionRequest"});
		}
		this.setList(itemList);
		this.savedFill = null; // for selecting items
		return this;
	},
	
	onDeserialize: function() {
		if (!this.itemList) this.itemList = [];
		for (var i = 0; i < this.submorphs.length; i++ ) {
			var m = this.submorphs[i];
			m.beListItem();
			m.relayMouseEvents(this);
			// this.itemList.push(m.textString);
		}
		// FIXME sometimes there are deserialization problems. replace completely!
		try { this.setList(this.itemList) } catch(e) {
			console.warn('Cannot correctly deserialize ' + this + ' because ' + e);
		}
		this.layoutChanged();
	},

	handlesMouseDown: Functions.True,

	generateSubmorphs: function(itemList) {
		var rect = pt(this.baseWidth, TextMorph.prototype.fontSize).extentAsRectangle();
		for (var i = 0; i < itemList.length; i++)  {
		  
			// Hacked to allow horizontal lines in menus. -- Adam
			var m = itemList[i];
			if (! (m instanceof Morph)) {
				m = new TextMorph(rect, m).beListItem();
			} else if (m.isMenuLine) {
			  m.setVertices([pt(0, 0), pt(this.baseWidth, 0)])
			}
			
			if (this.textStyle) m.applyStyle(this.textStyle);
			this.addMorph(m);
			m.relayMouseEvents(this);
		}
		// FIXME: border doesn't belong here, doesn't take into account padding.
		var borderBounds = this.bounds();//.expandBy(this.getBorderWidth()/2);
		var delta = 2; // FIXME FIXME
		var newBounds = new Rectangle(delta, 0, borderBounds.width - delta, borderBounds.height + this.padding.bottom());
		this.shape.setBounds(newBounds);
	},

	adjustForNewBounds: function($super) {
		$super();
		// FIXME: go through all the submorphs adjust?
		// Really, just fold into the layout logic, when in place
		this.baseWidth = this.bounds().width;
	},

	takesKeyboardFocus: Functions.True,

	setHasKeyboardFocus: function(newSetting) { 
		this.hasKeyboardFocus = newSetting;
		return newSetting;
	},
	
	onMouseDown: function(evt) {
		var target = this.morphToReceiveEvent(evt);
		var index = this.submorphs.indexOf(target);
		this.highlightItem(evt, index, true);
		evt.hand.setMouseFocus(this); // to get moves
	},

	onMouseMove: function(evt) {
		 // console.log("%s got evt %s", this.getType(),  evt);
		 if (!this.highlightItemsOnMove) return;
		 var target = this.morphToReceiveEvent(evt);
		 var index = this.submorphs.indexOf(target);
		 this.highlightItem(evt, index, false);
	},
	
	onMouseWheel: function(evt) {
		console.log("wheel event " + evt + "," + evt.wheelDelta() + " on " + this); // no break
	},

	highlightItem: function(evt, index, updateModel) {
		if (index >= 0) {
			this.selectLineAt(index, updateModel);
			this.requestKeyboardFocus(evt.hand);
			return true;
		}
		if (!updateModel) this.selectLineAt(-1, updateModel);
		return false;
	},

    onKeyPress: Functions.Empty,

    onKeyDown: function(evt) {
        switch (evt.getKeyCode()) {
        case Event.KEY_UP: {
            var lineNo = this.selectedLineNo;
            if (lineNo > 0) {
                this.selectLineAt(lineNo - 1, true); 
            } 
            evt.stop();
            break;
        }
        case Event.KEY_BACKSPACE: {
            // request deletion by setting a deletion request in the model
            // if model is subsequently updated with a "setDeletionConfirmation"
            // the selected item will be removed from the view.
            this.setDeletionRequest(this.itemList[this.selectedLineNo]);
            evt.stop();
            break;
        }
        case Event.KEY_DOWN: {
            var lineNo = this.selectedLineNo;
            if (lineNo < this.itemList.length - 1) {
                this.selectLineAt(lineNo + 1, true); 
            } 
            evt.stop();
            break;
        }
        case Event.KEY_ESC: {
            this.relinquishKeyboardFocus(evt.hand);
            this.selectLineAt(-1, true);
            evt.stop();
            break;
        }    
        case Event.KEY_SPACEBAR: { // FIXME this should be more generally
            // avoid paging down
            evt.stop();
            return true;
        }
        }
    },

    selectLineAt: function(lineNo, shouldUpdateModel) {  
        if (this.selectedLineNo in this.submorphs) {
          if (this.submorphs[this.selectedLineNo] instanceof TextMorph) { // added by Adam to allow horizontal lines in menus
            this.submorphs[this.selectedLineNo].setFill(this.savedFill);
            this.submorphs[this.selectedLineNo].setTextColor(this.savedTextColor); // added by Adam
          }
        }

        this.selectedLineNo = lineNo;

        var selectionContent = null;
        if (lineNo in this.submorphs) {
            var item = this.submorphs[lineNo];
            this.savedFill = item.getFill(); 
            if (item.getTextColor) { this.savedTextColor = item.getTextColor(); } // added by Adam
            item.setFill(TextSelectionMorph.prototype.style.fill);
            if (item.setTextColor) { item.setTextColor(TextSelectionMorph.prototype.style.textColor); } // added by Adam
            selectionContent = item.textString;
            this.scrollItemIntoView(item);
        }
        shouldUpdateModel && this.setSelection(selectionContent, true);
    },

    appendList: function(newItems) {
        var capacity = this.getCapacity();
        var priorItem = this.getSelection();
        var removed = this.itemList.length + newItems.length - capacity;
        if (removed > 0) {
			var oldPosition = this.submorphs[0].getPosition();
            for (var i = 0; i < removed; i++) {
                this.submorphs[0].remove();
            }
            this.itemList = this.itemList.slice(removed);
			
			// update position of of old morphs in list, 
			// normally this would be the job of the VerticalLayout behavior
			// -> TODO: implement layoutChanged() in VerticalLayout
			var delta = oldPosition.subPt(this.submorphs[0].getPosition());
			for (var i = 0; i < this.submorphs.length; i++) {
                this.submorphs[i].moveBy(delta);
            }
        }
        this.itemList = this.itemList.concat(newItems);
        this.generateSubmorphs(newItems);
        if (this.selectedLineNo + removed >= this.itemList.length - 1) {
            this.selectedLineNo = -1;
        }
        this.resetScrollPane(true);
    },

  	prependItem: function(item) {
    	if(!item){
			console.log("no item to prepend");
    		return;
    	}
    	var priorItem = this.getSelection();
    	this.itemList.unshift(item);
    	this.generateSubmorphs([item]);

    	//no the last submorph has to become the first one:
    	var oldPosition = this.submorphs[0].getPosition();
    	var p2 = this.submorphs[1].getPosition();
    	var delta = pt(0, p2.y-oldPosition.y);
		for (var i = 0; i < this.submorphs.length-1; i++) {
            this.submorphs[i].moveBy(delta);
        }
    	var last = this.submorphs.last();
    	last.remove();
    	this.insertMorph(last,false);
    	/*this.rawNode.insertBefore(last.rawNode, this.submorphs.last().rawNode.nextSibling);

    	this.submorphs.unshift(last);*/
    	last.setPosition(oldPosition);

    	this.setSelectionToMatch(priorItem);
    	this.resetScrollPane();
    	//this.enclosingScrollPane();
    },

    
    updateList: function(newList) {
	if(!newList || newList.length == 0) newList = ["-----"]; // jl 2008-08-02 workaround... :-(
        var priorItem = this.getSelection();
        this.itemList = newList;
        this.removeAllMorphs();
        this.generateSubmorphs(newList);
        this.setSelectionToMatch(priorItem)
        this.resetScrollPane();
        // this.emitSelection(); 
    },

    setSelectionToMatch: function(item) {
        for (var i = 0; i < this.submorphs.length; i++) {
            if (this.submorphs[i].textString === item) {
                this.selectLineAt(i, false);
                return true;
            }
        }
        return false;
    },

	onListUpdate: function(list) {
		this.updateList(list);
	},

    // FIXME containing ScrollPane has a Menu formal var  but update callbacks will be directed the List
    onMenuUpdate: Functions.Empty, 

	onListDeltaUpdate: function(delta) {
		this.appendList(delta);
	},

	onSelectionUpdate: function(selection) {
		console.log("got selection " + selection);
		this.setSelectionToMatch(selection);
		this.selection = selection; // for connect
	},

    onDeletionConfirmationUpdate: function(conf) {
        if (conf == true) {
            // update self to reflect that model changed
            var index = this.selectedLineNo;
            var list = this.getList();
            list.splice(index, 1);
            this.updateList(list);
        } 
    },
    
	updateView: function(aspect, controller) {
		var c = this.modelPlug;
		if (!c) return;
		switch (aspect) {
			case this.modelPlug.getList:
			case 'all':
			this.onListUpdate(this.getList());
			return this.itemList; // debugging

			case this.modelPlug.getListDelta:
			this.onListDeltaUpdate(this.getListDelta());
			return this.itemList;

			case this.modelPlug.getSelection:
			var selection = this.getSelection();
			this.onSelectionUpdate(selection);
			return selection; //debugging

			case this.modelPlug.getDeletionConfirmation: //someone broadcast a deletion
			this.onDeletionConfirmationUpdate(this.getDeletionConfirmation());
			return null;
		}
	},

	enclosingScrollPane: function() { 
		// Need a cleaner way to do this
		if (! (this.owner instanceof ClipMorph)) return null;
		var sp = this.owner.owner;
		if (! (sp instanceof ScrollPane)) return null;
		return sp;
	},
    
    scrollItemIntoView: function(item) { 
        var sp = this.enclosingScrollPane();
        if (!sp) return;
        sp.scrollRectIntoView(item.bounds()); 
    },
    
	resetScrollPane: function(toBottom) { 
		// Need a cleaner way to do this ;-)
		var sp = this.enclosingScrollPane();
		if (!sp) return false;
		if (toBottom) sp.scrollToBottom();
		else sp.scrollToTop();
		return true;
	},

});

// it should be the other way round...
TextListMorph.subclass("ListMorph", {

    documentation: 'Can handle list items, not only strings. {isListItem: true, string: string, value: object}',
    
    initialize: function($super, initialBounds, itemList, optPadding, optTextStyle, suppressSelectionOnUpdate) {
        $super(initialBounds, itemList, optPadding, optTextStyle)
        this.suppressSelectionOnUpdate = suppressSelectionOnUpdate;
    },
    
    generateListItem: function(value, rect) {
        if (this.itemPrinter)
            value = this.itemPrinter(value);
        return new TextMorph(rect, value.string /*fix for Fabrik XMLStringArray, use itemPrinter*/ || value.toString()).beListItem();
    },

    generateSubmorphs: function(itemList) {
        var rect = pt(this.baseWidth, TextMorph.prototype.fontSize).extentAsRectangle();
        for (var i = 0; i < itemList.length; i++)  {
            var m = this.generateListItem(itemList[i], rect);
            if (this.textStyle) m.applyStyle(this.textStyle);
            this.addMorph(m);
            m.closeDnD();
            m.relayMouseEvents(this);
        }
    },
    
    selectLineAt: function(lineNo, shouldUpdateModel) {  
        if (this.selectedLineNo in this.submorphs) { 
            this.submorphs[this.selectedLineNo].setFill(this.savedFill);
        }

        this.selectedLineNo = lineNo;

        var selectionContent = null; 
        if (lineNo in this.submorphs) {
            var item = this.submorphs[lineNo];
            this.savedFill = item.getFill();
            item.setFill(TextSelectionMorph.prototype.style.fill);
            selectionContent = this.itemList[lineNo].isListItem ?
				this.itemList[lineNo].value :
				this.itemList[lineNo];
            this.scrollItemIntoView(item);
        }
        shouldUpdateModel && this.setSelection(selectionContent, true);
    },
    
	onSelectionUpdate: function($super, selection) {
		if (!selection) {
			this.selectLineAt(-1);
			this.selection = null; // for connect
			return;
		}
		if (!Object.isString(selection)) {
			var item = this.itemList.detect(function(ea) { return ea.value === selection });
			if (item) {
				this.selectLineAt(this.itemList.indexOf(item));
				this.selection = item; // for connect
			}
			return
		}
		$super(selection);
	},
    
    setSelectionToMatch: function($super, item) {
        if (!item) return false;
        return $super(item.isListItem ? item.string : item);
    },
    
    
    updateList: function($super, newList) {
        $super(newList);
        this.suppressSelectionOnUpdate || this.selectLineAt(this.selectedLineNo);
    }
});

Morph.subclass('DragWrapper', {

	initialize: function($super, draggedObject, source, index, evt) {
		$super(new lively.scene.Rectangle(new Rectangle(0,0,100,100)));
		this.applyStyle({borderWidth: 0, fill: null});
		this.draggedObject = draggedObject;
		this.source = source;
		this.index=index;
		this.labelMe();
		this.startObservingMouseMoves(evt);
	},

	labelMe: function() {
		var label = new TextMorph(new Rectangle(0,0,100,100));
		if (Object.isString(this.draggedObject))
			label.textString = this.draggedObject;
		else if (this.draggedObject.string)
		label.textString = this.draggedObject.string;
		else
		label.textString = 'unknown';
		label.beLabel();
		label.setFill(Color.white);
		this.addMorph(label);
		label.centerAt(this.getPosition());
	},

	dropMeOnMorph: function(morph) {    
		var pos = this.owner.getPosition();
		var evt = newFakeMouseEvent(pos);
		morph = this.lookForBestReceiver(evt) || morph;

		this.remove();
		this.stopObservingMouseMoves();
		if (this.highlighted) this.highlighted.becomeNormal();

		this.source.isDragging = false;
		console.log('Asking ' + morph + ' if it wants ' + this.draggedObject + '(' + pos + ')');
		if (morph.acceptsDropOf && morph.acceptsDropOf(this.draggedObject)) {
			console.log('Yes :-)');
			morph.acceptDrop(this.draggedObject, evt);
		} else {
			console.log('No :-(')
			this.returnDraggedToSource();
		}
	},
	
	returnDraggedToSource: function() {
		this.source.draggedComesHome(this.draggedObject, this.index);
	},
	
	lookForBestReceiver: function(evt) {
		return evt.hand.world().morphToGrabOrReceive(evt);
	},
	
	startObservingMouseMoves: function(evt) {
		this.startEvent = evt;
		var wrapper=this;
		wrapper.highlighted = null;
		evt.hand.handleMouseEvent = evt.hand.handleMouseEvent.wrap(function(proceed, evt) {
			wrapper.highlighted && wrapper.highlighted.becomeNormal();
			var m = wrapper.lookForBestReceiver(evt);
			var oldColor = m.getBorderColor();
			var oldWidth = m.getBorderWidth();
			wrapper.highlighted = {
				becomeNormal: function() {			
					var x=m;
					x.setBorderColor(oldColor);
					x.setBorderWidth(oldWidth); //wrapper.highlighted=null;
				}
			}
			m.setBorderColor(Color.red);
			m.setBorderWidth(3);
			return proceed(evt);
		})
	},

	stopObservingMouseMoves: function() {
		if (!this.startEvent) return;
		this.startEvent.hand.handleMouseEvent = this.startEvent.hand.constructor.prototype.handleMouseEvent;
	},
});

ListMorph.subclass('DragnDropListMorph', {
    
    dragEnabled: true,

    onMouseDown: function($super, evt) {
        $super(evt);
		var target = this.morphToReceiveEvent(evt);
		var index = this.submorphs.indexOf(target);
        if (this.dragEnabled)
    		this.dragItem = this.itemList[index];    
    },

    onMouseUp: function(evt) {
    	if (this.dragEnabled)
    		this.dragItem = null;
    },

    onMouseMove: function($super, evt) {
    	if (this.dragEnabled && !this.isDragging && this.dragItem && evt.point().dist(evt.priorPoint) > 8) {
    		this.dragSelection(evt);
    		return;
    	}
    	$super(evt);
	},
    
    dragSelection: function(evt) {
    	console.log('start dragging');
		var item = this.dragItem;
		this.dragItem = null;
    	if (!item) {
    		console.log('got no item to drag!');
    		return;
    	}
    	this.isDragging = true;
		var index = this.itemList.indexOf(item);
    	var newList = this.itemList.without(item);
    	this.setList(newList, true); //this.updateList(newList); //?
		if (item.onDrag) item.onDrag();
		evt.hand.grabMorph(new DragWrapper(item, this, index, evt), evt);
	},

	draggedComesHome: function(item, index) {
		this.setList(this.listWith(item, index), true);
	},

	listWith: function(item, index) {
		var list = this.itemList;
		if (index in list)
			return list.slice(0,index).concat([item]).concat(list.slice(index, list.length));
		return list.concat([item]);
	},

	acceptsDropOf: function(item) {
		return Object.isString(item) || item.isListItem
	},

	acceptDrop: function(item, evt) {
		var target = this.morphToReceiveEvent(evt);
		var index = this.submorphs.indexOf(target);
		console.log(index);
		var otherItem = this.itemList[index];
		this.setList(this.listWith(item, index), true);
		if (item.onDrop) item.onDrop(otherItem);
		console.log('Drop accepted!')
	},    
});

Morph.addMethods({
    acceptsDropOf: function(item) {
        var h = this.mouseHandler;
        if (h && h.target)
    		return h.target.acceptsDropOf(item);
    	return false;
    },
    
    acceptDrop: function(item, evt) {
		console.log('relaying drop to: ' + this.mouseHandler.target);
        this.mouseHandler.target.acceptDrop(item,evt);
    },
    
});

DragnDropListMorph.subclass('FilterableListMorph', {
	defaultFilter: /.*/i,
	filter: /.*/i,
	initialize: function($super, initialBounds, itemList, optPadding, optTextStyle, suppressSelectionOnUpdate) {
        $super(initialBounds, itemList, optPadding, optTextStyle, suppressSelectionOnUpdate);
		this.clearFilter();
    },
	getFilter: function() { return this.filter },
	setFilter: function(regexp) {
		this.filter = regexp;
		this.updateList(this.itemList);
	},
	clearFilter: function() {
		this.setFilter(this.defaultFilter)
	},
	applyFilter: function(items) {
		return items.select(function(item) {
			return this.filter.test(item.string);
		}, this);
	},
	filteredItemList: function() {
		return this.applyFilter(this.itemList);
	},
	generateSubmorphs: function($super, itemList) {
		$super(this.applyFilter(this.itemList))
	},
	onKeyDown: function($super, evt) {
		if ($super(evt)) return true;
		if (evt.isAltDown() && evt.getKeyChar() == 'F') {
			this.showFilterDialog(evt);
			evt.stop();
			return true;
		};
		return false
	},
	showFilterDialog: function(evt) {
		var w = this.world();
		var regexString = this.filter.toString();
		regexString = regexString.substring(1, regexString.length-2);
		var acceptRegex = function(input) {
			if (!input) input = '.*';
			var evalString = '/' + input + '/i';
			try {
				var result = eval(evalString);
				if (result.constructor != RegExp) return;
				this.setFilter(result);
			} catch(e) { console.log(e) }
		}.bind(this);

		w.prompt('Edit Filter', acceptRegex, regexString);
	},
	morphToGrabOrReceive: function($super, evt, droppingMorph, checkForDnD) {
		// force to get the menu
		if (evt.isRightMouseButtonDown()) return this;
		return $super(evt, droppingMorph, checkForDnD);
	},
	morphMenu: function($super, evt) {
		var menu = $super(evt);
		menu.addItem(['set filter...', this.showFilterDialog], 0);
		return menu;
	},
	// FIXME cleanup the two methods below
	selectLineAt: function(lineNo, shouldUpdateModel) {  
        if (this.selectedLineNo in this.submorphs) { 
            this.submorphs[this.selectedLineNo].setFill(this.savedFill);
        }

        this.selectedLineNo = lineNo;

        var selectionContent = null; 
        if (lineNo in this.submorphs) {
            var item = this.submorphs[lineNo];
            this.savedFill = item.getFill();
            item.setFill(TextSelectionMorph.prototype.style.fill);
            selectionContent = /*****/this.filteredItemList()/*changed for filter*/[lineNo];
            if (selectionContent.isListItem) {
				selectionContent = selectionContent.value;
			}
            this.scrollItemIntoView(item);
        }
        shouldUpdateModel && this.setSelection(selectionContent, true);
    },
	onSelectionUpdate: function($super, selection) {
		if (!selection) {
			this.selectLineAt(-1);
			this.selection = null; // for connect
			return;
		}
		if (!Object.isString(selection)) {
			var item = this.itemList.detect(function(ea) { return ea.value === selection });
			if (item) {
				this.selectLineAt(/*****/this.filteredItemList()/*changed for filter*/.indexOf(item));
				this.selection = selection; // for connect
			}
			return
		}
		$super(selection);
	},
	
});

PseudoMorph.subclass('MenuItem', {
    
    initialize: function($super, name, closureOrMorph, selectorOrClosureArg, selectorArg) {
		$super();
		this.name = name;
		this.action = closureOrMorph;
		this.para1 = selectorOrClosureArg;
		this.para2 = selectorArg;
    },

    asArrayItem: function() { // for extrinsic menu manipulations
		return [this.name, this.action, this.para1, this.para2];
    },

    invoke: function(evt, targetMorph) {
		// Commented out the log messages because they're annoying. And added "var" in front of item so it won't be global. -- Adam
		//console.log("-------------------------------------------")
		var item = this;
		//console.log("invoke "+ targetMorph)
        if (! this.action) { return; } // added by Adam to make menu lines work
        if (this.action instanceof Function) { // alternative style, items ['menu entry', function] pairs
            this.action.call(targetMorph || this, evt);
        } else if (Object.isString(this.action.valueOf())) {
            // another alternative style, send a message to the targetMorph's menu target (presumably a view).
            var responder = (targetMorph || this).getModelValue("getMenuTarget");
            if (responder)  {
                var func = responder[this.action];
                if (!func) console.log(this.action + " not found in menu target " + responder);
                else func.call(responder, this.para1, evt, this);
            } else {
                console.log("no menu target " + targetMorph);
            }
        } else {
	    	var functionName = this.para1;
            var func = this.action[functionName];  // target[functionName]
            if (func == null) { 
				console.log('Could not find function ' + functionName + " on " + this.action);
            	// call as target.function(parameterOrNull,event,menuItem)
            } else { 	    
				var arg = this.para2;
				//console.log("menu.invoke: " + Object.inspect(this.action) + " action=" + functionName + " arg =" + Object.inspect(arg));
				func.call(this.action, arg, evt, this); 
	    	}
        }
    }

});

MenuItem.subclass("SubMenuItem", {
        
    isSubMenuItem: true,
    
    initialize: function($super, name, closureOrArray) {
        var closure = Object.isArray(closureOrArray) ? function() { return closureOrArray } : closureOrArray;
        $super(name + '...', closure);    
    },
    
    getList: function(evt, targetMorph) {
        if (!this.action) return [];
        return this.action.call(targetMorph || this, evt);
    },
    
    showMenu: function(evt, originalMenu) {
        var target = originalMenu.targetMorph;
        var menu = this.menu || new MenuMorph(this.getList(evt, target), target, originalMenu);
        var ownIndex = originalMenu.items.indexOf(this);
        var pos = pt(originalMenu.getPosition().x + originalMenu.listMorph.getExtent().x,
                     originalMenu.getPosition().y + originalMenu.listMorph.submorphs[ownIndex].getPosition().y);
        menu.openIn(originalMenu.owner, pos, false); 
        this.menu = menu;
    },
    
    closeMenu: function(evt, originalMenu) {
        if (!this.menu) return;
        this.menu.remove();
        this.menu = null;
    }
});

Morph.subclass("MenuMorph", {

    listStyle: { 
        borderColor: Color.blue,
        borderWidth: 0.5,
        fill: Color.blue.lighter(5),
        borderRadius: 4, 
        fillOpacity: 0.75,
        wrapStyle: text.WrapStyle.Shrink
    },

    textStyle: {
        textColor: Color.blue,
        padding: Rectangle.inset(4, 1), // added by Adam
        fontSize: 14  // added by Adam
    },

    labelStyle: {
        padding: Rectangle.inset(3),
		borderWidth: 1, 
        borderRadius: 4, 
        fillOpacity: 0.75, 
        wrapStyle: text.WrapStyle.Shrink
    },

    suppressHandles: true,
    focusHaloBorderWidth: 0,
    
    initialize: function($super, items, targetMorph, ownerMenu) {
        // items is an array of menuItems, each of which is an array of the form
        // 	[itemName, target, functionName, parameterIfAny]
        // At mouseUp, the item will be executed as follows:
        // 	target.function(parameterOrNull,event,menuItem)
        // The last item is seldom used, but it allows the caller to put
        // additional data at the end of the menuItem, where the receiver can find it.

		// Note that an alternative form of item is supported, as:
		// 	[itemName, itemFunction]
		// which will be executed as follows:
		//	itemFunction.call(targetMorph || this, evt)
		// See MenuItem for yet another form of invocation for targets matching
		//	var responder = (targetMorph || this).getModelValue("getMenuTarget");

		// Finally, note that if the itemName is followed by an array
		//	then that array is the specification for a subMenu,
		//	and, the itemName will appear followed by '...'

        // The optional parameter lineList is an array of indices into items.
        // It will cause a line to be displayed below each item so indexed
    
        // It is intended that a menu can also be created incrementally
        // with calls of the form...
        //     var menu = MenuMorph([]);
        //     menu.addItem(nextItem);  // May be several of these
        //     menu.addLine();          // interspersed with these
        //     menu.openIn(world,location,stayUp,captionIfAny);
	
        $super(new lively.scene.Rectangle(pt(0, 0).extentAsRectangle()));
        this.items = items.map(function(item) { return this.addPseudoMorph(this.checkItem(item)) }, this);
        this.targetMorph = targetMorph || this;
        this.listMorph = null;
        this.applyStyle({fill: null, borderWidth: 0, fillOpacity: 0});
        this.ownerMenu = ownerMenu;
    },

    onDeserialize: function() {
		this.listMorph.relayMouseEvents(this);
    },

    addItem: function(item, index) {
        var item = this.addPseudoMorph(this.checkItem(item));
        if (!index && (index != 0)) { this.items.push(item); return }
        if (index > this.items.length || index < 0) throw dbgOn(new Error('Strange index'));
        var parts = this.items.partition(function(ea, i) { return i < index });
        parts[0].push(item);
        this.items = parts[0].concat(parts[1]);
    },

    checkItem: function(item) {
      if (!item) { return new MenuItem(this.makeLine()); } // added by Adam
		if (Object.isString(item)) throw dbgOn(new Error(
			'Menu item specification should be an array, not just a string'));
		return Object.isArray(item[1]) ?
        	new SubMenuItem(item[0], item[1], item[2], item[3]) :
			new MenuItem(item[0], item[1], item[2], item[3]); 
    },

    addItems: function(items) {
		items.forEach( function(item) { this.addItem(item); }.bind(this));
    },

    getRawItems: function() {
		return this.items  // Private protocol for pie-menu access
    },

    addRawItem: function(item) {
		this.items.push(this.addPseudoMorph(item));  // Private protocol for pie-menu access
    },

    addLine: function(item) { // Not yet supported
        this.items.push(new MenuItem(this.makeLine())); // extracted the makeLine method -- Adam
    },

    // makeLine method extracted by Adam
    makeLine: function() { // Not yet supported
        // The idea is for this to add a real line on top of the text
        
        // Hacked to make the lines look like real lines, not just -----. -- Adam
        // return new MenuItem('-----');
        var line = Morph.makeLine([pt(0,5), pt(100,5)], 1, Color.gray);
        line.isMenuLine = true;
        return line;
    },

    addSubmenuItem: function(item) {
		// FIXME: Isn't this now just equivalent to addItem?
        var item = new SubMenuItem(item[0], item[1], item[2], item[3]);
        this.items.push(this.addPseudoMorph(item));
    },
    
    removeItemNamed: function(itemName) {
        // May not remove all if some have same name
        // Does not yet fix up the lines array
        for (var i = 0; i < this.items.length; i++)
            if (this.items[i].name == itemName) {
		this.items[i].remove();
                this.items.splice(i,1);
	    }
    },

    replaceItemNamed: function(itemName, newItem) {
        for (var i = 0; i < this.items.length; i++)
            if (this.items[i].name == itemName)
                this.items[i] = this.addPseudoMorph(new MenuItem(newItem[0], newItem[1], newItem[2], newItem[3]));
    },

    removeItemsNamed: function(nameList) {
        nameList.forEach(function(n) { this.removeItemNamed(n); }, this);
    },

    keepOnlyItemsNamed: function(nameList) {
        var rejects = [];
        this.items.forEach(function(item) { if (nameList.indexOf(item.name) < 0) rejects.push(item.name)});
        this.removeItemsNamed(rejects);
    },

    estimateListWidth: function(proto) {
		// estimate with based on some prototypical TextMorph object
		// lame but let's wait to do the right thing until the layout business is complete
		var maxWidth = 0;
		for (var i = 0; i < this.items.length; i++)
		    if (this.items[i].name.length > maxWidth) maxWidth = this.items[i].name.length;
		var protoPadding = Rectangle.inset(6, 4);
		return maxWidth *   (this.textStyle.fontSize || /* added by Adam */ proto.fontSize)/2 + protoPadding.left() + protoPadding.right();
    },

    openIn: function(parentMorph, loc, remainOnScreen, captionIfAny) { 
        if (this.items.length == 0) return;

        // Note: on a mouseDown invocation (as from a menu button),
        // mouseFocus should be set immediately before or after this call
        this.stayUp = remainOnScreen; // set true to keep on screen

        parentMorph.addMorphAt(this, loc);
	
		var textList = this.items.pluck('name');
        this.listMorph = new TextListMorph(pt(this.estimateListWidth(TextMorph.prototype), 0).extentAsRectangle(), 
					   textList, Rectangle.inset(0, this.listStyle.borderRadius/2), this.textStyle);
	
		var menu = this;
		this.listMorph.onKeyDown = function(evt) {
	    	var result = Class.getPrototype(this).onKeyDown.call(this, evt);
		    switch (evt.getKeyCode()) {
		    	case Event.KEY_ESC: {
					if (!menu.stayUp) menu.removeOnEvent(evt);
						evt.stop();
					return true;
				}
		    	case Event.KEY_RETURN: {
					if (menu.invokeItemAtIndex(evt, this.selectedLineNo)) 
			    		evt.stop();
					return true;
	    		}
	    	}
		};

        this.listMorph.applyStyle(this.listStyle);
        this.listMorph.suppressHandles = true;
        this.listMorph.focusHaloBorderWidth = 0;
        this.listMorph.highlightItemsOnMove = true;
        this.addMorph(this.listMorph);

        this.label = null;
        if (captionIfAny) { // Still under construction
            var label = TextMorph.makeLabel(captionIfAny, this.labelStyle);
            label.align(label.bounds().bottomCenter(), this.listMorph.shape.bounds().topCenter());
            this.label = this.addMorph(label);
	    	this.label.setFill(new lively.paint.LinearGradient([new lively.paint.Stop(0, Color.white),
								new lively.paint.Stop(1, Color.gray)]));
        }

        // If menu and/or caption is off screen, move it back so it is visible
       var menuRect = this.bounds();  //includes caption if any
       menuRect = menuRect.topLeft().extent(menuRect.extent().scaleBy(1 / this.overallScale())); // adjust for the menu's scale -- Adam
       var world = this.world() || WorldMorph.current();
       var bounds = world.visibleBounds();
       //console.log("Visible Bounds for World Morph: " + bounds);  // commented out, annoying -- Adam
       var visibleRect = menuRect.intersection(bounds);
        var delta = visibleRect.topLeft().subPt(menuRect.topLeft());  // delta to fix topLeft off screen
        delta = delta.addPt(visibleRect.bottomRight().subPt(menuRect.bottomRight()));  // same for bottomRight
        if (delta.dist(pt(0, 0)) > 1) this.moveBy(delta);  // move if significant

        this.startOpeningAnimation(); // Added by Adam; must be down here so that the bounds calculations use the full size

        this.listMorph.relayMouseEvents(this);
        // Note menu gets mouse focus by default if pop-up.  If you don't want it, you'll have to null it
        if (!remainOnScreen) {
	    var hand = parentMorph.world().firstHand();
	    hand.setMouseFocus(this);
            hand.setKeyboardFocus(this.listMorph);
        }
    },

    // Added by Adam
    startOpeningAnimation: function() {
      var world = this.world();
      var desiredScale = Config.fatFingers ? 1.5 : 1;
      if (world) {
        desiredScale = desiredScale / world.getScale();
        this.setScale(desiredScale * 0.01);
        this.smoothlyScaleTo(desiredScale);
      } else {
        this.setScale(desiredScale);
      }
    },
    
    selectedItemIndex: function(evt) {
        var target = this.listMorph.morphToReceiveEvent(evt);
        var index = this.listMorph.submorphs.indexOf(target);
        if (index === -1) return null;
        return index;
    },
    
    submenuItems: function() {
        return this.items.select(function(ea) { return ea.isSubMenuItem });
    },
    
    handOverMenu: function(hand) {
        return this.listMorph.bounds().containsPoint(this.localize(hand.getPosition()));
    },
    
    setMouseFocus: function(evt) {
        evt.hand.setMouseFocus(this);
        evt.hand.setKeyboardFocus(this.listMorph);    
    },

    setMouseFocusOverSubmenu: function(evt) {
		// Return true iff the mouse is in a submenu
        var submenuItem = this.submenuItems().detect(function(ea) { return ea.menu && ea.menu.handOverMenu(evt.hand) }) ;
        if (!submenuItem) return false;
        submenuItem.menu.setMouseFocus(evt);
		return true;
    },
    
    setMouseFocusOverOwnerMenu: function(evt) {
        if (this.ownerMenu && this.ownerMenu.handOverMenu(evt.hand))
            this.ownerMenu.setMouseFocus(evt);
    },
    
    setMouseFocusOverOwnerMenuOrSubMenu: function(evt) {
        this.setMouseFocusOverOwnerMenu(evt);
        this.setMouseFocusOverSubmenu(evt);
    },
        
    removeOnEvent: function(evt) {
        this.submenuItems().invoke('closeMenu');
        this.remove();
        this.ownerMenu && this.ownerMenu.removeOnEvent(evt);
        if (evt.hand.mouseFocus === this) evt.hand.setMouseFocus(null);
    },

    onMouseUp: function(evt) {
		if (evt.hand.checkMouseUpIsInClickTimeSpan(evt))
			return true; // do nothing on a click...
	
		if (!this.invokeItemAtIndex(evt, this.selectedItemIndex(evt)) && !this.stayUp)
	    	this.setMouseFocus(evt); // moved away, don't lose the focus
    },

    onMouseDown: function(evt) {
        this.onMouseMove(evt); // Added by Adam to make highlighting work on touch devices even when no movement
        if (this.selectedItemIndex(evt) === null && !this.stayUp) {
          this.removeOnEvent(evt);
        }
    },

    onMouseMove: function(evt) {
        this.setMouseFocus(evt);
		if (!this.handOverMenu(evt.hand)) {
			if (this.stayUp) evt.hand.setMouseFocus(null);
			if (this.setMouseFocusOverSubmenu(evt)) return;
			this.listMorph.highlightItem(evt, -1, false);
			this.setMouseFocusOverOwnerMenu(evt);
			return;    
			}

        var index = this.selectedItemIndex(evt);
        if (index === null) return;
        this.listMorph.highlightItem(evt, index, false);
        
        var item = this.items[index];
		this.submenuItems().without(item).invoke('closeMenu');
        if (! item.isSubMenuItem) return;
		if (! item.menu) item.showMenu(evt, this);
			else if (item.menu.handOverMenu(evt.hand)) item.menu.setMouseFocus(evt);
        
    },
    
    // is not called
    onMouseOut: function(evt) {
        console.log("mouse moved away ....");
        this.setMouseFocusOverSubmenu(evt);
        if (this.stayUp) return;
        this.removeOnEvent(evt);
    },
    
    invokeItemAtIndex: function(evt, index) {
		if (index === null) return false;
	        try {
		    this.invokeItem(evt, this.items[index]);
	        } finally {
		    if (!this.stayUp) this.removeOnEvent(evt);
	        }
		return true;
    },
    
    invokeItem: function invokeItem(evt, item) {
        if (!item) return;
		item.invoke(evt, this.targetMorph);
    }

});

BoxMorph.subclass("SliderMorph", {

	documentation: "Slider/scroll control",

	mss: 12,  // minimum slider size
	formals: { 
		Value:		  {byDefault: 0}, // from: function(value) { alert('from!' + value); return value;}}, 
		SliderExtent: {mode: "-", byDefault: 0} 
	},
	style: {borderWidth: 1, borderColor: Color.black},
	selfModelClass: PlainRecord.prototype.create({Value: { byDefault: 0 }, SliderExtent: { byDefault: 0}}),
	
	connections: ['value'],

	initialize: function($super, initialBounds, scaleIfAny) {
		$super(initialBounds);
		// this default self connection may get overwritten by, eg, connectModel()...
		var modelClass = this.selfModelClass;
		var model = new modelClass({}, {});
		this.connectModel(model.newRelay({Value: "Value", SliderExtent: "SliderExtent"}));
		this.valueScale = (scaleIfAny === undefined) ? 1.0 : scaleIfAny;
		var slider = Morph.makeRectangle(0, 0, this.mss, this.mss);
		slider.relayMouseEvents(this, {onMouseDown: "sliderPressed", onMouseMove: "sliderMoved", onMouseUp: "sliderReleased"});
		this.slider = this.addMorph(slider);
		this.slider.linkToStyles(['slider']);
		this.adjustForNewBounds();
		this.adjustFill();
		return this;
	},

 	onDeserialize: function() {
		if (!this.slider) {
			console.warn('no slider in %s, %s', this, this.textContent);
		   return;
		}
		this.slider.relayMouseEvents(this, {onMouseDown: "sliderPressed", onMouseMove: "sliderMoved", onMouseUp: "sliderReleased"});
		// TODO: remove this workarounds by serializing observer relationsships
		if (this.formalModel && this.formalModel.addObserver) {
			this.formalModel.addObserver(this)
		}	
	},
	
	vertical: function() {
		var bnds = this.shape.bounds();
		return bnds.height > bnds.width; 
	},
	
	applyStyle: function($super, spec) {
		$super(spec);
		// need to call adjust to update graphics, but only after slider exists
		if (this.slider) {
			this.adjustForNewBounds(); 
			this.adjustFill();
		}
		return this; // added by Adam
	},
	
	adjustForNewBounds: function($super) {
		$super();
		this.adjustSliderParts();
	},
	
	adjustSliderParts: function($super) {
		// This method adjusts the slider for changes in value as well as geometry
		var val = this.getScaledValue();
		var bnds = this.shape.bounds();
		var ext = this.getSliderExtent(); 

    // added by Adam
		if (ext === 1) {
		  if (this.owner) {
		    this._desiredOwner = this.owner;
		    this.remove();
		  }
    } else if (!this.owner && this._desiredOwner) {
      console.log()
      this._desiredOwner.addMorph(this);
    }
	
		if (this.vertical()) { // more vertical...
			var elevPix = Math.max(ext*bnds.height, this.mss); // thickness of elevator in pixels
			var topLeft = pt(0, (bnds.height - elevPix)*val);
			var sliderExt = pt(bnds.width, elevPix);
		} else { // more horizontal...
			var elevPix = Math.max(ext*bnds.width, this.mss); // thickness of elevator in pixels
			var topLeft = pt((bnds.width - elevPix)*val, 0);
			var sliderExt = pt(elevPix, bnds.height); 
		}
		this.slider.setBounds(bnds.topLeft().addPt(topLeft).extent(sliderExt));

		//this.slider.shapeRoundEdgesBy((this.vertical() ? sliderExt.x : sliderExt.y)/2);
		this.slider.shapeRoundEdgesBy(Math.min(sliderExt.x, sliderExt.y)/2);
		
	},

	adjustFill: function() {
	  
	  // added by Adam
	  var shouldMakeScrollBarsLookSortaLikeMacOS = true;
	  if (shouldMakeScrollBarsLookSortaLikeMacOS) {
	    var sliderColor = new Color(0.5, 0.5, 0.5);
	    this.slider.setFill(sliderColor);
	    this.slider.setBorderColor(sliderColor);
	    this.setFill(Color.black);
	    this.setFillOpacity(0.1);
	    this.setBorderWidth(0);
	    this.setBorderColor(null);
	    return;
	  }
	  
		var fill = this.slider.getFill();
		var gfx = lively.paint;
		if (fill instanceof lively.paint.LinearGradient) {
			var direction = this.vertical() ? gfx.LinearGradient.EastWest : gfx.LinearGradient.NorthSouth;
			var baseColor = fill.stops[0].color();
			this.setFill(new gfx.LinearGradient([new gfx.Stop(0, baseColor, 1), 
							 new gfx.Stop(0.5, baseColor.lighter(2)),
							 new gfx.Stop(1, baseColor)], direction));
			// FIXME: just flip the gradient
			this.slider.setFill(
				new gfx.LinearGradient([ new gfx.Stop(0, baseColor),
				new gfx.Stop(1, fill.stops[1].color())], direction));
			this.setBorderWidth(this.slider.getBorderWidth());
		} else if (fill) {
			this.setFill(fill.lighter());
		}		
	},
	
	sliderPressed: function(evt, slider) {
		//	  Note: want setMouseFocus to also cache the transform and record the hitPoint.
		//	  Ideally thereafter only have to say, eg, morph.setPosition(evt.hand.adjustedMousePoint)
		this.hitPoint = this.localize(evt.mousePoint).subPt(this.slider.bounds().topLeft());
	},
	
	sliderMoved: function(evt, slider) {
		if (!evt.mouseButtonPressed) return;

		// Compute the value from a new mouse point, and emit it
		var p = this.localize(evt.mousePoint).subPt(this.hitPoint || evt.mousePoint);//Sometimes this.hitPoint is undefined
		var bnds = this.shape.bounds();
		var ext = this.getSliderExtent(); 
	
  	 // Yield 0 if the elevator takes up the full slider - otherwise we get infinities and weird jerky behaviour. -- Adam
		if (this.vertical()) { // more vertical...
			var elevPix = Math.max(ext*bnds.height,this.mss); // thickness of elevator in pixels
			var newValue = bnds.height === elevPix ? 0 : p.y / (bnds.height-elevPix);
		} else { // more horizontal...
			var elevPix = Math.max(ext*bnds.width,this.mss); // thickness of elevator in pixels
			var newValue = bnds.width === elevPix ? 0 : p.x / (bnds.width-elevPix); 
		}
		
		if (isNaN(newValue)) newValue = 0;
		this.setScaledValue(this.clipValue(newValue));
		this.adjustForNewBounds(); 
	},

	sliderReleased: Functions.Empty,
	
	handlesMouseDown: function(evt) { return !evt.isCommandKey(); },

	onMouseDown: function(evt) {
		this.requestKeyboardFocus(evt.hand);
		var inc = this.getSliderExtent();
		var newValue = this.getValue();

		var delta = this.localize(evt.mousePoint).subPt(this.slider.bounds().center());
		if (this.vertical() ? delta.y > 0 : delta.x > 0) newValue += inc;
		else newValue -= inc;
	
		if (isNaN(newValue)) newValue = 0;
		this.setScaledValue(this.clipValue(newValue));
		this.adjustForNewBounds(); 
	},
	
	onMouseMove: function($super, evt) {
		// Overriden so won't drag me if mouse pressed
		if (evt.mouseButtonPressed) return;
		return $super(evt);
	},
	
	clipValue: function(val) { 
		return Math.min(1.0,Math.max(0,0,val.roundTo(0.0001))); 
	},

	updateView: function(aspect, controller) { // obsolete soon ?
		var p = this.modelPlug;
		if (!p) return;
		if (aspect == p.getValue || aspect == 'all') {
			this.onValueUpdate(this.getValue());
		} else if (aspect == p.getSliderExtent || aspect == 'all')	{
			this.onSliderExtentUpdate(this.getSliderExtent()); 
		}
	},

	onSliderExtentUpdate: function(extent) {
		this.adjustForNewBounds();
	},

	onValueUpdate: function(value) {
		this.adjustForNewBounds();
		this.value = value // for connect
	},

	getScaledValue: function() {
		return (this.getValue() || 0) / this.valueScale; // FIXME remove 0
	},

	setScaledValue: function(value) {
		return this.setValue(value * this.valueScale);
	},
	
	takesKeyboardFocus: Functions.True,
	
	setHasKeyboardFocus: function(newSetting) { 
		return newSetting; // no need to remember
	},

	onKeyPress: Functions.Empty,

	onKeyDown: function(evt) {
		var delta = 0;
		if (this.vertical()) {
			switch (evt.getKeyCode()) {
			case Event.KEY_DOWN: delta = 1; break;
			case Event.KEY_UP:	delta = -1; break;
			default: return false;
			} 
		} else {
			switch (evt.getKeyCode()) {
			case Event.KEY_RIGHT: delta = 1;  break;	
			case Event.KEY_LEFT:  delta = -1; break;
			default: return false;
			}	 
		}
		this.setScaledValue(this.clipValue(this.getScaledValue() + delta * (this.getSliderExtent())));
		this.adjustForNewBounds();
		evt.stop();
		return true;
	}

});

BoxMorph.subclass("ScrollPane", {

    description: "A scrolling container",
    style: { borderWidth: 2, fill: null},
    scrollBarWidth: 6, // used to say 14 -- Adam
    ScrollBarFormalRelay: Relay.create({Value: "ScrollPosition", SliderExtent: "-VisibleExtent"}), // a class for relays

    initialize: function($super, morphToClip, initialBounds) {
        $super(initialBounds);
        
		var clipR = this.calcClipR();
        // I don't understand why this next line of code was in there, with
        // a comment next to it explaining exactly why it's broken.
        // Commenting it out. -- Adam
        //morphToClip.shape.setBounds(clipR); // FIXME what if the targetmorph should be bigger than the clipmorph?
        
        // Make a clipMorph with the content (morphToClip) embedded in it
        this.clipMorph = this.addMorph(new ClipMorph(clipR));    
        //this.clipMorph.shape.setFill(morphToClip.shape.getFill());
	this.clipMorph.setFill(morphToClip.getFill());
        morphToClip.setBorderWidth(0);
        morphToClip.setPosition(clipR.topLeft());
        this.clipMorph.addMorph(morphToClip);
	
	
		this.showScrollBar = true;
       	this.initializeScrollBar();
	
        // suppress handles throughout
        [this, this.clipMorph, morphToClip, this.scrollBar].forEach(function(m) {m.suppressHandles = true});
        // alert('inner morph is ' + this.innerMorph());
	
        return this;
    },

	calcClipR: function() {
		var bnds = this.innerBounds();
		return bnds.withWidth(bnds.width - this.scrollBarWidth+1).insetBy(1);
	},

	initializeScrollBar: function() {
		if (this.showScrollBar) {
			var morph = new SliderMorph(this.innerBounds().withTopLeft(this.calcClipR().topRight()))
        	this.scrollBar = this.addMorph(morph);
			this.scrollBar.connectModel(new (this.ScrollBarFormalRelay)(this));
		}
	},

	getScrollBar: function() {
		if (!this.scrollBar) {
			this.initializeScrollBar();
		};
		return this.scrollBar
	},
	
	disableScrollBar: function() {
		if (this.scrollBar) {
			this.scrollBar.remove();
			this.showScrollBar = false;
			delete this.scrollBar;
			this.adjustForNewBounds();
		}
	},

	enableScrollBar: function() {
		this.showScrollBar = true;
		this.initializeScrollBar();
	},

    onDeserialize: function() { // FIXME duplication between here and initialize
        if (this.scrollBar && this.ScrollBarFormalRelay) 
	    	this.scrollBar.formalModel = new (this.ScrollBarFormalRelay)(this);
        if (this.menuButton)
            this.menuButton.relayMouseEvents(this, {onMouseDown: "menuButtonPressed"});
		this.adjustForNewBounds();
    },

    submorphBounds: function() {
		// a little optimization 
		// FIXME: epimorphs should be included
		if (this.clipMorph)
			return this.clipMorph.bounds();
    },

    innerMorph: function() {
        return this.clipMorph.innerMorph();
    },

    connectModel: function(plugSpec, optFlag) { // connection is mapped to innerMorph
        this.innerMorph().connectModel(plugSpec, optFlag);
        if (plugSpec.getMenu) this.addMenuButton();
    },
    
    disconnectModel: function() {
        this.innerMorph().disconnectModel();
    },
    
    getModel: function() {
        return this.innerMorph().getModel();
    },

    getModelPlug: function() {
        return this.innerMorph().getModelPlug();
    },

    updateView: function(aspect, source) {
        return this.innerMorph().updateView(aspect, source);
    },
    
    addMenuButton: function() {
        if (this.menuButton) return;

        var w = this.scrollBarWidth;
        this.menuButton = this.addMorph(Morph.makeRectangle(0, 0, w, w));
        this.menuButton.setFill(Color.white);
        // Make it look like 4 tiny lines of text (doesn't work yet...)
        var p0 = this.menuButton.innerBounds().topLeft().addXY(2, 2);
        for (var i = 1; i <= 4; i++) {
	    var line = new lively.scene.Polyline([p0.addXY(0, i*2), p0.addXY([6, 2, 4, 6][i-1], i*2)]);
	    line.setStroke(Color.black);
	    line.setStrokeWidth(1);
            this.menuButton.addMorph(new Morph(line)).ignoreEvents();
        }
	
        if (this.scrollBar) {
            this.menuButton.setPosition(this.getScrollBar().getPosition());
            this.menuButton.setFill(this.getScrollBar().getFill());
            this.getScrollBar().setBounds(this.getScrollBar().bounds().withTopLeft(
            	this.getScrollBar().bounds().topLeft().addXY(0, w)));
        }
        this.menuButton.relayMouseEvents(this, {onMouseDown: "menuButtonPressed"});
    },

    menuButtonPressed: function(evt, button) {
		//console.log("menuButtonPressed")
        evt.hand.setMouseFocus(null);
        var editItems = this.innerMorph().editMenuItems();
		var items = this.innerMorph().getModelValue("getMenu") || [];
        if (editItems.length == 0 && items.length == 0) return;
        var menu;
		if (editItems.length > 0 && items.length > 0) {
            var menu = new MenuMorph(editItems, this);
	    	menu.addLine();
	    	items.forEach(function(item) {menu.addItem(item); });
		} else {
	    	var menu = new MenuMorph(editItems.concat(items), this);
		}
        menu.openIn(this.world(), evt.mousePoint, false); 
    },

	slideRoom: function() {
		// 10 is a offset that works with the default font size... I think this may be font size related
		return this.innerMorph().bounds().height - this.bounds().height + 10;
	},

    getScrollPosition: function() {         
        var slideRoom = this.slideRoom();
		// note that inner morph may have exactly the same size as outer morph so slideRoom may be zero
        return slideRoom && -this.innerMorph().position().y/slideRoom; 
    },
    
    setScrollPosition: function(scrollPos) { 
		// this.adjustForNewBounds();
        this.innerMorph().setPosition(pt(this.innerMorph().position().x, -this.slideRoom()*scrollPos )); 
		if (this.scrollBar)
        	this.getScrollBar().adjustForNewBounds();

    },

    getVisibleExtent: function(scrollPos) {
        return Math.min(1, this.bounds().height / Math.max(10, this.innerMorph().bounds().height)); 
    },
    
    scrollToTop: function() {
        this.setScrollPosition(0);
		if (this.scrollBar)
        	this.getScrollBar().adjustForNewBounds(); 
    },

    scrollToBottom: function() {
        this.setScrollPosition(1);
		if (this.scrollBar)
        	this.getScrollBar().adjustForNewBounds(); 
    },

    scrollRectIntoView: function(r) {
        var im = this.innerMorph();
        if (!r || !im) return;
        var bnds = this.innerBounds();
		var yToView = r.y + im.getPosition().y;  // scroll down if above top
        if (yToView < bnds.y) {
            im.moveBy(pt(0, bnds.y - yToView));
			if (this.scrollBar)
            	this.getScrollBar().adjustForNewBounds();
            return;
        }
        var yToView = r.y + r.height + im.getPosition().y;  // scroll up if below bottom
        var tweak = 5;  // otherwise it doesnt scroll up enough to look good
        if (yToView > bnds.maxY() - tweak) {
            im.moveBy(pt(0, bnds.maxY() - tweak - yToView))
            if (this.scrollBar)
				this.getScrollBar().adjustForNewBounds();
        }
    },
    
    adjustForNewBounds: function ($super) {
        // Compute new bounds for clipMorph and scrollBar
        $super();
        if (!this.clipMorph) return;
        var bnds = this.innerBounds();    	
  		var clipR = bnds.insetBy(1);
		if (this.scrollBar) {
			clipR = this.calcClipR();
		};
        this.clipMorph.setExtent(clipR.extent());
        
		// Yeah, I'm completely baffled. There's a broken line of code, commented out, with
		// a comment saying *why* it's broken, and then an uncommented exact copy of that
		// line of code. Commenting out the second version. -- Adam
		//this.innerMorph().setExtent(clipR.extent());
		// WebCards commented this out: //this destroyes the content. i don't like that (Julius)
		//this.innerMorph().setExtent(clipR.extent()); 
		
        var barBnds = bnds.withTopLeft(clipR.topRight());
        if (this.menuButton) {
            var w = this.scrollBarWidth;
            this.menuButton.setPosition(barBnds.topLeft());
            //this.menuButton.setBounds(barBnds.topLeft().extent(pt(w, w)));
            barBnds = barBnds.withTopLeft(barBnds.topLeft().addXY(0, w));
        }
		if (this.scrollBar)
        	this.getScrollBar().setBounds(barBnds);
    },

});

// added by Adam
ScrollPane.prototype._layout = {
  possiblyDoSomethingBecauseASubmorphMinimumExtentHasChanged: function (scrollPane) {
    scrollPane.forceLayoutRejiggering();
    return true;
  },

  rejigger: function (scrollPane, availableSpace) {
    var r = scrollPane.rejiggerJustMyLayout(availableSpace);
    scrollPane.adjustForNewBounds();
    return r;
  },
  
  isAffectedBy: function (operation, morph) {
    return false;
  },
};

Global.newListPane = function(initialBounds) {
    return new ScrollPane(new CheapListMorph(initialBounds,["-----"]), initialBounds); 
};

Global.newTextListPane = function(initialBounds) {
    return new ScrollPane(new TextListMorph(initialBounds, ["-----"]), initialBounds); 
};

Global.newRealListPane = function(initialBounds, suppressSelectionOnUpdate) {
    return new ScrollPane(new ListMorph(initialBounds, ["-----"], null, null, suppressSelectionOnUpdate), initialBounds); 
};

Global.newDragnDropListPane = function(initialBounds, suppressSelectionOnUpdate) {
    return new ScrollPane(new FilterableListMorph(initialBounds, ["-----"], null, null, suppressSelectionOnUpdate), initialBounds); 
};

Global.newTextPane = function(initialBounds, defaultText) {
	var useChangeClue = true;
    return new ScrollPane(new TextMorph(initialBounds, defaultText, useChangeClue), initialBounds); 
};

Global.newPrintPane = function(initialBounds, defaultText) {
    return new ScrollPane(new PrintMorph(initialBounds, defaultText), initialBounds); 
};

Global.newXenoPane = function(initialBounds) {
    return new ScrollPane(new XenoMorph(initialBounds.withHeight(1000)), initialBounds);
}

// ===========================================================================
// Utility widgets
// ===========================================================================

/**
 * @class ColorPickerMorph
 */ 
BoxMorph.subclass("ColorPickerMorph", {


    style: { borderWidth: 1, fill: null, borderColor: Color.black},
    formals: ["+Color"],

    initialize: function($super, initialBounds, targetMorph, setFillName, popup) {
        $super(initialBounds);
        this.targetMorph = targetMorph;
        this.setFillFunctionName = setFillName; // name like "setBorderColor"
        if (targetMorph != null) this.connectModel({model: targetMorph, setColor: setFillName});
        this.colorWheelCache = null;
        this.isPopup = popup; 
        this.buildView();
        return this;
    },

    buildView: function() {
        // Slow -- should be cached as a bitmap and invalidated by layoutChanged
        // Try caching wheel as an interim measure
        var r = this.shape.bounds().insetBy(this.getBorderWidth());
        var rh2 = r.height/2;
        var dd = 2; // grain for less resolution in output (input is still full resolution)
	var content = this.addMorph(Morph.makeRectangle(this.shape.bounds()));
	content.ignoreEvents();
	content.setShape(new lively.scene.Group()); // Group isn't really a shape

        //DI: This could be done with width*2 gradients, instead of width*height simple fills
        //    For now it seems to perform OK at 2x granularity, and actual color choices 
        //    are still full resolution
        for (var x = 0; x < r.width; x += dd) {
            for (var y = 0; y < r.height; y += dd) { // lightest down to neutral
                var element = new lively.scene.Rectangle(new Rectangle(x + r.x, y + r.y, dd, dd));
		element.setFill(this.colorMap(x, y, rh2, this.colorWheel(r.width + 1)));
		element.setStrokeWidth(0);
                // element.setAttributeNS("fill", this.colorMap(x, rh2, rh2, this.colorWheel(r.width + 1)).toString());
		content.shape.add(element);
            }
        }
    },

    colorMap: function(x,y,rh2,wheel) {
        var columnHue = wheel[Math.round(x)];
        if (y <= rh2) return columnHue.mixedWith(Color.white, y/rh2); // lightest down to neutral
        else return Color.black.mixedWith(columnHue, (y - rh2)/rh2);  // neutral down to darkest
    },

    colorWheel: function(n) { 
        if (this.colorWheelCache && this.colorWheelCache.length == n) return this.colorWheelCache;
        console.log("computing wheel for " + n);
        return this.colorWheelCache = Color.wheelHsb(n,338,1,1);
    },

    handlesMouseDown: function(evt) { return !evt.isCommandKey() && evt.isLeftMouseButtonDown() },

    onMouseDown: function(evt) {
        return this.onMouseMove(evt);
    },

    onMouseUp: function(evt) {
        if (!this.isPopup) return;
        this.remove();
    },

    onMouseMove: function(evt) {
        if (evt.mouseButtonPressed) { 
            var r = this.bounds().insetBy(this.getBorderWidth());
            r = pt(0,0).extent(r.extent());
            var rh2 = r.height/2;
            var wheel = this.colorWheel(r.width+1);
            var relp = r.constrainPt(this.localize(evt.mousePoint).addXY(-2,-2));
            // console.log('mp = ' + Object.inspect(this.localize(evt.mousePoint)) + ' / relp = ' + Object.inspect(relp));
            var selectedColor = this.colorMap(relp.x,relp.y,rh2,wheel);
            this.setColor(selectedColor);
        } 
    }
    
});

BoxMorph.subclass('XenoMorph', {

    documentation: "Contains a foreign object, most likely XHTML",
    style: { borderWidth: 0, fill: Color.gray.lighter() },

    initialize: function($super, bounds) { 
        $super(bounds);
        this.foRawNode = NodeFactory.createNS(Namespace.SVG, "foreignObject", 
                             {x: bounds.x, y: bounds.y, 
                              width: bounds.width,
                              height: bounds.height });

        //this.foRawNode.appendChild(document.createTextNode("no content, load an URL"));
		//this.foRawNode.appendChild(NodeFactory.createNS(null, 'input', {type: 'text', name: '?', size: 20})); // commented out by Adam
        this.addNonMorph(this.foRawNode);
	      this.adjustForNewBounds(); // added by Adam
    },

    onURLUpdate: function(url) {
	if (!url) return;
	var xeno = this;
	function clearChildren(node) {
	    while(node.firstChild) node.removeChild(node.firstChild);
	}
	var callback = Object.extend(new NetRequestReporter(), {
	    setContent: function(doc) {
		clearChildren(xeno.foRawNode);
		xeno.foRawNode.appendChild(document.adoptNode(doc.documentElement));
	    },
	    setContentText: function(txt) {
		clearChildren(xeno.foRawNode);
		xeno.foRawNode.appendChild(document.createTextNode(txt));
	    }
	});
        var req = new NetRequest({model: callback, setResponseXML: "setContent", setResponseText: "setContentText"});
        req.setContentType("text/xml");
        req.get(url);
    },

    adjustForNewBounds: function($super) {
        $super();
        var bounds = this.shape.bounds();
		// console.log("bounds " + bounds + " vs " + bounds.width + "," + bounds.height);
		
		// following lines uncommented out or added by Adam
        this.foRawNode.setAttributeNS(null, "x", bounds.x);
        this.foRawNode.setAttributeNS(null, "y", bounds.y);
		this.foRawNode.x = bounds.x;
		this.foRawNode.y = bounds.y;
        this.foRawNode.setAttributeNS(null, "width", bounds.width);
        this.foRawNode.setAttributeNS(null, "height", bounds.height);
		this.foRawNode.width = bounds.width;
		this.foRawNode.height = bounds.height;
    }

});

XenoMorph.subclass('VideoMorph', {
	
	useExperimentalRotation: false,

	onDeserialize: function() {
		var foreign = $A(this.rawNode.childNodes).select(function(ea) {
			return ea.tagName == 'foreignObject' && ea !== this.foRawNode}, this);
		foreign.forEach(function(ea) { this.rawNode.removeChild(ea) }, this);
	},

	initialize: function($super, bounds) { 
	$super(bounds || new Rectangle(0,0,100,100));
	this.applyStyle({fillOpacity: 0.6, borderColor: Color.black, borderWidth: 1});
    },

openExample: function(worldOrNil) {
	var thisMorph = this;
	//require('lively.Helper').toRun(function() {  // for stringToXML
	thisMorph.embedVideo('<object width="425" height="344"><param name="movie" value="http://www.youtube.com/v/gGw09RZjQf8&hl=en&fs=1"></param><param name="allowFullScreen" value="true"></param><param name="allowscriptaccess" value="always"></param><embed src="http://www.youtube.com/v/gGw09RZjQf8&hl=en&fs=1" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" width="425" height="344"></embed></object>');
	//});
	this.translateBy(pt(85, 85));
	this.updateCSS();
	(worldOrNil || WorldMorph.current()).addMorph(this);
},


	interactivelyEmbedVideo: function() {
		var w = WorldMorph.current();
		w.prompt('Paste HTML or URL below.', this.embedVideoOrStream.bind(this));
	},
	
	embedVideoOrStream: function(input) {
		if (input.startsWith('http'))
			this.embedStream(input);
		else
			this.embedVideo(input);
	},
	
	embedVideo: function(stringifiedHTML) {
		if (!stringifiedHTML) return;
		console.log('Embedding video...');
		this.foRawNode.removeChild(this.foRawNode.firstChild);
		stringifiedHTML = stringifiedHTML.replace(/[\n\r]/, ' ');
		var url = this.extractURL(stringifiedHTML);
		var extent = this.extractExtent(stringifiedHTML);
		var node = this.objectNodeFromTemplate(url, extent);
		this.foRawNode.appendChild(node);
		this.setExtent(extent);
	},
	
	embedMov: function(name) {
      console.log('Embedding mov...');
      this.foRawNode.removeChild(this.foRawNode.firstChild);
      var extent = this.getExtent();
      var node = this.objectNodeForMovFromTemplate(name, extent);
      this.foRawNode.appendChild(node);
      this.setExtent(extent);
    },

	embedStream: function(name) {
      console.log('Embedding Stream...');
      this.foRawNode.removeChild(this.foRawNode.firstChild);
      var extent = this.getExtent();
      var node = this.objectNodeForStreamFromTemplate(name, extent);
      this.foRawNode.appendChild(node);
      this.setExtent(extent);
    },

	objectNodeForStreamFromTemplate: function(url, extent) {
		// get filename: rtsp://localhost:554/mystream.sdp --> mystream
		var movieName = /.*\/([a-zA-Z0-9]+)(\.sdp)?/.exec(url)[1];
		var name = movieName + '.mov';
		var string = Strings.format('<body xmlns="http://www.w3.org/1999/xhtml"><embed src="%s" qtsrc="%s" type="video/quicktime" width="%s" height="%s" autoplay="false" controller="true"/></body>', name, url, extent.x, extent.y);
		var node = document.adoptNode(stringToXML(string));
		return node;		
	},
			
	objectNodeForMovFromTemplate: function(name, extent) {
	var string = Strings.format('<body xmlns="http://www.w3.org/1999/xhtml"><embed src="%s" type="video/quicktime" width="%s" height="%s" autoplay="false" controller="true"/></body>', name, extent.x, extent.y);
	var node = document.adoptNode(stringToXML(string));
	return node;
      },
	
objectNodeFromTemplate: function(url, extent) {
	url = url.toString().replace(/&/g, "&amp;");
	var string = '<body xmlns="http://www.w3.org/1999/xhtml">' + 
		'<object type="application/x-shockwave-flash" data="' + url + '">' +
		/*'<object type="application/x-shockwave-flash" style="width:'
			+ extent.x + 'px; height:' + extent.y + 'px;" data="' + url + '">' +*/
		'<param name="movie" value="' + url + '" />' +
		'</object>' + '</body>';
	var node = document.adoptNode(stringToXML(string));
	return node;
},
objectNode: function() {
	return  this.foRawNode.firstChild.firstChild;
},

extractURL: function(htmlString) {
	var regex = /[a-zA-Z]+:\/\/(?:[a-zA-Z0-9\.=&\?\;\_]+\/?)+/;
	var result = htmlString.match(regex);
	return result && result[0];
},
extractExtent: function(htmlString) {
	var regex = /.*width[=:]"([0-9]+)".*height[=:]"([0-9]+)".*/;
	var result = htmlString.match(regex);
	var extent = result && pt(Number(result[1]), Number(result[2]));
	return extent;
},



	
	handlesMouseDown: Functions.True, // Flash takes care
	
	adjustForNewBounds: function ($super) {
        // Compute scales of old submorph extents in priorExtent, then scale up to new extent
        $super();
		this.updateCSS();
    },
onMouseMove: function($super, evt, hasFocus) {
	if (this.getVideoBounds().containsPoint(evt.point())) return;
	$super(evt, hasFocus);
	this.updateCSS();
},

updateCSS: function() {
	var videoBnds = this.getVideoBounds();	
	if (this.useExperimentalRotation) {
	this.objectNode().setAttributeNS(null, 'style',
		Strings.format("position:absolute; left:%spx; top:%spx; width: %spx; height: %spx; -webkit-transform-origin: %spx %spx; -webkit-transform: rotate(%sdeg)",
			videoBnds.x,
			videoBnds.y,
			videoBnds.width,
			videoBnds.height,
			videoBnds.x,
			videoBnds.y,
			this.getRotation()*180/Math.PI
	));
	} else {
	this.objectNode().setAttributeNS(null, 'style',
		Strings.format("position:absolute; left:%spx; top:%spx; width: %spx; height: %spx;",
			videoBnds.x,
			videoBnds.y,
			videoBnds.width,
			videoBnds.height
	));
	}
},

getVideoBounds: function() {
	var margin = 20;
	var gt = this.getGlobalTransform();
	return gt.transformRectToRect(this.innerBounds().insetBy(margin));
},

});

Object.extend(VideoMorph, {
	openAndInteractivelyEmbed: function(pos) {
		require('lively.Helper').toRun(function() { // for stringToXML
			var v = new VideoMorph();
			v.setPosition(pos);
			v.openInWorld();
			v.interactivelyEmbedVideo();
		});
	},
	openStream: function(url) {
		require('lively.Helper').toRun(function() { // for stringToXML
			var m = new VideoMorph(new Rectangle(0,0,360,300));
			m.openInWorld();
			m.embedStream(url);
		});
	}
});

// most likely deprecated, should use Widget, which is a view.
Model.subclass('WidgetModel', {

    viewTitle: "Widget",
    initialViewExtent: pt(400, 300),

    openTriggerVariable: 'all',
    documentation: "Convenience base class for widget models",
    
    getViewTitle: function() { // a string or a TextMorph
        return this.viewTitle;
    },

    buildView: function(extent) {
        throw new Error("override me");
    },

    getInitialViewExtent: function(world, hint) {
        return hint || this.initialViewExtent;
    },
    
    openIn: function(world, loc) {
        var win = 
	    world.addFramedMorph(this.buildView(this.getInitialViewExtent(world)), 
				 this.getViewTitle(), loc);
        if (this.openTriggerVariable) {
            this.changed(this.openTriggerVariable);
        }
        return win;
    },

    open: function() { // call interactively
        return this.openIn(WorldMorph.current());
    }

});

lively.data.Wrapper.subclass('Widget', ViewTrait, { // FIXME remove code duplication

    viewTitle: "Widget",
    initialViewExtent: pt(400, 300),
    initialViewPosition: pt(50, 50),
    documentation: "Nonvisual component of a widget",
    useLightFrame: false,
    
       noShallowCopyProperties: ['id', 'rawNode',  'formalModel', 'actualModel', '__annotation__'], // __annotation__ added by Adam


    getViewTitle: function() { // a string or a TextMorph
        return this.viewTitle;
    },

    buildView: function(extent, model) {
        throw new Error("override me");
    },

    getInitialViewExtent: function(world, hint) {
        return hint || this.initialViewExtent;
    },
    
    viewMenu: function(items) {
	// Default function passes through all view items if not overridden by a given application
        return items;
    },
    
    openIn: function(world, optLoc) {
	var view = this.buildView(this.getInitialViewExtent(world), this.getModel());
	view.ownerWidget = this; // for remembering the widget during serialization...
	return world.addFramedMorph(view, this.getViewTitle(), optLoc, this.useLightFrame);
    },
    
	ownModel: function(model) {
		this.actualModel = model;
		// get rid of old model rawNodes
		$A(this.rawNode.childNodes).each(function(ea){
			if(ea.tagName == "record") {
				this.rawNode.removeChild(ea);
			}
		}, this)
		if (model.rawNode instanceof Node) {
			this.rawNode.appendChild(model.rawNode);
		}
    },

    open: function() { // call interactively
        return this.openIn(WorldMorph.current());
    },

    initialize: function($super, plug) {
	$super();
	this.rawNode = NodeFactory.create("widget");
	this.setId(this.newId());
        if (plug) this.connectModel(plug);
    },

    parentWindow: function(view) {
	var parent = view.owner;
	while (parent && !(parent instanceof WindowMorph)) {
	    parent = parent.owner;
	}
	return parent;
    },
      
    restoreFromSubnodes: function(importer) {
        
        // Todo: move common parts to super class wrapper
        var children = [];
        var helperNodes = [];
        
        children = this.rawNode.childNodes;
        
        for (var i = 0; i < children.length; i++) {
            var node = children[i];
            switch (node.localName) {
                // nodes from the Lively namespace
                case "field": {
                    helperNodes.push(node);
                    this.deserializeFieldFromNode(importer, node);      
                    break;
                }
                case "widget": {
                    this.deserializeWidgetFromNode(importer, node);
                    break;
                }
                case "array": {
                    helperNodes.push(node);
                    this.deserializeArrayFromNode(importer, node);
                    break;
                }
                case "relay": {
                    this.deserializeRelayFromNode(importer, node);
                    break;
                }
                case "record": {
                    this.deserializeRecordFromNode(importer, node);
                    break;
                }
                default: {
                    if (node.nodeType === Node.TEXT_NODE) {
                        console.log('text tag name %s', node.tagName);
                        // whitespace, ignore
                    } else if (!this.restoreFromSubnode(importer, node)) {
                        console.warn('not handling %s, %s', node.tagName || node.nodeType, node.textContent);
                    }
                }
            }
        } // end for

        for (var i = 0; i < helperNodes.length; i++) {
            var n = helperNodes[i];
            n.parentNode.removeChild(n);
        }
    },

	copyFrom: function($super, copier, other) {
		$super(copier, other);
		LivelyNS.setType(this.rawNode, this.getType());
    	this.setId(this.newId());
		copier.addMapping(other.id(), this); 
		
		copier.smartCopyProperty("formalModel", this, other);
		copier.smartCopyProperty("actualModel", this, other);
		if (this.actualModel)
			this.ownModel(this.actualModel);
	
		copier.shallowCopyProperties(this, other);

		
		return this;
	}
});

Widget.subclass('Dialog', {
    inset: 10,
    style: { borderColor: Color.blue, borderWidth: 4, borderRadius: 16,
             fill: Color.blue.lighter(), opacity: 0.9},
    useLightFrame: true,
    viewTitle: "",
    removeTopLevel: function() {
        (this.parentWindow(this.panel) || this.panel).remove();
    },

    openIn: function($super, world, position) {
	var view = $super(world, position);
	if (position)  // slight usability improvement
	    view.align(view.bounds().center(), position);
	if (this.label) {
		var newWidth = Math.max(view.getExtent().x, this.label.getExtent().x + 20);
		view.setExtent(pt(newWidth, view.getExtent().y));
	}
	return view;

    },
    
});

Dialog.subclass('ConfirmDialog', {

	formals: [	"+Result",  // yes or no, listen for updates
				"-Message"], // what to display
	initialViewExtent: pt(300, 90),
    
	openIn: function($super, world, position) {
		var view = $super(world, position);
		world.firstHand().setKeyboardFocus(view.targetMorph.submorphs[1]);
		return view;

	},

	cancelled: function(value, source) {
		this.removeTopLevel();
		if (value == false) this.setResult(false);
	},

	confirmed: function(value, source) {
		this.removeTopLevel();
		if (value == true) this.setResult(true);
	},

	buildView: function(extent, model) {
		var panel = new PanelMorph(extent);
		this.panel = panel;
		panel.linkToStyles(["panel"]);

		var r = new Rectangle(this.inset, this.inset, extent.x - 2*this.inset, 30);
		this.label = panel.addMorph(new TextMorph(r, this.getMessage()).beLabel());

		var indent = extent.x - 2*70 - 3*this.inset;

		r = new Rectangle(r.x + indent, r.maxY() + this.inset, 70, 30);
		var yesButton = panel.addMorph(new ButtonMorph(r)).setLabel("Yes");
		yesButton.connectModel({model: this, setValue: "confirmed"});

		r = new Rectangle(r.maxX() + this.inset, r.y, 70, 30);
		var noButton = panel.addMorph(new ButtonMorph(r)).setLabel("No");
		noButton.connectModel({model: this, setValue: "cancelled"});
		return panel;
	}
});

Dialog.subclass('PromptDialog', {

    formals: ["-Message", "Input", "+Result"],
    initialViewExtent: pt(300, 130),

    openIn: function($super, world, loc) {
        var view = $super(world, loc);
        view.targetMorph.inputLine.requestKeyboardFocus(world.firstHand());
        return view;
    },

    onInputUpdate: function(input) { this.confirmed(true) },

    cancelled: function(value) {
        if (value == false) return;
        this.removeTopLevel();
		this.setResult(false);
    },
    
    confirmed: function(value) {
        if (value == false) return;
		if (this.getInput() != this.panel.inputLine.textString)
			this.panel.inputLine.doSave();
        this.removeTopLevel();
		this.setResult(true);
    },

	buildView: function(extent, model) {
		var panel = new PanelMorph(extent);
		this.panel = panel;
		panel.linkToStyles(["panel"]);


		var r = new Rectangle(this.inset, this.inset, extent.x - 2*this.inset, 30);
		this.label = panel.addMorph(new TextMorph(r, this.getMessage()).beLabel());

		r = new Rectangle(r.x, r.maxY() + this.inset, r.width, r.height);

		panel.inputLine = panel.addMorph(new TextMorph(r, "").beInputLine());

		panel.inputLine.connectModel({model: this, getText: "getInput", setText: "setInput"});
		// FIXME is this necessary
		if (this.getInput()) panel.inputLine.updateTextString(this.getInput());

		var indent = extent.x - 2*70 - 3*this.inset;
		r = new Rectangle(r.x + indent, r.maxY() + this.inset, 70, 30);
		var okButton = panel.addMorph(new ButtonMorph(r)).setLabel("OK");

		okButton.connectModel({model: this, setValue: "confirmed"});
		r = new Rectangle(r.maxX() + this.inset, r.y, 70, 30);
		var cancelButton = panel.addMorph(new ButtonMorph(r)).setLabel("Cancel");
		cancelButton.connectModel({model: this, setValue: "cancelled"});
		return panel;
	},

});

PromptDialog.test = function() {
    return WorldMorph.current().prompt("what", function(value) { alert('got input ' + value) });
}

Widget.subclass('ConsoleWidget', {

	viewTitle: "Console",
	formals: ["LogMessages", "RecentLogMessages", "Commands", "CommandCursor", "LastCommand", "Menu", "Capacity"],
	ctx: {},
	
	initialize: function($super, capacity) {
		$super(null);

		
		// BEWARE don't use newNodeInstance, because it causes problems with serializing Menu
		// but I do it anyway.... lets fix this!
		var model = Record.newNodeInstance({LogMessages: [], RecentLogMessages: [], Commands: [], 
			CommandCursor: 0,  LastCommand: "", Capacity: capacity,
			Menu: [
				["command history", this, "addCommandHistoryInspector"],
				["clear", this, "clearList"]
			]});
		
		this.relayToModel(model, {LogMessages: "LogMessages",
				  RecentLogMessages: "+RecentLogMessages",
				  Commands: "Commands",
				  LastCommand: "LastCommand",
				  Menu: "Menu",
				  Capacity: "-Capacity"});
		
		this.ownModel(model);


		Global.console.consumers.push(this); 
		this.ans = undefined; // last computed value
		return this;
	},

	onDeserialize: function() {
		this.clearList();
		Global.console.consumers.push(this);
	},

	clearList: function() {
		this.setLogMessages([]);
		// hack to find the real solution...
		if (this.panel) {
			this.panel.messagePane.adjustForNewBounds();
		}
	},

	addCommandHistoryInspector: function() {
		WorldMorph.current().addTextListWindow({
			extent:pt(500, 40),
			content: this.getCommands([]),
			title: "Command history"
		});
	},

	getInitialViewExtent: function(world, hint) {
		return hint || pt(world.viewport().width - 200, 160); 
	},
	
	buildView: function(extent) {
		var panel = PanelMorph.makePanedPanel(extent, [
			['messagePane', newTextListPane, new Rectangle(0, 0, 1, 0.8)],
			['commandLine', TextMorph, new Rectangle(0, 0.8, 1, 0.2)]
		]);
		panel.ownerWidget = this; // to serialize the widget
		this.panel = panel;

		panel.commandLine.suppressHandles = true;

		var model = this.getModel();
		var m = panel.messagePane;
	
		m.relayToModel(model, {List: "-LogMessages", ListDelta: "RecentLogMessages", 
				   Capacity: "-Capacity", Menu: "-Menu"});
	
		m.innerMorph().focusHaloBorderWidth = 0;
	
		var self = this;
		panel.shutdown = function() {
			Class.getPrototype(this).shutdown.call(this);
			var index = window.console.consumers.indexOf(self);
			if (index >= 0) {
				window.console.consumers.splice(index);
			}
		};

		m = panel.commandLine.beInputLine(100);
		m.relayToModel(model, { History: "-Commands", HistoryCursor: "CommandCursor", Text: "LastCommand"});
		return panel;
	},

	evaluate: function(string){
		var result = this.panel.commandLine.tryBoundEval(string)
		return result
	},
	
	onLogMessagesUpdate: function() {
		// do nothing... onDeserialize seem to need it
	},

	onLastCommandUpdate: function(text) {
		if (!text) return;
		try {
			var ans = this.evaluate(text);
			if (ans !== undefined) this.ans = ans;
		var command = Object.inspect(ans);
		this.setRecentLogMessages([command]);
		} catch (er) {
		dbgOn(true);
			alert("Whoa Evaluation error: "	 + er);
		}
	},
	
	log: function(message) {
		this.setRecentLogMessages([message]);
	}
	
});


Widget.subclass('XenoBrowserWidget', {
    
    initialViewExtent: pt(800, 300),

    initialize: function($super, filename) {
	var url = filename ? URL.source.withFilename(filename) : null;
	this.actualModel = Record.newPlainInstance({URL: url});
	$super();
    },
    
    buildView: function(extent) {
	var panel = PanelMorph.makePanedPanel(extent, [
	    ['urlInput', TextMorph, new Rectangle(0, 0, 1, 0.1)],
	    ['contentPane', newXenoPane, new Rectangle(0, 0.1, 1, 0.9)]
	]);
	var model = this.actualModel;
	
	panel.urlInput.beInputLine();
	panel.urlInput.connectModel(model.newRelay({Text: { name: "URL", to: URL.create, from: String }}), true);
	panel.contentPane.connectModel(model.newRelay({URL: "-URL"}), true);
	
	return panel;
    }
});
    

// ===========================================================================
// Window widgets
// ===========================================================================


BoxMorph.subclass("TitleBarMorph", {

    documentation: "Title bar for WindowMorphs",

    controlSpacing: 3,
    barHeight: 22,
    shortBarHeight: 15,
    style: {borderWidth: 0, fill: null},
    labelStyle: { borderRadius: 8, padding: Rectangle.inset(6, 2), 
		  fill: lively.paint.LinearGradient([new lively.paint.Stop(0, Color.white),
						     new lively.paint.Stop(1, Color.gray)])
		},
    
    initialize: function($super, headline, windowWidth, windowMorph, optSuppressControls) {
	if (optSuppressControls)  {  // for dialog boxes
	  this.suppressControls = true;
	  this.barHeight = this.shortBarHeight;
  }
	var bounds = new Rectangle(0, 0, windowWidth, this.barHeight);
	
        $super(bounds);
	
	// contentMorph is bigger than the titleBar, so that the lower rounded part of it can be clipped off
	// arbitrary paths could be used, but FF doesn't implement the geometry methods :(
	// bounds will be adjusted in adjustForNewBounds()
	var contentMorph = Morph.makeRectangle(bounds);
	this.addMorph(new ClipMorph(bounds)).addMorph(contentMorph);
	contentMorph.linkToStyles(["titleBar"]);
	this.ignoreEvents();
	contentMorph.ignoreEvents();
	contentMorph.owner.ignoreEvents();
	this.contentMorph = contentMorph;
	
        this.windowMorph = windowMorph;

	    
        // Note: Layout of submorphs happens in adjustForNewBounds (q.v.)
        var label;
        if (headline instanceof TextMorph) {
	    label = headline;
        } else if (headline != null) { // String
	    // wild guess headlineString.length * 2 *  font.getCharWidth(' ') + 2;
	    var width = headline.length * 8; 
	    label = new TextMorph(new Rectangle(0, 0, width, this.barHeight), headline).beLabel();
        }
        label.applyStyle(this.labelStyle);
        this.label = this.addMorph(label);
	if (!this.suppressControls) {
            var cell = new Rectangle(0, 0, this.barHeight, this.barHeight);
            this.closeButton =  this.addMorph(new WindowControlMorph(cell, this.controlSpacing, Color.primary.orange));
	    this.menuButton = this.addMorph(new WindowControlMorph(cell, this.controlSpacing, Color.primary.blue));
            this.collapseButton = this.addMorph(new WindowControlMorph(cell, this.controlSpacing, Color.primary.yellow));
	    this.connectButtons(windowMorph);
	} 
        this.adjustForNewBounds();  // This will align the buttons and label properly
        return this;
    },
    
    connectButtons: function(w) {
      if (this.suppressControls) return;
	this.closeButton.relayToModel(w, {HelpText: "-CloseHelp", Trigger: "=initiateShutdown"});
	this.menuButton.relayToModel(w, {HelpText: "-MenuHelp", Trigger: "=showTargetMorphMenu"});
	this.collapseButton.relayToModel(w, {HelpText: "-CollapseHelp", Trigger: "=toggleCollapse"});
    },

    
    onDeserialize: function() {
        this.connectButtons(this.windowMorph);
    },

    acceptsDropping: function(morph) {
        //console.log('accept drop from %s of %s, %s', this, morph, morph instanceof WindowControlMorph);
        return morph instanceof WindowControlMorph; // not used yet... how about text...
    },

    highlight: function(trueForLight) {
	var gfx = lively.paint;
	this.label.setFill(trueForLight ? new gfx.LinearGradient([new gfx.Stop(0, Color.white), 
								  new gfx.Stop(1, Color.lightGray)]) : null);
    },

    okToBeGrabbedBy: function(evt) {
        var oldTop = this.world().topSubmorph();
	if (oldTop instanceof WindowMorph) oldTop.titleBar.highlight(false);
        return this.windowMorph;
    },

    adjustForNewBounds: function($super) {
	var innerBounds = this.innerBounds();
	var sp = this.controlSpacing;
        $super();
        var loc = this.innerBounds().topLeft().addXY(sp, sp);
        var l0 = loc;
        var dx = pt(this.barHeight - sp, 0);
        if (this.menuButton) { 
	    this.menuButton.setPosition(loc);  
	    loc = loc.addPt(dx); 
	}
        if (this.label) {
            this.label.align(this.label.bounds().topCenter(), this.innerBounds().topCenter());
            if (this.label.bounds().topLeft().x < loc.x) {
                this.label.align(this.label.bounds().topLeft(), loc.addXY(0,-3));
            }
        }
	if (this.closeButton) { 
	    loc = this.innerBounds().topRight().addXY(-sp - this.closeButton.shape.bounds().width, sp);
	    this.closeButton.setPosition(loc);  
	    loc = loc.subPt(dx); 
	}
        if (this.collapseButton) { 
	    this.collapseButton.setPosition(loc);  
	    //loc = loc.subPt(dx); 
	}
	
	
	var style = this.styleNamed("titleBar");
	var w = style.borderWidth;
	var r = style.borderRadius;
	this.contentMorph.setBounds(new Rectangle(w/2, w/2, innerBounds.width, this.barHeight + r));
	var clip = this.contentMorph.owner;
	clip.setBounds(innerBounds.insetByRect(Rectangle.inset(-w/2, -w/2, -w/2, 0)));
    },
	
	setTitle: function(string) {
		this.label.setTextString(string);
		this.adjustForNewBounds();  // This will align the buttons and label properly
	},

    okToDuplicate: Functions.False

});

BoxMorph.subclass("TitleTabMorph", {

    documentation: "Title bar for tabbed window morphs",

    barHeight: 0,
    controlSpacing: 0,
    suppressHandles: true,
    
    styleClass: ['titleBar'],
    
    initialize: function($super, headline, windowWidth, windowMorph) {
        $super(Rectangle(0, 0, windowWidth, this.barHeight));
        this.windowMorph = windowMorph;
        this.applyLinkedStyles();
        this.ignoreEvents();

        var label;
        if (headline instanceof TextMorph) {
            label = headline;
        } else { // String
            var width = headline.length * 8;
            // wild guess headlineString.length * 2 *  font.getCharWidth(' ') + 2; 
            label = new TextMorph(new Rectangle(0, 0, width, this.barHeight), headline).beLabel();
        }
        var topY = this.shape.bounds().y;
        label.align(label.bounds().topLeft(), pt(0,0));
        this.label = this.addMorph(label);
        this.shape.setBounds(this.shape.bounds().withTopRight(pt(label.bounds().maxX(), topY)));
        return this;
    },

    okToBeGrabbedBy: function(evt) {
        return this;
    },

    handlesMouseDown: Functions.True,

    onMouseDown: Functions.Empty,

    onMouseUp: function(evt) {
        this.windowMorph.toggleCollapse();
    },

    highlight: TitleBarMorph.prototype.highlight

});

Morph.subclass("WindowControlMorph", {

    documentation: "Event handling for Window morphs",

    style: {borderWidth: 0},
    
    focus: pt(0.4, 0.2),
    formals: ["-HelpText", "-Trigger"],
    
    initialize: function($super, rect, inset, color) {
        $super(new lively.scene.Ellipse(rect.insetBy(inset)));
	var gfx = lively.paint;
        this.setFill(new gfx.RadialGradient([new gfx.Stop(0, color.lighter(2)),
					     new gfx.Stop(0.5, color),
					     new gfx.Stop(1, color.darker())], this.focus));
        return this;
    },

    handlesMouseDown: Functions.True,

    onMouseDown: function($super, evt) {
        $super(evt);
	// interesting case for the MVC architecture
        return this.formalModel.onTriggerUpdate(evt);
    },

    onMouseOver: function($super, evt) {
        var prevColor = this.getFill().stops[1].color();
	var gfx = lively.paint;
        this.setFill(new gfx.RadialGradient([new gfx.Stop(0, Color.white), 
					     new gfx.Stop(0.5, prevColor),
					     new gfx.Stop(1, prevColor.darker())], this.focus));
        $super(evt);
    },
    
    onMouseOut: function($super, evt) {
        var prevColor = this.getFill().stops[1].color();
	var gfx = lively.paint;
        this.setFill(new gfx.RadialGradient([new gfx.Stop(0, prevColor.lighter(2)),
					     new gfx.Stop(0.5, prevColor),
					     new gfx.Stop(1, prevColor.darker())], this.focus));
        $super(evt);
    },
    
    checkForControlPointNear: Functions.False,
    
    okToBeGrabbedBy: Functions.Null

 
});

BoxMorph.subclass('StatusBarMorph', {

    style: { borderWidth: 0, fill: null},

    initialize: function($super, titleBar) {
	var bounds = titleBar.getExtent().extentAsRectangle().withHeight(8);
        $super(bounds);
	
	// contentMorph is bigger than the titleBar, so that the lower rounded part of it can be clipped off
	// arbitrary paths could be used, but FF doesn't implement the geometry methods :(
	// bounds will be adjusted in adjustForNewBounds()
	var contentMorph = Morph.makeRectangle(bounds.withHeight(bounds.height*2).withY(-bounds.height));
	this.addMorph(new ClipMorph(bounds.withHeight(bounds.height + 2).withWidth(bounds.width + 2))).addMorph(contentMorph);
	contentMorph.linkToStyles(["titleBar"]);
	
	this.ignoreEvents();
	contentMorph.ignoreEvents();
	contentMorph.owner.ignoreEvents();
	this.contentMorph = contentMorph;
        return this;
    },
    adjustForNewBounds: function ($super) {
        $super();
	var cm = this.contentMorph;
	if (cm) cm.setExtent(pt(this.bounds().width, cm.bounds().height))
    }
});


Morph.subclass('WindowMorph', {

    documentation: "Full-fledged windows with title bar, menus, etc.",
    state: 'expanded',
    titleBar: null,
    statusBar: null,
    targetMorph: null,
    style: {borderWidth: 0, fill: null, borderRadius: 0},
    
    initialize: function($super, targetMorph, headline, optSuppressControls) {
        var bounds = targetMorph.bounds();
        $super(new lively.scene.Rectangle(bounds));
        var titleBar = this.makeTitleBar(headline, bounds.width, optSuppressControls);
        var titleHeight = titleBar.bounds().height;
	this.setBounds(bounds.withHeight(bounds.height + titleHeight));
        this.targetMorph = this.addMorph(targetMorph);
        this.titleBar = this.addMorph(titleBar);
        this.contentOffset = pt(0, titleHeight - titleBar.getBorderWidth()/2); // FIXME: hack
        targetMorph.setPosition(this.contentOffset);
        this.closeAllToDnD();
	this.collapsedTransform = null;
	this.collapsedExtent = null;
        this.expandedTransform = null;
	this.expandedExtent = null;
	this.ignoreEventsOnExpand = false;
	if (Config.useStatusBar) this.statusBar = this.addMorph(new StatusBarMorph(this.titleBar));
        // this.adjustForNewBounds();
        return this;
    },

    shadowCopy: function(hand) {
	// For now just make a rectangle, later add top rounding
	var copy = Morph.makeRectangle(this.getPosition().extent(this.getExtent()));
	copy.applyStyle({fill: Color.black, fillOpacity: 0.3, strokeOpacity: 0.3, borderRadius: 8});
	copy.pvtSetTransform(this.getTransform());
	return copy;
    },

    toString: function($super) {
        var label = this.titleBar && this.titleBar.label;
        return $super() + (label ? ": " + label.textString : ""); 
    },

    restorePersistentState: function($super, importer) {
        $super(importer);
	// remove the following:
        //this.contentOffset = pt(0, this.titleBar.bounds().height);
    },
    
    makeTitleBar: function(headline, width, optSuppressControls) {
        // Overridden in TabbedPanelMorph
        return new TitleBarMorph(headline, width, this, optSuppressControls);
    },

    windowContent: function() { return this.targetMorph; },
    
    immediateContainer: function() { return this;  },

    toggleCollapse: function() {
        return this.isCollapsed() ? this.expand() : this.collapse();
    },
    
    collapse: function() { 
        if (this.isCollapsed()) return;
        this.expandedTransform = this.getTransform();
	this.expandedExtent = this.getExtent();
	this.expandedPosition = this.position();
	this.ignoreEventsOnExpand = this.targetMorph.areEventsIgnored();
	this.targetMorph.ignoreEvents(); // unconditionally
	this.targetMorph.setVisible(false);
	var finCollapse = function () {
		this.setTransform(this.collapsedTransform  || this.expandedTransform);
        	this.state = 'collapsed';  // Set it now so setExtent works right
        	if (this.collapsedExtent) this.setExtent(this.collapsedExtent);
		this.shape.setBounds(this.titleBar.bounds());
		this.layoutChanged();
        	this.titleBar.highlight(false);
	}.bind(this);
	if(this.collapsedPosition && this.collapsedPosition.dist(this.position()) > 100)
			this.animatedInterpolateTo(this.collapsedPosition, 5, 50, finCollapse);
		else finCollapse();
    },
    
    expand: function() {
        if (!this.isCollapsed()) return;
        this.collapsedTransform = this.getTransform();
        this.collapsedExtent = this.innerBounds().extent();
	this.collapsedPosition = this.position();
        var finExpand = function () {	
		this.setTransform(this.expandedTransform); 
		this.targetMorph.setVisible(true);
		// enable events if they weren't disabled in expanded form
		if (!this.ignoreEventsOnExpand) this.targetMorph.enableEvents();
        	this.state = 'expanded';  // Set it now so setExtent works right
		if (this.expandedExtent) {
			this.setExtent(this.expandedExtent);
			this.shape.setBounds(this.expandedExtent.extentAsRectangle());
		}
		this.world().addMorphFront(this);  // Bring this window forward if it wasn't already
		this.layoutChanged();
        	this.takeHighlight();
	}.bind(this);
	if(this.expandedPosition && this.expandedPosition.dist(this.position()) > 100)
			this.animatedInterpolateTo(this.expandedPosition, 5, 50, finExpand);
		else finExpand();
    },

    isCollapsed: function() { return this.state === 'collapsed'; },

    getCloseHelp: function() { return "Close"; },

    getMenuHelp: function() { return "Menu"; },
    
    getCollapseHelp: function() { return this.isCollapsed() ? "Expand" : "Collapse"; },

    contentIsVisible: function() { return !this.isCollapsed(); },

    // Following methods promote windows on first click----------------
    morphToGrabOrReceive: function($super, evt, droppingMorph, checkForDnD) {
        // If this window is doesn't need to come forward, then respond normally
        if (!this.needsToComeForward(evt) || droppingMorph != null) {
            return $super(evt, droppingMorph, checkForDnD)
        }
        // Otherwise, hold mouse focus until mouseUp brings it to the top
        return this;
    },

    needsToComeForward: function(evt) {
        if (this.owner !== this.world()) return true; // weird case -- not directly in world
        if (!this.fullContainsWorldPoint(evt.point())) return false;  // not clicked in me
        if (this === this.world().topSubmorph()) return false;  // already on top
        if (this.isCollapsed()) return false;  // collapsed labels OK from below
        if (this.titleBar.fullContainsWorldPoint(evt.point())) return false;  // labels OK from below
        return true;  // it's in my content area
    },

    // Next four methods hold onto control until mouseUp brings the window forward.
    handlesMouseDown: function(evt) { return this.needsToComeForward(evt); },

    onMouseDown: Functions.Empty,

    onMouseMove: function($super, evt) {
        if (!evt.mouseButtonPressed) $super(evt);
    },    

    onMouseUp: function(evt) {
        // I've been clicked on when not on top.  Bring me to the top now
        this.takeHighlight()
        var oldTop = this.world().topSubmorph();
        this.world().addMorphFront(this);
        evt.hand.setMouseFocus(null);
	if(this.targetMorph.takesKeyboardFocus()) evt.hand.setKeyboardFocus(this.targetMorph);
        return true;
    },

    captureMouseEvent: function($super, evt, hasFocus) {
        if (!this.needsToComeForward(evt) && evt.mouseButtonPressed) {
            return $super(evt, hasFocus);
        }
        return this.mouseHandler.handleMouseEvent(evt, this); 
    },

    okToBeGrabbedBy: function(evt) {
        this.takeHighlight();
        return this; 
    },

    takeHighlight: function() {
        // I've been clicked on.  unhighlight old top, and highlight me
        var oldTop = this.world().topWindow();
	if (!oldTop.titleBar) return; // may be too early when in deserialization
        if (oldTop instanceof WindowMorph) oldTop.titleBar.highlight(false);
        this.titleBar.highlight(true);
    },
    // End of window promotion methods----------------

    isShutdown: function() { return this.state === 'shutdown'; },
    
    initiateShutdown: function() {
        if (this.isShutdown()) return;
        this.targetMorph.shutdown(); // shutdown may be prevented ...
        this.ensureIsNotInWorld(); // used to say this.remove(), changed by Adam so that it does the cool whooshing-off-the-screen thing
        this.state = 'shutdown'; // no one will ever know...
        return true;
    },
    
    showTargetMorphMenu: function(evt) { 
        var tm = this.targetMorph.morphMenu(evt);
        tm.replaceItemNamed("remove", ["remove", this, 'initiateShutdown']);
        tm.replaceItemNamed("reset rotation", ["reset rotation", this, 'setRotation', 0]);
        tm.replaceItemNamed("reset scaling", ["reset scaling", this, 'setScale', 1]);
        tm.removeItemNamed("duplicate");
        tm.removeItemNamed("turn fisheye on");
        tm.openIn(this.world(), evt.mousePoint, false, this.targetMorph.inspect().truncate()); 
    },

    reshape: function($super, partName, newPoint, lastCall) {
	// Minimum size for reshap should probably be a protoype var
	var r = this.innerBounds().withPartNamed(partName, newPoint);
	var maxPoint = r.withExtent(r.extent().maxPt(pt(100,120))).partNamed(partName);
	return $super(partName, maxPoint, lastCall);
    },

    adjustForNewBounds: function ($super) {
        $super();
        if (!this.titleBar || !this.targetMorph) return;
        var titleHeight = this.titleBar.innerBounds().height;
        var bnds = this.innerBounds();
        var newWidth = bnds.width;
        var newHeight = bnds.height;
        this.titleBar.setExtent(pt(newWidth, titleHeight));
        this.titleBar.setPosition(bnds.topLeft());
	if (this.statusBar) {  // DI: this doesn't track reframing...
	    this.statusBar.setPosition(pt(0, this.isCollapsed() ? titleHeight : bnds.height));
	    this.statusBar.setExtent(pt(newWidth, this.statusBar.innerBounds().height));
	}
        if (this.isCollapsed()) return;
        this.targetMorph.setExtent(pt(newWidth, newHeight - titleHeight));
        this.targetMorph.setPosition(bnds.topLeft().addXY(0, titleHeight));
    },

	setTitle: function(string) {
		this.titleBar.setTitle(string);
	}

});
   
// every morph should be able to get his window
// e.g. helper texts are created in the window, not in the world
Morph.addMethods({
    // KP: shouldn't this be replaced by Morph.immediateContainer?
    window: function(morph) {
        if(!this.owner) return this;
        return this.owner.window();
    },
});
   
   
WindowMorph.subclass("TabbedPanelMorph", {

    documentation: "Alternative to windows for off-screen content",

    initialize: function($super, targetMorph, headline, location, sideName) {
        // A TabbedPanelMorph is pretty much like a WindowMorph, in that it is intended to 
        // be a container for applications that may frequently want to be put out of the way.
        // With windows, you collapse them to their title bars, with tabbed panels, you
        // click their tab and they retreat to the edge of the screen like a file folder.
        this.sideName = sideName ? sideName : "south";
        $super(targetMorph, headline, location);
        this.applyStyle({fill: null, borderColor: null});
        this.newToTheWorld = true;
        this.setPositions();
        this.moveBy(this.expandedPosition.subPt(this.position()));
        return this;
    },

    setPositions: function() {
        // Compute the nearest collapsed and expanded positions for side tabs
        var wBounds = WorldMorph.current().shape.bounds();
        if (this.sideName == "south") {
            var edgePt = this.position().nearestPointOnLineBetween(wBounds.bottomLeft(), wBounds.bottomRight());
            this.collapsedPosition = edgePt.subPt(this.contentOffset);  // tabPosition
            this.expandedPosition = edgePt.addXY(0,-this.shape.bounds().height);
        }
    },

    makeTitleBar: function(headline, width) {
        return new TitleTabMorph(headline, width, this);
    }

});


Morph.subclass("PieMenuMorph", {

	documentation: "Fabrik-style gesture menus for fast one-button UI",

	initialize: function($super, items, targetMorph, offset, clickFn) {
		// items is an array of menuItems, each of which is an array of the form
		// [itemName, closure], and
		// itemName has the form 'menu text (pie text)'
		// If offset is zero, the first item extends CW from 12 o'clock
		// If offset is, eg, 0.5, then the first item begins 1/2 a slice-size CCW from there.
		this.items = items;
		// clickFn, if supplied, will be called instead of bringing up a textMenu in the case
		//	of a quick click -- less than 300ms; ie before the help disk has been drawn
		this.targetMorph = targetMorph;
		this.r1 = 15;  // inner radius
		this.r2 = 50;  // outer radius
		this.offset = offset || 0; // default to 0 -- Adam
		this.clickFn = clickFn;
		$super(new lively.scene.Ellipse(pt(100 + this.r2, 100 + this.r2), this.r2));
		this.setBorderColor(Color.black);  this.setBorderWidth(1);
		this.hasCommitted = false;  // Gesture not yet outside commitment radius
		return this;
	},
	helpString: function() {
		var help = "Pie menus let you choose mouse-down actions";
		help += "\nbased on the direction of your stroke.";
		help += "\nIf you hold the button down without moving,";
		help += "\nyou will see a map of the directions and actions.";
		help += "\nThis menu has the same items with words to";
		help += "\nexplain the abbreviated captions in the map.";
		help += "\nYou can disable pie menus in world-menu/preferences.";
		return help;
	},
	open: function(evt) {
		// Note current mouse position and start a timer
		this.mouseDownPoint = evt.mousePoint;
		this.originalEvent = evt;
		this.setPosition(this.mouseDownPoint.subPt(this.bounds().extent().scaleBy(0.5)));
		var opacity = 0.1;  this.setFillOpacity(opacity);  this.setStrokeOpacity(opacity);
		WorldMorph.current().addMorph(this);
		evt.hand.setMouseFocus(this);
		this.world().scheduleForLater(new SchedulableAction(this, "makeVisible", evt, 0), 300, false);
	},
	onMouseMove: function(evt) {
		// Test for whether we have reached the commitment radius.
		var delta = evt.mousePoint.subPt(this.mouseDownPoint)
		if (delta.dist(pt(0, 0)) < this.r1) return
		// If so dispatch to appropriate action
		this.hasCommitted = true;
		this.remove();
		evt.hand.setMouseFocus(null);
		var n = this.items.length;
		var index = this.itemIndexForAngle(delta.theta()); // refactored to use itemIndexForAngle -- Adam
		index = (index+n).toFixed(0)%n;  // 0..n-1
		var item = this.items[index];
		if (item[1] instanceof Function) item[1](this.originalEvent)
			//	else what?
	},
	onMouseUp: function(evt) {
		// This should only happen inside the commitment radius.
		if (this.hasCommitted) return;  // shouldn't happen
		var world = this.world();
		this.remove();

		// if this was a quick click, call clickFn if supplied and return
		if (!this.hasSubmorphs() && this.clickFn) {
			console.log('Calling PieMenu clickFn');
			return this.clickFn(evt);
		}

		// Display a normal menu with this.items and a help item at the top.
		var normalMenu = new MenuMorph([
			["pie menu help", function(helpEvt) {
				var helpMenu = new MenuMorph(this.items, this.targetMorph);
				helpMenu.openIn(world, evt.mousePoint, false, this.helpString());
			}.bind(this)]], this.targetMorph);
		normalMenu.addLine();
		this.targetMorph.morphMenu(evt).getRawItems().forEach( function (item) { normalMenu.addRawItem(item); });
		normalMenu.openIn(world, evt.mousePoint, false, Object.inspect(this.targetMorph).truncate());
		evt.hand.setMouseFocus(normalMenu);
	},
	
	// refactored by Adam because there was a bug in it and it was easier to see this way
	itemIndexForAngle: function(theta) { return ((theta/(Math.PI*2) + (1/4)) * this.items.length) + this.offset; },
	angleForItemIndex: function(index) { return (( (index-this.offset) / this.items.length) - (1/4)) * Math.PI*2; },
	
	makeVisible: function(openEvent) {
		if (this.hasCommitted) return;
		var opacity = 0.5;
		this.setFillOpacity(opacity);
		this.setStrokeOpacity(opacity);
		// Make an inner circle with 'menu'
		var nItems = this.items.length;
		if(nItems == 0) return;
		for (var i=0; i<nItems; i++) {
			var theta = this.angleForItemIndex(i); // refactored to use angleForItemIndex -- Adam
			var line = Morph.makeLine([Point.polar(this.r1, theta), Point.polar(this.r2, theta)], 1, Color.black);
			line.setStrokeOpacity(opacity);
			this.addMorph(line);
			var labelString = this.items[i][0];
			var x = labelString.indexOf('(');
			
			// aaa - Huh??? Why was this thing requiring the parens? -- Adam
			//if (x < 0) continue
			//labelString = labelString.slice(x+1, labelString.length-1);  // drop parens
			if (x >= 0) { labelString = labelString.slice(x+1, labelString.length-1); }  // just use the thing in the parens if it's there
			
			var labelPt = Point.polar(this.r2*0.7, theta+(0.5/nItems*Math.PI*2))
			this.addMorph(TextMorph.makeLabel(labelString).centerAt(labelPt));
		}
		this.addMorph(TextMorph.makeLabel("menu").centerAt(pt(0, 0)));
	},
	addHandleTo: function(morph, evt, mode) {
		var handle = new HandleMorph(evt.point(), lively.scene.Rectangle, evt.hand, morph, null);
		handle.mode = mode;
		handle.rollover = false;
		morph.addMorph(handle);
		evt.hand.setMouseFocus(handle);
	},
});
Object.extend(PieMenuMorph, {
    setUndo: function(undoFunction) {
    	PieMenuMorph.undoer = undoFunction;
    },
    doUndo: function() {
    	if(PieMenuMorph.undoer) PieMenuMorph.undoer();
	PieMenuMorph.undoer = null;
    }
});

(function setUpNodeStyle() {
    var mainFill = Color.white;
    var mainBorderColor = Color.gray.darker();
    var mainConnectorColor = mainBorderColor;
    Global.NodeStyle = {
        connector: {fill: mainConnectorColor, borderWidth: 1, borderColor: mainConnectorColor},
        node: {fontSize: 9, fill: mainFill, borderRadius: 10, borderWidth: 1, borderColor: mainBorderColor}
    }
})()

Morph.subclass('ArrowHeadMorph', {
     
    initialize: function($super, lineWidth, lineColor, fill, length, width) {
        $super(new lively.scene.Group());
        
        /* FIXME
         * Morph abuse!
		 * rk: Morph rape!! ;-)
         */
        this.setFillOpacity(0);
        this.setStrokeOpacity(0);

        lineWidth = lineWidth || 1;
        lineColor = lineColor || Color.black;
        fill = fill || Color.black;
        length = length || 16;
        width = width || 12;

		var offset = 0.2;
        var verts = [pt(offset* length, 0), pt((-1.0 + offset)* length , 0.5* width), pt((-1 + offset) * length, -0.5 * width)];
        var poly = new lively.scene.Polygon(verts);
        // FIXME: positioning hack, remove the following
        this.head = this.addMorph(new Morph(poly));
        
		this.head.applyStyle(NodeStyle.connector);
		this.head.setFill(lineColor); // JL: style vs. explict color?        
        this.head.setBorderColor(lineColor);

        this.setPosition(this.head.getPosition());
        this.setExtent(this.head.getExtent());
        this.ignoreEvents();
        this.head.ignoreEvents();
        
        // this.head.setFillOpacity(0.7);
        // this.head.setStrokeOpacity(0.7);
        
        return this;
    },
    
    pointFromTo: function(from, to) {
        var dir = (to.subPt(from)).theta()
        this.setRotation(dir)
        this.setPosition(to);
    }

});

Morph.subclass('ConnectorMorph', {

	suppressHandles: true,

	style: NodeStyle.connector,//{borderColor: Color.rgb(230,230,230), borderWidth: 1},
	
	initialize: function($super, morph1, morph2) {
		var startPoint  = pt(0,0);
		var endPoint = pt(10,10);
		if (morph1) startPoint =  morph1.getCenter();
		if (morph2) endPoint = morph2.getCenter();
		
		var vertices = [startPoint, endPoint];
		vertices.invoke('subPt', vertices[0]);
		$super(new lively.scene.Polyline(vertices));

		// ArrowHeadMorph needs cleanup
		this.arrow = this.addMorph(new ArrowHeadMorph(null,null, null, 30, 8));
		this.arrow.head.applyStyle(NodeStyle.connector);

        this.closeAllToDnD();    

		this.setStartMorph(morph1);
		this.setEndMorph(morph2);
	},
	
    
	onDeserialize: function() {
		this.setStartMorph(this.startMorph);
		this.setEndMorph(this.endMorph);
	},
	
	// I don't know who sends this, but by intercepting here I can stop him.... drag me
    // logStack shows no meaningfull results here
    translateBy: function($super, delta) {
		//logStack();
		//$super(delta)
    },
	
	handlesMouseDown: Functions.True,
	
	getStartMorph: function() { return this.startMorph },
	
	getEndMorph: function() { return this.endMorph },
	
	setStartMorph: function(morph) {
		this.startMorph = morph;
		if (morph) this.register(morph, 'Start');
	},	
	
	setEndMorph: function(morph) {	
		this.endMorph = morph;
		if (morph) this.register(morph, 'End');
	},
	
	getStartPos: function() { 
		return this.shape.vertices().first() 
	},
	
	getEndPos: function() { 
		return this.shape.vertices().last() 
	},
	
	setStartPos: function(p) {
		var v = this.shape.vertices(); v[0] = p; this.setVertices(v);
	},
	
	setEndPos: function(p) {
		var v = this.shape.vertices(); v[v.length-1] = p; this.setVertices(v);
	},

	setCustomColor: function(color) {
		this.applyStyle({borderColor: color});
		this.arrow.head.applyStyle({fill: color});
	},

	register: function(morph, startOrEnd) {
		var con = this;
		morph.changed = morph.changed.wrap(function (proceed) {
			proceed();
			con.updatePos(startOrEnd);
		});
		con.updatePos(startOrEnd); // kickstart
	},
	
	unregister: function(startOrEnd) {
		var getMorphSelector = 'get' + startOrEnd + 'Morph';
		var morph = this[getMorphSelector]();
		if (!morph)
			return;
		if (morph.rebuildChangeMethod)
			morph.rebuildChangeMethod();
		else
			morph.changed = morph.constructor.prototype.changed;
		console.log('unregistered ' + startOrEnd);
	},

	updatePos: function(startOrEnd) {

		/*if (!this.getStartMorph() || !this.getEndMorph())
			return;
		var center = this.getStartMorph().getCenter();
		if (startOrEnd == 'Start')
			this.setStartPos(center);
		this.setEndPos(this.getEndMorph().bounds().closestPointToPt(center));
		this.arrow && this.arrow.pointFromTo(this.getStartPos(), this.getEndPos());*/

		var getMorphSelector = 'get' + startOrEnd + 'Morph';
		var setPosSelector = 'set' + startOrEnd + 'Pos';
		var morph = this[getMorphSelector]();
		if (morph.owner) {
			var newPos = morph.owner.worldPoint(morph.getCenter())
			this[setPosSelector](newPos);
			this.arrow && this.arrow.pointFromTo(this.getStartPos(), this.getEndPos());
		}
	},
	
	toString: function() {
		return Strings.format("#<ConnectorMorph:%s->%s>", this.getStartMorph(), this.getEndMorph());
	},
	
	remove: function($super) {
		$super();
		this.unregister('Start');
		this.unregister('End');
	},

});

Morph.subclass('NodeMorph', {

	maxDist: 200 ,
	minDist: 155 ,
	step: 15,
	minStepLength: 0,
	findOtherMorphsDelay: 10,
	
	suppressHandles: true,

	initialize: function($super, bounds) {
		$super(new lively.scene.Rectangle(bounds));
		//$super(new lively.scene.Ellipse(bounds.center(), (bounds.width+bounds.height)/2));
		//var gradient = new lively.paint.LinearGradient([
		//		new lively.paint.Stop(0.2, Color.lightGray), 
		//		new lively.paint.Stop(1, Color.darkGray)]);
		//this.applyStyle({fill: gradient});
		//this.applyStyle({fill: Color.white});
		this.applyStyle({fill: null});
		this.connections = [];
		this.connectionsPointingToMe = [];
		this.energy=1;
	},
	onDeserialize: function($super) {
		this.activeBoundsOfWorld = null;
	},
	configure: function(spec) {
		for (name in spec) this[name] = spec[name];
	},
	forceOfMorphs: function(morphs) {
		var avg = pt(0,0);
		this.cachedNodes=[];
		for (var i=0; i<morphs.length; i++) {
			var ea = morphs[i];
			var d = this.getCenter().subPt(ea.getCenter());
			var dist = d.fastR();
			var isConnected = this.isConnectedTo(ea) || ea.isConnectedTo(this);
			if (!isConnected && dist > this.maxDist + 150*this.energy)
				continue;
			this.cachedNodes.push(ea);
			avg = avg.addPt(this.forceOfMorph(ea, d, dist, isConnected));
		}
		if (avg.eqPt(pt(0,0))) return avg;
		return Point.polar(this.energy*this.step, avg.theta());
	},
	forceOfMorph: function(morph, vector /*between centers of me and morph*/, dist /*of vector*/, isConnected) {
		// effect positive --> push away, negative -> attract
		if (dist == 0) return pt(0,0); var effect;
		if (dist < this.minDist) {
			//effect = this.minDist/dist;
			effect = 1;
		} else if (isConnected) {
			if (dist <= this.maxDist) return pt(0,0);
			effect = -1;
		} else {
			if (dist >= this.maxDist) return pt(0,0);
			effect = 1;
		}
		return vector.fastNormalized().scaleBy(effect);
	},
	makeStep: function() {
		if (this.energy == 0) return;
		var nodes = this.cachedNodes;
		if (!this.calls || this.calls % this.findOtherMorphsDelay == 0) {
		 	this.cachedNodes = this.findNodeMorphs();
			this.calls = 1;

			if (this.connectedNodes().length == 0) {
				this.minDist = 20;
				this.maxDist = 50;
			} else {
				this.minDist = this.constructor.prototype.minDist;
				this.maxDist = this.constructor.prototype.maxDist;
			}
		}
		this.calls++;
		var v = this.forceOfMorphs(this.cachedNodes);
		if (!v.x || !v.y /*|| v.fastR() <= this.minStepLength*/) return; // what about v.x/y === 0 ???
		this.moveBy(v);
		this.ensureToStayInWorldBounds();
	},
	findNodeMorphs: function() {
		return NodeMorph.all().without(this);
	},
	ensureToStayInWorldBounds: function() {
		if (!this.activeBoundsOfWorld) {
			// World bounds are sometimes wrong??? Use canvas ...
			var canvas = Global.document.getElementById('canvas');
			this.activeBoundsOfWorld = pt(canvas.clientWidth, canvas.clientHeight).subPt(this.getExtent()).extentAsRectangle();
		//this.activeBoundsOfWorld =  pt(1051.9,584.5).extentAsRectangle();
		}
		if (!this.activeBoundsOfWorld.containsPoint(this.getPosition()))
			this.setPosition(this.activeBoundsOfWorld.closestPointToPt(this.getPosition()));
	},
	startSteppingScripts: function(ms, random) {
		var timing = 10 //ms || 1000;
		if (random) {
			var getRandomNumber = function(max) { return Math.floor(Math.random()*max+1)-1};
			timing = timing + getRandomNumber(200);
		}
        this.startStepping(timing, "makeStep");
    },
	connectTo: function(otherNode) {
		this.connectedNodesCache = null;
		var con = new ConnectorMorph(this, otherNode);
		this.ensureConnectionIsVisible(con);
		this.connections.push(con);
		otherNode.connectionsPointingToMe.push(con);
		return con;
	},
	ensureConnectionToNodeIsVisible: function(node) {
		this.ensureConnectionIsVisible(this.getConnectionToNode(node));
	},
	ensureConnectionIsVisible: function(connection) {
		var w = WorldMorph.current();
		if (this.ownerChain().include(w))
			w.addMorphBack(connection);
	},
	disconnect: function(node) {
		this.connectedNodesCache = null;
		var c = this.getConnectionToNode(node);
		if (!c) {
			console.warn('Trying to disconnect nodes but couldn\'t find connection!');
			return;
		}
		c.remove();
		this.connections = this.connections.without(c);
	},
	getConnectionToNode: function(node) {
		return this.connections.detect(function(ea) { return ea.getEndMorph() == node });
	},
	connectedNodes: function() {
		if (!this.connectedNodesCache)
			this.connectedNodesCache = this.connections.collect(function(ea) { return ea.getEndMorph() });
		return this.connectedNodesCache
	},
allConnectedNodes: function() {
		return this.connectedNodes().concat(this.connectedNodesPointingToMe());
	},
connectedNodesPointingToMe: function() {
		return this.connectionsPointingToMe.collect(function(ea) { return ea.getStartMorph() });
	},
	isConnectedTo: function(otherNode) {
		return this.connectedNodes().indexOf(otherNode) != -1;
	},
	remove: function($super) {
		$super();
		this.connectionsPointingToMe.forEach(function(ea) { ea.getStartMorph().disconnect(this) }, this);
		this.connections.invoke('remove');
	},
	rebuildChangeMethod: function() {
		this.changed = this.constructor.prototype.changed;
		this.connections.forEach(function(ea) {ea.register(this, 'Start')}, this);
		this.connectionsPointingToMe.forEach(function(ea) {ea.register(this, 'End')}, this);
	},
	addLabel: function(text) {
		if (!this.label)
			this.label = this.addMorph(new TextMorph(new Rectangle(0,0,this.getExtent().x,10)));
		this.label.textString = text;
		this.label.beLabel();
//		this.label.setFontSize(9); this.label.applyStyle({fill: Color.white, borderRadius: 10, borderWidth: 1, borderColor: Color.gray.darker()});
        this.label.applyStyle(NodeStyle.node);
		this.setExtent(this.label.getExtent().addXY(0,5));
		this.label.centerAt(this.innerBounds().center());
	},
placeNearConnectedNode: function() {
	if (this.allConnectedNodes().length == 0) return;
	var other = this.allConnectedNodes().first();
	var newPos = other.bounds().expandBy(other.maxDist).randomPoint();
	this.centerAt(newPos);
},
continouslyTryToPlaceNearConnectedNodes: function() {
	var tries = 5;
	var self = this;
	var tryPlace = function() {
		if (self.allConnectedNodes().length > 0) {
			self.placeNearConnectedNode();
			return;
		}
		if (tries > 0) {
			tries--;
			tryPlace.delay(1);
		}
	};
	tryPlace();
},


});

Object.extend(NodeMorph, {
	all: function() {
		return WorldMorph.current().submorphs.select(function(ea) { return ea instanceof NodeMorph });
	},
	buildEnergySlider: function() {
		var slider = new NodeEnergySlider(); // FIXME somehow a addObserver does not deserialize so have to subclass
		slider.openInWorld();
	}
});

SliderMorph.subclass('NodeEnergySlider', {
	initialize: function($super, optB) {
		$super(optB || new Rectangle(0,0,200,30));
	},
	onValueUpdate: function($super, value) {
		$super(value);
		var energy = value*2;
		console.log('Node Energy: ' + energy);
		NodeMorph.all().forEach(function(ea) { ea.energy = energy });
	},
	onDeserialize: function($super) {
		$super();
		// slider deserialization seems to be broken...
		var b = this.bounds();
		this.owner.addMorph(new NodeEnergySlider(b));
		this.remove();
	},
});

/**
 * A Morph for marking regions 
 * - that does not accept the dropping of other morphs 
 * - and does only react on mouse clicks on the border
 */

MouseHandlerForDragging.subclass('MarkerMorphMouseHandler', {
	handleMouseEvent: function($super, evt, targetMorph) {
		// console.log("handle event " + evt + ", " + targetMorph)
		if (targetMorph && (!targetMorph.containsWorldPoint(evt.mousePoint)))
			return false;
		return $super(evt, targetMorph); 
	},
});

Morph.subclass("MarkerMorph", {

	openForDragAndDrop: false,

	mouseHandler: MarkerMorphMouseHandler.prototype,

	initialize: function($super, rectangle) {
		$super(new lively.scene.Rectangle(rectangle))

		this.applyStyle({borderWidth: 2, borderColor: Color.tangerine , fill: null});
		this.shape.setStrokeDashArray("9,7");
	},
	
	containsPoint: function($super, point) {
		var result = $super(point)
		if (result) {
			var innerRect = this.shape.bounds().insetBy(5);
			return ! innerRect.containsPoint(this.localize(point));
		} else {
			return false;
		}
	}

});

Morph.subclass("ProgressBarMorph", {

	initialize: function($super, bounds) {
		this.bar = Morph.makeRectangle(0,0,0,0)
		$super(new lively.scene.Rectangle(bounds));
		this.bar.applyStyle({fill: Color.darkGray, borderWidth: pt(0,0), borderColor: null})
		this.bar.ignoreEvents();
		
		this.addMorph(this.bar);
		this.applyStyle({fill: Color.gray})
		this.setValue(0.3);

		this.label = new TextMorph(new Rectangle(0,0, 100, 20), '');
		this.label.applyStyle({textColor: Color.white, fill: null, borderWidth: 0})
		this.addMorph(this.label);
		this.label.ignoreEvents()
	},

	setValue: function(number){
		this.value = number;
		this.updateBar(number);
	},

	getValue: function(){
		return this.value;
	},
	
	setLabel: function(str) {
		if (!this.label) return
		this.label.setExtent(this.getExtent());
		this.label.textString = str;
		this.label.emphasizeAll({style: 'bold', align: 'center'});
		this.label.align(this.label.bounds().center(), this.shape.bounds().center());
	},


	updateBar: function(number){
		var bounds = this.shape.bounds()
		this.bar.setPosition(pt(0,0));
		this.bar.setExtent(pt(Math.floor(number * bounds.width), bounds.height)) 	
	},

	adjustForNewBounds: function($super) {
        $super();
		this.updateBar(this.getValue())
    },

})

// Usable Setup of a Widget - Record - Slider
// this demonstrates some issues to be resolved 
Widget.makeSlider = function(bounds, range) {
	
	bounds = bounds || new Rectangle(0, 0, 100, 20)
	range = range || 10.0;
	
	// Why are simple morphs not funcitonal without any model underneath?
	
	// Why should widgets not be graphical? 
	// and when they are not where should we put them
	var widget = new Widget();
	// why could widgets and other morphs not act as a model?
	var model = Record.newNodeInstance({Value: null,  SliderExtent: null});
	widget.ownModel(model);

	slider = new SliderMorph(bounds, range)
	slider.connectModel(model);
	slider.ownerWidget = widget 

	// TODO 
	model.addObserver(slider)
	return slider
}
	
/* 
 * Replacement for PromptDialog Widget
 *
 */ 
// TODO: get rid of the magic and repetitive layout numbers....
BoxMorph.subclass("PromptDialogMorph", {

    suppressHandles: true,

	padding: new Rectangle(10,10,10,10),

	connections: ['accepted', 'canceled', 'title'], // for documentation only
	
	initialize: function($super, bounds) {
		bounds = bounds || new Rectangle(0,0,500,400);
		$super(bounds);

		this.callback = null;
		this.layoutManager = new VerticalLayout();
		this.addTitle("Prompt Dialog");
		this.addTextPane();
		this.addButtons();
		this.linkToStyles(["panel"]);
		this.adjustForNewBounds();
	},

	addTitle: function(str) {
		this.label =  new TextMorph(new Rectangle(0,0,20,10)).beLabel();
		connect(this, "title", this.label, 'setTextString');
		this.label.padding = new Rectangle(0,10,0,0);
		this.addMorph(this.label);
		this.title = str;
		
	},
	
	addTextPane: function() {
		this.textPane = newTextPane(new Rectangle(0,0,300,100), "");
		this.textPane.applyStyle({fill: Color.white});
		this.textPane.innerMorph().applyStyle({fill: null});
		this.textPane.innerMorph().owner.applyStyle({fill: null}); // clip
		this.addMorph(this.textPane);
	},
	
	addButtons: function() {
		this.okButton = new ButtonMorph(new Rectangle(0,0,70,20));
		this.okButton.setLabel("OK");
		connect(this.okButton, "fire", this, 'removeWithWindow');
		connect(this.okButton, "fire", this, 'onAcceptButtonFire');
		
        this.cancelButton = new ButtonMorph(new Rectangle(0,0,70,20));
		this.cancelButton.setLabel("Cancel");
		connect(this.cancelButton, "fire", this, 'removeWithWindow');
		connect(this.cancelButton, "fire", this, 'canceled');

		var pane = new BoxMorph();
		pane.layoutManager = new HorizontalLayout();
		pane.padding = new Rectangle(5,5,5,5);
  		pane.addMorph(this.cancelButton);
		pane.addMorph(this.okButton);
		pane.setBounds(pane.submorphBounds(true));
		pane.setFill(null);
		this.addMorph(pane);
		this.buttonPane = pane;    
	},
	
	setText: function(aString) {
		this.textPane.innerMorph().setTextString(aString);
	},

	getText: function() {
		return this.textPane.innerMorph().textString
	},

	onAcceptButtonFire: function() {
		this.callback && this.callback(this.getText());
		updateAttributeConnection(this, 'accepted', this.getText())
	},

	adjustForNewBounds: function ($super) {
		var newExtent = this.innerBounds().extent();
	
		var offset = pt(0,0);
		offset = offset.addPt(pt(0, this.buttonPane.getExtent().y));		
		offset = offset.addPt(pt(0, this.label.getExtent().y));

		this.textPane.setExtent(newExtent.subPt(offset))
		this.relayout();

		// move Buttons 
		var offset = this.shape.bounds().bottomRight().subPt(this.buttonPane.bounds().bottomRight())
		this.buttonPane.moveBy(offset.subPt(pt(5,5)))

	},
	
	openIn: function(world, loc) {
		var useLightFrame = true;
        var win = world.addFramedMorph(this, '', loc, useLightFrame);
        this.textPane.innerMorph().requestKeyboardFocus(world.firstHand());
		win.adjustForNewBounds()
        return win;
    },

	removeWithWindow: function() {
		if (this.owner && (this.owner instanceof WindowMorph)) {
			this.owner.remove()
		} else {
			this.remove()
		}
	},

})

// should these go to the tests?
Morph.subclass("PromptDialogMorphExampleClientMorph", {

	oncancel: function() {
		console.log("oncancel")
	},

	onaccept: function(input ) {
		console.log("onaccept " + input);
	}
})

Object.extend(PromptDialogMorph, {
	openExample: function() {
		if($morph('testPromptDialog'))
			$morph('testPromptDialog').remove();
		var morph = new PromptDialogMorph();

		//morph.openInWorld();
		var win = morph.openIn(WorldMorph.current(), pt(550,50));
		win.setExtent(pt(300,300))
		win.name = 'testPromptDialog';

		// we need objects that are persistent and implement the behavior
		var client = new PromptDialogMorphExampleClientMorph(new lively.scene.Rectangle(0,0,1,1));
		morph.addMorph(client); // store it somewhere		

		connect(morph, 'canceled', client, 'oncancel');
		connect(morph, 'accepted', client, 'onaccept');
	}
})


BoxMorph.subclass('HorizontalDivider', {

	suppressGrabbing: true,

	suppressHandles: true,

	style: {fill: Color.gray},

	handlesMouseDown: function(evt) { return true },

	initialize: function($super, bounds) {
		$super(bounds);
		this.fixed = [];
		this.scalingBelow = [];
		this.scalingAbove = [];
		this.minHeight = 20;
		this.pointerConnection = null;
	},

	onMouseDown: function(evt) {
		this.oldPoint = evt.point();
		this.pointerConnection = connect(evt.hand, 'origin', this, 'movedVerticallyBy', function(pos) {
			var resizer = this.getTargetObj();
			var p1 = resizer.oldPoint;
			var p2 = pos;
			var deltaY = p2.y - p1.y;
			resizer.oldPoint = pos;
			return deltaY
		});
	},

	onMouseUp: function(evt) {
		evt.hand.lookNormal() // needed when hand is not over morph anymore
		this.pointerConnection.disconnect();
		this.pointerConnection = null;
	},

	movedVerticallyBy: function(deltaY) {
		if (!this.resizeIsSave(deltaY)) return;

		var morphsForPosChange = this.fixed.concat(this.scalingBelow);
		morphsForPosChange.forEach(function(m) {
			var pos = m.getPosition();
			m.setPosition(pt(pos.x, pos.y + deltaY));
		})
		this.scalingAbove.forEach(function(m) {
			var ext = m.getExtent();
			m.setExtent(pt(ext.x, ext.y + deltaY));
		})
		this.scalingBelow.forEach(function(m) {
			var ext = m.getExtent();
			m.setExtent(pt(ext.x, ext.y - deltaY));
		})
		this.setPosition(this.getPosition().addPt(pt(0, deltaY)));
	},

	resizeIsSave: function(deltaY) {
		return this.scalingAbove.all(function(m) { return (m.getExtent().y + deltaY) > this.minHeight }, this) &&
			this.scalingBelow.all(function(m) { return (m.getExtent().y - deltaY) > this.minHeight}, this)
	},

	onMouseMove: function(evt) {
		evt.hand.lookLikeAnUpDownArrow()
		// also overwritten to prevent super behavior
	},

	onMouseOut: function(evt) {	evt.hand.lookNormal() },

	addFixed: function(m) { if (!this.fixed.include(m)) this.fixed.push(m) },

	addScalingAbove: function(m) { this.scalingAbove.push(m) },

	addScalingBelow: function(m) {  this.scalingBelow.push(m) },

});


BoxMorph.subclass("StatusMessageContainer", {
 	defaultExtent: pt(400,30),

	suppressGrabbing: true,
	suppressHandles: true,
	openForDragAndDrop: false,
	
	layoutManager: new VerticalLayout(),

	initialize: function($super) {
		$super(this.defaultExtent.extentAsRectangle());
		this.setFill(null);
		this.setupDismissAllButton();
	},

	setupDismissAllButton: function(){
		this.dismissAllButton = new ButtonMorph(new Rectangle(0,0,400,15)).setLabel("dismiss all");
		this.dismissAllButton.applyStyle({fill: Color.lightGray, borderWidth: 0})
		connect(this.dismissAllButton, "fire", this, "dismissAll");
	},

	dismissAll: function() {
		this.submorphs.clone().each(function(ea) {
			ea.remove()
		})
	},

	startUpdate: function() {
		// don't use the script morphs
		this.world().startSteppingFor(new SchedulableAction(this, 'updateMessages', undefined, 1000))
	},

	showDismissAllButton: function() {
		if (!this.dismissAllButton) {
			this.setupDismissAllButton();
		}
		if (!this.dismissAllButton.owner) {
			this.addMorphBack(this.dismissAllButton);
			this.relayout()
		}
	},

	onDeserialize: function() {
		this.dismissAll();
		this.stopStepping(); // ensure that  it works even for old potentially broken pages...		
		this.startUpdate();
	},

	updateMessages: function() {
		var time = new Date().getTime();
		var messagesToBeDeleted = this.submorphs.select( function(ea) {return ea.removeAtTime && ea.removeAtTime < time})
		
		if (messagesToBeDeleted.length > 0) {
			messagesToBeDeleted.each(function(ea) {ea.remove()});
			this.relayout();
		}
		// get rid of the dismiss button
		var visibleMorphs = this.visibleSubmorphs();
		if (visibleMorphs.length == 1) {
			visibleMorphs[0].remove();
		}
	},

	addStatusMessage: function(msg, color, delay, callback, optStyle, kind) {	
		console.log((kind ? kind : "status msg: ") + msg)
		this.showDismissAllButton();

		var statusMorph = new TextMorph(pt(400,30).extentAsRectangle())
	
		var closeButton = new ButtonMorph(pt(20,20).extentAsRectangle())
		closeButton.setLabel("X");
		closeButton.applyStyle({fill: Color.white})
		closeButton.align(closeButton.bounds().rightCenter(), statusMorph.shape.bounds().rightCenter().subPt(pt(5,0)));
		connect(closeButton, "fire", statusMorph, "remove")
		statusMorph.addMorph(closeButton);


		if (callback) {
			var moreButton = new ButtonMorph(pt(40,20).extentAsRectangle())
			moreButton.setLabel("more");
			moreButton.applyStyle({fill: Color.white})
			moreButton.align(moreButton.bounds().topRight(), closeButton.bounds().topLeft().subPt(pt(5,0)));
			var pressed = false;
			var callbackObject = {callback: function() {
				// hack prevent weird chrome behavior...
				if (!pressed) {
					pressed = true;
					callback();
				}
			}};
			connect(moreButton, "fire", this, "relinquishKeyboardFocus", function(){ return WorldMorph.current().firstHand()})
			connect(moreButton, "fire", callbackObject, "callback")
			statusMorph.addMorph(moreButton);
		}

		statusMorph.applyStyle({borderWidth: 0, fill: Color.gray, fontSize: 16, fillOpacity: 0.7, borderRadius: 10});
		if (optStyle)
			statusMorph.applyStyle(optStyle);
		statusMorph.textString = msg;
		statusMorph.setTextColor(color || Color.black);

		statusMorph.ignoreEvents();
		
		this.addMorph(statusMorph);
		if (delay) {
			statusMorph.removeAtTime = new Date().getTime() + (delay * 1000);
		};
		
		this.startUpdate() // actually not needed but to be sure....
		
	}
})

/*
 * A Slider with Text field that acts as an interface to the scale of other Morphs
 * 
 */
BoxMorph.subclass('ScaleMorph', {
	
	defaultExtent: pt(40,200),
	layoutManager: new VerticalLayout(),
	padding: new Rectangle(5,5,0,0),
	style: {fill: Color.gray},

	initialize: function($super, bounds) {
		bounds = bounds || pt(0,0).extent(this.defaultExtent	);

		$super(bounds)		

		this.scaleValue = 1;

		this.scaleSlider =  Widget.makeSlider(new Rectangle(0,0,40,200));
		this.scaleText = new  TextMorph(new Rectangle(0,0,40,20));

		this.addMorph(this.scaleSlider);
		this.addMorph(this.scaleText);

		var m = this.scaleText;
		m.setTextString("-");
		m.beInputLine();
		m.suppressHandles = true;
		m.suppressGrabbing = true;

		var m = this.scaleSlider;
		m.suppressHandles = true;
		m.suppressGrabbing = true;

		// ok, fix layout for the moment
		this.shape.setBounds(this.submorphBounds(true).outsetByRect(this.padding));
		this.suppressHandles = true;

		this.setupConnections();

		return this.panel
	},

	setupConnections: function() {
		connect(this, 'scaleValue', this.scaleText, 'setTextString', {
			converter: function(value){return String(value.toFixed(2))}})

		connect( this.scaleText, 'savedTextString', this, 'scaleValue', {converter: function(value) {return Number(value)}})

		connect(this.scaleSlider, 'value', this, 'scaleValue', {converter: function(value){
			var threshold = 5
			if (value < threshold)
				return  (value / threshold)
			else 
				return  value - threshold + 1
		}})

		// ATTENTION: bidirectional dataflow, may be dangerous...
		connect(this, 'scaleValue', this.scaleSlider, 'setValue', {converter: function(value){
			var threshold = 5
			value = Number(value)
			if (value < 1)
				var result = value * threshold
			else 
				var result = value + threshold - 1
			if (result < 0)
				return 0;
			if (result > 10)
				return 10
		}})
	},

	setTarget: function(target) {
		// there should only be one target...
		if (this.target) {
			disconnect(this, 'scaleValue', this.target, 'setScale');
		};
		if (target) {
			connect(this, 'scaleValue', target, 'setScale')
		};
		this.target = target;
	},
})

if (window.shouldShowLoadingMessages) { console.log('loaded Widgets.js'); }


}); // end of module
avocado.transporter.module.onLoadCallbacks["lk/Widgets"] = 'done';

avocado.transporter.module.onLoadCallbacks["lk/Network"] = function() {};
/*
 * Copyright (c) 2006-2009 Sun Microsystems, Inc.
 *
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * Network.js.  Networking capabilities.
 *
 * Note: In a browser-based implementation of our system,
 * most of the necessary networking functionality is 
 * inherited from the browser.  
 */

module('lively.Network').requires().toRun(function(thisModule) {
	
Object.subclass('URL', {
    splitter: new RegExp('(http:|https:|file:)' + '(//[^/:]*(:[0-9]+)?)?' + '(/.*)?'),
    pathSplitter: new RegExp("([^\\?#]*)(\\?[^#]*)?(#.*)?"),
    
	initialize: function(/*...*/) { // same field names as window.location
		dbgOn(!arguments[0]);
		if (Object.isString(arguments[0].valueOf())) {
			var urlString = arguments[0];
			var result = urlString.match(this.splitter);
			if (!result) throw new Error("malformed URL string '" + urlString + "'");
			this.protocol = result[1]; 
			if (!result[1]) 
				throw new Error("bad url " + urlString + ", " + result);
			this.hostname = result[2] && result[2].substring(2).split(':')[0]; // skip the leading slashes and remove port
			this.port = result[3] && parseInt(result[3].substring(1)); // skip the colon

			var fullpath = result[4];
			if (fullpath) {
				result = fullpath.match(this.pathSplitter);
				this.pathname = result[1];
				this.search = result[2];
				this.hash = result[3];
			} else {
				this.pathname = "/";
				this.search = "";
				this.hash = "";
			}
		} else { // spec is either an URL or window.location
			var spec = arguments[0];
			this.protocol = spec.protocol || "http";
			this.port = spec.port;
			this.hostname = spec.hostname;
			this.pathname = spec.pathname || "";
			if (spec.search !== undefined) this.search = spec.search;
			if (spec.hash !== undefined) this.hash = spec.hash;
		}
	},
    
	inspect: function() {
		return JSON.serialize(this);
	},
    
	toString: function() {
		return this.protocol + "//" + this.hostname + (this.port ? ":" + this.port : "") + this.fullPath();
	},

	fullPath: function() {
		return this.pathname + (this.search || "") + (this.hash || "");
	},
    
	isLeaf: function() {
		return !this.fullPath().endsWith('/');
	},
    
	// POSIX style
	dirname: function() {
		var p = this.pathname;
		var slash = p.endsWith('/') ? p.lastIndexOf('/', p.length - 2) : p.lastIndexOf('/');
		return p.substring(0, slash + 1);
	},

	filename: function() {
		var p = this.pathname;
		var slash = p.endsWith('/') ? p.lastIndexOf('/', p.length - 2) : p.lastIndexOf('/');
		return p.substring(slash + 1);
	},

	normalizedHostname: function() {
		return this.hostname.replace(/^www\.(.*)/, '$1');
	},
	
	getDirectory: function() {
		return this.withPath(this.dirname());
	},

	withPath: function(path) { 
		var result = path.match(this.pathSplitter);
		if (!result) return null;
		return new URL({protocol: this.protocol, port: this.port, hostname: this.hostname, pathname: 
			result[1], search: result[2], hash: result[3] });
	},

	withRelativePath: function(pathString) {
		if (pathString.startsWith('/')) {
			if (this.pathname.endsWith('/'))
				pathString = pathString.substring(1);
		} else {
			if (!this.pathname.endsWith('/'))
				pathString = "/" + pathString;
		}
		return this.withPath(this.pathname + pathString);
	},
    
	withFilename: function(filename) {
		if (filename == "./" || filename == ".") // a bit of normalization, not foolproof
		filename = "";
		var dirPart = this.isLeaf() ? this.dirname() : this.fullPath();
		return new URL({protocol: this.protocol, port: this.port, 
			hostname: this.hostname, pathname: dirPart + filename});
	},

	toQueryString: function(record) {
		var results = [];
		Properties.forEachOwn(record, function(p, value) {
			results.push(encodeURIComponent(p) + "=" + encodeURIComponent(String(value)));
		});
		return results.join('&');
	},

	withQuery: function(record) {
		return new URL({protocol: this.protocol, port: this.port, hostname: this.hostname, pathname: this.pathname,
			search: "?" + this.toQueryString(record), hash: this.hash});
	},
    
	withoutQuery: function() {
		return new URL({protocol: this.protocol, port: this.port, hostname: this.hostname, pathname: this.pathname});
	},

	getQuery: function() {
		var s = this.toString();
		if (!s.include("?"))
			return {};
		return s.toQueryParams();
	},
	
	eq: function(url) {
		if (!url) return false;
		return url.protocol == this.protocol && url.port == this.port && url.normalizedHostname() == this.url.normalizedHostname()
			&& url.pathname == this.pathname && url.search == this.search && url.hash == this.hash;
	},

	relativePathFrom: function(origin) {
		if (!this.pathname.startsWith(origin.pathname)  || origin.normalizedHostname() != this.normalizedHostname())
			throw new Error('bad origin ' + origin + ' vs ' + this);
		return this.pathname.substring(origin.pathname.length);
	},

	svnWorkspacePath: function() {
		// heuristics to figure out the Subversion path
		var path = this.pathname;
		// note that the trunk/branches/tags convention is only a convention
		var index = path.lastIndexOf('trunk');
		if (index < 0) index = path.lastIndexOf('branches');
		if (index < 0) index = path.lastIndexOf('tags');
		if (index < 0) return null;
		return path.substring(index);
	},

	svnVersioned: function(repo, revision) {
		var relative = this.relativePathFrom(repo);
		return repo.withPath(repo.pathname + "!svn/bc/" + revision + "/" + relative);
	},
    
	notSvnVersioned: function() {
		// concatenates the two ends of the url
		// "http://localhost/livelyBranch/proxy/wiki/!svn/bc/187/test/index.xhtml"
		// --> "http://localhost/livelyBranch/proxy/wiki/index.xhtml"
		return this.withPath(this.fullPath().replace(/(.*)!svn\/bc\/[0-9]+\/(.*)/, '$1$2'));
	},

	toLiteral: function() {
		// URLs are literal
		return Object.clone(this);
	},
    
	toExpression: function() {
		// this does not work with the new prototype.js (rev 2808) anymore
		// return 'new URL(JSON.unserialize(\'' + JSON.serialize(this) + '\'))';
		return Strings.format('new URL({protocol: "%s", hostname: "%s", pathname: "%s"})',
			this.protocol, this.hostname, this.pathname);
	},

	withRelativePartsResolved: function() {
		var urlString = this.toString();
		var result = urlString;
		do {
			urlString = result;
			result = urlString.replace(/\/[^\/]+\/\.\./g, '')
			result = result.replace(/([^:])[\/]+/g, '$1/')
		} while(result != urlString)
		return new URL(result)
	},

});

// create URLs often needed
Object.extend(URL, {

	source: new URL(document.documentURI),

	codeBase: new URL(Config.codeBase).withRelativePartsResolved(),
})

Object.extend(URL, {
	proxy: (function() {
		if (!Config.proxyURL) {
			if (URL.source.protocol.startsWith("file")) 
				console.log("loading from localhost, proxying won't work");
			return URL.source.withFilename("proxy/");
		} else {
			var str = Config.proxyURL;
			if (!str.endsWith('/')) str += '/';
			return new URL(str);
		}
	})(),	
});

Object.extend(URL, {
	// FIXME: better names?
	common: {
		wiki:   URL.proxy.withFilename('lively-wiki/'),
		repository: URL.proxy.withFilename('lively-kernel/'),
		project: URL.proxy.withFilename('lively-project/'),  // currently lively-kernel.org
		domain: new URL(Global.document.location.protocol + '//' + Global.document.location.host)
	},
});

Object.extend(URL, {
	
	create: function(string) { return new URL(string) },

	ensureAbsoluteURL: function(urlString) {
		return /^http.*/.test(urlString) ?
		new URL(urlString) :
		URL.source.notSvnVersioned().getDirectory().withRelativePath(urlString);
	},

	fromLiteral: function(literal) { return new URL(literal) },

	makeProxied: function makeProxied(url) {
		url = url instanceof URL ? url : new URL(url);
		var px = this.proxy;
		if (!px) return url;
		if (px.normalizedHostname() != url.normalizedHostname()) // FIXME  protocol?
			return px.withFilename(url.hostname + url.fullPath());
		if (px.port != url.port)
			return px.withFilename(url.hostname + "/" + url.port + url.fullPath());
		if (px.hostname != url.hostname) // one has prefix www, the other not
			return new URL({
				protocol: url.protocol,
				port: url.port,
				hostname: px.hostname, // arghhh
				pathname: url.pathname,
				search: url.search,
				hash: url.hash
			})
		return url;
	},

});


Object.subclass('NetRequestStatus', {
	documentation: "nice parsed status information, returned by NetRequest.getStatus when request done",

	initialize: function(method, url, transport) {
		this.method = method;
		this.url = url;
		this.transport = transport;
		this.exception = null;
	},

	isSuccess: function() {
		var code = this.transport.status;
		return code >= 200 && code < 300;
	},

	setException: function(e) {
		this.exception = e;
	},

	toString: function() {
		return Strings.format("#<NetRequestStatus{%s,%s,%s}>", this.method, this.url, this.exception || this.transport.status);
	},

	requestString: function() {
		return this.method + " " + decodeURIComponent(this.url);
	},

	code: function() {
		return this.transport.status;
	},

	getResponseHeader: function(name) {
		return this.transport.getResponseHeader(name);
	}

});


View.subclass('NetRequest', {
	documentation: "a view that writes the contents of an http request into the model",

	// see XMLHttpRequest documentation for the following:
	Unsent: 0,
	Opened: 1,
	HeadersReceived: 2,
	Loading: 3,
	Done: 4,

	formals: ["+Status",  // Updated once, when request is {Done} with the value returned from 'getStatus'.
		"+ReadyState", // Updated on every state transition of the request.
		"+ResponseXML", // Updated at most once, when request state is {Done}, with the parsed XML document retrieved.
		"+ResponseText", // Updated at most once, when request state is {Done}, with the text content retrieved.
		"StreamContent",
		"Progress",
	],

	initialize: function($super, modelPlug) {
		this.transport = new XMLHttpRequest();
		this.requestNetworkAccess();
		this.transport.onreadystatechange = this.onReadyStateChange.bind(this);
		// FIXME onprogress leads to strange 101 errors when no internet connection available
		// this.transport.onprogress = this.onProgress.bind(this);
		// if (!UserAgent.isTouch) // FIXME crashes Mobile Safari
		// 	this.transport.upload.onprogress = this.onProgress.bind(this);
		this.isSync = false;
		this.requestHeaders = {};
		$super(modelPlug)
	},

	requestNetworkAccess: function() {
		if (Global.netscape && Global.location.protocol == "file:") {       
			try {
				netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead");
				console.log("requested browser read privilege");
				return true;
			} catch (er) {
				console.log("no privilege granted: " + er);
				return false;
			}
		}
	},

	beSync: function() {
		this.isSync = true;
		return this;
	},

	onReadyStateChange: function() {
		this.setReadyState(this.getReadyState());
		if (this.getReadyState() === this.Loading) { // For comet networking
			this.setStatus(this.getStatus());
			if (this.transport.responseText) {
				var allContent = this.getResponseText();
				var newStart = this._streamContentLength ? this._streamContentLength : 0;
				var newContent = allContent.substring(newStart);
				newContent = /^([^\n\r]*)/.exec(newContent)[1]; // remove line breaks
				this.setStreamContent(newContent);
				this._streamContentLength = allContent.length;
			}
				
		}
		if (this.getReadyState() === this.Done) {
			this.setStatus(this.getStatus());
			if (this.transport.responseText) 
				this.setResponseText(this.getResponseText());
			if (this.transport.responseXML) 
				this.setResponseXML(this.getResponseXML());
			this.disconnectModel(); // autodisconnect?
		}
	},

	onProgress: function(progress) { this.setProgress(progress) },
	
	setRequestHeaders: function(record) {
		Properties.forEachOwn(record, function(prop, value) {
			this.requestHeaders[prop] = value;
		}, this);
	},

	setContentType: function(string) {
		// valid before send but after open?
		this.requestHeaders["Content-Type"] = string;
	},

	getReadyState: function() {
		return this.transport.readyState;
	},

	getResponseText: function() {
		return this.transport.responseText || "";
	},

	getResponseXML: function() {
		return this.transport.responseXML || "";
	},

	getStatus: function() {
		return new NetRequestStatus(this.method, this.url, this.transport);
	},

	request: function(method, url, content) {
		try {
			this.url = url;
			this.method = method.toUpperCase();	    
			this.transport.open(this.method, url.toString(), !this.isSync);
			Properties.forEachOwn(this.requestHeaders, function(p, value) {
				this.transport.setRequestHeader(p, value);
				}, this);
			this.transport.send(content || '');
			return this;
		} catch (er) {
			var status = this.getStatus();
			status.setException(er);
			this.setStatus(status);
			throw er;
		}
	},

	get: function(url) {
		return this.request("GET", URL.makeProxied(url), null);
	},

	put: function(url, content) {
		return this.request("PUT", URL.makeProxied(url), content);
	},

	post: function(url, content) {
		return this.request("POST", URL.makeProxied(url), content);
	},

	propfind: function(url, depth, content) {
		this.setContentType("text/xml"); // complain if it's set to something else?
		if (depth != 0 && depth != 1)
			depth = "infinity";
		this.setRequestHeaders({ "Depth" : depth });
		return this.request("PROPFIND", URL.makeProxied(url), content);
	},

	report: function(url, content) {
		return this.request("REPORT", URL.makeProxied(url), content);
	},

	mkcol: function(url, content) {
		return this.request("MKCOL", URL.makeProxied(url), content);
	},

	del: function(url) {
		return this.request("DELETE", URL.makeProxied(url));
	},

	copy: function(url, destUrl, overwrite) {
		this.setRequestHeaders({ "Destination" : destUrl.toString() });
		if (overwrite) this.setRequestHeaders({ "Overwrite" : 'T' });
		return this.request("COPY", URL.makeProxied(url));
	},

	lock: function(url, owner) {
		this.setRequestHeaders({Timeout: 'Infinite, Second-30'});
		var content = Strings.format('<?xml version="1.0" encoding="utf-8" ?> \n\
		<D:lockinfo xmlns:D=\'DAV:\'> \n\
		<D:lockscope><D:exclusive/></D:lockscope> \n\
		<D:locktype><D:write/></D:locktype> \n\
		<D:owner>%s</D:owner> \n\
		</D:lockinfo>', owner || 'unknown user');
		return this.request("LOCK", URL.makeProxied(url), content);
	},
	
	unlock: function(url, lockToken, force) {
		if (force) {
			var req = new NetRequest().beSync().propfind(url);
			var xml = req.getResponseXML() || stringToXML(req.getResponseText());
			var q = new Query('/descendant::*/D:lockdiscovery/descendant::*/D:locktoken/D:href');
			var tokenElement = q.findFirst(xml);
			if (!tokenElement) // no lock token, assume that resource isn't locked
			return req;
			lockToken = tokenElement.textContent;
		}
		this.setRequestHeaders({'Lock-Token': '<' + lockToken + '>'});
		return this.request("UNLOCK", URL.makeProxied(url));
	},


	toString: function() {
		return "#<NetRequest{"+ this.method + " " + this.url + "}>";
	},

});


// extend your objects with this trait if you don't want to deal with error reporting yourself.
NetRequestReporterTrait = {
	setRequestStatus: function(status) {
		// update the model if there is one
		if (this.getModel && this.getModel() && this.getModel().setRequestStatus)
			this.getModel().setRequestStatus(status);
		
		var world = WorldMorph.current();
		// some formatting for alerting. could be moved elsewhere
		var request = status.requestString();
		var tooLong = 80;
		if (request.length > tooLong) {
			var arr = [];
			for (var i = 0; i < request.length; i += tooLong) {
				arr.push(request.substring(i, i + tooLong));
			}
			request = arr.join("..\n");
		}
		// error reporting
		if (status.exception) {
			world.alert("exception " + status.exception + " accessing\n" + request);
		} else if (status.code() >= 300) {
			if (status.code() == 301) {
				// FIXME reissue request? need the 'Location' response header for it
				world.alert("HTTP/301: Moved to " + status.getResponseHeader("Location") + "\non " + request);
			} else if (status.code() == 401) {
				world.alert("not authorized to access\n" + request); 
				// should try to authorize
			} else if (status.code() == 412) {
				console.log("the resource was changed elsewhere\n" + request);
			} else if (status.code() == 423) {
				world.alert("the resource is locked\n" + request);
			} else {
				world.alert("failure to\n" + request + "\ncode " + status.code());
			}
		} else  console.log("status " + status.code() + " on " + status.requestString());
	}
};

// convenience base class with built in handling of errors
Object.subclass('NetRequestReporter', NetRequestReporterTrait);

Importer.subclass('NetImporter', NetRequestReporterTrait, {
	onCodeLoad: function(error) {
		if (error) WorldMorph.current().alert("eval got error " + error);
	},

	pvtLoadCode: function(responseText) {
		try {
			eval(responseText); 
		} catch (er) {
			this.onCodeLoad(er);
			return;
		}
		this.onCodeLoad(null);
	},

	loadCode: function(url, isSync) {
		var req = new NetRequest({model: this, setResponseText: "pvtLoadCode", setStatus: "setRequestStatus"});
		if (isSync) req.beSync();
		req.get(url);
	},

	onWorldLoad: function(world, error) {
		if (error) WorldMorph.current().alert("doc got error " + error);
	},

	pvtLoadMarkup: function(doc) {
		var world;
		try {
			world = this.loadWorldContents(doc);
		} catch (er) {
			this.onWorldLoad(null, er);
			return;
		}
		this.onWorldLoad(world, null);
	},

	loadMarkup: function(url, isSync) {
		var req = new NetRequest({model: this, setStatus: "setRequestStatus", setResponseXML: "pvtLoadMarkup"});
		if (isSync) req.beSync();
		req.get(url);
	},

	loadElement: function(filename, id) {
		var result;
		this.processResult = function(doc) {
			var elt = doc.getElementById(id);
			if (elt) {
				var canvas = document.getElementById("canvas"); // note, no error handling
				var defs = canvas.getElementsByTagName("defs")[0];
				result = defs.appendChild(document.importNode(elt, true));
			}
		}
		var url = URL.source.withFilename(filename);
		new NetRequest({model: this, setStatus: "setRequestStatus", setResponseXML: "processResult"}).beSync().get(url);
		return result;
	}

});


View.subclass('Resource', NetRequestReporterTrait, {
	documentation: "a remote document that can be fetched, stored and queried for metadata",
	// FIXME: should probably encapsulate content type

	formals: ["ContentDocument", //:XML
		"ContentText", //:String
		"URL", // :URL
		"RequestStatus", // :NetRequestStatus
		"Progress",
	],

	initialize: function(plug, contentType) {
		this.contentType  = contentType;
		this.connectModel(plug);
	},

	deserialize: Functions.Empty, // stateless besides the model and content type

	toString: function() {
		return "#<Resource{" + this.getURL() + "}>";
	},

	removeNetRequestReporterTrait: function() {
		delete this.setRequestStatus;
		this.setRequestStatus = function(status) {
			if (this.getModel && this.getModel() && this.getModel().setRequestStatus)
				this.getModel().setRequestStatus(status);
		}.bind(this);
	},
	
	updateView: function(aspect, source) {
		var p = this.modelPlug;
		if (!p) return;
		switch (aspect) {
			case p.getURL:
			this.onURLUpdate(this.getURL()); // request headers?
			break;
		}
	},

	onURLUpdate: function(url) {
		return this.fetch(url);
	},

	fetch: function(sync, optRequestHeaders) {
		// fetch the document content itself
		var req = new NetRequest(Relay.newInstance({
			ResponseXML: "+ContentDocument", 
			ResponseText: "+ContentText", 
			Status: "+RequestStatus",
			Progress: "+Progress"}, this));
		if (sync) req.beSync();
		if (this.contentType) req.setContentType(this.contentType);
		if (optRequestHeaders) req.setRequestHeaders(optRequestHeaders);
		req.get(this.getURL());
		return req;
	},

	fetchProperties: function(destModel, optSync, optRequestHeaders) {
		// fetch the metadata
		destModel = destModel || this.getModel().newRelay({Properties: "ContentDocument", PropertiesString: "ContentText", URL: "URL", Progress: 'Progress'});
		var req = new NetRequest(Relay.newInstance({ ResponseXML: "Document", Status: "+RequestStatus", Progress: '+Progress'}, 
			Object.extend(new NetRequestReporter(), {
				// FIXME replace with relay
				setDocument: function(doc) {
					destModel.setProperties(doc);
				}
			})));
		if (optSync) req.beSync();
		if (this.contentType) req.setContentType(this.contentType);
		if (optRequestHeaders) req.setRequestHeaders(optRequestHeaders);
		req.propfind(this.getURL(), 1);
		return req;
	},

	store: function(content, optSync, optRequestHeaders) {
		// FIXME: check document type
		if (Global.Document && content instanceof Document) {
			content = Exporter.stringify(content);
		} else if (Global.Node && content instanceof Node) {
			content = Exporter.stringify(content);
		}
		var req = new NetRequest(Relay.newInstance({Status: "+RequestStatus", Progress: '+Progress'}, this));
		if (optSync) req.beSync();
		if (this.contentType) req.setContentType(this.contentType);
		if (optRequestHeaders) req.setRequestHeaders(optRequestHeaders);
		req.put(this.getURL(), content);
		return req;
	},

	findAll: function(query, defaultValue) {
		var content = this.getContentDocument();
		if (!content) return defaultValue;
		return query.findAll(content.documentElement, defaultValue);
	},


	fetchHeadRevision: function(destModel) {
		var req = new NetRequest(Relay.newInstance({ResponseXML: "+Document", Status: "+RequestStatus", Progress: '+Progress'}, 
		Object.extend(new NetRequestReporter(), { 
			setDocument: function(xml) {
				if (!xml) return;
				/* The response contains the properties of the specified file or directory,
				e.g. the revision (= version-name) */
				var revisionNode = xml.getElementsByTagName('version-name')[0];
				if (!revisionNode) 
					return;
				var number = Number(revisionNode.textContent);
				destModel.setHeadRevision(number);
			}
		})));

		req.propfind(this.getURL(), 1);
		return req;
	},

	logReportTemplate: '<S:log-report xmlns:S="svn:">' + 
		'<S:start-revision>%s</S:start-revision>' +
		'<S:end-revision>%s</S:end-revision>' +
		'<S:all-revprops/>' +
		'<S:path/>' +
		'</S:log-report>',

	fetchVersionHistory: function(mostRecentRev, leastRecentRev, destModel) {
		var req = new NetRequest(Relay.newInstance({ResponseXML: "+Document", Status: "+RequestStatus", Progress: '+Progress'},
		Object.extend(new NetRequestReporter(), {
			setDocument: function(doc) {
				destModel.setRevisionHistory(doc);
			}
		})));

		req.report(this.getURL(), 
		Strings.format(this.logReportTemplate, mostRecentRev, leastRecentRev));
		return req;
	}

});

Resource.subclass('SVNResource', {

	formals: Resource.prototype.formals.concat(['Metadata', 'HeadRevision']),

	initialize: function($super, repoUrl, plug, contentType) {
		this.repoUrl = repoUrl.toString();
		$super(plug, contentType);
	},

	getLocalUrl: function() {
		return this.getURL().slice(this.repoUrl.length + (this.repoUrl.endsWith('/') ? 0 : 1));
	},

	fetchHeadRevision: function(optSync) {
		this.setHeadRevision(null); // maybe there is a new one
		var req = new NetRequest({
			model: this,
			setResponseXML: "pvtSetHeadRevFromDoc",
			setStatus: "setRequestStatus",
			setProgress: 'setProgress'
		});
		if (optSync) req.beSync();
		req.propfind(this.getURL(), 1);
		return req;
	},

	fetch: function($super, optSync, optRequestHeaders, rev) {
		var req;
		if (rev) {
			this.withBaselineUriDo(rev, function() {
				req = $super(optSync, optRequestHeaders);
			});
		} else {
			req = $super(optSync, optRequestHeaders);
		};
		return req;
	},
	
	store: function($super, content, optSync, optRequestHeaders, optHeadRev) {
		// if optHeadRev is not undefined than the store will only succeed
		// if the head revision of the resource is really optHeadRev
		if (optHeadRev) {
			var headers = optRequestHeaders ? optRequestHeaders : {};
			//determine local path of resource
			//var local = new URL(this.getURL()).relativePathFrom(new URL(this.repoUrl));
			var local = this.getURL().toString().substring(this.repoUrl.toString().length);
			local = local.slice(1); // remove leading slash
			var ifHeader = Strings.format('(["%s//%s"])', optHeadRev, local);
			console.log('Creating if header: ' + ifHeader);
			Object.extend(headers, {'If': ifHeader});
		}
		return $super(content, optSync, headers);
	},
	
	del: function(sync, optRequestHeaders) {
		var req = new NetRequest(Relay.newInstance({
			Status: "+RequestStatus",
			Progress: '+Progress'
		}, this));
		if (sync) req.beSync();
		if (optRequestHeaders) req.setRequestHeaders(optRequestHeaders);
		req.del(this.getURL());
		return req;
	},

	fetchProperties: function($super, destModel, optSync, optRequestHeaders, rev) {
		var req;
		//Record.newPlainInstance({ Properties: null, PropertiesString: "", URL: this.getURL()});
		if (rev) {
			this.withBaselineUriDo(rev, function() {
				req = $super(destModel, optSync, optRequestHeaders);
			});
		} else {
			req = $super(destModel, optSync, optRequestHeaders);
		};
		return req;
	},

	fetchMetadata: function(optSync, optRequestHeaders, startRev, endRev, reportDepth) {
		// get the whole history if startRev is undefined
		// FIXME: in this case the getHeadRevision will be called synchronous
		if (!startRev) {
			this.fetchHeadRevision(true);
			startRev = this.getHeadRevision();
		}
		this.reportDepth = reportDepth; // FISXME quick hack, needed in 'pvtScanLog...'
		var req = new NetRequest({
			model: this,
			setResponseXML: "pvtScanLogReportForVersionInfos",
			setStatus: "setRequestStatus",
			setProgress: 'setProgress'
		});
		if (optSync) req.beSync();
		if (optRequestHeaders) req.setRequestHeaders(optRequestHeaders);
		req.report(this.getURL(), this.pvtRequestMetadataXML(startRev, endRev));
		return req;
	},

	pvtSetHeadRevFromDoc: function(xml) {
		if (!xml) return;
		/* The response contains the properties of the specified file or directory,
		e.g. the revision (= version-name) */
		var revisionNode = xml.getElementsByTagName('version-name')[0];
		if (!revisionNode) return;
		this.setHeadRevision(Number(revisionNode.textContent));
	},

	pvtScanLogReportForVersionInfos: function(logReport) {
		// FIXME Refactor: method object?
		var depth = this.reportDepth;
		var logItemQ = new Query('//S:log-item');
		var versionInfos = [];
		//var repoUrl = new URL(this.repoUrl);
		var repoUrl = this.repoUrl;
		logItemQ.findAll(logReport).forEach(function(logElement) {
			var spec = {};
			$A(logElement.childNodes).forEach(function(logProp) {
				switch(logProp.tagName) {
					case 'D:version-name':
						spec.rev = Number(logProp.textContent); break;
					case 'D:creator-displayname':
						spec.author = logProp.textContent; break;
					case 'S:date':
						spec.date = logProp.textContent; break;
					case 'S:added-path':
					case 'S:modified-path':
					case 'S:deleted-path':
					case 'S:replaced-path':
						var relPath = logProp.textContent;
						if (depth && relPath.split('/').length-1 > depth)
							return;
						//relPath = relPath.slice(1); // remove trailing /
						if (repoUrl.endsWith(relPath))
							spec.url = repoUrl; // hmmm???
						else
						spec.url = repoUrl.toString() + relPath.slice(1); 
						// console.log('Created spec.url:' + spec.url);
						if (spec.change != null) {// was set before... assume only one change per rev
							//	console.warn('multiple changes for one revision of ' + spec.url);
							spec.url = null;
							return;
						}
						spec.change = logProp.tagName.split('-').first();
						break;
					default:
				}
			});
			if (!spec.url) return;
			spec.url = new URL(spec.url);
			versionInfos.push(new SVNVersionInfo(spec));
		});
		// newest version first
		versionInfos = versionInfos.sort(function(a,b) { return b.rev - a.rev });
		this.setMetadata(versionInfos);
	},
	
	pvtScanLogReportForVersionInfosTrace: function(logReport) {
		lively.lang.Execution.trace(this.pvtScanLogReportForVersionInfos.curry(logReport).bind(this));
	},

	pvtRequestMetadataXML: function(startRev, endRev) {
		return Strings.format(
			'<S:log-report xmlns:S="svn:" xmlns:D="DAV:">' + 
			'<S:start-revision>%s</S:start-revision>' +
			'<S:end-revision>%s</S:end-revision>' +
			'<S:discover-changed-paths/>' +
			'<S:path></S:path>' +
			'<S:all-revprops/>' +
			'</S:log-report>', startRev, endRev || 0);
	},

	withBaselineUriDo: function(rev, doFunc) {
		var tempUrl = this.getURL();
		this.setURL(this.repoUrl + '/!svn/bc/' + rev + '/' + this.getLocalUrl());
		doFunc();
		this.setURL(tempUrl);
	},
});

Object.subclass('SVNVersionInfo', {

	documentation: 'This object wraps svn infos from report or propfind requests',

	initialize: function(spec) {
		// possible properties of spec:
		// rev, date, author, url, change, content
		for (name in spec) {
			var val = spec[name];
			if (name == 'date') {
				if (Object.isString(val)) {
					this.date = this.parseUTCDateString(val);
				} else if (val instanceof Date) {
					this.date = val;
				}
			} else {
				this[name] = val;
			}
		}
		if (!this.author)
			this.author = '(no author)';
		if (!this.date)
			this.date = new Date();
	},

	parseUTCDateString: function(dateString) {
		var yearElems = dateString.slice(0,10).split('-').collect(function(ea) {return Number(ea)});
		var timeElems = dateString.slice(11,19).split(':').collect(function(ea) {return Number(ea)});
		return new Date(yearElems[0], yearElems[1]-1, yearElems[2], timeElems[0], timeElems[1], timeElems[2])
	},

	toString: function() {
		// does not work when evaluate {new SVNVersionInfo() + ""} although toStrings() works fine. *grmph*
		// string = Strings.format('%s, %s, %s, Revision %s',
		//     this.author, this.date.toTimeString(), this.date.toDateString(), this.rev);
		// string = new String(string);
		// string.orig = this;
		return Strings.format('%s, %s, %s, Revision %s',
			this.author, this.date.toTimeString(), this.date.toDateString(), this.rev);
	},
	
	toExpression: function() {
		return Strings.format('new SVNVersionInfo({rev: %s, url: %s, date: %s, author: %s, change: %s})',
		this.rev, toExpression(this.url), toExpression(this.date),
		toExpression(this.author), toExpression(this.change));
	},
	
});


// TODO will be merged with Resource
// TODO make async?
// deprecated
Object.subclass('FileDirectory', {

	initialize: function(url) {
		this.url = url.isLeaf() ? url.getDirectory() : url;
		this.writeAsync = false;
	},

	fileContent: function(localname, revision, contentType) {
		var url = this.url.withFilename(localname);
		var resource = new SVNResource(this.url.toString(), Record.newPlainInstance({URL: url.toString(), ContentText: null}));
		resource.contentType = contentType;
		resource.fetch(true, null, revision);
		return resource.getContentText();
	},

	filesAndDirs: function(revision) {
		var webfile = new lively.Storage.WebFile(Record.newPlainInstance({DirectoryList: [], RootNode: this.url}));
		webfile.fetchContent(this.url, true);
		return webfile.getModel().getDirectoryList();
	},

	files: function(optRev) {
		return this.filesAndDirs(optRev).select(function(ea) { return ea.isLeaf() });
	},

	filenames: function(optRev) {
		return this.files(optRev).collect(function(ea) { return ea.filename() } );
	},

	subdirectories: function(optRev) {
		// remove the first, its the url of the current directory
		var result = this.filesAndDirs(optRev).reject(function(ea) { return ea.isLeaf() });
		result.shift();
		return result;
	},

	subdirectoryNames: function(optRev) {
		return this.subdirectories(optRev).collect(function(ea) { return ea.filename() } );
	},

	fileOrDirectoryExists: function(localname) {
		return new NetRequest().beSync().get(this.url.withFilename(localname)).transport.status != 404;
	},

	writeFileNamed: function(localname, content, contentType) {
		var url = this.url.withFilename(localname);
		var resource = new Resource(Record.newPlainInstance({URL: url}));
		resource.contentType = contentType;
		if(this.writeAsync)
			return resource.store(content, false);
		else
		return resource.store(content, true).getStatus().isSuccess();
	},

	createDirectory: function(localname) {
		return new NetRequest().beSync().mkcol(this.url.withFilename(localname)).getStatus().isSuccess();
	},

	deleteFileNamed: function(localname) {
		return new NetRequest().beSync().del(this.url.withFilename(localname)).getStatus().isSuccess();       
	},

	// Move to somewhere else? Not directory specific...
	copyFile: function(srcUrl, destUrl) {
		return new NetRequest().beSync().copy(srcUrl, destUrl, true /*overwrite*/).getStatus().isSuccess();
	},

	copyFileNamed: function(srcFileName, optRev, destUrl, optNewFileName, contentType) {
		console.log('Copy file ' + srcFileName);
		if (!optNewFileName) optNewFileName = srcFileName;
		var otherDir = new FileDirectory(destUrl);
		otherDir.writeFileNamed(optNewFileName, this.fileContent(srcFileName, optRev, contentType), contentType);
	},

	copyAllFiles: function(destUrl, selectFunc, optRev) {
		var filesToCopy = selectFunc ? this.filenames().select(selectFunc) : this.filenames();
		filesToCopy.each(function(ea) { this.copyFileNamed(ea, optRev, destUrl) }, this);
	},

	copySubdirectory: function(subDirName, newDirName, toUrlOrFileDir, recursively, selectFunc) {
		if (!newDirName) newDirName = subDirName;
		if (!this.subdirectoryNames().include(subDirName)) {
			console.log(this.url.toString() + ' has no subdirectory ' + subDirName);
			return;
		}

		var foreignDir = toUrlOrFileDir.constructor === this.constructor ? toUrlOrFileDir : new this.constructor(toUrlOrFileDir);
		var toUrl = foreignDir.url;
		if (!foreignDir.fileOrDirectoryExists(newDirName)) foreignDir.createDirectory(newDirName);
		var subDir = new this.constructor(this.url.withFilename(subDirName));

		subDir.copyAllFiles(toUrl.withFilename(newDirName), selectFunc);
		subDir.copyAllSubdirectories(toUrl.withFilename(newDirName), recursively, selectFunc);
	},

	copyAllSubdirectories: function(toUrl, recursively, selectFunc) {
		console.log('copying subdirs to url:' + toUrl + ' recursively: ' + recursively + ' selectFunc: ' + selectFunc);
		var dirsToCopy = selectFunc ? this.subdirectoryNames().select(selectFunc) : this.subdirectoryNames();

		dirsToCopy.each(function(ea) { this.copySubdirectory(ea, ea, toUrl, recursively, selectFunc) }, this);
	},

});

Object.extend(FileDirectory, {
	getContent: function(url) {
		url = new URL(url);
		var dir = new FileDirectory(url.getDirectory());
		return dir.fileContent(url.filename());
	},
	setContent: function(url, content) {
		url = new URL(url);
		var dir = new FileDirectory(url.getDirectory());
		return dir.writeFileNamed(url.filename(), content || '');
	},
});

Object.subclass('WebResource', {

	initialize: function(url) {
		this._url = new URL(url);
		this.beSync();
	},

	getURL: function() { return this._url },

	getName: function() { return this.getURL().filename() },

	isSync: function() { return this._isSync },
	
	beSync: function() { this._isSync = true; return this },

	beAsync: function() { this._isSync = false; return this },

	forceUncached: function() {
		this._url = this.getURL().withQuery({time: new Date().getTime()});
		return this;
	},

	// deprecated
	getContent: function(rev, contentType) {
		var resource = new SVNResource(
			this.getURL().toString(),
			Record.newPlainInstance({URL: this.getURL().toString(), ContentText: null}));
		if (contentType)
			resource.contentType = contentType;
		resource.fetch(true, null, rev);
		return resource.getContentText();
	},

	// deprecated
	getDocument: function(rev, contentType) {
		var resource = new SVNResource(
			this.getURL().toString(),
			Record.newPlainInstance({URL: this.getURL().toString(), ContentDocument: null}));
		if (contentType)
			resource.contentType = contentType;
		resource.fetch(true, null, rev);
		return resource.getContentDocument();
	},

	// deprecated
	setContent: function(content, contentType) {
		var resource = new Resource(Record.newPlainInstance({URL: this.getURL().toString()}));
		if (contentType) resource.contentType = contentType;
		resource.store(content, this.isSync());
	},

	// deprecated
	exists: function(optCb) {
		if (this.isSync())
			return new NetRequest().beSync().get(this.getURL()).transport.status < 400;
		var model = {
			setStatus: function(status) { optCb && optCb(status.code < 400) }
		}
		return new NetRequest({model: model, setStatus: "setStatus"}).get(this.getURL());
	},

	isCollection: function() { return !this.getURL().isLeaf() },

	copyTo: function(url) {
		var otherResource = new WebResource(url);
		otherResource.create();
		new NetRequest().copy(this.getURL(), url, true /*overwrite*/);
		return otherResource;
	},

	subElements: function(depth) {
		if (!depth) depth = 1;
		var req = new NetRequest(Record.newPlainInstance({ResponseXML: null, Status: null}));
		req.beSync();
		req.propfind(this.getURL(), depth);
		// FIXME: resolve prefix "D" to something meaningful?
		if (!req.getStatus().isSuccess())
			throw new Error('Cannot access subElements of ' + this.getURL());
		var nodes = new Query("/D:multistatus/D:response").findAll(req.getResponseXML().documentElement)
		nodes.shift(); // remove first since it points to this WebResource
		var result = [];
		for (var i = 0; i < nodes.length; i++) {
			var url = new Query('D:href').findFirst(nodes[i]).textContent;
			if (!/!svn/.test(url)) // ignore svn dirs
				result.push(new WebResource(this.getURL().withPath(url)))
		}
		return result;
	},

	// subCollections: function(depth) {
	// 	return this.subElements(depth).select(function(ea) { return ea.isCollection() });
	// },
	// 
	// subDocuments: function(depth) {
	// 	return this.subElements(depth).select(function(ea) { return !ea.isCollection() });
	// },

	create: function() {
		if (!this.isCollection()) { this.setContent(''); return }
		new NetRequest().beSync().mkcol(this.getURL());
	},

	del: function() {
		new NetRequest().beSync().del(this.getURL());
	},

	toString: function() { return 'WebResource(' + this.getURL() + ')' },
	
});


// make WebResource async
WebResource.addMethods({

	connections: ['status', 'content', 'contentDocument', 'isExisting', 'subCollections', 'subDocuments', 'progress', 'readystate'],

	reset: function() {
		this.status = null;
		this.content = null;
		this.contentDocument = null;
		this.isExisting = null;
		this.subResources = null;
	},

	createResource: function() {
		var self = this;
		var resource = new SVNResource(
			this.getURL().toString(),
			{
				model: {
					getURL: function() { return self.getURL().toString() },
					setRequestStatus: function(reqStatus) { self.status = reqStatus; self.isExisting = reqStatus.isSuccess() },
					setContentText: function(string) { self.content = string },
					setContentDocument: function(doc) { self.contentDocument = doc },
					setProgress: function(progress) { self.progress = progress },
				},
				getURL: 'getURL',
				setRequestStatus: 'setRequestStatus',
				setContentText: 'setContentText',
				setContentDocument: 'setContentDocument',
				setProgress: 'setProgress',
			});
		resource.removeNetRequestReporterTrait();
		return resource
	},

	createNetRequest: function() {
		var self = this;
		var request = new NetRequest({
				model: {
					setStatus: function(reqStatus) { self.status = reqStatus; self.isExisting = reqStatus.isSuccess() },
					setResponseText: function(string) { self.content = string },
					setResponseXML: function(doc) { self.contentDocument = doc },
					setReadyState: function(readyState) { self.readystate = readyState },
					setProgress: function(progress) { self.progress = progress },
					setStreamContent: function(content) { self.content = content },
				},
				setStatus: 'setStatus',
				setResponseText: 'setResponseText',
				setResponseXML: 'setResponseXML',
				setReadyState: 'setReadyState',
				setProgress: 'setProgress',
				setStreamContent: 'setStreamContent',
		});
		if (this.isSync())
			request.beSync();
		return request;
	},

	get: function(rev, contentType) {
		var resource = this.createResource();
		if (contentType)
			resource.contentType = contentType;
		resource.fetch(this.isSync(), null, rev);
		return this
	},

	put: function(content, contentType) {
		if ((Global.Document && content instanceof Document) || (Global.Node && content instanceof Node)) {
			content = Exporter.stringify(content);
		}
		this.content = content;
		var resource = this.createResource();
		if (contentType)
			resource.contentType = contentType;
		resource.store(content, this.isSync());
		return this;
	},

	del: function() {
		var request = this.createNetRequest();
		request.del(this.getURL());
		return this;
	},

	post: function(content, contentType) {
		this.content = content;
		var request = this.createNetRequest();
		if (contentType)
			request.setContentType(contentType);
		request.post(this.getURL(), content);
		return this;
	},
	
	exists: function() {
		// for async use this.get().isExisting directly
		return this.beSync().get().isExisting
	},

	copyTo: function(url) {
		var otherResource = new WebResource(url);
		this.isSync() ? otherResource.beSync() : otherResource.beAsync();
		connect(this, 'content', otherResource, 'put', {removeAfterUpdate: true});
		this.get();
		return otherResource; // better return this for consistency?
	},

	getSubElements: function(depth) {
		if (!depth) depth = 1;
		var req = this.createNetRequest();
		connect(this, 'contentDocument', this, 'pvtProcessPropfind', {removeAfterUpdate: true});
		req.propfind(this.getURL(), depth);
		return this;
	},
	
	pvtProcessPropfind: function(doc) {
		if (!this.status.isSuccess())
			throw new Error('Cannot access subElements of ' + this.getURL());
		// FIXME: resolve prefix "D" to something meaningful?
		var nodes = new Query("/D:multistatus/D:response").findAll(doc.documentElement)
		nodes.shift(); // remove first since it points to this WebResource
		var result = [];
		for (var i = 0; i < nodes.length; i++) {
			var url = new Query('D:href').findFirst(nodes[i]).textContent;
			if (!/!svn/.test(url)) // ignore svn dirs
				result.push(new WebResource(this.getURL().withPath(url)))
		}
		this.subCollections = result.select(function(ea) { return ea.isCollection() });
		this.subDocuments = result.select(function(ea) { return !ea.isCollection() });
	},

});


if (window.shouldShowLoadingMessages) { console.log('loaded Network.js'); }


}); // end of module
avocado.transporter.module.onLoadCallbacks["lk/Network"] = 'done';

avocado.transporter.module.onLoadCallbacks["lk/Data"] = function() {};
/*
 * Copyright (c) 2006-2009 Sun Microsystems, Inc.
 *
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * Data.js.  Data manipulation (mostly XML).
 */

module('lively.Data').requires().toRun(function(thisModule) {
	
View.subclass('Query',  {
    documentation: "Wrapper around XPath evaluation",

    xpe: Global.XPathEvaluator ? new XPathEvaluator() : (console.log('XPath not available') || null),
    
    formals: ["+Results", // Node[]
	   "-ContextNode", // where to evaluate
	  ],

    initialize: function(expression, optPlug) {
	//if (!this.xpe) throw new Error("XPath not available");
	this.contextNode = null;
	this.expression = expression;
	if (optPlug) this.connectModel(optPlug);
    },


    establishContext: function(node) {
	var ctx = node.ownerDocument ? node.ownerDocument.documentElement : node.documentElement;
	if (ctx !== this.contextNode) {
	    this.contextNode = ctx;
	    this.nsResolver = this.xpe.createNSResolver(ctx);
	}
    },

    updateView: function(aspect, controller) {
	var p = this.modelPlug;
	if (!p) return;
	switch (aspect) {
	case p.getContextNode:
	    this.onContextNodeUpdate(this.getContextNode());
	    break;
	}
    },
    
    onContextNodeUpdate: function(node) {
	if (node instanceof Document) node = node.documentElement;
	var result = this.findAll(node, null);
	this.setResults(result);
    },


    findAll: function(node, defaultValue) {
	this.establishContext(node);
	var result = this.xpe.evaluate(this.expression, node, this.nsResolver, XPathResult.ANY_TYPE, null);
	var accumulator = [];
	var res = null;
	while (res = result.iterateNext()) accumulator.push(res);
	return accumulator.length > 0 || defaultValue === undefined ? accumulator : defaultValue;
    },


    findFirst: function(node) {
	this.establishContext(node);
	var result = this.xpe.evaluate(this.expression, node, this.nsResolver, XPathResult.ANY_TYPE, null);
	return result.iterateNext();
    }

});

TextMorph.subclass('XPathQueryMorph', {
    documentation: "TextMorph with an associated contextNode, evals result in evaluating XPath queries",
    
    initialize: function($super, bounds, contextNode) {
	$super(bounds, "");
	this.contextNode = contextNode;
    },

    boundEval: function(str) {    
	var xq = new Query(str);
	return Exporter.stringifyArray(xq.findAll(this.contextNode, []), '\n');
    }

});


/// RSS Feed support (will be rewritten)

lively.data.Wrapper.subclass('FeedChannel', {
    documentation: "Convenience wrapper around RSS Feed Channel XML nodes",

    titleQ: new Query("title"),
    itemQ: new Query("item"),

    initialize: function(rawNode) {
	this.rawNode = rawNode;
        this.items = [];
        var results = this.itemQ.findAll(rawNode);
	
        for (var i = 0; i < results.length; i++) {
            this.items.push(new FeedItem(results[i]));
        }
    },

    title: function() {
	return this.titleQ.findFirst(this.rawNode).textContent;
    }
    
});

lively.data.Wrapper.subclass('FeedItem', {
    documentation: "Convenience wrapper around individual RSS feed items",
    titleQ: new Query("title"),
    descriptionQ: new Query("description"),
    linkQ: new Query("link"),

    initialize: function(rawNode) {
	this.rawNode = rawNode;
    },
    
    title: function() {
	return this.titleQ.findFirst(this.rawNode).textContent;
    },

    description: function() {
	return this.descriptionQ.findFirst(this.rawNode).textContent;
    },

    link: function() {
	return this.linkQ.findFirst(this.rawNode).textContent;
    },
    
});

View.subclass('Feed', NetRequestReporterTrait, {

    // FIXME: merge into Resource
    formals: ["-URL", "+FeedChannels"],
    channelQuery: new Query("/rss/channel"),

    updateView: function(aspect, source) { // model vars: getURL, setFeedChannels
        var p = this.modelPlug;
	if (!p) return;
	switch (aspect) {
	case p.getURL:
	    this.onURLChange(this.getURL());
	    break;
	}
    },

    onURLChange: function(newValue) {
	this.request(newValue);
    },
    
    deserialize: Functions.Empty,

    kickstart: function() {
	if (this.formalModel) this.onURLChange(this.getURL());
	else if (this.modelPlug) this.updateView(this.modelPlug.getURL, this);
    },
    
    setRawFeedContents: function(responseXML) {
	this.setFeedChannels(this.parseChannels(responseXML));
    },
    
    request: function(url) {
        var hourAgo = new Date((new Date()).getTime() - 1000*60*60);
	var req = new NetRequest(Relay.newInstance({ ResponseXML: "+RawFeedContents", Status: "+RequestStatus"}, this));
	req.setContentType('text/xml');
	req.setRequestHeaders({ "If-Modified-Since": hourAgo.toString() });
	console.log("feed requesting " + url);
	req.get(url);
    },

    parseChannels: function(elt) {
	var results = this.channelQuery.findAll(elt);
        var channels = [];
        for (var i = 0; i < results.length; i++) {
	    channels.push(new FeedChannel(results[i]));
        }
	return channels;
    }

});


}); // end of module
avocado.transporter.module.onLoadCallbacks["lk/Data"] = 'done';

avocado.transporter.module.onLoadCallbacks["lk/Storage"] = function() {};
/*
 * Copyright (c) 2006-2009 Sun Microsystems, Inc.
 *
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


/**
 * Storage.js.  Storage system implementation.
 */

module('lively.Storage').requires().toRun(function(module) {


BoxMorph.subclass('PackageMorph', {
    documentation: "Visual representation for a serialized morph",
    style: { borderWidth: 3, borderColor: Color.black,
	     fill: new lively.paint.RadialGradient([new lively.paint.Stop(0, Color.primary.orange), 
						    new lively.paint.Stop(0.3, Color.primary.orange.lighter()),
						    new lively.paint.Stop(1, Color.primary.orange)]), 
	     borderRadius: 6
	   },
    openForDragAndDrop: false,
    suppressHandles: true,
    size: 40,
    
    initialize: function($super, targetMorph) {
	var size = this.size;
	$super(pt(size, size).extentAsRectangle());
        var exporter = new Exporter(targetMorph);
	var helpers = exporter.extendForSerialization();
	if (!this.defs)  
	    this.defs = this.rawNode.insertBefore(NodeFactory.create("defs"), this.rawNode.firstChild);
        this.serialized = this.defs.appendChild(targetMorph.rawNode.cloneNode(true));
	exporter.removeHelperNodes(helpers);
	this.helpText = "Packaged " + targetMorph.getType() + ".\nSelect unpackage from menu to deserialize contents.";
	var delta = this.getBorderWidth()/2;
	var lines = [ 
	    [pt(delta, size/2), pt(size - delta, size/2)],
	    [pt(size/2, delta), pt(size/2, size - delta)] 
	];
	lines.forEach(function(vertices) {
	    var m = new Morph(new lively.scene.Polyline(vertices));
	    m.applyStyle({borderWidth: 3, borderColor: Color.black});
	    m.ignoreEvents();
	    this.addMorph(m);
	}, this);
    },

    getHelpText: function() {
	return this.helpText;
    },
    
    openIn: function(world, loc) {
        world.addMorphAt(this, loc);
    },
    
	morphMenu: function($super, evt) { 
		var menu = $super(evt);
		menu.replaceItemNamed("package", ["unpackage", function(evt) { 
			this.unpackageAt(this.getPosition()); 
		}]);
		menu.replaceItemNamed("show Lively markup", ["show packaged Lively markup", function(evt) {
			this.world().addTextWindow({
				content: Exporter.stringify(this.serialized),
				title: "XML dump",
				position: this.world().positionForNewMorph(null, this)
			});
		}]);
		menu.replaceItemNamed("publish packaged ...", ["save packaged morph as ... ", function() { 
			var node = this.serialized;
			this.world().prompt("save packaged morph as (.xhtml)", function(filename) { 
				filename && Exporter.saveNodeToFile(node, filename) })
		}]);
		return menu;
	},

    unpackageAt: function(loc) {
	if (!this.serialized) {
	    console.log("no morph to unpackage");
	    return;
	}
	var importer = new Importer();
	// var targetMorph = importer.importWrapperFromString(Exporter.stringify(this.serialized));
	var targetMorph = importer.importWrapperFromNode(this.serialized);
	if (targetMorph instanceof WorldMorph) {
	    this.world().addMorph(new LinkMorph(targetMorph, loc));
	    for (var i = 0; i < targetMorph.submorphs.length; i++) {
		var m = targetMorph.submorphs[i];
		if (m instanceof LinkMorph) { 
		    // is it so obvious ? should we mark the link world to the external word?
		    m.myWorld = this.world();
		}
	    }
	    importer.finishImport(targetMorph);
	} else {
	    this.world().addMorphAt(targetMorph, loc);
	    importer.finishImport(this.world());
	}
	this.remove();
    },

    restoreFromSubnode: function($super, importer, node) {
	if (!$super(importer, node)) {
	    if (node.parentNode && node.parentNode.localName == "defs" && node.localName == "g") {
		this.serialized = node;
		console.log("package located " + node);
		return true;
	    } else return false;
	} else return true;
    }
});


lively.data.Wrapper.subclass('lively.Storage.CollectionItem', {
    documentation: "Wrapper around information returned from WebDAV's PROPFIND",

    nameQ: new Query("D:href"),
    propertiesQ: new Query("D:propstat"),
    
    initialize: function(raw, baseUrl) {
        this.rawNode = raw; 
	this.baseUrl = baseUrl;
    },
    
    name: function() {
	// FIXME: resolve prefix "D" to something meaningful?
	var result = this.nameQ.findFirst(this.rawNode);
	if (!result) {
	    console.log("query failed " + Exporter.stringify(this.rawNode));
	    return "?";
	} else 
	    return decodeURIComponent(result.textContent);
    },

    toURL: function() {
		// this doesn't return a correct url when used with proxy, see toURL2
		return this.baseUrl.withPath(this.name());
    },

    toURL2: function() {
		this.baseUrl.withFilename(z.shortName());
    },

    toString: function() {
	return "#<" + this.getType() + "," + this.toURL() + ">";
    },

    shortName: function() {
	var n = this.name();
	var slash = n.endsWith('/') ? n.lastIndexOf('/', n.length - 2) : n.lastIndexOf('/');
	return n.substring(slash + 1);
    },
    
    properties: function() {
	return this.propertiesQ.findAll(this.rawNode).pluck('textContent').join('\n');
    },

	asSVNVersionInfo: function() {
		var r = this.rawNode;
		// FIXME cleanup --> SVNResource>>pvtSetMetadataDoc
		// rk 2/22/10: the namespace tag lp1 is required by Firefox
		var prefix = UserAgent.fireFoxVersion ? 'lp1:' : '';

		var versionTag = r.getElementsByTagName(prefix + 'version-name')[0];
		var rev = versionTag ? Number(versionTag.textContent) : 0;

		var dateTag = r.getElementsByTagName(prefix + 'getlastmodified')[0];
		var date = new Date(dateTag ? dateTag.textContent : 'Mon, 01 Jan 1900 00:00:00 GMT');

		var authorTag = r.getElementsByTagName(prefix + 'creator-displayname')[0];
		var author = authorTag ? authorTag.textContent : 'anonymous';

		return new SVNVersionInfo({rev: rev, date: date, author: author});
	},
});


View.subclass('lively.Storage.WebFile', NetRequestReporterTrait, { 
    documentation: "Read/Write file",     // merge with Resource?
    formals: ["-File", "Content", "+CollectionItems", "+DirectoryList", "-RootNode"],

    initialize: function($super, plug) {
	$super(plug);
	this.lastFile = null;
    },

    deserialize: function() {
	// empty, no state should be needed, other than the modelPlug
    },


    toString: function() {
	return "#<" + this.getType() + "," + this.getFile() + ">";
    },

    startFetchingFile: function() {
		if (this.modelPlug)
			this.updateView(this.modelPlug.getFile, this);
    },

    updateView: function(aspect, source) { // setContent, getContent, getFile
	var p = this.getModel();
	if (!p) return;
	switch (aspect) {
	case p.getFile:
	    var file = this.getFile();
	    if (file)
		this.fetchContent(file);
	    break;
	case p.getContent:
	    var file = this.lastFile; // this.getFile();
	    console.log("saving " + file + " source " + source);
	    if (file)
		this.saveFileContent(file, this.getModelValue('getContent'));
	    break;
	}
    },
    
    fetchContent: function(url, optSync) {
	this.lastFile = url; // FIXME, should be connected to a variable
	if (url.isLeaf()) {
	    var req = new NetRequest({model: this,  // this is not a full model
		setResponseText: "pvtSetFileContent", 
		setStatus: "setRequestStatus"});
	    if (Config.suppressWebStoreCaching)
		req.setRequestHeaders({"Cache-Control": "no-cache"});
	    if (optSync) req.beSync();
	    req.get(url);
	} else {
	    var req = new NetRequest({model: this, setResponseXML: "pvtSetDirectoryContent", 
		setStatus: "setRequestStatus"});
	    if (optSync) req.beSync();
            // initialize getting the content
	    req.propfind(url, 1);
	}
    },


    pvtSetDirectoryContent: function(responseXML) {
	var result = new Query("/D:multistatus/D:response").findAll(responseXML.documentElement);
	var baseUrl = this.getModelValue("getRootNode");
	var colItems = result.map(function(rawNode) { return new module.CollectionItem(rawNode, baseUrl) });
	this.setModelValue("setCollectionItems", colItems);
	var files = colItems.map(function(ea) { return ea.toURL(); });
	files = this.arrangeFiles(files);
	this.setModelValue("setDirectoryList", files);
    },

    saveFileContent: function(url, content) {
	new Resource(Record.newPlainInstance({URL: url})).store(content);
    },

    pvtSetFileContent: function(responseText) {
	this.setModelValue("setContent", responseText);
    },

    arrangeFiles: function(fullList) {
	var dirs = [];
	var second = [];
	var last = [];
	// little reorg to show the more relevant stuff first.
	for (var i = 0; i < fullList.length; i++) {
	    var n = fullList[i];
	    if (n.filename().endsWith('/')) {
		dirs.push(n);
	    } else if (n.filename().indexOf(".#") == -1) {
		second.push(n);
	    } else {
		last.push(n);
	    }
	}
	return dirs.concat(second).concat(last);
    }
    
});



Widget.subclass('TwoPaneBrowser', { // move to Widgets.js sometime

    pins: ["-RootNode", "TopNode", 
	   "UpperNodeList" , "UpperNodeNameList", "SelectedUpperNode", "SelectedUpperNodeName", "-UpperNodeListMenu", 
	   "LowerNodeList", "LowerNodeNameList", "SelectedLowerNode", "SelectedLowerNodeName", "-LowerNodeListMenu", 
	   "+LowerNodeDeletionConfirmation", "-LowerNodeDeletionRequest"],
	   
    initialize: function(rootNode, lowerFetcher, upperFetcher) {
	// this got a bit out of hand
	var model = new SyntheticModel(["RootNode", //: Node, constant
	    "TopNode", //:Node the node whose contents are viewed in the left pane
	    
	    "UpperNodeList",  //:Node[]
	    "UpperNodeNameList", // :String[]
	    "SelectedUpperNode", //:Node
	    "SelectedUpperNodeName", //: String
	    "SelectedUpperNodeContents", //:String
	    "UpperNodeListMenu", 

	    "LowerNodeList",   // :Node[]
	    "LowerNodeNameList", // :String[]
	    "SelectedLowerNode",  // :Node
	    "SelectedLowerNodeName", //:String
	    "SelectedLowerNodeContents", // : String
	    "LowerNodeListMenu",

	    "LowerNodeDeletionRequest", 
	    "LowerNodeDeletionConfirmation"]);
	

	this.connectModel(model.makePlugSpecFromPins(this.pins));
	
	model.setRootNode(rootNode);
	model.setUpperNodeList([rootNode]);
	model.setUpperNodeNameList([this.SELFLINK]);
	model.setTopNode(rootNode);

	this.lowerFetcher = lowerFetcher;
	lowerFetcher.connectModel({model: model, 
				   getRootNode: "getRootNode",
				   getContent: "getSelectedLowerNodeContents",
				   setContent: "setSelectedLowerNodeContents",
				   setDirectoryList: "setLowerNodeList"});

	this.upperFetcher = upperFetcher;
	upperFetcher.connectModel({model: model, 
				   getRootNode: "getRootNode", 
				   getContent: "getSelectedUpperNodeContents",
				   setContent: "setSelectedUpperNodeContents",
				   setDirectoryList: "setUpperNodeList"});

    },

    UPLINK: "<up>",
    SELFLINK: "<top>",
    
    getSelectedLowerNode: function() {
	return this.getModelValue("getSelectedLowerNode");
    },
    
    setSelectedLowerNode: function(url) {
	console.log("setting selected lower to " + url);
	this.setModelValue("setSelectedLowerNode", url);
    },
    
    getSelectedUpperNode: function() {
	return this.getModelValue("getSelectedUpperNode");
    },

    setSelectedUpperNode: function(url) {
	console.log("setting selected upper to " + url);
	return this.setModelValue("setSelectedUpperNode", url);
    },

    clearLowerNodes: function() {
	this.setModelValue("setLowerNodeList", []);
	this.setModelValue("setLowerNodeNameList", []);
	this.setSelectedLowerNode(null);
	this.setModelValue("setSelectedLowerNodeName", null);
	this.setModelValue("setSelectedLowerNodeContents", "");
    },

    getRootNode: function() {
	return this.getModelValue("getRootNode");
    },
    
    getTopNode: function() {
	return this.getModelValue("getTopNode");
    },

    handleUpperNodeSelection: function(upperName) {
	if (!upperName) return;
	if (upperName == this.UPLINK) { 
	    if (this.nodeEqual(this.getTopNode(), this.getRootNode())) {
		// console.log("we are at root, do nothing");
		return;
	    } else {
		var newTop = this.retrieveParentNode(this.getTopNode());
		this.setModelValue("setTopNode", newTop); 
		console.log("walking up to " + newTop);
		
		// copy left pane to right pane 
		this.setModelValue("setLowerNodeList", this.getModelValue("getUpperNodeList")); 
		this.setModelValue("setLowerNodeNameList", this.getModelValue("getUpperNodeNameList"));
		this.setModelValue("setSelectedLowerNodeName", upperName);
		this.setSelectedUpperNode(null);
		this.upperFetcher.fetchContent(newTop);
	    } 
	} else {
	    var newUpper = upperName == this.SELFLINK ? 
		this.getRootNode() : this.deriveChildNode(this.getTopNode(), upperName);
	    this.setSelectedUpperNode(newUpper);
	    this.lowerFetcher.fetchContent(newUpper);
	}
    },

    handleLowerNameSelection: function(lowerName) {
	if (!lowerName) return;
	var selectedUpper = this.getSelectedUpperNode();
	var newNode = (lowerName == this.UPLINK) ? selectedUpper : this.deriveChildNode(selectedUpper, lowerName);
	if (this.isLeafNode(newNode)) {
	    this.setSelectedLowerNode(newNode);
	} else {
	    this.setModelValue("setTopNode", selectedUpper);
	    this.setModelValue("setUpperNodeList", this.getModelValue("getLowerNodeList"));
	    this.setModelValue("setUpperNodeNameList", this.getModelValue("getLowerNodeNameList"));
	    // the above will cause the list to set selection, to a new upper name, which will 
	    // cause the corresp. upper node to be loaded 
	    this.setModelValue("setSelectedUpperNodeName", lowerName); 
	    this.setSelectedUpperNode(newNode);
	    this.setSelectedLowerNode(null);
	    if (lowerName == this.UPLINK) {
		this.clearLowerNodes();
		return;
	    } 
	} 
	this.lowerFetcher.fetchContent(newNode);
    },

    updateView: function(aspect, source) {
	var p = this.modelPlug;
	if (!p) return;
	switch (aspect) {
	case p.getSelectedUpperNodeName:
	    this.handleUpperNodeSelection(this.getModelValue("getSelectedUpperNodeName"));
	    break;

	case p.getSelectedLowerNodeName:
	    this.handleLowerNameSelection(this.getModelValue("getSelectedLowerNodeName"));
	    break;
	    
	case p.getLowerNodeList: 
	    this.setModelValue("setLowerNodeNameList", 
			       this.nodesToNames(this.getModelValue("getLowerNodeList"), 
						 this.getSelectedUpperNode()));
	    break;
	    
	case p.getUpperNodeList: 
	    this.setModelValue("setUpperNodeNameList", 
			       this.nodesToNames(this.getModelValue("getUpperNodeList"), 
						 this.getTopNode()));
	    break;

	case p.getLowerNodeDeletionRequest:
	    this.removeNode(this.getSelectedLowerNode());
	    break;
	}
    },

    removeNode: function(node) {
	console.log("implement remove node?");
    },
    
    buildView: function(extent, model) {
        var panel = PanelMorph.makePanedPanel(extent, [
            ['leftPane', newTextListPane, new Rectangle(0, 0, 0.5, 0.6)],
            ['rightPane', newTextListPane, new Rectangle(0.5, 0, 0.5, 0.6)],
            ['bottomPane', newTextPane, new Rectangle(0, 0.6, 1, 0.4)]
        ]);
        panel.leftPane.connectModel({model: model,
				     getList: "getUpperNodeNameList",
				     getMenu: "getUpperNodeListMenu",
				     setSelection: "setSelectedUpperNodeName", 
				     getSelection: "getSelectedUpperNodeName"});

        var m = panel.rightPane;
        m.connectModel({model: model, getList: "getLowerNodeNameList", setSelection: "setSelectedLowerNodeName", 
			getDeletionConfirmation: "getLowerNodeDeletionConfirmation",
			setDeletionRequest: "setLowerNodeDeletionRequest",
			getMenu: "getLowerNodeListMenu"});
	
	
        panel.bottomPane.connectModel({model: model, 
				       getText: "getSelectedLowerNodeContents", 
				       setText: "setSelectedLowerNodeContents"});
	
	// kickstart
	var im = panel.leftPane.innerMorph();
	im.updateView(im.modelPlug.getList, im);
        return panel;
    },

    getViewTitle: function() {
	var title = new PrintMorph(new Rectangle(0, 0, 150, 15), 'Browser ').beLabel();
	title.formatValue = function(value) { return String(value).truncate(50) }; // don't inspect URLs, just toString() them.
	title.connectModel({model: this.getModel(), getValue: "getTopNode"});
	// kickstart
	title.updateView(title.modelPlug.getValue);
	return title;
    }

});


TwoPaneBrowser.subclass('FileBrowser', {

    initialize: function($super, rootNode) {
	if (!rootNode) rootNode = URL.source.getDirectory();
	$super(rootNode, new module.WebFile(), new module.WebFile());
	var model = this.getModel();
	var browser = this;

	function addSvnItems(url, items) {
	    var svnPath = url.svnWorkspacePath();
	    if (!svnPath) return;
	    items.push(["repository info", function(evt) {
		var m = Record.newPlainInstance({Info: "fetching info"});
		var s = new Subversion();
		s.connectModel(m.newRelay({ServerResponse: "+Info"}));
		var txt = this.world().addTextWindow({
		    acceptInput: false,
		    title: "info " + url,
		    position: evt.point()
		});
		m.addObserver(txt, { Info: "!Text" });
		s.info(svnPath);
	    }]);
	    items.push(["repository diff", function(evt) {
		var m = new SyntheticModel(["Diff"]);
		this.world().addTextWindow({acceptInput: false,
					    plug: {model: m, getText: "getDiff"},
					    title: "diff " + url,
					    position: evt.point() });
		new Subversion({model: m, setServerResponse: "setDiff"}).diff(svnPath);
			       
	    }]);
	    items.push(["repository commit", function(evt) {
		var world = this.world();
		world.prompt("Enter commit message", function(message) {
		    if (!message) {
			// FIXME: pop an alert if message empty
			console.log("cancelled commit");
			return;
		    }
		    var m = new SyntheticModel(["CommitStatus"]);
		    this.world().addTextWindow({acceptInput: false,
						title: "commit " + url, 
						plug: {model: m, getText: "getCommitStatus"}, 
						position: evt.point() });
		    new Subversion({model: m, setServerResponse: "setCommitStatus"}).commit(svnPath, message);
		});
	    }]);
	    items.push(["repository log", function(evt) {
		var world = this.world();
		var url = URL.common.repository.withRelativePath(svnPath);

		var model = Record.newPlainInstance({
		    HeadRevision: 0, 
		    RevisionHistory: null, 
		    ReportDocument: null, 
		    LogItems: null, 
		    URL: url});
		
		var res = new Resource(model.newRelay({URL: "-URL", ContentDocument: "+ReportDocument"}));
		
		var q = new Query("//S:log-item", model.newRelay({ContextNode: "-RevisionHistory",
								  Results: "+LogItems"}));
		
		model.addObserver({  //app logic is here
		    onHeadRevisionUpdate: function(rev) {
			res.fetchVersionHistory(rev, 0, model);
		    },
		    
		    onLogItemsUpdate: function(items) {
			var content = items.map(function(node) { 
			    var creator = node.getElementsByTagName("creator-displayname")[0].textContent;
			    var date = node.getElementsByTagName("date")[0].textContent;
			    var comment = node.getElementsByTagName("comment")[0].textContent;
			    return Strings.format("On %s by %s: %s", date, creator, comment);
			});
			var world = WorldMorph.current();
			
			world.addTextListWindow({ 
			    extent: pt(500, 300), 
			    content: content,
			    title: "log history for " + url.filename(),
			    plug: Record.newPlainInstance({
				List: content,
				Menu: [['show head revision', function() {
				    world.alert('head revision ' + model.getHeadRevision())
				}]]
			    }).newRelay({List: "-List", Menu: "-Menu"})
			});
		    }
		});
		
		res.fetchHeadRevision(model);
		
	    }]);


	    
	}
	function addWebDAVItems(url, items) { 
	    items.push(["get WebDAV info", function(evt) {
		var m = Record.newPlainInstance({ Properties: null, PropertiesString: "", URL: url});
		m.addObserver({  // ad-hoc observer, convenient data conversion
		    onPropertiesUpdate: function(doc) { 
			m.setPropertiesString(Exporter.stringify(doc));
		    }
		});
		
		var txt = this.world().addTextWindow({acceptInput: false,
		    title: url,
		    position: evt.point() });
		txt.connectModel(m.newRelay({Text : "-PropertiesString"}));
		
		var res = new Resource(m);
		// resource would try to use its own synthetic model, which is useless
		res.fetchProperties(m);
		
	    }]);
	    
	}

	model.getUpperNodeListMenu =  function() { // cheating: non stereotypical model
	    var model = this;
	    var selected = model.getSelectedUpperNode();
	    if (!selected) return [];
	    
	    var items = [
		["make subdirectory", function(evt) {
		    var dir = browser.retrieveParentNode(selected);
		    this.world().prompt("new directory name", function(response) {
			if (!response) return;
			var newdir = dir.withFilename(response);
			//console.log("current dir is " + newdir);
			var req = new NetRequest({model: model, setStatus: "setRequestStatus"});
			req.mkcol(newdir);
			// FIXME: reload subnodes
		    });
		}]
	    ];
	    addWebDAVItems(selected, items);
	    addSvnItems(selected, items);
	    return items;
	};

	model.getLowerNodeListMenu =  function() { // cheating: non stereotypical model
	    var items = [];
	    var url = this.getSelectedLowerNode();
	    if (!url) 
		return [];
	    var fileName = url.toString();
	    var model = this;

	    var items = [
		['edit in separate window', function(evt) {
		    this.world().addTextWindow({
			content: "Fetching " + url + "...",
			plug: {model: model, getText: "getSelectedLowerNodeContents", setText: "setSelectedLowerNodeContents"},
			title: url.toString(),
			position: evt.point()
		    });
		    var webfile = new module.WebFile({
			model: model, 
			getFile: "getSelectedLowerNode", 
			setContent: "setSelectedLowerNodeContents",
			getContent: "getSelectedLowerNodeContents" 
		    });
		    webfile.startFetchingFile();
		}],
		["get XPath query morph", browser, "onMenuAddQueryMorph", url],
		["get modification time (temp)", browser, "onMenuShowModificationTime", url] // will go away
	    ];
	    addWebDAVItems(url, items);
	    addSvnItems(url, items);

	    // FIXME if not trunk, diff with trunk here.
	    var shortName = url.filename();
	    if (shortName.endsWith(".xhtml")) {
		items.push(["load into current world", function(evt) {
		    new NetRequest({model: new NetImporter(), setResponseXML: "loadWorldContentsInCurrent", 
				    setStatus: "setRequestStatus"}).get(url);
		}]);
		
		items.push(["load into new linked world", function(evt) {
		    new NetRequest({model: new NetImporter(), setResponseXML: "loadWorldInSubworld",
				    setStatus: "setRequestStatus"}).get(url);
		}]);
		
	    } else if (shortName.endsWith(".js")) {
		items.push(["evaluate as Javascript", function(evt) {
		    var importer = NetImporter();
		    importer.onCodeLoad = function(error) {
			if (error) evt.hand.world().alert("eval got error " + error);
		    }
		    importer.loadCode(url); 
		}]);
	    } else if (FileBrowser.prototype.isGraphicFile(url)) {
		// FIXME tell the browser not to load the contents.
		items.push(["load image", function(evt) {
		    var img = new ImageMorph(rect(pt(0,0), pt(500*2, 380*2)), fileName);
		    evt.hand.world().addFramedMorph(img, shortName, evt.point());
		}]);
	    }
	    
	    if (lively.Tools.SourceControl) {
		var fileName = url.filename();
		items.unshift(['open a changeList browser', function(evt) {
                    var chgList = lively.Tools.SourceControl.changeListForFileNamed(fileName);
		    new ChangeList(fileName, null, chgList).openIn(this.world()); 
		}]);
	    }
	    return items; 
	};

    },
    
    isGraphicFile: function(url) {
	var shortName = url.filename();
	// not extensive
	return (shortName.endsWith(".jpg") || shortName.endsWith(".PNG") || shortName.endsWith(".png"));
    },


    onMenuAddQueryMorph: function(url, evt) {
	var req = new NetRequest().beSync();
	var doc = req.propfind(url, 1).getResponseXML(); // FIXME: make async
	var m = new XPathQueryMorph(new Rectangle(0, 0, 500, 200), doc.documentElement);
	evt.hand.world().addFramedMorph(m, url.toString(), evt.point());
    },

    onMenuShowModificationTime: function(url, evt) {
	// to be removed
	var model = new SyntheticModel(["InspectedNode", "ModTime"]);
	var res = new Resource({model: model, setContentDocument: "setInspectedNode" });
	var query = new Query("/D:multistatus/D:response/D:propstat/D:prop/D:getlastmodified", 
	    {model: model, getContextNode: "getInspectedNode", setResults: "setModTime"});
	res.fetchProperties(model, true);
	evt.hand.world().alert('result is ' + Exporter.stringifyArray(model.getModTime(), '\n'));
    },
    
    removeNode: function(url) {
	var model = this.getModel();
	if (!url.isLeaf()) {
	    WorldMorph.current().alert("will not erase directory " + url);
	    model.setLowerNodeDeletionConfirmation(false);
	    return;
	}
	
        WorldMorph.current().confirm("delete resource " + url, function(result) {
	    if (result) {
		var eraser = { 
		    setRequestStatus: function(status) { 
			if (status.isSuccess()) 
			    model.setLowerNodeDeletionConfirmation(true);
			NetRequestReporterTrait.setRequestStatus.call(this, status);
		    }
		};
		new NetRequest({model: eraser, setStatus: "setRequestStatus"}).del(url);
	    } else console.log("cancelled removal of " + url);
	});
    },


    retrieveParentNode: function(node) {
	return node.getDirectory();
    },

    nodesToNames: function(nodes, parent) {
	var UPLINK = this.UPLINK;
	// FIXME: this may depend too much on correct normalization, which we don't quite do.
	return nodes.map(function(node) { return node.eq(parent) ?  UPLINK : node.filename()});
    },

    isLeafNode: function(node) {
	return node.isLeaf();
    },
    
    deriveChildNode: function(parentNode, childName)  {
	return parentNode.withFilename(childName);
    },

    nodeEqual: function(n1, n2) {
	return n1.eq(n2);
    }

	
});


View.subclass('lively.Storage.DOMFetcher', {

    initialize: function($super, plug) {
	$super(plug);
	this.lastNode = null;
    },

    updateView: function(aspect, source) { // setContent, getContent, getFile
	var p = this.modelPlug;
	if (!p) return;
	switch (aspect) {
	case p.getContent:
	    var file = this.lastNode; // this.getFile();
	    console.log("!not saving " + file + " source " + source);
	    break;
	}
    },
    
    fetchContent: function(node) {
	console.log("fetching " + node);
	this.lastNode = node; // FIXME, should be connected to a variable
	var nodes = [];
	for (var n = node.firstChild; n != null; n = n.nextSibling)
	    nodes.push(n);
	this.setModelValue("setDirectoryList", nodes);
	
	var info;
	if (node.nodeType !== Node.ELEMENT_NODE) {
	    info = node.textContent;
	} else {
	    info = "tagName=" + node.tagName;
	    
	    if (node.attributes) {
		var attributes = [];
		for (var i = 0; i < node.attributes.length; i++)  {
		    var a = node.attributes[i];
		    info += "\n" + a.name + "=" + a.value;
		}
	    }
	}
	this.setModelValue("setContent", info);
    }

});


TwoPaneBrowser.subclass('DOMBrowser', {

    // indexed by Node.nodeType
    nodeTypes: [ "", "Node", "Attribute", "Text", "CData", "EntityReference", "Entity", "ProcessingInstruction", 
		 "Comment", "Document", "DocumentType", "DocumentFragment", "Notation"],

    initialize: function($super, element) {
	$super(element || document.documentElement, new module.DOMFetcher(), new module.DOMFetcher());
    },

    nodesToNames: function(nodes, parent) {
	// FIXME: this may depend too much on correct normalization, which we don't quite do.
	var result = [];
	var nodeTypes = this.nodeTypes;
	function printNode(n) {
	    var id = n.getAttribute && n.getAttribute("id");
	    var t = n.getAttributeNS && LivelyNS.getType(n);
	    return (n.nodeType == Node.ELEMENT_NODE ? n.tagName : nodeTypes[n.nodeType]) 
		+ (id ? ":" + id : "") + (t ? ":" + t : "");
	}
	
	for (var i = 0; i < nodes.length; i++) {
	    result[i] = String(i) + ":" + printNode(nodes[i]);
	}
	result.unshift(this.UPLINK);
	return result;
    },

    retrieveParentNode: function(node) {
	return node.parentNode;
    },

    isLeafNode: function(node) {
	return !node || node.firstChild == null;
    },

    deriveChildNode: function(parentNode, childName)  {
	var index = parseInt(childName.substring(0, childName.indexOf(':')));
	if (isNaN(index))
	    return parentNode;
	else 
	    return parentNode && parentNode.childNodes.item(index);
    },

    nodeEqual: function(n1, n2) {
	return n1 === n2;
    }
    
});


// move elsewhere
View.subclass('ObjectFetcher', {

    initialize: function($super, plug) {
	$super(plug);
	this.lastNode = null;
    },

    updateView: function(aspect, source) { // setContent, getContent, getFile
	var p = this.modelPlug;
	if (!p) return;
	switch (aspect) {
	case p.getContent:
	    var file = this.lastNode; // this.getFile();
	    console.log("!not saving " + file + " source " + source);
	    break;
	}
    },
    
    fetchContent: function(node) {
	console.log("fetching properties of " + node);
	this.lastNode = node; // FIXME, should be connected to a variable
	// console.log("properties are " + Properties.all(node));
	var values = Properties.own(node).map(function(name) { return node[name]; });
	this.setModelValue("setDirectoryList", values);
	this.setModelValue("setContent", Object.inspect(node));
    }

});



TwoPaneBrowser.subclass('TwoPaneObjectBrowser', {
    // clearly not quite finished

    initialize: function($super) {
	$super(WorldMorph.current(), new ObjectFetcher(), new ObjectFetcher());
    },

    nodesToNames: function(nodes, parent) {
	var props = Properties.own(parent);
	var names = [];
	// FIXME! ouch quadratic
	for (var i = 0; i < nodes.length; i++) 
	    for (var j = 0; j < props.length; j++) {
		if (parent[props[j]] === nodes[i] && nodes[i])
		    names[i] = props[j];
	    }
	names.unshift(this.UPLINK);
	
	return names;
    },


    retrieveParentNode: function(node) {
	return this.getRootNode(); // ???
    },

    isLeafNode: function(node) {
	return Properties.own(node).length == 0;
    },

    deriveChildNode: function(parentNode, childName)  {
	return parentNode[childName];
    },

    nodeEqual: function(n1, n2) {
	return n1 === n2;
    }
    
});


// deprecated?
View.subclass('Subversion',  NetRequestReporterTrait, {
    documentation: "A simple subversion client",
    
    pins:["ServerResponse"],

    initialize: function($super, plug) {
	$super(plug);
	this.server = new URL(URL.source);
	this.server.port = Config.personalServerPort; 
	this.server.search = undefined;
	this.server.pathname = "/trunk/source/server/svn.sjs";
	this.setModelValue("setServerResponse", "");
    },

    diff: function(repoPath) {
	var req = new NetRequest(Relay.newInstance({Status: "+RequestStatus", ResponseText: "+SubversionResponse"}, this));
	this.setModelValue("setServerResponse", "");
	req.get(this.server.withQuery({command: "diff " + (repoPath || "")}));
    },

    info: function(repoPath) {
	var req = new NetRequest(Relay.newInstance({Status: "+RequestStatus", ResponseText: "+SubversionResponse"}, this));
	// use space as argument separator!
	return req.get(this.server.withQuery({command: "info " + (repoPath|| "")}));
    },
    
    commit: function(repoPath, message) {
	var req = new NetRequest(Relay.newInstance({Status: "+RequestStatus", ResponseText: "+SubversionResponse"}, this));
	// use space as argument separator!
	return req.get(this.server.withQuery({command: "commit " + (repoPath || "") + ' -m "' + message + '"'}));
    },

    setSubversionResponse: function(txt) {	
	this.setModelValue("setServerResponse", txt);
    }

});

if (window.shouldShowLoadingMessages) { console.log('loaded Storage.js'); }


}); // end of module

avocado.transporter.module.onLoadCallbacks["lk/Storage"] = 'done';

avocado.transporter.module.onLoadCallbacks["lk/bindings"] = function() {};
module('lively.bindings').requires().toRun(function() {

Object.subclass('AttributeConnection', {

	initialize: function(source, sourceProp, target, targetProp, spec) {
		this.sourceObj = source;
		this.sourceAttrName = sourceProp;
		this.targetObj = target;
		this.targetMethodName = targetProp;
		if (spec) {
			this.removeAfterUpdate = spec.removeAfterUpdate;
			// when converter function references objects from its environment we can't
			// serialize it. To fail as early as possible we will serialize the converter
			// already here
			this.converter = spec.converter ? eval('(' + spec.converter.toString() + ')') : null
		}
	},

	getTargetObj: function() { return this.targetObj },

	getSourceObj: function() { return this.sourceObj },

	getSourceAttrName: function() { return this.sourceAttrName },

	getTargetMethodName: function() { return this.targetMethodName },

	privateAttrName: function(attrName) { return '$$' + attrName },

	connect: function() {
		var existing = this.getExistingConnection()
		if (existing !== this) {
			// when existing == null just add new connection
			// when existing === this then connect was called twice or we are
			//    in deserialization. Just do nothing then.
			existing && existing.disconnect();
			this.addAttributeConnection();
		}
		var setter = this.sourceObj.__lookupSetter__(this.sourceAttrName);
		if (!setter)
			this.addSourceObjGetterAndSetter()
		return this;
	},

	disconnect: function() {
		var obj = this.sourceObj;
		if (!obj.attributeConnections) return;
		obj.attributeConnections = obj.attributeConnections.reject(function(con) {
			return this.isSimilarConnection(con);
		}, this);
		var connectionsWithSameSourceAttr = obj.attributeConnections.select(function(con) {
			return this.getSourceAttrName() == con.getSourceAttrName();
		}, this);
		if (connectionsWithSameSourceAttr.length == 0)
			this.removeSourceObjGetterAndSetter()
	},

	addSourceObjGetterAndSetter: function() {
		var
			sourceObj = this.sourceObj,
			sourceAttrName = this.sourceAttrName,
			newAttrName = this.privateAttrName(sourceAttrName);

		if (sourceObj[newAttrName])
			throw new Error('newAttrName ' + newAttrName + ' already exists. Are there already other connections?');

		// add new attr to the serialization ignore list
		if (sourceObj.doNotSerialize !== undefined && sourceObj.doNotSerialize.push)
			sourceObj.doNotSerialize.push(newAttrName);

		// assign old value to new slot
		sourceObj[newAttrName] = sourceObj[sourceAttrName];

		this.sourceObj.__defineSetter__(sourceAttrName, function(newVal) {
			sourceObj[newAttrName] = newVal;
			if (sourceObj.attributeConnections === undefined)
				throw new Error('Sth wrong with sourceObj, has no attributeConnections')
			for (var i = 0; i < sourceObj.attributeConnections.length; i++) {
				var c = sourceObj.attributeConnections[i];
				if (c.getSourceAttrName() == sourceAttrName)
					c.update(newVal);
			}
		})

		this.sourceObj.__defineGetter__(this.sourceAttrName, function() {
			return sourceObj[newAttrName];
		})
	},

	removeSourceObjGetterAndSetter: function() {
		// delete the getter and setter and the slot were the real value was stored
		// assign the real value to the old slot
		var attrName = this.privateAttrName(this.sourceAttrName);
		delete this.sourceObj[this.sourceAttrName];
		this.sourceObj[this.sourceAttrName] = this.sourceObj[attrName];
		delete this.sourceObj[attrName];
	},

	addAttributeConnection: function() {
		if (!this.sourceObj.attributeConnections)
			this.sourceObj.attributeConnections = [];
		this.sourceObj.attributeConnections.push(this);
	},

	getExistingConnection: function() {
		var conns = this.sourceObj.attributeConnections;
		if (!conns) return null;
		for (var i = 0; i < conns.length; i++)
			if (this.isSimilarConnection(conns[i]))
				return conns[i];
	},

	update: function(newValue) {
		if (this.isRecursivelyActivated()) return;
		try {
			this.activate();
			if (this.converter)
				newValue = this.converter.call(this, newValue);
			if (Object.isFunction(this.targetObj[this.targetMethodName]))
				this.targetObj[this.targetMethodName](newValue);
			else
				this.targetObj[this.targetMethodName] = newValue;
		} catch(e) {
			console.warn('Error when trying to update ' + this + ' with value ' + newValue + ':\n' + e);
		} finally {
			this.deactivate();
			if (this.removeAfterUpdate) this.disconnect();
		}
	},
	isRecursivelyActivated: function() {
		// is this enough? Maybe use Stack?
		return this.isActive
	},

	activate: function() { this.isActive = true },

	deactivate: function() { this.isActive = false },

	isSimilarConnection: function(other) {
		if (!other) return;
		if (other.constructor != this.constructor) return false;
		return this.sourceObj == other.sourceObj &&
			this.sourceAttrName == other.sourceAttrName &&
			this.targetObj == other.targetObj &&
			this.targetMethodName == other.targetMethodName
	},

	onSourceAndTargetRestored: function() {
		if (this.sourceObj && this.targetObj) this.connect();
	},

	toString: function() {
		return Strings.format('AttributeConnection(%s.%s --> %s.%s())',
			this.getSourceObj(),
			this.getSourceAttrName(),
			this.getTargetObj(),
			this.getTargetMethodName());
	},

});

AttributeConnection.addMethods({
	toLiteral: function() {
		if (!this.sourceObj || !this.sourceObj.id || !this.targetObj || !this.targetObj.id) {
			console.warn('Cannot serialize objects having no id');
			return {
				sourceObj: null,
				sourceAttrName: this.sourceAttrName,
				targetObj: null,
				targetMethodName: this.targetMethodName,
				converter: null,
				removeAfterUpdate: this.removeAfterUpdate,
			}; 
		};
		return {
			sourceObj: this.sourceObj.id(),
			sourceAttrName: this.sourceAttrName,
			targetObj: this.targetObj.id(),
			targetMethodName: this.targetMethodName,
			converter: this.converter ? this.converter.toString() : null,
			removeAfterUpdate: this.removeAfterUpdate,
		};
	},
})

Object.extend(AttributeConnection, {
	fromLiteral: function(literal, importer) {
		if (!importer)
			throw new Error('AttributeConnection needs importer for resolving uris!!!');

		// just create the connection, connection not yet installed!!!
		var con = new AttributeConnection(
			null, literal.sourceAttrName, null, literal.targetMethodName,
			{converter: literal.converter, removeAfterUpdate: literal.removeAfterUpdate});

		importer.addPatchSite(con, 'sourceObj', literal.sourceObj);
		importer.addPatchSite(con, 'targetObj', literal.targetObj);

		new AttributeConnection(con, 'sourceObj', con, 'onSourceAndTargetRestored', {removeAfterUpdate: true}).connect();
		new AttributeConnection(con, 'targetObj', con, 'onSourceAndTargetRestored', {removeAfterUpdate: true}).connect();

		return con;
	}
});

Object.extend(lively.bindings, {
	
	connect: function connect(sourceObj, attrName, targetObj, targetMethodName, specOrConverter) {
		if (Object.isFunction(specOrConverter)) {
			console.warn('Directly passing a converter function to connect() is deprecated! Use spec object instead!');
			spec = {converter: specOrConverter};
		} else {
			spec = specOrConverter;
		}
		return new AttributeConnection(sourceObj, attrName, targetObj, targetMethodName, spec).connect();
	},
	
	disconnect: function(sourceObj, attrName, targetObj, targetMethodName) {
		if (!sourceObj.attributeConnections) return;
		sourceObj.attributeConnections.select(function(con) {
			return 	con.getSourceAttrName() == attrName &&
					con.getTargetObj() === targetObj &&
					con.getTargetMethodName() == targetMethodName;
		}).forEach(function(con) { con.disconnect() });
	},
	
	disconnectAll: function(sourceObj) {
		if (!sourceObj.attributeConnections) return;
		while (sourceObj.attributeConnections.length > 0)
			sourceObj.attributeConnections[0].disconnect()
	},
	
	signal: function(sourceObj, attrName, newVal) {
		if (!sourceObj.attributeConnections) return;
		for (var i = 0; i < sourceObj.attributeConnections.length; i++) {
			var c = sourceObj.attributeConnections[i];
			if (c.getSourceAttrName() == attrName) c.update(newVal);
		}
	},

})

Object.extend(Global, {
	connect: lively.bindings.connect,
	disconnect: lively.bindings.disconnect,
	disconnectAll: lively.bindings.disconnectAll,
	signal: lively.bindings.signal,
	updateAttributeConnection: lively.bindings.signal,
});
	
}); // end of module
avocado.transporter.module.onLoadCallbacks["lk/bindings"] = 'done';

avocado.transporter.module.onLoadCallbacks["lk/Tools"] = function() {};
/*
 * Copyright (c) 2006-2009 Sun Microsystems, Inc.
 *
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * Tools.js.  This file defines various tools such as the class browser,
 * object inspector, style editor, and profiling and debugging capabilities.  
 */

module('lively.Tools').requires('lively.Text', 'lively.bindings').toRun(function(module, text) {

// ===========================================================================
// Class Browser -- A simple browser for Lively Kernel code
// ===========================================================================

Widget.subclass('SimpleBrowser', {

    viewTitle: "Javascript Code Browser",
    pins: ["+ClassList", "-ClassName", "+MethodList", "-MethodName", "MethodString", "+ClassPaneMenu"],

    initialize: function($super) { 
        var model = new SyntheticModel(this.pins);
        var plug = model.makePlugSpecFromPins(this.pins);
        $super(plug); 
        this.scopeSearchPath = [Global];
        model.setClassList(this.listClasses());
        // override the synthetic model logic to recompute new values
        var browser = this;
        model.getClassPaneMenu = function() {
           return browser.getClassPaneMenu();
        }
    },

    updateView: function(aspect, source) {
        var p = this.modelPlug;
        if (!p) return;

        switch (aspect) {
        case p.getClassName:
            var className = this.getModelValue('getClassName');
        this.setModelValue("setMethodList", this.listMethodsFor(className));
        break;
        case p.getMethodName:
            var methodName = this.getModelValue("getMethodName");
            var className = this.getModelValue("getClassName");
            var source = this.getMethodStringFor(className, methodName);    
            this.setModelValue("setMethodString", source);
            break;
        case p.getMethodString:
            var className = this.getModelValue("getClassName");
            var methodName = this.getModelValue("getMethodName");
            var methodString = this.getModelValue("getMethodString");
            var methodDef = className + ".prototype." + methodName + " = " + methodString;
	    try {
                eval(methodDef);
            } catch (er) {
                WorldMorph.current().alert("error evaluating method " + methodDef);
            }
            ChangeSet.current().logChange({type: 'method', className: className, methodName: methodName, methodString: methodString});
            break;
        }
    },

    listClasses: function() { 
        return Global.classes(true)
		.collect(function(ea) {return Class.className(ea)})
		.select(function(ea) {return !ea.startsWith("anonymous")})
		.concat(["Global"])
		.sort();  
    },


    listMethodsFor: function(className) {
        if (className == null) return [];
        var sorted = (className == 'Global')
            ? this.functionNames(Global).sort()
            : Class.forName(className).localFunctionNames().sort();
        var defStr = "*definition";
        var defRef = module.SourceControl && module.SourceControl.getSourceInClassForMethod(className, defStr);
        return defRef ? [defStr].concat(sorted) : sorted;
    },
    
    functionNames: function(namespace) {
	// This logic should probably be in, eg, Namespace.functionNames()
	return Object.keys(namespace)
		.select(function(ea) {
			var func = namespace[ea];
			return func && !Class.isClass(func) && Object.isFunction(func) && !func.declaredClass})
		.collect(function(ea) { return namespace[ea].name || ea})
    },
    
    getMethodStringFor: function(className, methodName) { 
        if (!className || !methodName) return "no code"; 
	if (module.SourceControl) 
	    var source = module.SourceControl.getSourceInClassForMethod(className, methodName);
	    if(source) return source;
	var func = (className == "Global") ? Global[methodName] : Class.forName(className).prototype[methodName];
	if (!func) return "-- no code --";
	if (module.SourceControl) return "// **Decompiled code** //\n" + func.getOriginal().toString();
	return func.getOriginal().toString();
    },
    
    buildView: function(extent) {
        var panel = PanelMorph.makePanedPanel(extent, [
            ['leftPane', newTextListPane, new Rectangle(0, 0, 0.5, 0.5)],
            ['rightPane', newTextListPane, new Rectangle(0.5, 0, 0.5, 0.5)],
            ['bottomPane', newTextPane, new Rectangle(0, 0.5, 1, 0.5)]
        ]);
        var model = this.getModel();
        var m = panel.leftPane;
        m.connectModel({model: model, getList: "getClassList", setSelection: "setClassName", getSelection: "getClassName", getMenu: "getClassPaneMenu"});
        m.updateView("getClassList");
        m = panel.rightPane;
        m.connectModel({model: model, getList: "getMethodList", setSelection: "setMethodName"});
        m = panel.bottomPane;
        m.innerMorph().getTextSelection().borderRadius = 0;
        m.connectModel({model: model, getText: "getMethodString", setText: "setMethodString", getMenu: "default"});
        return panel;
    },

    getClassPaneMenu: function() {
        var items = [];
        var className = this.getModelValue("getClassName");
dbgOn(true);
        if (className != null) {
            var theClass = Class.forName(className);
            items.push(['make a new subclass', 
                    function() { WorldMorph.current().prompt("name of subclass", this.makeSubclass.bind(this));}.bind(this)]);
            if (theClass.prototype != null) {
                items.push(['profile selected class', 
                    function() { showStatsViewer(theClass.prototype, className + "..."); }]);
            }
        }
        if (!URL.source.protocol.startsWith("file")) {
            items.push(['import source files', function() {
                if (! module.SourceControl) module.SourceControl = new SourceDatabase();
                // Note: the list isn't used anymore in importKernelFiles!
                module.SourceControl.importKernelFiles(["JSON.js", "miniprototype.js", "defaultconfig.js", "localconfig.js", "Base.js", "scene.js", "Core.js", "Text.js", "Widgets.js", "Network.js", "Data.js", "Storage.js", "Tools.js", "Examples.js", "Main.js"]);
                WorldMorph.current().setFill(new lively.paint.RadialGradient([Color.rgb(36,188,255), 1, Color.rgb(127,15,0)]));
            }]);
        }
        if (!Config.debugExtras) {
            items.push(['enable call tracing', function() {
                Config.debugExtras = true;
		lively.lang.Execution.installStackTracers();  
            }]);
        }
	items.push(["test showStack (in console)", lively.lang.Execution.showStack.curry(false)]);
	items.push(["test showStack (in viewer)", lively.lang.Execution.showStack.curry(true)]);
        if (Config.debugExtras) {
	    items.push(["test profiling (in console)", lively.lang.Execution.testTrace]);
	    items.push(["test tracing (in console)", this.testTracing]);
            items.push(['disable call tracing', function() {
                Config.debugExtras = false;
		lively.lang.Execution.installStackTracers("uninstall"); 
            }]);
        }
        return items; 
    },
    makeSubclass: function(subName) {
        var className = this.getModelValue("getClassName");
        var theClass = Class.forName(className);
	theClass.subclass(subName, {});
	// Need to regenerate the class list and select the new sub
        this.getModel().setClassList(this.listClasses());
        this.getModel().setClassName(subName);
	var doitString = className + '.subclass("' + subName + '", {})';
	ChangeSet.current().logChange({type: 'subclass', className: className, subName: subName});

    },
    testTracing: function() {
	console.log("Function.prototype.logAllCalls = true; tracing begins...");
	Function.prototype.logAllCalls = true;
	this.toString();
	Function.prototype.logAllCalls = false;
    }
});
   
// ===========================================================================
// Object Hierarchy Browser
// ===========================================================================

WidgetModel.subclass('ObjectBrowser', {

    viewTitle: "Object Hierarchy Browser",
    openTriggerVariable: 'getObjectList',

    initialize: function($super, objectToView) {
        $super();
        this.fullPath     = ""; // The full pathname of the object (string)
        this.nameToView   = ""; // Current name ("node") that we are viewing
        this.objectToView = objectToView || Global; // Start by viewing the Global namespace if no argument
        return this;
    },

    getObjectList: function() {
        var list = [];
        for (var name in this.objectToView) list = list.concat(name);
        list.sort();

        // The topmost row in the object list serves as the "up" operation.
        list.unshift("..");

        if (this.panel) {
            var nameMorph = this.panel.namePane;
            var path = (this.fullPath != "") ? this.fullPath : "Global";
            nameMorph.setTextString(path);
        }

        return list;
    },

    setObjectName: function(n) {
        if (!n) return;

        // Check if we are moving up in the object hierarchy
        if (n.substring(0, 2) == "..") {
            var index = this.fullPath.lastIndexOf(".");
            if (index != -1) {
                this.fullPath     = this.fullPath.substring(0, index);
                this.objectToView = eval(this.fullPath);
            } else {
                this.fullPath     = "";
                this.objectToView = Global;
            }
            this.nameToView = "";
            this.changed("getObjectList");
            return;
        }

        // Check if we are "double-clicking" or choosing another item
        if (n != this.nameToView) {
            // Choosing another item: Get the value of the selected item
            this.nameToView = n;
            this.changed("getObjectValue");
        } else {
            // Double-clicking: Browse child
            if (this.fullPath != "") this.fullPath += ".";

            if ((this.objectToView instanceof Array) && !isNaN(parseInt(n))) {
                this.fullPath += "[" + n + "]";
            } else {
                this.fullPath += this.nameToView;
            }
            this.objectToView = eval(this.fullPath);
            // if (!this.objectToView) this.objectToView = Global;
            this.nameToView = "";
            this.changed("getObjectList");
        }
    },

    getObjectValue: function() {
        if (!this.objectToView || !this.nameToView || this.nameToView == "") return "(no data)";
        return Object.inspect(this.objectToView[this.nameToView]);
    },

    setObjectValue: function(newDef) { eval(newDef); },

    buildView: function(extent) {
        var panel = PanelMorph.makePanedPanel(extent, [
            ['namePane', TextMorph, new Rectangle(0, 0, 1, 0.07)],
            ['topPane', newTextListPane, new Rectangle(0, 0.07, 1, 0.5)],
            ['bottomPane', newTextPane, new Rectangle(0, 0.5, 1, 0.5)]
        ]);

        this.panel = panel;

        var m = panel.topPane;
        m.connectModel({model: this, getList: "getObjectList", setSelection: "setObjectName"});
        m = panel.bottomPane;
        m.connectModel({model: this, getText: "getObjectValue", setText: "setObjectValue"});

        return panel;
    }

});

// ===========================================================================
// Object Inspector
// ===========================================================================

Widget.subclass('SimpleInspector', {

    description: "A simple JavaScript object (instance) inspector",

    initialViewExtent: pt(400,250),

    formals: ["+PropList", "PropName", "+PropText", "-Inspectee"],
    
    initialize: function($super, targetMorph) {
        $super();
        this.relayToModel(Record.newPlainInstance({PropList: [], PropName: null, Inspectee: targetMorph, PropText: "",
						   PropMenu: [['inspect selection', function() { 
						       var name = this.getPropName();
						       if (!name) return;
						       new SimpleInspector(this.propValue(name)).open()}.bind(this)]]}));
    },
   
    onPropTextUpdate: function(input, source) {
		if (source === this) return;
        var propName = this.getPropName();
        if (propName) {
			var target = this.getInspectee();
			try {
				var result = (interactiveEval.bind(this.target))(input);
			} catch (er) {
				throw dbgOn(er);
			};
			// and what if the value is false?
			if (!result) { console.log('no changes in inspector'); return; }
			console.log("inspector set " + propName + " from " + target[propName] + " to " + result)
			target[propName] = result;
        }
    },

    onInspecteeUpdate: function(inspectee) {
	this.setPropList(Properties.all(inspectee));
    },

    onPropNameUpdate: function(propName) {
        var prop = this.propValue(propName);
		if (prop == null) {
            this.setPropText("----");
        } else {
            this.setPropText(Strings.withDecimalPrecision(Object.inspect(prop), 2));
        }
    },

    
    propValue: function(propName) {
        var target = this.getInspectee();
        return target ? target[propName] : undefined;
    },

    getViewTitle: function() {
        return Strings.format('Inspector (%s)', this.getInspectee()).truncate(50);
    },

    /*
    openIn: function(world, location) {
        // DI: experimental continuous update feature.  It works, but not removed upon close
        // var rightPane = window.targetMorph.rightPane.innerMorph();
        // rightPane.startStepping(1000, 'updateView', 'getPropText');
    },
   */

    buildView: function(extent, model) {
        var panel = PanelMorph.makePanedPanel(extent, [
            ['leftPane', newTextListPane, new Rectangle(0, 0, 0.5, 0.6)],
            ['rightPane', newTextPane, new Rectangle(0.5, 0, 0.5, 0.6)],
            ['bottomPane', newTextPane, new Rectangle(0, 0.6, 1, 0.4)]
        ]);
	
	var model = this.getModel();
	
	panel.leftPane.relayToModel(model, {List: "-PropList", Selection: "+PropName", Menu: "-PropMenu"});
	
	panel.rightPane.relayToModel(model, {Text: "PropText", DoitContext: "-Inspectee"});

	
	var m = panel.bottomPane;
	m.relayToModel(model, {DoitContext: "-Inspectee"});
        m.innerMorph().setTextString("doits here have this === inspectee");

        var widget = this;
        panel.morphMenu = function(evt) { // offer to inspect the current selection
            var menu = Class.getPrototype(this).morphMenu.call(this, evt);
            if (!widget.propValue(widget.getPropName())) return menu;
            menu.addLine();
            menu.addItem(['inspect selection', function() { 
                new SimpleInspector(widget.propValue(widget.getPropName())).open()}])
            return menu; 
        }
	// FIXME: note that we already relay to a model
	this.relayToModel(model, {PropList: "+PropList", PropName: "PropName", 
				  PropText: "PropText", Inspectee: "-Inspectee"}, true);

        return panel;
    }

});
Object.extend(SimpleInspector, {
	inspectObj: function(object) {
    	new SimpleInspector(object).openIn(WorldMorph.current(), pt(200,10))
	}
});

// ===========================================================================
// Style Editor Panel
// ===========================================================================
Widget.subclass('StylePanel', {

	documentation: "Interactive style editor for morphs",
	initialViewExtent: pt(340,100),
	viewTitle: "Style Panel",

	initialize: function($super, targetMorph) {
		$super();
		this.targetMorph = targetMorph;
		this.sendLayoutChanged = true;	// force propagation of changes
		var spec = targetMorph.makeStyleSpec();
		this.actualModel = Record.newPlainInstance({
			BorderWidth: spec.borderWidth,
			BorderColor: spec.textColor,
			BorderRadius: spec.borderRadius,
			FillOpacity: spec.fillOpacity,
			StrokeOpacity: spec.strokeOpacity,
			FontSize: String(spec.fontSize || TextMorph.prototype.fontSize),
			FontFamily: spec.fontFamily || TextMorph.prototype.fontFamily, 
			FillType: "simple", 
			FillDir: null, 
			Color1: null, 
			Color2: null,
			TextColor: null
		}); 
		this.actualModel.addObserver(this);
		this.color1 = null;
		this.color2 = null;
		this.fillDir = null;
		this.fillType = this.actualModel.getFillType();
		var base = targetMorph.getFill();
		this.baseColor = (base instanceof lively.paint.Gradient) ? base.stops[0].color() : base;
	},

	onBorderWidthUpdate: function(w) {
		this.targetMorph.setBorderWidth(w.roundTo(0.1));
		if (this.sendLayoutChanged) this.targetMorph.layoutChanged();
	},

	onBorderColorUpdate: function(c) { // Maybe add a little color swatch in the view
		this.targetMorph.setBorderColor(c);
		if (this.sendLayoutChanged) this.targetMorph.layoutChanged();
	},
	
	onBorderRadiusUpdate: function(r) {
		this.targetMorph.shapeRoundEdgesBy(r.roundTo(1));
		if (this.sendLayoutChanged) this.targetMorph.layoutChanged();
	},

	onFillTypeUpdate: function(type) { this.fillType = type; this.setFill(); },
	onFillDirUpdate: function(dir) { this.fillDir = dir;  this.setFill(); },

	onColor1Update: function(color) { this.color1 = color; this.setFill(); },
	onColor2Update: function(color) { this.color2 = color; this.setFill(); },
	
	setFill: function() {
		if (this.fillType == null) this.fillType = 'simple';
		if (this.color1 == null) this.color1 = this.baseColor;
		if (this.color2 == null) this.color2 = this.baseColor;

		if (this.fillType == 'simple')	this.targetMorph.setFill(this.color1);

		var gfx = lively.paint;
		if (this.fillType == 'linear gradient') {
			if (this.fillDir == null) this.fillDir = 'NorthSouth';
			this.targetMorph.setFill(new gfx.LinearGradient([new gfx.Stop(0, this.color1), new gfx.Stop(1, this.color2)], 
			gfx.LinearGradient[this.fillDir]));
		}

		if (this.fillType == 'radial gradient')
			this.targetMorph.setFill(new gfx.RadialGradient([new gfx.Stop(0, this.color1), new gfx.Stop(1, this.color2)]));
		if (this.sendLayoutChanged) this.targetMorph.layoutChanged();
	},
	
	
	onFillOpacityUpdate: function(op) {
		var value = op.roundTo(0.01);
		this.targetMorph.setFillOpacity(value);
		this.actualModel.setStrokeOpacity(value); // Stroke opacity is linked to fill
		if (this.sendLayoutChanged) this.targetMorph.layoutChanged();
	},

	onStrokeOpacityUpdate: function(op) {
		var value = op.roundTo(0.01);
		this.targetMorph.setStrokeOpacity(value);
		if (this.sendLayoutChanged) this.targetMorph.layoutChanged();
	},

	onTextColorUpdate: function(c) { // Maybe add a little color swatch in the view
		this.targetMorph.setTextColor(c);
		if (this.sendLayoutChanged) this.targetMorph.layoutChanged();
	},

	onFontFamilyUpdate: function(familyName) {
		this.targetMorph.setFontFamily(familyName);
		if (this.sendLayoutChanged) this.targetMorph.layoutChanged();
	},
	
	onFontSizeUpdate: function(fontSize) {
		this.targetMorph.setFontSize(Number(fontSize));
		if (this.sendLayoutChanged) this.targetMorph.layoutChanged();
	},

	needsControlFor: function(methodName) {
		if (this.targetMorph.canRespondTo) return this.targetMorph.canRespondTo(methodName);
		if (methodName == 'shapeRoundEdgesBy') return this.targetMorph.shape.roundEdgesBy instanceof Function;
		return this.targetMorph[methodName] instanceof Function;
	},

	buildView: function(extent) {
		var panel = new PanelMorph(extent);
		panel.linkToStyles(["panel"]);
		var m;

		var y = 10;
		var model = this.actualModel;

		panel.addMorph(new TextMorph(new Rectangle(50, y, 100, 20), "Border Width").beLabel());

		m = panel.addMorph(new PrintMorph(new Rectangle(150, y, 40, 20)));
		m.connectModel(model.newRelay({Value: "BorderWidth"}), true);

		m = panel.addMorph(new SliderMorph(new Rectangle(200, y, 100, 20), 10.0));
		m.connectModel(model.newRelay({Value: "BorderWidth"}), true);

		y += 30;

		panel.addMorph(new TextMorph(new Rectangle(50, y, 100, 20), 'Border Color').beLabel());
		m = panel.addMorph(new ColorPickerMorph(new Rectangle(250, y, 50, 30)));
		m.connectModel(model.newRelay({Color: "+BorderColor"}), true);

		y += 40;

		if (this.needsControlFor('shapeRoundEdgesBy')) {
			panel.addMorph(new TextMorph(new Rectangle(50, y, 100, 20), 'Round Corners').beLabel());
			m = panel.addMorph(new PrintMorph(new Rectangle(150, y, 40, 20)));
			m.precision = 1;
			m.connectModel(model.newRelay({Value: "BorderRadius"}), true);
			m = panel.addMorph(new SliderMorph(new Rectangle(200, y, 100, 20), 50.0));
			m.connectModel(model.newRelay({Value: "BorderRadius"}), true);

			y += 30;
		}

		m = panel.addMorph(new TextListMorph(new Rectangle(50, y, 100, 50), 
		["simple", "linear gradient", "radial gradient", "stipple"]));
		m.connectModel(model.newRelay({Selection: "FillType"}), true);
		m = panel.addMorph(new TextListMorph(new Rectangle(160, y, 75, 60),
		["NorthSouth", "SouthNorth", "EastWest", "WestEast"]));
		m.connectModel(model.newRelay({Selection: "FillDir"}));
		m = panel.addMorph(new ColorPickerMorph(new Rectangle(250, y, 50, 30)));
		m.connectModel(model.newRelay({Color: "+Color1"}));
		m = panel.addMorph(new ColorPickerMorph(new Rectangle(250, y + 40, 50, 30)));
		m.connectModel(model.newRelay({Color: "+Color2"}));
		y += 80;

		panel.addMorph(new TextMorph(new Rectangle(50, y, 90, 20), "Fill Opacity").beLabel());
		panel.addMorph(m = new PrintMorph(new Rectangle(150, y, 40, 20)));
		m.connectModel(model.newRelay({Value: "FillOpacity"}), true);
		m = panel.addMorph(new SliderMorph(new Rectangle(200, y, 100, 20), 1.0));
		m.connectModel(model.newRelay({Value: "FillOpacity"}), true);

		y += 30;

		panel.addMorph(new TextMorph(new Rectangle(50, y, 90, 20), "Stroke Opacity").beLabel());
		m = panel.addMorph(new PrintMorph(new Rectangle(150, y, 40, 20)));
		m.connectModel(model.newRelay({Value: "StrokeOpacity"}), true);

		panel.addMorph(m = new SliderMorph(new Rectangle(200, y, 100, 20), 1.0));
		m.connectModel(model.newRelay({Value: "StrokeOpacity"}), true);

		y += 30;


		if (this.needsControlFor('setTextColor')) {
			panel.addMorph(new TextMorph(new Rectangle(50, y, 100, 20), "Text Color").beLabel());
			m = panel.addMorph(new ColorPickerMorph(new Rectangle(250, y, 50, 30)));
			m.connectModel(model.newRelay({Color: "+TextColor"}));
			y += 40;

			panel.addMorph(new TextMorph(new Rectangle(50, y, 100, 20), 'Font Family').beLabel());
			m = panel.addMorph(new TextMorph(new Rectangle(150, y, 150, 20)));
			m.connectModel(model.newRelay({Text: "FontFamily"}), true);
			y += 30;

			panel.addMorph(new TextMorph(new Rectangle(50, y, 100, 20), 'Font Size').beLabel());
			m = panel.addMorph(new TextMorph(new Rectangle(150, y, 50, 20)));
			m.connectModel(model.newRelay({Text: "FontSize"}), true);
			y += 30;
		}


		var oldBounds = panel.shape.bounds();
		panel.shape.setBounds(oldBounds.withHeight(y + 5 - oldBounds.y));

		panel.morphMenu = function(evt) { 
			var menu = Class.getPrototype(this).morphMenu.call(this, evt);
			menu.addLine();
			menu.addItem(['inspect model', new SimpleInspector(panel.getModel()), "openIn", this.world()]);
			return menu;
		}
		panel.priorExtent = panel.innerBounds().extent();


		panel.submorphs.each(function(ea){
				ea.suppressHandles = true;
		})

		return panel;
	}
	
});


// ===========================================================================
// Profiler & Statistics Viewer
// ===========================================================================
Object.profiler = function (object, service) {
    // The wondrous Ingalls profiler...
    // Invoke as, eg, Object.profiler(Color, "start"), or Object.profiler(Color.prototype, "start")
    var stats = {};
    var fnames = object.constructor.localFunctionNames();

    for (var i = 0; i < fnames.length; i++) { 
        var fname = fnames[i];

        if (fname == "constructor") {} // leave the constructor alone
        else if (service == "stop") 
            object[fname] = object[fname].originalFunction;  // restore original functions
        else if (service == "tallies") 
            stats[fname] = object[fname].tally;  // collect the tallies
        else if (service == "ticks") 
            stats[fname] = object[fname].ticks;  // collect the real-time ticks
        else if (service == "reset") { 
            object[fname].tally = 0; object[fname].ticks = 0; // reset the stats
        } else if (service == "start") { // Make a proxy function object that just calls the original
            var tallyFunc = function () {
                var tallyFunc = arguments.callee;
                tallyFunc.tally++;
                msTime = new Date().getTime();
                var result = tallyFunc.originalFunction.apply(this, arguments); 
                tallyFunc.ticks += (new Date().getTime() - msTime);
                return result;
            }
            
            // Attach tallies, and the original function, then replace the original
            if (object[fname].tally == null) 
                tallyFunc.originalFunction = object[fname];
            else 
                tallyFunc = object[fname]; // So repeated "start" will work as "reset"

            tallyFunc.tally = 0;  
            tallyFunc.ticks = 0;
            object[fname] = tallyFunc; 
        } 
    }
    
    return stats; 
};

function showStatsViewer(profilee,title) {
    Object.profiler(profilee, "start");
    var m = new ButtonMorph(WorldMorph.current().bounds().topCenter().addXY(0,20).extent(pt(150, 20)));
    m.getThisValue = function() { return this.onState; };
    m.setThisValue = function(newValue) {
        this.onState = newValue;
	if(this.removed) return;
	if (this.world().firstHand().lastMouseEvent.isShiftDown()) {
		// shift-click means remove profiling
    		Object.profiler(profilee, "stop");
            	if (this.statsMorph != null) this.statsMorph.remove();
		this.remove();
		this.removed = true;
		return;
	}	
        if (newValue == false) { // on mouseup...
            if (this.statsMorph == null) {
                this.statsMorph = new TextMorph(this.bounds().bottomLeft().extent(pt(250,20)), "no text");
                WorldMorph.current().addMorph(this.statsMorph); 
            }
            var tallies = Object.profiler(profilee, "tallies");
            var ticks = Object.profiler(profilee, "ticks");
            var statsArray = [];
            
            for (var field in tallies) {
                if (tallies[field] instanceof Function) continue;
                if (tallies[field] == 0) continue;
                
                statsArray.push([tallies[field], ticks[field], field]);
            }

            statsArray.sort(function(a,b) {return b[1]-a[1];});
            var statsText = "";
            if (title) statsText += title + "\n";
            statsText += "tallies : ticks : methodName\n";
            statsText += statsArray.invoke('join', ' : ').join('\n');
            this.statsMorph.setTextString(statsText);
            Object.profiler(profilee, "reset"); 
        } 
    }
    m.connectModel({model: m, getValue: "getThisValue", setValue: "setThisValue"});
    WorldMorph.current().addMorph(m);
    var t = new TextMorph(m.bounds().extent().extentAsRectangle(), 'Display and reset stats').beLabel();
    m.addMorph(t);
};


// ===========================================================================
// The even-better Execution Tracer
// ===========================================================================
using().run(function() { // begin scoping function
	// The Execution Tracer is enabled by setting Config.debugExtras = true in localconfig.js.
	// When this is done, every method of every user class is wrapped by tracingWrapper (q.v.),
	// And the entire system is running with a shadow stack being maintained in this way.

	// This execution tracer maintains a separate stack or tree of called methods.
	// The variable 'currentContext' points to a TracerNode for the currently executing
	// method.  The caller chain of that node represents the JavaScript call stack, and
	// each node gives its method (which has been tagged with its qualifiedMethodName() ),
	// and also the receiving object, 'itsThis', and the arguments to the call, 'args'.
	// The end result can be seen in, eg, lively.lang.Execution.showStack(), which displays a stack trace
	// either in the console or in the StackViewer.  You can test this by invoking
	// "test showStack" in the menu of any morph.

	// At key points in the Morphic environment (like at the beginning of event dispatch and
	// ticking behavior), the stack environment gets reinitialized by a call to 
	// lively.lang.Execution.resetDebuggingStack().  This prevents excessively long chains from being
	// held around wasting storage.

	// The tracingWrapper function is the key to how this works.  It calls traceCall()
	// before each method execution, and traceReturn() afterwards.  The important thing
	// is that these messages are sent to the currentContext object.  Therefore the same
	// wrapper works to maintain a simple call stack as well as a full tally and time
	// execution profile.  In the latter case, currentContext and other nodes of the tracing
	// structure are instances of TracerTreeNode, rather than TracerStackNode
	// 

	// This mechanism can perform much more amazing feats with the use of TracerTreeNode.
	// Here the nodes stay in place, accumulating call tallies and ticks of the millisecond
	// clock.  You start it by calling lively.lang.Execution.trace() with a function to run (see the example
	// in lively.lang.Execution.testTrace()).  As in normal stack tracing, the value of currentContext is
	// the node associated with the currently running method.

var rootContext;
var currentContext;

Global.getCurrentContext = function() {
	return currentContext;
};

Object.subclass('TracerStackNode', {
	
	initialize: function(caller, method) {
		this.caller = caller;
		this.method = method;
		this.itsThis = null;  // These two get nulled after return
		this.args = null;  //  .. only used for stack trace on error
		this.callee = null;
	},
	
	copyMe: function() {
		var result = new TracerStackNode(this.caller, this.method);
		result.itsThis = this.itsThis;
		result.args = this.args;
		result.callee = this.callee;
		return result;
	},
	
	traceCall: function(method , itsThis, args) {
		// this is the currentContext (top of stack)
		// method has been called with itsThis as receiver, and args as arguments
		// --> Check here for exceptions
		var newNode = this.callee;  // recycle an old callee node
		if (!newNode) {             // ... or make a new one
			newNode = new TracerStackNode(this, method);
			this.callee = newNode;
		} else {
			newNode.method = method;
		}
		newNode.itsThis = itsThis;		
		newNode.args = args;
		if (Function.prototype.logAllCalls) console.log(this.dashes(this.stackSize()) + this);
		currentContext = newNode;
	},
	
	traceReturn: function(method) {
		// this is the currentContext (top of stack)
		// method is returning
		this.args = null;  // release storage from unused stack
		this.itsThis = null;  //   ..
		currentContext = this.caller;
	},
	
	each: function(funcToCall) {
		// Stack walk (leaf to root) applying function
		for (var c = this; c; c=c.caller) funcToCall(this, c);
	},
	
	stackSize: function() {
		var size = 0;
		for (var c = this; c; c=c.caller) size++;
		return size;
	},
	
	dashes: function(n) {
		var lo = n% 5;
		return '----|'.times((n-lo)/5) + '----|'.substring(0,lo);
	},
	
	toString: function() {
		return "<" + this.method.qualifiedMethodName() + ">";
	},
	
});
    
TracerStackNode.subclass('TracerTreeNode', {
	
	initialize: function($super, caller, method) {
		$super(caller, method);
		this.callees = {};
		this.tally = 0;
		this.ticks = 0;
		this.calltime = null;
		//console.log("adding node for " + method.qualifiedMethodName());
	},
	
	traceCall: function(method , itsThis, args) {
		// this is the currentContext (top of stack)
		// method has been called with itsThis as receiver, and args as arguments
		// --> Check here for exceptions
		var newNode = this.callees[method];
		if (!newNode) {
			// First hit -- need to make a new node
			newNode = new TracerTreeNode(this, method);
			this.callees[method] = newNode;
		}
		newNode.itsThis = itsThis;
		newNode.args = args;
		newNode.tally++;
		newNode.callTime = new Date().getTime();
		currentContext = newNode;
	},
	
	traceReturn: function(method) {
		// this is the currentContext (top of stack)
		// method is returning
		//if(stackNodeCount < 20) console.log("returning from " + method.qualifiedMethodName());
		this.args = null;  // release storage from unused stack info
		this.itsThis = null;  //   ..
		this.ticks += (new Date().getTime() - this.callTime);
		currentContext = this.caller;
	},
	
	each: function(funcToCall, level, sortFunc) { 
		// Recursive tree visit with callees order parameter (eg, tallies, ticks, alpha)
		if (level == null) level = 0;
		funcToCall(this, level);
		var sortedCallees = [];
		Properties.forEachOwn(this.callees, function(meth, node) { sortedCallees.push(node); })
		if(sortedCallees.length == 0) return;
		sortedCallees.sort(sortFunc);
		sortedCallees.forEach(function(node) { node.each(funcToCall, level+1, sortFunc); });
	},
	
	fullString: function(options) {  
		var totalTicks = 0;
		Properties.forEachOwn(this.callees, function(meth, node) { totalTicks += node.ticks; })
		var major = (options.sortBy == "tally") ? "tally" : "ticks";
		var minor = (major == "tally") ? "ticks" : "tally";
		var threshold = options.threshold;
		if (!threshold && threshold !== 0)  threshold = major == "ticks" ? (totalTicks/100).roundTo(1) : 0;

		var sortFunction = function(a, b) {
			if(a[major] == b[major]) return (a[minor] > b[minor]) ? -1 : (a[minor] < b[minor]) ? 1 : 0; 
			return (a[major] > b[major]) ? -1 : 1;
		}
		var str = "Execution profile (" + major + " / " + minor + "):\n";
		str += "    options specified = {" ;
		str += " repeat: "  + (options.repeat || 1);
		str += ", sortBy: " + '"' + major + '"' ;
		str += ", threshold: " + threshold + " }\n" ;
		var leafCounts = {};

		// Print the call tree, and build the dictionary of leaf counts...
		this.each(function(node, level, sortFunc) {
			if (node.ticks >= threshold) str += (this.dashes(level) + node.toString(major, minor) + "\n");
			if (leafCounts[node.method] == null) leafCounts[node.method] =
			{methodName: node.method.qualifiedMethodName(), tallies: 0, ticks: 0};
			var leafCount = leafCounts[node.method];
			leafCount.tallies += node.tally;
			leafCount.ticks += node.ticksInMethod();
		}.bind(this), 0, sortFunction);

		str += "\nLeaf nodes sorted by ticks within that method (ticks / tallies):\n" ;
		var sortedLeaves = [];
		Properties.forEachOwn(leafCounts, function(meth, count) { sortedLeaves.push(count); })
		if (sortedLeaves.length == 0) return;
		sortedLeaves.sort(function (a, b) { return (a.ticks > b.ticks) ? -1 : (a.ticks < b.ticks) ? 1 : 0 } );
		sortedLeaves.forEach( function (count) {
			if (count.ticks >= threshold*0.4)  str += "(" + count.ticks + " / " + count.tallies + ") " + count.methodName + "\n"; 
		});

		return str;
	},
	
	toString: function(major, minor) {
		if(!major) {major = "ticks";  minor = "tally"};
		return '(' + this[major].toString() + ' / ' + this[minor].toString() + ') ' + this.method.qualifiedMethodName();
	},
	
	ticksInMethod: function() {
		var localTicks = this.ticks;
		// subtract ticks of callees to get net ticks in this method
		Properties.forEachOwn(this.callees, function(meth, node) { localTicks -= node.ticks; })
		return localTicks;
	},
});
    
Object.extend(lively.lang.Execution, {

	resetDebuggingStack: function resetDebuggingStack() {
		var rootMethod = arguments.callee.caller;
		rootContext = new TracerStackNode(null, rootMethod);
		currentContext = rootContext;
		Function.prototype.logAllCalls = false;
	},

	showStack: function(useViewer, c) {
		var currentContext = c;
		if (useViewer) { new StackViewer(this, currentContext).open(); return; }

		if (Config.debugExtras) {
			for (var c = currentContext, i = 0; c != null; c = c.caller, i++) {
				var args = c.args;
				if (!args) {
					console.log("no frame at " + i);
					continue;
				}
				var header = Object.inspect(args.callee.originalFunction);
				var frame = i.toString() + ": " + header + "\n";
				frame += "this: " + c.itsThis + "\n";
				var k = header.indexOf('(');
				header = header.substring(k + 1, 999);  // ')' or 'zort)' or 'zort,baz)', etc
				for (var j = 0; j <args.length; j++) {
					k = header.indexOf(')');
					var k2 = header.indexOf(',');
					if (k2 >= 0) k = Math.min(k,k2);
					var argName = header.substring(0, k);
					header = header.substring(k + 2);
					if (argName.length > 0) frame += argName + ": " + Object.inspect(args[j]) + "\n";
				}
				console.log(frame);
				if (i >= 500) {
					console.log("stack overflow?");
					break;
				}
			}
		} else {
			var visited = [];
			for (var c = arguments.callee.caller, i = 0; c != null; c = c.caller, i++) {
				console.log("%s: %s", i, Object.inspect(c));
				if (visited.indexOf(c) >= 0) {
					console.log("possible recursion");
					break;
					} else visited.push(c);
					if (i > 500) {
						console.log("stack overflow?");
						break;
					}
				}
			}
		},

		testTrace: function(options) { // lively.lang.Execution.testTrace( {repeat: 10} )  
		this.trace( RunArray.test.curry([3, 1, 4, 1, 5, 9]), options);
	},

	trace: function(method, options) {  
		// options = { printToConsole: false, repeat: 1, threshold: 0 }
		if (!options) options = {};
		var traceRoot = new TracerTreeNode(currentContext, method);
		currentContext = traceRoot;
		for (var i=1; i <= (options.repeat || 1); i++)  result = method.call(this);
		currentContext = traceRoot.caller;
		traceRoot.caller = null;
		if (options.printToConsole) console.log(traceRoot.fullString(options));
		else WorldMorph.current().addTextWindow(traceRoot.fullString(options));
		return result;
	},

	installStackTracers: function(remove) {
		console.log("Wrapping all methods with tracingWrapper... " + (remove || ""));
		remove = (remove == "uninstall");  // call with this string to uninstall
		Class.withAllClassNames(Global, function(cName) { 
			if (cName.startsWith('SVG') || cName.startsWith('Tracer')) return;
			if (cName == 'Global' || cName == 'Object') return;
			var theClass = Class.forName(cName);
			var methodNames = theClass.localFunctionNames();

			// Replace all methods of this class with a wrapped version
			for (var mi = 0; mi < methodNames.length; mi++) {
				var mName = methodNames[mi];
				var originalMethod = theClass.prototype[mName];
				// Put names on the original methods 
				originalMethod.declaredClass = cName;
				originalMethod.methodName = mName;
				// Now replace each method with a wrapper function (or remove it)
				if (!Class.isClass(originalMethod)) {  // leave the constructor alone and other classes alone
					if(!remove) theClass.prototype[mName] = originalMethod.tracingWrapper();
					else if(originalMethod.originalFunction) theClass.prototype[mName] = originalMethod.originalFunction;
				}
			}
			// Do the same for class methods (need to clean this up)
			var classFns = []; 
			for (var p in theClass) {
				if (theClass.hasOwnProperty(p) && theClass[p] instanceof Function && p != "superclass")
					classFns.push(p);
			}
			for (var mi = 0; mi < classFns.length; mi++) {
				var mName = classFns[mi];
				var originalMethod = theClass[mName];
				// Put names on the original methods 
				originalMethod.declaredClass = cName;
				originalMethod.methodName = mName;
				// Now replace each method with a wrapper function (or remove it)
				if (!Class.isClass(originalMethod)) { // leave the constructor alone and other classes alone
					if(!remove) theClass[mName] = originalMethod.tracingWrapper();
					else if(originalMethod.originalFunction) theClass[mName] = originalMethod.originalFunction;
				}
			}
		});
	},
	
	tallyLOC: function() {
		console.log("Tallying lines of code by decompilation");
		var classNames = [];
		Class.withAllClassNames(Global, function(n) { n.startsWith('SVG') || classNames.push(n)});
		classNames.sort();
		var tallies = "";
		for (var ci= 0; ci < classNames.length; ci++) {
			var cName = classNames[ci];
			if (cName != 'Global' && cName != 'Object') {
				var theClass = Class.forName(cName);
				var methodNames = theClass.localFunctionNames();
				var loc = 0;
				for (var mi = 0; mi < methodNames.length; mi++) {
					var mName = methodNames[mi];
					var originalMethod = theClass.prototype[mName];
					// decompile and count lines with more than one non-blank character
					var lines = originalMethod.toString().split("\n");
					lines.forEach( function(line) { if(line.replace(/\s/g, "").length>1) loc++ ; } );
				}
			}
			console.log(cName + " " + loc);
			// tallies += cName + " " + loc.toString() + "\n";
		}
	},
	
});
    
Object.subclass('InspectHelper', {
	
	inspect: function(obj,selector){
		if (!Morph.prototype.initialize.originalFunction) // poor test
		return; // no tracers installed
		var openTracer = function(contextNode){
			var dbgObj = {classname: this.constructor.type, selector: 'inspect', err:{stack:contextNode}};
			new ErrorStackViewer(dbgObj).open();
		}.bind(this);
		return {inspectMe: true, message: 'opening StackInspector', openTracer: openTracer}
	},
	
});

Global.halt = function() {
	new InspectHelper().inspect();
}

Object.extend(Function.prototype, {

	tracingWrapper: function () {
		// Make a proxy method (traceFunc) that calls the tracing routines before and after this method
		var traceFunc = function () {
			var originalFunction = arguments.callee.originalFunction; 
			if (!currentContext) return originalFunction.apply(this, arguments);  // not started yet
			try {
				currentContext.traceCall(originalFunction, this, arguments);
				var result = originalFunction.apply(this, arguments); 
				if (result && result.inspectMe === true)
					result.openTracer(currentContext);
				currentContext.traceReturn(originalFunction);
				return result;
			} catch(e) {
				console.log('got error:' + e.message);
				if (!e.stack) console.log('caller ' + currentContext.caller);
				if (!e.stack) e.stack = currentContext.copyMe();
				throw e;
			};
		};
		traceFunc.originalFunction = this;  // Attach this (the original function) to the tracing proxy
		return traceFunc;
	}
});
    
}); // end scoping function


// ===========================================================================
// Call Stack Viewer
// ===========================================================================
WidgetModel.subclass('StackViewer', {

    viewTitle: "Call Stack Viewer",
    openTriggerVariable: 'getFunctionList',

    initialize: function($super, param, currentCtxt) {
        $super();
        this.selected = null;
        if (Config.debugExtras) {
            this.stack = [];
            this.thises = [];
            this.argses = [];
            for (var c = currentCtxt; c != null; c = c.caller) {
                this.thises.push (c.itsThis);
                this.argses.push (c.args);
                this.stack.push (c.method);
            }
        } else {
            // if no debugStack, at least build an array of methods
	    // KP: what about recursion?
            this.stack = [];
            for (var c = arguments.callee.caller; c != null; c = c.caller) {
                this.stack.push (c);
            }
        }
    },
    
    getFunctionList: function() {
        var list = [];

        for (var i = 0; i < this.stack.length; i++) {
            list.push(i + ": " + Object.inspect(this.stack[i]));
        }

        return list;
    },

    setFunctionName: function(n) {
        this.selected = null;
        if (n) {
            var itemNumber = parseInt(n);
            if (!isNaN(itemNumber)) {
                this.stackIndex = itemNumber;
                this.selected = this.stack[itemNumber].toString();
            }
        }
       this.changed("getCodeValue");
       this.changed("getVariableList");
    },

    getCodeValue: function() {
        if (this.selected) return this.selected;
        else return "no value";
    },

    setCodeValue: function() { return; },

    getVariableList: function () {
        if (this.selected) {
            var ip = this.selected.indexOf(")");
            if (ip<0) return ["this"];
            varString = this.selected.substring(0,ip);
            ip = varString.indexOf("(");
            varString = varString.substring(ip+1);
            this.variableNames = (varString.length == 0)
                ? ["this"]
                : ["this"].concat(varString.split(", "));
            return this.variableNames
        }
        else return ["----"];
    },

    setVariableName: function(n) {
        this.variableValue = null;
        if (this.variableNames) {
            for (var i = 0; i < this.variableNames.length; i++) {
                if (n == this.variableNames[i]) {
                    this.variableValue = (n == "this")
                        ? this.thises[this.stackIndex]
                        : this.argses[this.stackIndex][i-1];
                    break;
                }
            }
        }
        this.changed("getVariableValue");
    },

    getVariableValue: function(n) {
        return Object.inspect(this.variableValue);
    },

    buildView: function(extent) { 
        var panel;
        if (! this.argses) {
            panel = PanelMorph.makePanedPanel(extent, [
                            ['stackPane', newListPane, new Rectangle(0, 0, 0.5, 1)],
                            ['codePane', newTextPane, new Rectangle(0.5, 0, 0.5, 1)]
                        ]);
                        panel.stackPane.connectModel({model: this, getList: "getFunctionList", setSelection: "setFunctionName"});
                        panel.codePane.connectModel({model: this, getText: "getCodeValue", setText: "setCodeValue"});
        } else {
            panel = PanelMorph.makePanedPanel(extent, [
                ['stackPane', newListPane, new Rectangle(0, 0, 0.5, 0.6)],
                ['codePane', newTextPane, new Rectangle(0.5, 0, 0.5, 0.6)],
                ['variablePane', newListPane, new Rectangle(0, 0.6, 0.5, 0.4)],
                ['valuePane', newTextPane, new Rectangle(0.5, 0.6, 0.5, 0.4)]
            ]);
            panel.stackPane.connectModel({model: this, getList: "getFunctionList", setSelection: "setFunctionName"});
            panel.codePane.connectModel({model: this, getText: "getCodeValue", setText: "setCodeValue"});
            panel.variablePane.connectModel({model: this, getList: "getVariableList", setSelection: "setVariableName"});
            panel.valuePane.connectModel({model: this, getText: "getVariableValue", setText: "setVariableValue"});
        }
        return panel;
    }
});


// ===========================================================================
// FrameRateMorph
// ===========================================================================
TextMorph.subclass('FrameRateMorph', {

    initialize: function($super, rect, textString) {
	// Steps at maximum speed, and gathers stats on ticks per sec and max latency
        $super(rect, textString);
        this.reset(new Date());
    },

    reset: function(date) {
        this.lastTick = date.getSeconds();
        this.lastMS = date.getTime();
        this.stepsSinceTick = 0;
        this.maxLatency = 0;
    },

    nextStep: function() {
        var date = new Date();
        this.stepsSinceTick ++;
        var nowMS = date.getTime();
        this.maxLatency = Math.max(this.maxLatency, nowMS - this.lastMS);
        this.lastMS = nowMS;
        var nowTick = date.getSeconds();
        if (nowTick != this.lastTick) {
            this.lastTick = nowTick;
            var ms = (1000 / Math.max(this. stepsSinceTick,1)).roundTo(1);
            this.setTextString(this.stepsSinceTick + " frames/sec (" + ms + "ms avg),\nmax latency " + this.maxLatency + " ms.");
            this.reset(date);
        }
    },

    startSteppingScripts: function() { this.startStepping(1,'nextStep'); }

});


// ===========================================================================
// ClickTimeMorph
// ===========================================================================
TextMorph.subclass('ClickTimeMorph', {
	// Displays a list of the number of milliseconds that the mouse was recently down or up

    initialize: function($super, zort) {
        $super(new Rectangle(100, 100, 120, 100), "---");
        var ms = new Date().getTime();
        this.nEvents = 4;
	this.ts = [];
	for (var i=0; i<this.nEvents; i++) this.ts.push(ms);
    },

    handlesMouseDown: function() { return true; },

    onMouseDown: function() {
	this.ts.unshift(new Date().getTime());
    },

    onMouseUp: function() {
	this.ts.unshift(new Date().getTime());
	if (this.ts.length > this.nEvents+2) { this.ts.pop(); this.ts.pop(); };
	this.showStats(this.ts);
    },

    showStats: function(ts) {
	var str = "";
	for (var i=0; i<this.nEvents; i++)  {
		str += (i>0 ? "\n" : "");
		str += ((i%2 == 0) ? "down for " : "up for ") + (ts[i] - ts[i+1]);
	}
        this.setTextString(str);
    }

});


// ===========================================================================
// EllipseMaker
// ===========================================================================
ButtonMorph.subclass('EllipseMakerMorph', {

	documentation: 'A button that emits bouncing ellipses to test graphical performance in conjunction with FrameRateMorph',
	
	initialize: function($super, loc) {
		$super(loc.extent(pt(200, 50)));
		this.ellipses = [];
		this.report();
		connect(this, 'value', this, 'makeNewEllipse');		
	},

	makeNewEllipse: function(btnVal) {
		if (!btnVal) return; // just make one, btn click would trigger it 2x
		var ext = this.owner.innerBounds().extent();
		var s = Math.min(ext.x/40, ext.y/40, 20);
		var e = new Morph(new lively.scene.Ellipse(pt(0,0), s));
		e.ignoreEvents();
		e.setExtent(pt(2*s, 4*s));
		e.applyStyle({ fill: Color.random(), fillOpacity: Math.random(), borderWidth: 1, borderColor: Color.random()});
		e.velocity = pt(s, s).random();
		e.angularVelocity = 0.3  * Math.random();
		this.owner.addMorph(e);
		e.moveOriginBy(e.innerBounds().center());  // Rotate about center
		this.ellipses.push(e);
		this.report()
	},

    report: function() { this.setLabel("Make more ellipses (" + this.ellipses.length + ")") },

	stepEllipses: function() { this.ellipses.forEach(function(e) { e.stepAndBounce() }) },

    startSteppingScripts: function() { this.startStepping(30, 'stepEllipses') },

});


// ===========================================================================
// File Parser
// ===========================================================================
Object.subclass('FileParser', {
    // The bad news is: this is not a real parser ;-)
    // It simply looks for class headers, and method headers,
    // and everything in between gets put with the preceding header
    // The good news is:  it can deal with any file,
    // and it does something useful 99 percent of the time ;-)
    // ParseFile() produces an array of SourceCodeDescriptors
    // If mode == "scan", that's all it does
    // If mode == "search", it only collects descriptors for code that matches the searchString
    // If mode == "import", it builds a source code index in SourceControl for use in the browser

    parseFile: function(fname, version, fstr, db, mode, str) {
        // Scans the file and returns changeList -- a list of informal divisions of the file
        // It should be the case that these, in order, exactly contain all the text of the file
        // Note that if db, a SourceDatabase, is supplied, it will be loaded during the scan
        var ms = new Date().getTime();
        this.fileName = fname;
        this.versionNo = version;
        this.sourceDB = db;
        this.mode = mode;  // one of ["scan", "search", "import"]
        if (mode == "search") this.searchString = str;

        this.verbose = this.verbose || false;
        // this.verbose = (fname == "Examples.js");
        this.ptr = 0;
        this.lineNo = 0;
        this.changeList = [];
        if (this.verbose) console.log("Parsing " + this.fileName + ", length = " + fstr.length);
        this.currentDef = {type: "preamble", startPos: 0, lineNo: 1};
        this.lines = fstr.split(/[\n\r]/);

        while (this.lineNo < this.lines.length) {
            var line = this.nextLine();
            if (this.verbose) console.log("lineNo=" + this.lineNo + " ptr=" + this.ptr + line); 
            if (this.lineNo > 100) this.verbose = false;

            if (this.scanComment(line)) {
            } else if (this.scanModuleDef(line)) {
            } else if (this.scanFunctionDef(line)) {
            } else if (this.scanClassDef(line)) {
            } else if (this.scanMethodDef(line)) {
            } else if (this.scanMainConfigBlock(line)) {
            } else if (this.scanBlankLine(line)) {
            } else this.scanOtherLine(line);
        }
        this.ptr = fstr.length;
        this.processCurrentDef();
        ms = new Date().getTime() - ms;
        console.log(this.fileName + " scanned; " + this.changeList.length + " patches identified in " + ms + " ms.");
        return this.changeList;
    },

    scanComment: function(line) {
        if (line.match(/^[\s]*\/\//) ) {
            if (this.verbose) console.log("// comment: "+ line);
            return true;
        }

        if (line.match(/^[\s]*\/\*/) ) {
            // Attempt to recognize match on one line...
            if (line.match(/^[\s]*\/\*[^\*]*\*\//) ) {
                if (this.verbose) console.log("short /* comment: "+ line);
                return true; 
            }

            // Note that /* and matching */ must be first non-blank chars on a line
            var saveLineNo = this.lineNo;
            var saveLine = line;
            var savePtr = this.ptr;
            if (this.verbose) console.log("long /* comment: "+ line + "...");
            do {
                if (this.lineNo >= this.lines.length) {
                    console.log("Unfound end of long comment beginning at line " + (saveLineNo +1));
                    this.lineNo = saveLineNo;
                    this.currentLine = saveLine;
                    this.ptr = savePtr;
                    return true;
                }
                more = this.nextLine()
            } while ( ! more.match(/^[\s]*\*\//) );

            if (this.verbose) console.log("..." + more);
            return true;
        }

        return false;
    },

    scanModuleDef: function(line) {
        // FIXME module defs ending on the same line
        var match = line.match(/\s*module\([\'\"]([a-zA-Z\.]*)[\'\"]\).*\(\{\s*/);
        if (match == null)  return false;
        this.processCurrentDef();
        if (this.verbose) console.log("Module def: " + match[1]);
        this.currentDef = {type: "moduleDef", name: match[1], startPos: this.ptr, lineNo: this.lineNo};
        return true;
    },
    
    scanFunctionDef: function(line) {
        var match = line.match(/^[\s]*function[\s]+([\w]+)[\s]*\(.*\)[\s]*\{.*/);
        if (!match)
            match = line.match(/^[\s]*var[\s]+([\w]+)[\s]*\=[\s]*function\(.*\)[\s]*\{.*/);
        if (match == null) return false;
        this.processCurrentDef();
        if (this.verbose) console.log("Function def: " + match[1]);
        this.currentDef = {type: "functionDef", name: match[1], startPos: this.ptr, lineNo: this.lineNo};
        return true;
    },
    
    scanClassDef: function(line) {
        // *** Need to catch Object.extend both Foo and Foo.prototype ***
        var match = line.match(/^[\s]*([\w\.]+)\.subclass\([\'\"]([\w\.]+)[\'\"]/);
        if (match == null) {
            var match = line.match(/^[\s]*([\w\.]+)\.subclass\(Global\,[\s]*[\'\"]([\w\.]+)[\'\"]/);
        }
        if (match == null)  return false;
        this.processCurrentDef();
        if (this.verbose) console.log("Class def: " + match[1] + "." + match[2]);
        this.currentDef = {type: "classDef", name: match[2], startPos: this.ptr, lineNo: this.lineNo};
        return true;
    },

    scanMethodDef: function(line) {
        var match = line.match(/^[\s]*([\w]+)\:/);
        if (match == null) return false;
        this.processCurrentDef();
        if (this.verbose) console.log("Method def: " + this.currentClassName + "." + match[1]);
        this.currentDef = {type: "methodDef", name: match[1], startPos: this.ptr, lineNo: this.lineNo};
        return true;
    },

    scanMainConfigBlock: function(line) {    // Special match for Config blocks in Main.js
        var match = line.match(/^[\s]*(if\s\(Config.show[\w]+\))/);
        if (match == null) return false;
        this.processCurrentDef();
        if (this.verbose) console.log("Main Config: " + this.currentClassName + "." + match[1]);
        this.currentDef = {type: "mainConfig", name: match[1], startPos: this.ptr, lineNo: this.lineNo};
        return true;
    },

    processCurrentDef: function() {
        // this.ptr now points at a new code section.
        // Terminate the currently open definition and process accordingly
        // We will want to do a better job of finding where it ends
        var def = this.currentDef;
        if (this.ptr == 0) return;  // we're being called at new def; if ptr == 0, there's no preamble
        def.endPos = this.ptr-1;  // don't include the newLine
        var descriptor = new SourceCodeDescriptor (this.sourceDB, this.fileName, this.versionNo, def.startPos, def.endPos, def.lineNo, def.type, def.name);

        if (this.mode == "scan") {
            this.changeList.push(descriptor);
        } else if (this.mode == "search") {
            if (this.matchStringInDef(this.searchString)) this.changeList.push(descriptor);
        } else if (this.mode == "import") {
            if (def.type == "classDef") {
                this.currentClassName = def.name;
                this.sourceDB.methodDictFor(this.currentClassName)["*definition"] = descriptor;
            } else if (def.type == "methodDef") {
                this.sourceDB.methodDictFor(this.currentClassName)[def.name] = descriptor;
            } else if (def.type == "functionDef") {
                this.sourceDB.addFunctionDef(descriptor);
            }
            this.changeList.push(descriptor);
        }
        this.currentDef = null;
    },
    
    scanBlankLine: function(line) {
        if (line.match(/^[\s]*$/) == null) return false;
        if (this.verbose) console.log("blank line");
        return true;
    },
    
    scanOtherLine: function(line) {
        // Should mostly be code body lines
        if (this.verbose) console.log("other: "+ line); 
        return true;
    },
    
    matchStringInDef: function(str) {
        for (var i=this.currentDef.lineNo-1; i<this.lineNo-1; i++) {
            if (this.lines[i].indexOf(str) >=0) return true;
        }
        return false;
    },
    
    nextLine: function() {
        if (this.lineNo > 0) this.ptr += (this.currentLine.length+1);
        if (this.lineNo < this.lines.length) this.currentLine = this.lines[this.lineNo];
        else this.currentLine = '';
        if (!this.currentLine) this.currentLine = '';  // Split puts nulls instead of zero-length strings!
        this.lineNo++;
        return this.currentLine;
    }

});


// ===========================================================================
// ChangeList
// ===========================================================================
WidgetModel.subclass('ChangeList', {
    // The ChangeListBrowser views a list of patches in a JavaScript (or other) file.
    // The patches taken together entirely capture all the text in the file
    // The quality of the fileParser determines how well the file patches correspond
    // to meaningful JavaScript entities.  A changeList accumulated from method defs
    // during a development session should (;-) be completely well-formed in this regard.
    // Saving a change in a ChangeList browser will only edit the file;  no evaluation is implied
    
    initialViewExtent: pt(420,450),
    openTriggerVariable: 'getChangeBanners',

    initialize: function($super, title, ignored, changes, searchString) {
        $super();
        this.title = title;
        this.changeList = changes;
		this.searchString = searchString;
    },
    
    getChangeBanners: function() {
        this.changeBanner = null;
        return this.changeList.map(function(each) { return this.bannerOfItem(each); }, this);
    },

    setChangeSelection: function(n, v) {
        this.changeBanner = n;
        this.changed("getChangeSelection", v);
        this.changed("getChangeItemText", v);
        if (this.searchString) this.changed("getSearchString", v);
    },

    getChangeSelection: function() {
        return this.changeBanner;
    },

    selectedItem: function() {
        if (this.changeBanner == null) return null;
        var i1 = this.changeBanner.indexOf(":");
        var i2 = this.changeBanner.indexOf(":", i1+1);
        var lineNo = this.changeBanner.substring(i1+1, i2);
        lineNo = new Number(lineNo);
        for (var i=0; i < this.changeList.length; i++) {
            var item = this.changeList[i];
            // Note: should confirm fileName here as well for search lists
            // where lineNo might match, but its a different file
            if (this.lineNoOfItem(item) == lineNo) return item;
        }
        return null;
    },

    bannerOfItem: function(item) {
		var lineStr = this.lineNoOfItem(item).toString();
        var firstLine = item.getSourceCode().truncate(40);  // a bit wastefull
        if (firstLine.indexOf("\r") >= 0) firstLine = firstLine.replace(/\r/g, "");
        var end = firstLine.indexOf(":");
        if (end >= 0) firstLine = firstLine.substring(0,end+1);
        var type = item.type ? item.type + ':' : '';
        var klass = item.className ? item.className + '>>' : '';
		if (!item.fileName)
			return lineStr.concat(": ", type, klass, firstLine);
		return item.fileName.concat(":", lineStr, ": ", type, klass, firstLine);
    },

    getChangeItemText: function() {
        var item = this.selectedItem();
        if (item == null) return "-----";
        return item.getSourceCode();
    },

    setChangeItemText: function(newString, view) {
        var item = this.selectedItem();
        if (item == null) return;

        var originalString = view.textBeforeChanges;
        var fileString = item.getSourceCode();
        if (originalString == fileString) {
            this.checkBracketsAndSave(item, newString, view);
            return;
        }

        WorldMorph.current().notify("Sadly it is not possible to save this text because\n"
            + "the original text appears to have been changed elsewhere.\n"
            + "Perhaps you could copy what you need to the clipboard, browse anew\n"
            + "to this code, repeat your edits with the help of the clipboard,\n"
            + "and finally try to save again in that new context.  Good luck.");
        },

    checkBracketsAndSave: function(item, newString, view) {
        var errorIfAny = this.checkBracketError(newString);
        if (! errorIfAny) {this.reallySaveItemText(item, newString, view); return; }

        var msg = "This text contains an unmatched " + errorIfAny + ";\n" +
                  "do you wish to save it regardless?";
        WorldMorph.current().confirm(msg, function (answer) {
            if (answer) this.reallySaveItemText(item, newString, view); }.bind(this));
    },

    reallySaveItemText: function(item, newString, editView) {
        item.putSourceCode(newString);
        editView.acceptChanges();
		this.changed('getChangeBanners');

        // Now recreate (slow but sure) list from new contents, as things may have changed
        if (this.searchString) return;  // Recreating list is not good for searches
        var oldSelection = this.changeBanner;
        this.changeList = item.newChangeList();
        this.changed('getChangeBanners');
        this.setChangeSelection(oldSelection);  // reselect same item in new list (hopefully)
    },

    checkBracketError: function (str) {
        // Return name of unmatched bracket, or null
        var cnts = {};
        cnts.nn = function(c) { return this[c] || 0; };  // count or zero
        for (var i=0; i<str.length; i++)  // tally all characters
            { cnts[ str[i] ] = cnts.nn(str[i]) +1 };
        if (cnts.nn("{") > cnts.nn("}")) return "open brace";
        if (cnts.nn("{") < cnts.nn("}")) return "close brace";
        if (cnts.nn("[") > cnts.nn("]")) return "open bracket";
        if (cnts.nn("[") < cnts.nn("]")) return "close bracket";
        if (cnts.nn("(") > cnts.nn(")")) return "open paren";
        if (cnts.nn("(") < cnts.nn(")")) return "close paren";
        if (cnts.nn('"')%2 != 0) return "double quote";  // "
        if (cnts.nn("'")%2 != 0) return "string quote";  // '
        return null; 
    },

    getSearchString: function() {
        return this.searchString;
    },

    getViewTitle: function() {
        return "Change list for " + this.title;
    },

	keyActions: function(evt) {
		// --> alt +b
		console.log('Key pressed....');
		if (!evt.isAltDown()) return false;
		if (evt.getKeyChar().toLowerCase() !== 'b') return false;
		if (!this.selectedItem().browseIt) return false;
		this.selectedItem().browseIt();
	},

    buildView: function(extent) {
        var panel = PanelMorph.makePanedPanel(extent, [
            ['topPane', newListPane, new Rectangle(0, 0, 1, 0.4)],
            ['bottomPane', newTextPane, new Rectangle(0, 0.4, 1, 0.6)]
        ]);
        var m = panel.topPane;
        m.connectModel({model: this, getList: "getChangeBanners", setSelection: "setChangeSelection", getSelection: "getChangeSelection", getMenu: "getListPaneMenu"});

		// adding keyPress actions fot the list
		// FIXME should be done in another way
		m.innerMorph().onKeyDown = m.innerMorph().onKeyDown.wrap(function(proceed, evt) {
			this.keyActions(evt);
			proceed(evt);
		}.bind(this));

        m = panel.bottomPane;
        m.innerMorph().getTextSelection().borderRadius = 0;
        m.connectModel({model: this, getText: "getChangeItemText", setText: "setChangeItemText", getSelection: "getSearchString", getMenu: "default"});
        return panel;
    },

	lineNoOfItem: function(item) {
		// helper for handling SourceCodeDescriptors as well as FileFragments... FIXME
		if (item.startLine) return item.startLine();
		if (item.lineNo) return item.lineNo;
		return -1;
	},

});  // balance


// ===========================================================================
// Source Database
// ===========================================================================
ChangeList.subclass('SourceDatabase', {
    // SourceDatabase is an interface to the Lively Kernel source code as stored
    // in a CVS-style repository, ie, as a bunch of text files.

    // First of all, it is capable of scanning all the source files, and breaking
    // them up into reasonable-sized pieces, hopefully very much like the
    // actual class defs and method defs in the files.  The partitioning is done
    // by FileParser and it, in turn, calls setDescriptorInClassForMethod to
    // store the source code descriptors for these variously recognized pieces.

    // In the process, it caches the full text of some number of these files for
    // fast access in subsequent queries, notably alt-w or "where", that finds
    // all occurrences of the current selection.  The result of such searches
    // is presented as a changeList.

    // The other major service provided by SourceDatabase is the ability to 
    // retrieve and alter pieces of the source code files without invalidating
    // previously scanned changeList-style records.

    // A sourceCodeDescriptor (q.v.) has a file name and version number, as well as 
    // start and stop character indices.  When a piece of source code is changed,
    // it will likely invalidate all the other sourceCodePieces that point later
    // in the file.  However, the SourceDatabase is smart (woo-hoo); it knows
    // where previous edits have been made, and what effect they would have had
    // on character ranges of older pieces.  To this end, it maintains an internal
    // version number for each file, and an edit history for each version.

    // With this minor bit of bookkeeping, the SourceDataBase is able to keep
    // producing source code pieces from old references to a file without the need
    // to reread it.  Moreover, to the extent its cache can keep all the
    // file contents, it can do ripping-fast scans for cross reference queries.
    //
    // cachedFullText is a cache of file contents.  Its keys are file names, and
    // its values are the current contents of the named file.

    // editHistory is a parallel dictionary of arrays of edit specifiers.

    // A SourceDatabase is created in response to the 'import sources' command
    // in the browser's classPane menu.  The World color changes to contrast that
    // (developer's) world with any other window that might be testing a new system
    // under develpment.

    // For now, we include all the LK sources, or at least all that you would usually
    // want in a typical development session.  We may soon want more control
    // over this and a reasonable UI for such control.

	codeBaseURL: URL.codeBase,
	
    initialize: function($super) {
        this.methodDicts = {};
        this.functionDefs = {};
        this.cachedFullText = {};
        this.editHistory = {};
    },

    addFunctionDef: function(def) {
        if (def.type !== 'functionDef') throw dbgOn(new Error('Wrong def'));
        this.functionDefs[def.name] = def;
    },
    
    functionDefFor: function(functionName) {
        return this.functionDefs[functionName];
    },
    
    methodDictFor: function(className) {
        if (!this.methodDicts[className]) this.methodDicts[className] = {}; 
        return this.methodDicts[className];
    },

    getSourceInClassForMethod: function(className, methodName) {
        var methodDict = this.methodDictFor(className);
        var descriptor = methodDict[methodName];
        if (!descriptor) return null;
        // *** Needs version edit tweaks...
        var fullText = this.getCachedText(descriptor.fileName);
        if (!fullText) return null;
        return fullText.substring(descriptor.startIndex, descriptor.stopIndex);
    },

    setDescriptorInClassForMethod: function(className, methodName, descriptor) {
        var methodDict = this.methodDictFor(className);
        methodDict[methodName] = descriptor;
    },

    browseReferencesTo: function(str) {
        var fullList = this.searchFor(str);
        if (fullList.length > 300) {
            WorldMorph.current().notify(fullList.length.toString() + " references abbreviated to 300.");
            fullList = fullList.slice(0,299);
        }
        var refs = new ChangeList("References to " + str, null, fullList);
        refs.searchString = str;
        refs.openIn(WorldMorph.current()); 
    },

    searchFor: function(str) {
        var fullList = [];
        Properties.forEachOwn(this.cachedFullText, function(fileName, fileString) {
            var refs = new FileParser().parseFile(fileName, this.currentVersion(fileName), fileString, this, "search", str);
            fullList = fullList.concat(refs);
        }, this);
        return fullList;
    },

    importKernelFiles: function(list) {
        // rk: list is not used anymore, can we get rid of that method?
        //     I also assume that the scanning should be syncronous, adding flag for that
        this.scanLKFiles(true);
	this.testImportFiles();
    },
    
    getSourceCodeRange: function(fileName, versionNo, startIndex, stopIndex) {
        // Remember the JS convention that str[stopindex] is not included!!
        var fileString = this.getCachedText(fileName);
        var mapped = this.mapIndices(fileName, versionNo, startIndex, stopIndex);
        return fileString.substring(mapped.startIndex, mapped.stopIndex);
    },

    putSourceCodeRange: function(fileName, versionNo, startIndex, stopIndex, newString) {
        var fileString = this.getCachedText(fileName);
        var mapped = this.mapIndices(fileName, versionNo, startIndex, stopIndex);
        var beforeString = fileString.substring(0, mapped.startIndex);
        var afterString = fileString.substring(mapped.stopIndex);
        var newFileString = beforeString.concat(newString, afterString);
        newFileString = newFileString.replace(/\r/gi, '\n');  // change all CRs to LFs
        var editSpec = {repStart: startIndex, repStop: stopIndex, repLength: newString.length};
        console.log("Saving " + fileName + "...");
        new NetRequest({model: new NetRequestReporter(), setStatus: "setRequestStatus"}
                ).put(this.codeBaseURL.withFilename(fileName), newFileString);
        // Update cache contents and edit history
        this.cachedFullText[fileName] = newFileString;
        this.editHistory[fileName].push(editSpec);
        console.log("... " + newFileString.length + " bytes saved.");
    },

    mapIndices: function(fileName, versionNo, startIndex, stopIndex) {
        // Figure how substring indices must be adjusted to find the same characters in the fileString
        // given its editHistory.
        // Note: This assumes only three cases: range above replacement, == replacement, below replacement
        // It should check for range>replacement or range<replacement and either indicate error or
        // possibly deal with it (our partitioning may be tractable)
        var edits = this.editHistory[fileName].slice(versionNo);
        var start = startIndex;  var stop = stopIndex;
        for (var i=0; i<edits.length; i++) {  // above replacement
            var edit = edits[i];
            var delta = edit.repLength - (edit.repStop - edit.repStart);  // patch size delta
            if (start >= edit.repStop) {  // above replacement
                start += delta;
                stop += delta;
            } else if (start == edit.repStart && stop == edit.repStop) {  // identical to replacement
                stop += delta;
            }  // else below the replacement so no change
        }  
        return {startIndex: start, stopIndex: stop};
    },

    changeListForFileNamed: function(fileName) {
        var fileString = this.getCachedText(fileName);
        return new FileParser().parseFile(fileName, this.currentVersion(fileName), fileString, this, "scan");
    },

    currentVersion: function(fileName) {
        // Expects to be called only when fileName will be found in cache!
        return this.editHistory[fileName].length;
    },

    getViewTitle: function() {
        return "Source Control for " + this.fileName;
    },

    testImportFiles: function() {
        // Enumerate all classes and methods, and report cases where we have no source descriptors
    },
    
    testMethodDefs: function() {
        // test if methods were parsed correctly
        // go to the source of all methods and use #checkBracketError for counting brackets
        var methodDefs = Object.values(this.methodDicts).inject([], function(methodDefs, classDef) {
            return methodDefs.concat(Object.values(classDef));
        });
        var defsWithError = methodDefs.select(function(ea) {
            if (Object.isFunction(ea) || !ea.getSourceCode) {
                console.log('No MethodDescriptor ' + ea);
                ea.error = 'Problem with descriptor, it is itself a function!';
                return true;
            };
            var error = this.checkBracketError(ea.getSourceCode());
            if (!error) return false;
            console.log('MethodDescriptor ' + ea.name + ' has an error.');
            ea.error = error;
            return true;
        }, this);
        return defsWithError;
    },
    
    // ------ reading files --------
    getCachedText: function(fileName) {
        // Return full text of the named file
        var fileString;
        var action = function(fileStringArg) { fileString = fileStringArg };
        this.getCachedTextAsync(fileName, action, true);
        return fileString || '';
    },
    
    getCachedTextAsync: function(fileName, action, beSync) {
        // Calls action with full text of the named file, installing it in cache if necessary
        var fileString = this.cachedFullText[fileName];
        if (fileString) {
            action.call(this, fileString);
            return;
        }
        
        var prepareDB = function(fileString) {
            this.cachedFullText[fileName] = fileString;
            this.editHistory[fileName] = [];
            action.call(this, fileString);
        }.bind(this);
        this.getFileContentsAsync(fileName, prepareDB, beSync);
    },
    
    getFileContentsAsync: function(fileName, action, beSync) {
	// DI:  This should be simplified - I removed timing (meaningless here for async)
	// rk: made async optional
	// convenient helper method
	var actionWrapper = function(fileString) {
		if (request.getStatus() >= 400)
			throw dbgOn(new Error('Cannot read ' + fileName));
	    action.call(this, fileString);
	}.bind(this);
	
	var request = new NetRequest({model: {callback: actionWrapper}, setResponseText: 'callback'});
	if (beSync) request.beSync();
        request.get(this.codeBaseURL.withFilename(fileName));
    },
    
    scanLKFiles: function(beSync) {
        this.interestingLKFileNames(URL.codeBase.withFilename('lively/')).each(function(fileName) {
            var action = function(fileString) {
                new FileParser().parseFile(fileName, this.currentVersion(fileName), fileString, this, "import");
            }.bind(this);
            this.getCachedTextAsync(fileName, action, beSync);
        }, this);
    },
    
    interestingLKFileNames: function(url) {
		var fileURLs = new WebResource(url).getSubElements().subDocuments.collect(function(ea) { return ea.getURL() })
		var fileNames = fileURLs.collect(function(ea) { return ea.relativePathFrom(URL.codeBase) })
        var acceptedFileNames = /.*\.(st|js|lkml|txt|ometa|st)/
		fileNames = fileNames.select(function(ea) { return acceptedFileNames.test(ea) });
        fileNames = fileNames.uniq();
        var rejects = ['JSON.js'];
		fileNames = fileNames.reject(function(ea) { return rejects.include(ea) });
		return fileNames;
    },

});

module.SourceControl = null;

module.startSourceControl = function() {
    if (module.SourceControl) return;
    module.SourceControl = new SourceDatabase();
    module.SourceControl.scanLKFiles(true);
};

// ===========================================================================
// Source Code Descriptor
// ===========================================================================
Object.subclass('SourceCodeDescriptor', {

    initialize: function(sourceControl, fileName, versionNo, startIndex, stopIndex, lineNo, type, name) {
	// This state represents a given range of a given version of a given file in the SourceControl
	// The lineNo, type and name are further info arrived at during file parsing
        this.sourceControl = sourceControl;
        this.fileName = fileName;
        this.versionNo = versionNo;
        this.startIndex = startIndex;
        this.stopIndex = stopIndex;
        this.lineNo = lineNo;
        this.type = type;  // Do these need to be retained?
        this.name = name;
    },

    getSourceCode: function() {
        return this.sourceControl.getSourceCodeRange(this.fileName, this.versionNo, this.startIndex, this.stopIndex);
    },

    putSourceCode: function(newString) {
        this.sourceControl.putSourceCodeRange(this.fileName, this.versionNo, this.startIndex, this.stopIndex, newString);
    },

    newChangeList: function() {
        return this.sourceControl.changeListForFileNamed(this.fileName);
    }

});

Object.subclass('BasicCodeMarkupParser', {
    documentation: "Evaluates code in the lkml code format",
    // this is the first attempt, format subject to change
    classQuery: new Query("/code/class"),
    protoQuery: new Query("proto"),
    staticQuery: new Query("static"),

    nameOf: function(element) {
	var name = element.getAttributeNS(null, "name");
	if (!name) throw new Error("no class name");
	return name;
    },

    parseDocumentElement: function(element, isHack) {
		var classes;
		if (isHack) {
	    	var xpe = new XPathEvaluator();
	    	function resolver(arg) {
				//return "http://www.w3.org/2000/svg";
				return Namespace.SVG;
			}
			var result = xpe.evaluate("/lively:code/lively:class", element, resolver, XPathResult.ANY_TYPE, null);
	    	var res = null;
	    	classes = [];
	    	while (res = result.iterateNext()) classes.push(res);
		}  else {
	    	classes = this.classQuery.findAll(element);
		}

		for (var i = 0; i < classes.length; i++) 
	  	  this.parseClass(classes[i], isHack);
		return classes;
    },

    parseClass: function(element, isHack) {
	// note eval oreder first parse proto methods, then static methods.
	var className = this.nameOf(element);
	var klass = null;
	var superName = element.getAttributeNS(null, "super");
	
	if (superName) { // super is present so we are subclassing (too hackerish?)
	    var superClass = Class.forName(superName);
	    if (!Class.isClass(superClass)) throw new Error('no superclass');
	    klass = superClass.subclass(className);
	} else {
	    klass = Class.forName(className);
	}
	
	var protos;

	if (isHack) {
	    var xpe = new XPathEvaluator();
	    function resolver(arg) {
		return Namespace.SVG;
	    }
	    var result = xpe.evaluate("hack:proto", element, resolver, XPathResult.ANY_TYPE, null);
	    protos = [];
	    var res = null;
	    while (res = result.iterateNext()) protos.push(res);
	}  else {
	    protos = this.protoQuery.findAll(element);
	}

	for (var i = 0; i < protos.length; i++)
	    this.parseProto(protos[i], klass);

	var statics = this.staticQuery.findAll(element);
	for (var i = 0; i < statics.length; i++)
	    this.parseStatic(statics[i], klass);
    },

    evaluateElement: function(element) {
	try {
	    // use intermediate value because eval doesn't seem to return function
	    // values.
	    // this would be a great place to insert a Cajita evaluator.
	    return eval("BasicCodeMarkupParser._=" + element.textContent);
	} catch (er) { 
	    console.log("error " + er + " parsing " + element.textContent);
	    return undefined;
	}
    },

    parseProto: function(protoElement, cls) {
	var name = this.nameOf(protoElement);
	var mixin = {};
	mixin[name] = this.evaluateElement(protoElement);
	cls.addMethods(mixin);
    },

    parseStatic: function(staticElement, cls) {
	var name = this.nameOf(staticElement);
	cls[name] = this.evaluateElement(staticElement);
    }

});



BasicCodeMarkupParser.subclass('CodeMarkupParser', ViewTrait, {
    formals: ["CodeDocument", "CodeText", "URL"],

    initialize: function(url) {
	var model = Record.newPlainInstance({ CodeDocument: null, CodeText: null, URL: url});
	this.resource = new Resource(model.newRelay({ ContentDocument: "+CodeDocument", ContentText: "+CodeText", URL: "-URL"}), 
				     "application/xml");
	this.connectModel(model.newRelay({ CodeDocument: "CodeDocument", CodeText: "CodeText"}));
    },

    parse: function() {
	this.resource.fetch();
    },
    
    onCodeTextUpdate: function(txt) {
	if (!txt) return;
	// in case the document is served as text anyway, try forcing xml
	var parser = new DOMParser();
	var xml = parser.parseFromString(txt, "text/xml");
	this.onCodeDocumentUpdate(xml);
    },

    onCodeDocumentUpdate: function(doc) {
	if (!doc) return;
	this.parseDocumentElement(doc.documentElement);
	this.onComplete();
    },

    onComplete: function() {
	// override to supply an action 
    }, 

});

Object.extend(CodeMarkupParser, {
    load: function(filename, callback) {
	var parser = new CodeMarkupParser(SourceDatabase.prototype.codeBaseURL.withFilename(filename));
	if (callback) parser.onComplete = callback;
	parser.parse();
    }
});

}.logCompletion("Tools.js"));

avocado.transporter.module.onLoadCallbacks["lk/Tools"] = 'done';

avocado.transporter.module.onLoadCallbacks["jslint"] = function() {};
// jslint.js
// 2009-10-04

/*
Copyright (c) 2002 Douglas Crockford  (www.JSLint.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

The Software shall be used for Good, not Evil.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

module('lively.jslint').requires().toRun(function() {

/*
    JSLINT is a global function. It takes two parameters.

        var myResult = JSLINT(source, option);

    The first parameter is either a string or an array of strings. If it is a
    string, it will be split on '\n' or '\r'. If it is an array of strings, it
    is assumed that each string represents one line. The source can be a
    JavaScript text, or HTML text, or a Konfabulator text.

    The second parameter is an optional object of options which control the
    operation of JSLINT. Most of the options are booleans: They are all are
    optional and have a default value of false.

    If it checks out, JSLINT returns true. Otherwise, it returns false.

    If false, you can inspect JSLINT.errors to find out the problems.
    JSLINT.errors is an array of objects containing these members:

    {
        line      : The line (relative to 0) at which the lint was found
        character : The character (relative to 0) at which the lint was found
        reason    : The problem
        evidence  : The text line in which the problem occurred
        raw       : The raw message before the details were inserted
        a         : The first detail
        b         : The second detail
        c         : The third detail
        d         : The fourth detail
    }

    If a fatal error was found, a null will be the last element of the
    JSLINT.errors array.

    You can request a Function Report, which shows all of the functions
    and the parameters and vars that they use. This can be used to find
    implied global variables and other problems. The report is in HTML and
    can be inserted in an HTML <body>.

        var myReport = JSLINT.report(limited);

    If limited is true, then the report will be limited to only errors.

    You can request a data structure which contains JSLint's results.

        var myData = JSLINT.data();

    It returns a structure with this form:

    {
        errors: [
            {
                line: NUMBER,
                character: NUMBER,
                reason: STRING,
                evidence: STRING
            }
        ],
        functions: [
            name: STRING,
            line: NUMBER,
            last: NUMBER,
            param: [
                STRING
            ],
            closure: [
                STRING
            ],
            var: [
                STRING
            ],
            exception: [
                STRING
            ],
            outer: [
                STRING
            ],
            unused: [
                STRING
            ],
            global: [
                STRING
            ],
            label: [
                STRING
            ]
        ],
        globals: [
            STRING
        ],
        member: {
            STRING: NUMBER
        },
        unuseds: [
            {
                name: STRING,
                line: NUMBER
            }
        ],
        implieds: [
            {
                name: STRING,
                line: NUMBER
            }
        ],
        urls: [
            STRING
        ],
        json: BOOLEAN
    }

    Empty arrays will not be included.

*/

/*jslint
    evil: true, nomen: false, onevar: false, regexp: false, strict: true
*/

/*members "\b", "\t", "\n", "\f", "\r", "!=", "!==", "\"", "%",
    "(begin)", "(breakage)", "(context)", "(error)", "(global)",
    "(identifier)", "(last)", "(line)", "(loopage)", "(name)", "(onevar)",
    "(params)", "(scope)", "(verb)", "*", "+", "++", "-", "--", "\/",
    "<", "<=", "==", "===", ">", ">=", ADSAFE, Array, Boolean,
    COM, Canvas, CustomAnimation, Date, Debug, E, Error, EvalError,
    FadeAnimation, Flash, FormField, Frame, Function, HotKey, Image, JSON,
    LN10, LN2, LOG10E, LOG2E, MAX_VALUE, MIN_VALUE, Math, MenuItem,
    MoveAnimation, NEGATIVE_INFINITY, Number, Object, Option, PI,
    POSITIVE_INFINITY, Point, RangeError, Rectangle, ReferenceError, RegExp,
    ResizeAnimation, RotateAnimation, SQRT1_2, SQRT2, ScrollBar, String,
    Style, SyntaxError, System, Text, TextArea, Timer, TypeError, URIError,
    URL, Web, Window, XMLDOM, XMLHttpRequest, "\\", a, abbr, acronym,
    addEventListener, address, adsafe, alert, aliceblue, animator,
    antiquewhite, appleScript, applet, apply, approved, aqua, aquamarine,
    area, arguments, arity, autocomplete, azure, b, background,
    "background-attachment", "background-color", "background-image",
    "background-position", "background-repeat", base, bdo, beep, beige, big,
    bisque, bitwise, black, blanchedalmond, block, blockquote, blue,
    blueviolet, blur, body, border, "border-bottom", "border-bottom-color",
    "border-bottom-style", "border-bottom-width", "border-collapse",
    "border-color", "border-left", "border-left-color", "border-left-style",
    "border-left-width", "border-right", "border-right-color",
    "border-right-style", "border-right-width", "border-spacing",
    "border-style", "border-top", "border-top-color", "border-top-style",
    "border-top-width", "border-width", bottom, br, brown, browser,
    burlywood, button, bytesToUIString, c, cadetblue, call, callee, caller,
    canvas, cap, caption, "caption-side", cases, center, charAt, charCodeAt,
    character, chartreuse, chocolate, chooseColor, chooseFile, chooseFolder,
    cite, clear, clearInterval, clearTimeout, clip, close, closeWidget,
    closed, closure, cm, code, col, colgroup, color, comment, condition,
    confirm, console, constructor, content, convertPathToHFS,
    convertPathToPlatform, coral, cornflowerblue, cornsilk,
    "counter-increment", "counter-reset", create, crimson, css, cursor,
    cyan, d, darkblue, darkcyan, darkgoldenrod, darkgray, darkgreen,
    darkkhaki, darkmagenta, darkolivegreen, darkorange, darkorchid, darkred,
    darksalmon, darkseagreen, darkslateblue, darkslategray, darkturquoise,
    darkviolet, data, dd, debug, decodeURI, decodeURIComponent, deeppink,
    deepskyblue, defaultStatus, defineClass, del, deserialize, dfn,
    dimension, dimgray, dir, direction, display, div, dl, document,
    dodgerblue, dt, edition, else, em, embed, empty, "empty-cells",
    encodeURI, encodeURIComponent, entityify, eqeqeq, errors, escape, eval,
    event, evidence, evil, ex, exception, exec, exps, fieldset, filesystem,
    firebrick, first, float, floor, floralwhite, focus, focusWidget, font,
    "font-face", "font-family", "font-size", "font-size-adjust",
    "font-stretch", "font-style", "font-variant", "font-weight",
    forestgreen, forin, form, fragment, frame, frames, frameset, from,
    fromCharCode, fuchsia, fud, funct, function, functions, g, gainsboro,
    gc, getComputedStyle, ghostwhite, global, globals, gold, goldenrod,
    gray, green, greenyellow, h1, h2, h3, h4, h5, h6, hasOwnProperty, head,
    height, help, history, honeydew, hotpink, hr, html, i, iTunes, id,
    identifier, iframe, img, immed, implieds, in, include, indent, indexOf,
    indianred, indigo, init, input, ins, isAlpha, isApplicationRunning,
    isDigit, isFinite, isNaN, ivory, join, jslint, json, kbd, khaki,
    konfabulatorVersion, label, labelled, lang, last, lavender,
    lavenderblush, lawngreen, laxbreak, lbp, led, left, legend,
    lemonchiffon, length, "letter-spacing", li, lib, lightblue, lightcoral,
    lightcyan, lightgoldenrodyellow, lightgreen, lightpink, lightsalmon,
    lightseagreen, lightskyblue, lightslategray, lightsteelblue,
    lightyellow, lime, limegreen, line, "line-height", linen, link,
    "list-style", "list-style-image", "list-style-position",
    "list-style-type", load, loadClass, location, log, m, magenta, map,
    margin, "margin-bottom", "margin-left", "margin-right", "margin-top",
    "marker-offset", maroon, match, "max-height", "max-width", maxerr, maxlen,
    md5, media, mediumaquamarine, mediumblue, mediumorchid, mediumpurple,
    mediumseagreen, mediumslateblue, mediumspringgreen, mediumturquoise,
    mediumvioletred, member, menu, message, meta, midnightblue,
    "min-height", "min-width", mintcream, mistyrose, mm, moccasin, moveBy,
    moveTo, name, navajowhite, navigator, navy, new, newcap, noframes,
    nomen, noscript, nud, object, ol, oldlace, olive, olivedrab, on,
    onbeforeunload, onblur, onerror, onevar, onfocus, onload, onresize,
    onunload, opacity, open, openURL, opener, opera, optgroup, option,
    orange, orangered, orchid, outer, outline, "outline-color",
    "outline-style", "outline-width", overflow, "overflow-x", "overflow-y",
    p, padding, "padding-bottom", "padding-left", "padding-right",
    "padding-top", page, "page-break-after", "page-break-before",
    palegoldenrod, palegreen, paleturquoise, palevioletred, papayawhip,
    param, parent, parseFloat, parseInt, passfail, pc, peachpuff, peru,
    pink, play, plum, plusplus, pop, popupMenu, position, powderblue, pre,
    predef, preferenceGroups, preferences, print, prompt, prototype, pt,
    purple, push, px, q, quit, quotes, random, range, raw, reach, readFile,
    readUrl, reason, red, regexp, reloadWidget, removeEventListener,
    replace, report, reserved, resizeBy, resizeTo, resolvePath,
    resumeUpdates, rhino, right, rosybrown, royalblue, runCommand,
    runCommandInBg, saddlebrown, safe, salmon, samp, sandybrown, saveAs,
    savePreferences, screen, script, scroll, scrollBy, scrollTo, seagreen,
    seal, search, seashell, select, serialize, setInterval, setTimeout,
    shift, showWidgetPreferences, sidebar, sienna, silver, skyblue,
    slateblue, slategray, sleep, slice, small, snow, sort, span, spawn,
    speak, split, springgreen, src, status, steelblue, strict, strong,
    style, styleproperty, sub, substr, sup, supplant, suppressUpdates, sync,
    system, table, "table-layout", tan, tbody, td, teal, tellWidget, test,
    "text-align", "text-decoration", "text-indent", "text-shadow",
    "text-transform", textarea, tfoot, th, thead, thistle, title,
    toLowerCase, toString, toUpperCase, toint32, token, tomato, top, tr, tt,
    turquoise, type, u, ul, undef, unescape, "unicode-bidi", unused,
    unwatch, updateNow, urls, value, valueOf, var, version,
    "vertical-align", violet, visibility, watch, wheat, white,
    "white-space", whitesmoke, widget, width, "word-spacing", "word-wrap",
    yahooCheckLogin, yahooLogin, yahooLogout, yellow, yellowgreen,
    "z-index"
*/


// We build the application inside a function so that we produce only a single
// global variable. The function will be invoked, its return value is the JSLINT
// application itself.

"use strict";

var JSLINT = (function () {
    var adsafe_id,      // The widget's ADsafe id.
        adsafe_may,     // The widget may load approved scripts.
        adsafe_went,    // ADSAFE.go has been called.
        anonname,       // The guessed name for anonymous functions.
        approved,       // ADsafe approved urls.

        atrule = {
            media      : true,
            'font-face': true,
            page       : true
        },

// These are operators that should not be used with the ! operator.

        bang = {
            '<': true,
            '<=': true,
            '==': true,
            '===': true,
            '!==': true,
            '!=': true,
            '>': true,
            '>=': true,
            '+': true,
            '-': true,
            '*': true,
            '/': true,
            '%': true
        },

// These are members that should not be permitted in the safe subset.

        banned = {              // the member names that ADsafe prohibits.
            'arguments'     : true,
            callee          : true,
            caller          : true,
            constructor     : true,
            'eval'          : true,
            prototype       : true,
            unwatch         : true,
            valueOf         : true,
            watch           : true
        },


// These are the JSLint boolean options.

        boolOptions = {
            adsafe     : true, // if ADsafe should be enforced
            bitwise    : true, // if bitwise operators should not be allowed
            browser    : true, // if the standard browser globals should be predefined
            cap        : true, // if upper case HTML should be allowed
            css        : true, // if CSS workarounds should be tolerated
            debug      : true, // if debugger statements should be allowed
            eqeqeq     : true, // if === should be required
            evil       : true, // if eval should be allowed
            forin      : true, // if for in statements must filter
            fragment   : true, // if HTML fragments should be allowed
            immed      : true, // if immediate invocations must be wrapped in parens
            laxbreak   : true, // if line breaks should not be checked
            newcap     : true, // if constructor names must be capitalized
            nomen      : true, // if names should be checked
            on         : true, // if HTML event handlers should be allowed
            onevar     : true, // if only one var statement per function should be allowed
            passfail   : true, // if the scan should stop on first error
            plusplus   : true, // if increment/decrement should not be allowed
            regexp     : true, // if the . should not be allowed in regexp literals
            rhino      : true, // if the Rhino environment globals should be predefined
            undef      : true, // if variables should be declared before used
            safe       : true, // if use of some browser features should be restricted
            sidebar    : true, // if the System object should be predefined
            strict     : true, // require the "use strict"; pragma
            sub        : true, // if all forms of subscript notation are tolerated
            white      : true, // if strict whitespace rules apply
            widget     : true  // if the Yahoo Widgets globals should be predefined
        },

// browser contains a set of global names which are commonly provided by a
// web browser environment.

        browser = {
            addEventListener: false,
            alert           : false,
            blur            : false,
            clearInterval   : false,
            clearTimeout    : false,
            close           : false,
            closed          : false,
            confirm         : false,
            console         : false,
            Debug           : false,
            defaultStatus   : false,
            document        : false,
            event           : false,
            focus           : false,
            frames          : false,
            getComputedStyle: false,
            history         : false,
            Image           : false,
            length          : false,
            location        : false,
            moveBy          : false,
            moveTo          : false,
            name            : false,
            navigator       : false,
            onbeforeunload  : true,
            onblur          : true,
            onerror         : true,
            onfocus         : true,
            onload          : true,
            onresize        : true,
            onunload        : true,
            open            : false,
            opener          : false,
            opera           : false,
            Option          : false,
            parent          : false,
            print           : false,
            prompt          : false,
            removeEventListener: false,
            resizeBy        : false,
            resizeTo        : false,
            screen          : false,
            scroll          : false,
            scrollBy        : false,
            scrollTo        : false,
            setInterval     : false,
            setTimeout      : false,
            status          : false,
            top             : false,
            XMLHttpRequest  : false
        },

        cssAttributeData,
        cssAny,

        cssColorData = {
            "aliceblue"             : true,
            "antiquewhite"          : true,
            "aqua"                  : true,
            "aquamarine"            : true,
            "azure"                 : true,
            "beige"                 : true,
            "bisque"                : true,
            "black"                 : true,
            "blanchedalmond"        : true,
            "blue"                  : true,
            "blueviolet"            : true,
            "brown"                 : true,
            "burlywood"             : true,
            "cadetblue"             : true,
            "chartreuse"            : true,
            "chocolate"             : true,
            "coral"                 : true,
            "cornflowerblue"        : true,
            "cornsilk"              : true,
            "crimson"               : true,
            "cyan"                  : true,
            "darkblue"              : true,
            "darkcyan"              : true,
            "darkgoldenrod"         : true,
            "darkgray"              : true,
            "darkgreen"             : true,
            "darkkhaki"             : true,
            "darkmagenta"           : true,
            "darkolivegreen"        : true,
            "darkorange"            : true,
            "darkorchid"            : true,
            "darkred"               : true,
            "darksalmon"            : true,
            "darkseagreen"          : true,
            "darkslateblue"         : true,
            "darkslategray"         : true,
            "darkturquoise"         : true,
            "darkviolet"            : true,
            "deeppink"              : true,
            "deepskyblue"           : true,
            "dimgray"               : true,
            "dodgerblue"            : true,
            "firebrick"             : true,
            "floralwhite"           : true,
            "forestgreen"           : true,
            "fuchsia"               : true,
            "gainsboro"             : true,
            "ghostwhite"            : true,
            "gold"                  : true,
            "goldenrod"             : true,
            "gray"                  : true,
            "green"                 : true,
            "greenyellow"           : true,
            "honeydew"              : true,
            "hotpink"               : true,
            "indianred"             : true,
            "indigo"                : true,
            "ivory"                 : true,
            "khaki"                 : true,
            "lavender"              : true,
            "lavenderblush"         : true,
            "lawngreen"             : true,
            "lemonchiffon"          : true,
            "lightblue"             : true,
            "lightcoral"            : true,
            "lightcyan"             : true,
            "lightgoldenrodyellow"  : true,
            "lightgreen"            : true,
            "lightpink"             : true,
            "lightsalmon"           : true,
            "lightseagreen"         : true,
            "lightskyblue"          : true,
            "lightslategray"        : true,
            "lightsteelblue"        : true,
            "lightyellow"           : true,
            "lime"                  : true,
            "limegreen"             : true,
            "linen"                 : true,
            "magenta"               : true,
            "maroon"                : true,
            "mediumaquamarine"      : true,
            "mediumblue"            : true,
            "mediumorchid"          : true,
            "mediumpurple"          : true,
            "mediumseagreen"        : true,
            "mediumslateblue"       : true,
            "mediumspringgreen"     : true,
            "mediumturquoise"       : true,
            "mediumvioletred"       : true,
            "midnightblue"          : true,
            "mintcream"             : true,
            "mistyrose"             : true,
            "moccasin"              : true,
            "navajowhite"           : true,
            "navy"                  : true,
            "oldlace"               : true,
            "olive"                 : true,
            "olivedrab"             : true,
            "orange"                : true,
            "orangered"             : true,
            "orchid"                : true,
            "palegoldenrod"         : true,
            "palegreen"             : true,
            "paleturquoise"         : true,
            "palevioletred"         : true,
            "papayawhip"            : true,
            "peachpuff"             : true,
            "peru"                  : true,
            "pink"                  : true,
            "plum"                  : true,
            "powderblue"            : true,
            "purple"                : true,
            "red"                   : true,
            "rosybrown"             : true,
            "royalblue"             : true,
            "saddlebrown"           : true,
            "salmon"                : true,
            "sandybrown"            : true,
            "seagreen"              : true,
            "seashell"              : true,
            "sienna"                : true,
            "silver"                : true,
            "skyblue"               : true,
            "slateblue"             : true,
            "slategray"             : true,
            "snow"                  : true,
            "springgreen"           : true,
            "steelblue"             : true,
            "tan"                   : true,
            "teal"                  : true,
            "thistle"               : true,
            "tomato"                : true,
            "turquoise"             : true,
            "violet"                : true,
            "wheat"                 : true,
            "white"                 : true,
            "whitesmoke"            : true,
            "yellow"                : true,
            "yellowgreen"           : true
        },

        cssBorderStyle,
        cssBreak,

        cssLengthData = {
            '%': true,
            'cm': true,
            'em': true,
            'ex': true,
            'in': true,
            'mm': true,
            'pc': true,
            'pt': true,
            'px': true
        },

        cssOverflow,

        escapes = {
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '/' : '\\/',
            '\\': '\\\\'
        },

        funct,          // The current function

        functionicity = [
            'closure', 'exception', 'global', 'label',
            'outer', 'unused', 'var'
        ],

        functions,      // All of the functions

        global,         // The global scope
        htmltag = {
            a:        {},
            abbr:     {},
            acronym:  {},
            address:  {},
            applet:   {},
            area:     {empty: true, parent: ' map '},
            b:        {},
            base:     {empty: true, parent: ' head '},
            bdo:      {},
            big:      {},
            blockquote: {},
            body:     {parent: ' html noframes '},
            br:       {empty: true},
            button:   {},
            canvas:   {parent: ' body p div th td '},
            caption:  {parent: ' table '},
            center:   {},
            cite:     {},
            code:     {},
            col:      {empty: true, parent: ' table colgroup '},
            colgroup: {parent: ' table '},
            dd:       {parent: ' dl '},
            del:      {},
            dfn:      {},
            dir:      {},
            div:      {},
            dl:       {},
            dt:       {parent: ' dl '},
            em:       {},
            embed:    {},
            fieldset: {},
            font:     {},
            form:     {},
            frame:    {empty: true, parent: ' frameset '},
            frameset: {parent: ' html frameset '},
            h1:       {},
            h2:       {},
            h3:       {},
            h4:       {},
            h5:       {},
            h6:       {},
            head:     {parent: ' html '},
            html:     {parent: '*'},
            hr:       {empty: true},
            i:        {},
            iframe:   {},
            img:      {empty: true},
            input:    {empty: true},
            ins:      {},
            kbd:      {},
            label:    {},
            legend:   {parent: ' fieldset '},
            li:       {parent: ' dir menu ol ul '},
            link:     {empty: true, parent: ' head '},
            map:      {},
            menu:     {},
            meta:     {empty: true, parent: ' head noframes noscript '},
            noframes: {parent: ' html body '},
            noscript: {parent: ' body head noframes '},
            object:   {},
            ol:       {},
            optgroup: {parent: ' select '},
            option:   {parent: ' optgroup select '},
            p:        {},
            param:    {empty: true, parent: ' applet object '},
            pre:      {},
            q:        {},
            samp:     {},
            script:   {empty: true, parent: ' body div frame head iframe p pre span '},
            select:   {},
            small:    {},
            span:     {},
            strong:   {},
            style:    {parent: ' head ', empty: true},
            sub:      {},
            sup:      {},
            table:    {},
            tbody:    {parent: ' table '},
            td:       {parent: ' tr '},
            textarea: {},
            tfoot:    {parent: ' table '},
            th:       {parent: ' tr '},
            thead:    {parent: ' table '},
            title:    {parent: ' head '},
            tr:       {parent: ' table tbody thead tfoot '},
            tt:       {},
            u:        {},
            ul:       {},
            'var':    {}
        },

        ids,            // HTML ids
        implied,        // Implied globals
        inblock,
        indent,
        jsonmode,
        lines,
        lookahead,
        member,
        membersOnly,
        nexttoken,
        noreach,
        option,
        predefined,     // Global variables defined by option
        prereg,
        prevtoken,

        rhino = {
            defineClass : false,
            deserialize : false,
            gc          : false,
            help        : false,
            load        : false,
            loadClass   : false,
            print       : false,
            quit        : false,
            readFile    : false,
            readUrl     : false,
            runCommand  : false,
            seal        : false,
            serialize   : false,
            spawn       : false,
            sync        : false,
            toint32     : false,
            version     : false
        },

        scope,      // The current scope

        sidebar = {
            System      : false
        },

        src,
        stack,

// standard contains the global names that are provided by the
// ECMAScript standard.

        standard = {
            Array               : false,
            Boolean             : false,
            Date                : false,
            decodeURI           : false,
            decodeURIComponent  : false,
            encodeURI           : false,
            encodeURIComponent  : false,
            Error               : false,
            'eval'              : false,
            EvalError           : false,
            Function            : false,
            hasOwnProperty      : false,
            isFinite            : false,
            isNaN               : false,
            JSON                : false,
            Math                : false,
            Number              : false,
            Object              : false,
            parseInt            : false,
            parseFloat          : false,
            RangeError          : false,
            ReferenceError      : false,
            RegExp              : false,
            String              : false,
            SyntaxError         : false,
            TypeError           : false,
            URIError            : false
        },

        standard_member = {
            E                   : true,
            LN2                 : true,
            LN10                : true,
            LOG2E               : true,
            LOG10E              : true,
            PI                  : true,
            SQRT1_2             : true,
            SQRT2               : true,
            MAX_VALUE           : true,
            MIN_VALUE           : true,
            NEGATIVE_INFINITY   : true,
            POSITIVE_INFINITY   : true
        },

        strict_mode,
        syntax = {},
        tab,
        token,
        urls,
        warnings,

// widget contains the global names which are provided to a Yahoo
// (fna Konfabulator) widget.

        widget = {
            alert                   : true,
            animator                : true,
            appleScript             : true,
            beep                    : true,
            bytesToUIString         : true,
            Canvas                  : true,
            chooseColor             : true,
            chooseFile              : true,
            chooseFolder            : true,
            closeWidget             : true,
            COM                     : true,
            convertPathToHFS        : true,
            convertPathToPlatform   : true,
            CustomAnimation         : true,
            escape                  : true,
            FadeAnimation           : true,
            filesystem              : true,
            Flash                   : true,
            focusWidget             : true,
            form                    : true,
            FormField               : true,
            Frame                   : true,
            HotKey                  : true,
            Image                   : true,
            include                 : true,
            isApplicationRunning    : true,
            iTunes                  : true,
            konfabulatorVersion     : true,
            log                     : true,
            md5                     : true,
            MenuItem                : true,
            MoveAnimation           : true,
            openURL                 : true,
            play                    : true,
            Point                   : true,
            popupMenu               : true,
            preferenceGroups        : true,
            preferences             : true,
            print                   : true,
            prompt                  : true,
            random                  : true,
            Rectangle               : true,
            reloadWidget            : true,
            ResizeAnimation         : true,
            resolvePath             : true,
            resumeUpdates           : true,
            RotateAnimation         : true,
            runCommand              : true,
            runCommandInBg          : true,
            saveAs                  : true,
            savePreferences         : true,
            screen                  : true,
            ScrollBar               : true,
            showWidgetPreferences   : true,
            sleep                   : true,
            speak                   : true,
            Style                   : true,
            suppressUpdates         : true,
            system                  : true,
            tellWidget              : true,
            Text                    : true,
            TextArea                : true,
            Timer                   : true,
            unescape                : true,
            updateNow               : true,
            URL                     : true,
            Web                     : true,
            widget                  : true,
            Window                  : true,
            XMLDOM                  : true,
            XMLHttpRequest          : true,
            yahooCheckLogin         : true,
            yahooLogin              : true,
            yahooLogout             : true
        },

//  xmode is used to adapt to the exceptions in html parsing.
//  It can have these states:
//      false   .js script file
//      html
//      outer
//      script
//      style
//      scriptstring
//      styleproperty

        xmode,
        xquote,

// unsafe comment or string
        ax = /@cc|<\/?|script|\]*s\]|<\s*!|&lt/i,
// unsafe characters that are silently deleted by one or more browsers
        cx = /[\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/,
// token
        tx = /^\s*([(){}\[.,:;'"~\?\]#@]|==?=?|\/(\*(jslint|members?|global)?|=|\/)?|\*[\/=]?|\+[+=]?|-[\-=]?|%=?|&[&=]?|\|[|=]?|>>?>?=?|<([\/=!]|\!(\[|--)?|<=?)?|\^=?|\!=?=?|[a-zA-Z_$][a-zA-Z0-9_$]*|[0-9]+([xX][0-9a-fA-F]+|\.[0-9]*)?([eE][+\-]?[0-9]+)?)/,
// html token
        hx = /^\s*(['"=>\/&#]|<(?:\/|\!(?:--)?)?|[a-zA-Z][a-zA-Z0-9_\-]*|[0-9]+|--|.)/,
// characters in strings that need escapement
        nx = /[\u0000-\u001f&<"\/\\\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/,
        nxg = /[\u0000-\u001f&<"\/\\\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
// outer html token
        ox = /[>&]|<[\/!]?|--/,
// star slash
        lx = /\*\/|\/\*/,
// identifier
        ix = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/,
// javascript url
        jx = /^(?:javascript|jscript|ecmascript|vbscript|mocha|livescript)\s*:/i,
// url badness
        ux = /&|\+|\u00AD|\.\.|\/\*|%[^;]|base64|url|expression|data|mailto/i,
// style
        sx = /^\s*([{:#%.=,>+\[\]@()"';]|\*=?|\$=|\|=|\^=|~=|[a-zA-Z_][a-zA-Z0-9_\-]*|[0-9]+|<\/|\/\*)/,
        ssx = /^\s*([@#!"'};:\-%.=,+\[\]()*_]|[a-zA-Z][a-zA-Z0-9._\-]*|\/\*?|\d+(?:\.\d+)?|<\/)/,
// attributes characters
        qx = /[^a-zA-Z0-9-_\/ ]/,
// query characters for ids
        dx = /[\[\]\/\\"'*<>.&:(){}+=#]/,

        rx = {
            outer: hx,
            html: hx,
            style: sx,
            styleproperty: ssx
        };

    function F() {}

    if (typeof Object.create !== 'function') {
        Object.create = function (o) {
            F.prototype = o;
            return new F();
        };
    }


    function is_own(object, name) {
        return Object.prototype.hasOwnProperty.call(object, name);
    }


    function combine(t, o) {
        var n;
        for (n in o) {
            if (is_own(o, n)) {
                t[n] = o[n];
            }
        }
    }

    String.prototype.entityify = function () {
        return this.
            replace(/&/g, '&amp;').
            replace(/</g, '&lt;').
            replace(/>/g, '&gt;');
    };

    String.prototype.isAlpha = function () {
        return (this >= 'a' && this <= 'z\uffff') ||
            (this >= 'A' && this <= 'Z\uffff');
    };


    String.prototype.isDigit = function () {
        return (this >= '0' && this <= '9');
    };


    String.prototype.supplant = function (o) {
        return this.replace(/\{([^{}]*)\}/g, function (a, b) {
            var r = o[b];
            return typeof r === 'string' || typeof r === 'number' ? r : a;
        });
    };

    String.prototype.name = function () {

// If the string looks like an identifier, then we can return it as is.
// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can simply slap some quotes around it.
// Otherwise we must also replace the offending characters with safe
// sequences.

        if (ix.test(this)) {
            return this;
        }
        if (nx.test(this)) {
            return '"' + this.replace(nxg, function (a) {
                var c = escapes[a];
                if (c) {
                    return c;
                }
                return '\\u' + ('0000' + a.charCodeAt().toString(16)).slice(-4);
            }) + '"';
        }
        return '"' + this + '"';
    };


    function assume() {
        if (!option.safe) {
            if (option.rhino) {
                combine(predefined, rhino);
            }
            if (option.browser || option.sidebar) {
                combine(predefined, browser);
            }
            if (option.sidebar) {
                combine(predefined, sidebar);
            }
            if (option.widget) {
                combine(predefined, widget);
            }
        }
    }


// Produce an error warning.

    function quit(m, l, ch) {
        throw {
            name: 'JSLintError',
            line: l,
            character: ch,
            message: m + " (" + Math.floor((l / lines.length) * 100) +
                    "% scanned)."
        };
    }

    function warning(m, t, a, b, c, d) {
        var ch, l, w;
        t = t || nexttoken;
        if (t.id === '(end)') {  // `~
            t = token;
        }
        l = t.line || 0;
        ch = t.from || 0;
        w = {
            id: '(error)',
            raw: m,
            evidence: lines[l - 1] || '',
            line: l,
            character: ch,
            a: a,
            b: b,
            c: c,
            d: d
        };
        w.reason = m.supplant(w);
        JSLINT.errors.push(w);
        if (option.passfail) {
            quit('Stopping. ', l, ch);
        }
        warnings += 1;
        if (warnings >= option.maxerr) {
            quit("Too many errors.", l, ch);
        }
        return w;
    }

    function warningAt(m, l, ch, a, b, c, d) {
        return warning(m, {
            line: l,
            from: ch
        }, a, b, c, d);
    }

    function error(m, t, a, b, c, d) {
        var w = warning(m, t, a, b, c, d);
        quit("Stopping, unable to continue.", w.line, w.character);
    }

    function errorAt(m, l, ch, a, b, c, d) {
        return error(m, {
            line: l,
            from: ch
        }, a, b, c, d);
    }



// lexical analysis

    var lex = (function lex() {
        var character, from, line, s;

// Private lex methods

        function nextLine() {
            var at;
            if (line >= lines.length) {
                return false;
            }
            character = 1;
            s = lines[line];
            line += 1;
            at = s.search(/ \t/);
            if (at >= 0) {
                warningAt("Mixed spaces and tabs.", line, at + 1);
            }
            s = s.replace(/\t/g, tab);
            at = s.search(cx);
            if (at >= 0) {
                warningAt("Unsafe character.", line, at);
            }
            if (option.maxlen && option.maxlen < s.length) {
                warningAt("Line too long.", line, s.length);
            }
            return true;
        }

// Produce a token object.  The token inherits from a syntax symbol.

        function it(type, value) {
            var i, t;
            if (type === '(color)') {
                t = {type: type};
            } else if (type === '(punctuator)' ||
                    (type === '(identifier)' && is_own(syntax, value))) {
                t = syntax[value] || syntax['(error)'];
            } else {
                t = syntax[type];
            }
            t = Object.create(t);
            if (type === '(string)' || type === '(range)') {
                if (jx.test(value)) {
                    warningAt("Script URL.", line, from);
                }
            }
            if (type === '(identifier)') {
                t.identifier = true;
                if (value === '__iterator__' || value === '__proto__') {
                    errorAt("Reserved name '{a}'.",
                        line, from, value);
                } else if (option.nomen &&
                        (value.charAt(0) === '_' ||
                         value.charAt(value.length - 1) === '_')) {
                    warningAt("Unexpected {a} in '{b}'.", line, from,
                        "dangling '_'", value);
                }
            }
            t.value = value;
            t.line = line;
            t.character = character;
            t.from = from;
            i = t.id;
            if (i !== '(endline)') {
                prereg = i &&
                        (('(,=:[!&|?{};'.indexOf(i.charAt(i.length - 1)) >= 0) ||
                        i === 'return');
            }
            return t;
        }

// Public lex methods

        return {
            init: function (source) {
                if (typeof source === 'string') {
                    lines = source.
                        replace(/\r\n/g, '\n').
                        replace(/\r/g, '\n').
                        split('\n');
                } else {
                    lines = source;
                }
                line = 0;
                nextLine();
                from = 1;
            },

            range: function (begin, end) {
                var c, value = '';
                from = character;
                if (s.charAt(0) !== begin) {
                    errorAt("Expected '{a}' and instead saw '{b}'.",
                            line, character, begin, s.charAt(0));
                }
                for (;;) {
                    s = s.slice(1);
                    character += 1;
                    c = s.charAt(0);
                    switch (c) {
                    case '':
                        errorAt("Missing '{a}'.", line, character, c);
                        break;
                    case end:
                        s = s.slice(1);
                        character += 1;
                        return it('(range)', value);
                    case xquote:
                    case '\\':
                        warningAt("Unexpected '{a}'.", line, character, c);
                    }
                    value += c;
                }

            },

// token -- this is called by advance to get the next token.

            token: function () {
                var b, c, captures, d, depth, high, i, l, low, q, t;

                function match(x) {
                    var r = x.exec(s), r1;
                    if (r) {
                        l = r[0].length;
                        r1 = r[1];
                        c = r1.charAt(0);
                        s = s.substr(l);
                        from = character + l - r1.length;
                        character += l;
                        return r1;
                    }
                }

                function string(x) {
                    var c, j, r = '';

                    if (jsonmode && x !== '"') {
                        warningAt("Strings must use doublequote.",
                                line, character);
                    }

                    if (xquote === x || (xmode === 'scriptstring' && !xquote)) {
                        return it('(punctuator)', x);
                    }

                    function esc(n) {
                        var i = parseInt(s.substr(j + 1, n), 16);
                        j += n;
                        if (i >= 32 && i <= 126 &&
                                i !== 34 && i !== 92 && i !== 39) {
                            warningAt("Unnecessary escapement.", line, character);
                        }
                        character += n;
                        c = String.fromCharCode(i);
                    }
                    j = 0;
                    for (;;) {
                        while (j >= s.length) {
                            j = 0;
                            if (xmode !== 'html' || !nextLine()) {
                                errorAt("Unclosed string.", line, from);
                            }
                        }
                        c = s.charAt(j);
                        if (c === x) {
                            character += 1;
                            s = s.substr(j + 1);
                            return it('(string)', r, x);
                        }
                        if (c < ' ') {
                            if (c === '\n' || c === '\r') {
                                break;
                            }
                            warningAt("Control character in string: {a}.",
                                    line, character + j, s.slice(0, j));
                        } else if (c === xquote) {
                            warningAt("Bad HTML string", line, character + j);
                        } else if (c === '<') {
                            if (option.safe && xmode === 'html') {
                                warningAt("ADsafe string violation.",
                                        line, character + j);
                            } else if (s.charAt(j + 1) === '/' && (xmode || option.safe)) {
                                warningAt("Expected '<\\/' and instead saw '</'.", line, character);
                            } else if (s.charAt(j + 1) === '!' && (xmode || option.safe)) {
                                warningAt("Unexpected '<!' in a string.", line, character);
                            }
                        } else if (c === '\\') {
                            if (xmode === 'html') {
                                if (option.safe) {
                                    warningAt("ADsafe string violation.",
                                            line, character + j);
                                }
                            } else if (xmode === 'styleproperty') {
                                j += 1;
                                character += 1;
                                c = s.charAt(j);
                                if (c !== x) {
                                    warningAt("Escapement in style string.",
                                            line, character + j);
                                }
                            } else {
                                j += 1;
                                character += 1;
                                c = s.charAt(j);
                                switch (c) {
                                case xquote:
                                    warningAt("Bad HTML string", line,
                                        character + j);
                                    break;
                                case '\\':
                                case '\'':
                                case '"':
                                case '/':
                                    break;
                                case 'b':
                                    c = '\b';
                                    break;
                                case 'f':
                                    c = '\f';
                                    break;
                                case 'n':
                                    c = '\n';
                                    break;
                                case 'r':
                                    c = '\r';
                                    break;
                                case 't':
                                    c = '\t';
                                    break;
                                case 'u':
                                    esc(4);
                                    break;
                                case 'v':
                                    c = '\v';
                                    break;
                                case 'x':
                                    if (jsonmode) {
                                        warningAt("Avoid \\x-.", line, character);
                                    }
                                    esc(2);
                                    break;
                                default:
                                    warningAt("Bad escapement.", line, character);
                                }
                            }
                        }
                        r += c;
                        character += 1;
                        j += 1;
                    }
                }

                for (;;) {
                    if (!s) {
                        return it(nextLine() ? '(endline)' : '(end)', '');
                    }
                    while (xmode === 'outer') {
                        i = s.search(ox);
                        if (i === 0) {
                            break;
                        } else if (i > 0) {
                            character += 1;
                            s = s.slice(i);
                            break;
                        } else {
                            if (!nextLine()) {
                                return it('(end)', '');
                            }
                        }
                    }
                    t = match(rx[xmode] || tx);
                    if (!t) {
                        if (xmode === 'html') {
                            return it('(error)', s.charAt(0));
                        } else {
                            t = '';
                            c = '';
                            while (s && s < '!') {
                                s = s.substr(1);
                            }
                            if (s) {
                                errorAt("Unexpected '{a}'.",
                                        line, character, s.substr(0, 1));
                            }
                        }
                    } else {

    //      identifier

                        if (c.isAlpha() || c === '_' || c === '$') {
                            return it('(identifier)', t);
                        }

    //      number

                        if (c.isDigit()) {
                            if (xmode !== 'style' && !isFinite(Number(t))) {
                                warningAt("Bad number '{a}'.",
                                    line, character, t);
                            }
                            if (xmode !== 'style' &&
                                     xmode !== 'styleproperty' &&
                                     s.substr(0, 1).isAlpha()) {
                                warningAt("Missing space after '{a}'.",
                                        line, character, t);
                            }
                            if (c === '0') {
                                d = t.substr(1, 1);
                                if (d.isDigit()) {
                                    if (token.id !== '.' && xmode !== 'styleproperty') {
                                        warningAt("Don't use extra leading zeros '{a}'.",
                                            line, character, t);
                                    }
                                } else if (jsonmode && (d === 'x' || d === 'X')) {
                                    warningAt("Avoid 0x-. '{a}'.",
                                            line, character, t);
                                }
                            }
                            if (t.substr(t.length - 1) === '.') {
                                warningAt(
        "A trailing decimal point can be confused with a dot '{a}'.",
                                        line, character, t);
                            }
                            return it('(number)', t);
                        }
                        switch (t) {

    //      string

                        case '"':
                        case "'":
                            return string(t);

    //      // comment

                        case '//':
                            if (src || (xmode && xmode !== 'script')) {
                                warningAt("Unexpected comment.", line, character);
                            } else if (xmode === 'script' && /<\s*\//i.test(s)) {
                                warningAt("Unexpected <\/ in comment.", line, character);
                            } else if ((option.safe || xmode === 'script') && ax.test(s)) {
                                warningAt("Dangerous comment.", line, character);
                            }
                            s = '';
                            token.comment = true;
                            break;

    //      /* comment

                        case '/*':
                            if (src || (xmode && xmode !== 'script' && xmode !== 'style' && xmode !== 'styleproperty')) {
                                warningAt("Unexpected comment.", line, character);
                            }
                            if (option.safe && ax.test(s)) {
                                warningAt("ADsafe comment violation.", line, character);
                            }
                            for (;;) {
                                i = s.search(lx);
                                if (i >= 0) {
                                    break;
                                }
                                if (!nextLine()) {
                                    errorAt("Unclosed comment.", line, character);
                                } else {
                                    if (option.safe && ax.test(s)) {
                                        warningAt("ADsafe comment violation.", line, character);
                                    }
                                }
                            }
                            character += i + 2;
                            if (s.substr(i, 1) === '/') {
                                errorAt("Nested comment.", line, character);
                            }
                            s = s.substr(i + 2);
                            token.comment = true;
                            break;

    //      /*members /*jslint /*global

                        case '/*members':
                        case '/*member':
                        case '/*jslint':
                        case '/*global':
                        case '*/':
                            return {
                                value: t,
                                type: 'special',
                                line: line,
                                character: character,
                                from: from
                            };

                        case '':
                            break;
    //      /
                        case '/':
                            if (prereg) {
                                depth = 0;
                                captures = 0;
                                l = 0;
                                for (;;) {
                                    b = true;
                                    c = s.charAt(l);
                                    l += 1;
                                    switch (c) {
                                    case '':
                                        errorAt("Unclosed regular expression.", line, from);
                                        return;
                                    case '/':
                                        if (depth > 0) {
                                            warningAt("Unescaped '{a}'.", line, from + l, '/');
                                        }
                                        c = s.substr(0, l - 1);
                                        q = {
                                            g: true,
                                            i: true,
                                            m: true
                                        };
                                        while (q[s.charAt(l)] === true) {
                                            q[s.charAt(l)] = false;
                                            l += 1;
                                        }
                                        character += l;
                                        s = s.substr(l);
                                        return it('(regexp)', c);
                                    case '\\':
                                        c = s.charAt(l);
                                        if (c < ' ') {
                                            warningAt("Unexpected control character in regular expression.", line, from + l);
                                        } else if (c === '<') {
                                            warningAt("Unexpected escaped character '{a}' in regular expression.", line, from + l, c);
                                        }
                                        l += 1;
                                        break;
                                    case '(':
                                        depth += 1;
                                        b = false;
                                        if (s.charAt(l) === '?') {
                                            l += 1;
                                            switch (s.charAt(l)) {
                                            case ':':
                                            case '=':
                                            case '!':
                                                l += 1;
                                                break;
                                            default:
                                                warningAt("Expected '{a}' and instead saw '{b}'.", line, from + l, ':', s.charAt(l));
                                            }
                                        } else {
                                            captures += 1;
                                        }
                                        break;
                                    case '|':
                                        b = false;
                                        break;
                                    case ')':
                                        if (depth === 0) {
                                            warningAt("Unescaped '{a}'.", line, from + l, ')');
                                        } else {
                                            depth -= 1;
                                        }
                                        break;
                                    case ' ':
                                        q = 1;
                                        while (s.charAt(l) === ' ') {
                                            l += 1;
                                            q += 1;
                                        }
                                        if (q > 1) {
                                            warningAt("Spaces are hard to count. Use {{a}}.", line, from + l, q);
                                        }
                                        break;
                                    case '[':
                                        c = s.charAt(l);
                                        if (c === '^') {
                                            l += 1;
                                            if (option.regexp) {
                                                warningAt("Insecure '{a}'.", line, from + l, c);
                                            }
                                        }
                                        q = false;
                                        if (c === ']') {
                                            warningAt("Empty class.", line, from + l - 1);
                                            q = true;
                                        }
    klass:                              do {
                                            c = s.charAt(l);
                                            l += 1;
                                            switch (c) {
                                            case '[':
                                            case '^':
                                                warningAt("Unescaped '{a}'.", line, from + l, c);
                                                q = true;
                                                break;
                                            case '-':
                                                if (q) {
                                                    q = false;
                                                } else {
                                                    warningAt("Unescaped '{a}'.", line, from + l, '-');
                                                    q = true;
                                                }
                                                break;
                                            case ']':
                                                if (!q) {
                                                    warningAt("Unescaped '{a}'.", line, from + l - 1, '-');
                                                }
                                                break klass;
                                            case '\\':
                                                c = s.charAt(l);
                                                if (c < ' ') {
                                                    warningAt("Unexpected control character in regular expression.", line, from + l);
                                                } else if (c === '<') {
                                                    warningAt("Unexpected escaped character '{a}' in regular expression.", line, from + l, c);
                                                }
                                                l += 1;
                                                q = true;
                                                break;
                                            case '/':
                                                warningAt("Unescaped '{a}'.", line, from + l - 1, '/');
                                                q = true;
                                                break;
                                            case '<':
                                                if (xmode === 'script') {
                                                    c = s.charAt(l);
                                                    if (c === '!' || c === '/') {
                                                        warningAt("HTML confusion in regular expression '<{a}'.", line, from + l, c);
                                                    }
                                                }
                                                q = true;
                                                break;
                                            default:
                                                q = true;
                                            }
                                        } while (c);
                                        break;
                                    case '.':
                                        if (option.regexp) {
                                            warningAt("Insecure '{a}'.", line, from + l, c);
                                        }
                                        break;
                                    case ']':
                                    case '?':
                                    case '{':
                                    case '}':
                                    case '+':
                                    case '*':
                                        warningAt("Unescaped '{a}'.", line, from + l, c);
                                        break;
                                    case '<':
                                        if (xmode === 'script') {
                                            c = s.charAt(l);
                                            if (c === '!' || c === '/') {
                                                warningAt("HTML confusion in regular expression '<{a}'.", line, from + l, c);
                                            }
                                        }
                                    }
                                    if (b) {
                                        switch (s.charAt(l)) {
                                        case '?':
                                        case '+':
                                        case '*':
                                            l += 1;
                                            if (s.charAt(l) === '?') {
                                                l += 1;
                                            }
                                            break;
                                        case '{':
                                            l += 1;
                                            c = s.charAt(l);
                                            if (c < '0' || c > '9') {
                                                warningAt("Expected a number and instead saw '{a}'.", line, from + l, c);
                                            }
                                            l += 1;
                                            low = +c;
                                            for (;;) {
                                                c = s.charAt(l);
                                                if (c < '0' || c > '9') {
                                                    break;
                                                }
                                                l += 1;
                                                low = +c + (low * 10);
                                            }
                                            high = low;
                                            if (c === ',') {
                                                l += 1;
                                                high = Infinity;
                                                c = s.charAt(l);
                                                if (c >= '0' && c <= '9') {
                                                    l += 1;
                                                    high = +c;
                                                    for (;;) {
                                                        c = s.charAt(l);
                                                        if (c < '0' || c > '9') {
                                                            break;
                                                        }
                                                        l += 1;
                                                        high = +c + (high * 10);
                                                    }
                                                }
                                            }
                                            if (s.charAt(l) !== '}') {
                                                warningAt("Expected '{a}' and instead saw '{b}'.", line, from + l, '}', c);
                                            } else {
                                                l += 1;
                                            }
                                            if (s.charAt(l) === '?') {
                                                l += 1;
                                            }
                                            if (low > high) {
                                                warningAt("'{a}' should not be greater than '{b}'.", line, from + l, low, high);
                                            }
                                        }
                                    }
                                }
                                c = s.substr(0, l - 1);
                                character += l;
                                s = s.substr(l);
                                return it('(regexp)', c);
                            }
                            return it('(punctuator)', t);

    //      punctuator

                        case '<!--':
                            l = line;
                            c = character;
                            for (;;) {
                                i = s.indexOf('--');
                                if (i >= 0) {
                                    break;
                                }
                                i = s.indexOf('<!');
                                if (i >= 0) {
                                    errorAt("Nested HTML comment.",
                                        line, character + i);
                                }
                                if (!nextLine()) {
                                    errorAt("Unclosed HTML comment.", l, c);
                                }
                            }
                            l = s.indexOf('<!');
                            if (l >= 0 && l < i) {
                                errorAt("Nested HTML comment.",
                                    line, character + l);
                            }
                            character += i;
                            if (s[i + 2] !== '>') {
                                errorAt("Expected -->.", line, character);
                            }
                            character += 3;
                            s = s.slice(i + 3);
                            break;
                        case '#':
                            if (xmode === 'html' || xmode === 'styleproperty') {
                                for (;;) {
                                    c = s.charAt(0);
                                    if ((c < '0' || c > '9') &&
                                            (c < 'a' || c > 'f') &&
                                            (c < 'A' || c > 'F')) {
                                        break;
                                    }
                                    character += 1;
                                    s = s.substr(1);
                                    t += c;
                                }
                                if (t.length !== 4 && t.length !== 7) {
                                    warningAt("Bad hex color '{a}'.", line,
                                        from + l, t);
                                }
                                return it('(color)', t);
                            }
                            return it('(punctuator)', t);
                        default:
                            if (xmode === 'outer' && c === '&') {
                                character += 1;
                                s = s.substr(1);
                                for (;;) {
                                    c = s.charAt(0);
                                    character += 1;
                                    s = s.substr(1);
                                    if (c === ';') {
                                        break;
                                    }
                                    if (!((c >= '0' && c <= '9') ||
                                            (c >= 'a' && c <= 'z') ||
                                            c === '#')) {
                                        errorAt("Bad entity", line, from + l,
                                        character);
                                    }
                                }
                                break;
                            }
                            return it('(punctuator)', t);
                        }
                    }
                }
            }
        };
    }());


    function addlabel(t, type) {

        if (option.safe && funct['(global)'] && typeof predefined[t] !== 'boolean') {
            warning('ADsafe global: ' + t + '.', token);
        } else if (t === 'hasOwnProperty') {
            warning("'hasOwnProperty' is a really bad name.");
        }

// Define t in the current function in the current scope.

        if (is_own(funct, t) && !funct['(global)']) {
            warning(funct[t] === true ?
                "'{a}' was used before it was defined." :
                "'{a}' is already defined.",
                nexttoken, t);
        }
        funct[t] = type;
        if (funct['(global)']) {
            global[t] = funct;
            if (is_own(implied, t)) {
                warning("'{a}' was used before it was defined.", nexttoken, t);
                delete implied[t];
            }
        } else {
            scope[t] = funct;
        }
    }


    function doOption() {
        var b, obj, filter, o = nexttoken.value, t, v;
        switch (o) {
        case '*/':
            error("Unbegun comment.");
            break;
        case '/*members':
        case '/*member':
            o = '/*members';
            if (!membersOnly) {
                membersOnly = {};
            }
            obj = membersOnly;
            break;
        case '/*jslint':
            if (option.safe) {
                warning("ADsafe restriction.");
            }
            obj = option;
            filter = boolOptions;
            break;
        case '/*global':
            if (option.safe) {
                warning("ADsafe restriction.");
            }
            obj = predefined;
            break;
        default:
        }
        t = lex.token();
loop:   for (;;) {
            for (;;) {
                if (t.type === 'special' && t.value === '*/') {
                    break loop;
                }
                if (t.id !== '(endline)' && t.id !== ',') {
                    break;
                }
                t = lex.token();
            }
            if (t.type !== '(string)' && t.type !== '(identifier)' &&
                    o !== '/*members') {
                error("Bad option.", t);
            }
            v = lex.token();
            if (v.id === ':') {
                v = lex.token();
                if (obj === membersOnly) {
                    error("Expected '{a}' and instead saw '{b}'.",
                            t, '*/', ':');
                }
                if (t.value === 'indent' && o === '/*jslint') {
                    b = +v.value;
                    if (typeof b !== 'number' || !isFinite(b) || b <= 0 ||
                            Math.floor(b) !== b) {
                        error("Expected a small integer and instead saw '{a}'.",
                                v, v.value);
                    }
                    obj.white = true;
                    obj.indent = b;
                } else if (t.value === 'maxerr' && o === '/*jslint') {
                    b = +v.value;
                    if (typeof b !== 'number' || !isFinite(b) || b <= 0 ||
                            Math.floor(b) !== b) {
                        error("Expected a small integer and instead saw '{a}'.",
                                v, v.value);
                    }
                    obj.maxerr = b;
                } else if (v.value === 'true') {
                    obj[t.value] = true;
                } else if (v.value === 'false') {
                    obj[t.value] = false;
                } else {
                    error("Bad option value.", v);
                }
                t = lex.token();
            } else {
                if (o === '/*jslint') {
                    error("Missing option value.", t);
                }
                obj[t.value] = false;
                t = v;
            }
        }
        if (filter) {
            assume();
        }
    }


// We need a peek function. If it has an argument, it peeks that much farther
// ahead. It is used to distinguish
//     for ( var i in ...
// from
//     for ( var i = ...

    function peek(p) {
        var i = p || 0, j = 0, t;

        while (j <= i) {
            t = lookahead[j];
            if (!t) {
                t = lookahead[j] = lex.token();
            }
            j += 1;
        }
        return t;
    }



// Produce the next token. It looks for programming errors.

    function advance(id, t) {
        switch (token.id) {
        case '(number)':
            if (nexttoken.id === '.') {
                warning(
"A dot following a number can be confused with a decimal point.", token);
            }
            break;
        case '-':
            if (nexttoken.id === '-' || nexttoken.id === '--') {
                warning("Confusing minusses.");
            }
            break;
        case '+':
            if (nexttoken.id === '+' || nexttoken.id === '++') {
                warning("Confusing plusses.");
            }
            break;
        }
        if (token.type === '(string)' || token.identifier) {
            anonname = token.value;
        }

        if (id && nexttoken.id !== id) {
            if (t) {
                if (nexttoken.id === '(end)') {
                    warning("Unmatched '{a}'.", t, t.id);
                } else {
                    warning("Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'.",
                            nexttoken, id, t.id, t.line, nexttoken.value);
                }
            } else if (nexttoken.type !== '(identifier)' ||
                            nexttoken.value !== id) {
                warning("Expected '{a}' and instead saw '{b}'.",
                        nexttoken, id, nexttoken.value);
            }
        }
        prevtoken = token;
        token = nexttoken;
        for (;;) {
            nexttoken = lookahead.shift() || lex.token();
            if (nexttoken.id === '(end)' || nexttoken.id === '(error)') {
                return;
            }
            if (nexttoken.type === 'special') {
                doOption();
            } else {
                if (nexttoken.id !== '(endline)') {
                    break;
                }
            }
        }
    }


// This is the heart of JSLINT, the Pratt parser. In addition to parsing, it
// is looking for ad hoc lint patterns. We add to Pratt's model .fud, which is
// like nud except that it is only used on the first token of a statement.
// Having .fud makes it much easier to define JavaScript. I retained Pratt's
// nomenclature.

// .nud     Null denotation
// .fud     First null denotation
// .led     Left denotation
//  lbp     Left binding power
//  rbp     Right binding power

// They are key to the parsing method called Top Down Operator Precedence.

    function parse(rbp, initial) {
        var left;
        if (nexttoken.id === '(end)') {
            error("Unexpected early end of program.", token);
        }
        advance();
        if (option.safe && typeof predefined[token.value] === 'boolean' &&
                (nexttoken.id !== '(' && nexttoken.id !== '.')) {
            warning('ADsafe violation.', token);
        }
        if (initial) {
            anonname = 'anonymous';
            funct['(verb)'] = token.value;
        }
        if (initial === true && token.fud) {
            left = token.fud();
        } else {
            if (token.nud) {
                left = token.nud();
            } else {
                if (nexttoken.type === '(number)' && token.id === '.') {
                    warning(
"A leading decimal point can be confused with a dot: '.{a}'.",
                            token, nexttoken.value);
                    advance();
                    return token;
                } else {
                    error("Expected an identifier and instead saw '{a}'.",
                            token, token.id);
                }
            }
            while (rbp < nexttoken.lbp) {
                advance();
                if (token.led) {
                    left = token.led(left);
                } else {
                    error("Expected an operator and instead saw '{a}'.",
                        token, token.id);
                }
            }
        }
        return left;
    }


// Functions for conformance of style.

    function adjacent(left, right) {
        left = left || token;
        right = right || nexttoken;
        if (option.white || xmode === 'styleproperty' || xmode === 'style') {
            if (left.character !== right.from && left.line === right.line) {
                warning("Unexpected space after '{a}'.", right, left.value);
            }
        }
    }

    function nospace(left, right) {
        left = left || token;
        right = right || nexttoken;
        if (option.white && !left.comment) {
            if (left.line === right.line) {
                adjacent(left, right);
            }
        }
    }


    function nonadjacent(left, right) {
        if (option.white) {
            left = left || token;
            right = right || nexttoken;
            if (left.line === right.line && left.character === right.from) {
                warning("Missing space after '{a}'.",
                        nexttoken, left.value);
            }
        }
    }

    function nobreaknonadjacent(left, right) {
        left = left || token;
        right = right || nexttoken;
        if (!option.laxbreak && left.line !== right.line) {
            warning("Bad line breaking before '{a}'.", right, right.id);
        } else if (option.white) {
            left = left || token;
            right = right || nexttoken;
            if (left.character === right.from) {
                warning("Missing space after '{a}'.",
                        nexttoken, left.value);
            }
        }
    }

    function indentation(bias) {
        var i;
        if (option.white && nexttoken.id !== '(end)') {
            i = indent + (bias || 0);
            if (nexttoken.from !== i) {
                warning("Expected '{a}' to have an indentation at {b} instead at {c}.",
                        nexttoken, nexttoken.value, i, nexttoken.from);
            }
        }
    }

    function nolinebreak(t) {
        t = t || token;
        if (t.line !== nexttoken.line) {
            warning("Line breaking error '{a}'.", t, t.value);
        }
    }


    function comma() {
        if (token.line !== nexttoken.line) {
            if (!option.laxbreak) {
                warning("Bad line breaking before '{a}'.", token, nexttoken.id);
            }
        } else if (token.character !== nexttoken.from && option.white) {
            warning("Unexpected space after '{a}'.", nexttoken, token.value);
        }
        advance(',');
        nonadjacent(token, nexttoken);
    }


// Functional constructors for making the symbols that will be inherited by
// tokens.

    function symbol(s, p) {
        var x = syntax[s];
        if (!x || typeof x !== 'object') {
            syntax[s] = x = {
                id: s,
                lbp: p,
                value: s
            };
        }
        return x;
    }


    function delim(s) {
        return symbol(s, 0);
    }


    function stmt(s, f) {
        var x = delim(s);
        x.identifier = x.reserved = true;
        x.fud = f;
        return x;
    }


    function blockstmt(s, f) {
        var x = stmt(s, f);
        x.block = true;
        return x;
    }


    function reserveName(x) {
        var c = x.id.charAt(0);
        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
            x.identifier = x.reserved = true;
        }
        return x;
    }


    function prefix(s, f) {
        var x = symbol(s, 150);
        reserveName(x);
        x.nud = (typeof f === 'function') ? f : function () {
            this.right = parse(150);
            this.arity = 'unary';
            if (this.id === '++' || this.id === '--') {
                if (option.plusplus) {
                    warning("Unexpected use of '{a}'.", this, this.id);
                } else if ((!this.right.identifier || this.right.reserved) &&
                        this.right.id !== '.' && this.right.id !== '[') {
                    warning("Bad operand.", this);
                }
            }
            return this;
        };
        return x;
    }


    function type(s, f) {
        var x = delim(s);
        x.type = s;
        x.nud = f;
        return x;
    }


    function reserve(s, f) {
        var x = type(s, f);
        x.identifier = x.reserved = true;
        return x;
    }


    function reservevar(s, v) {
        return reserve(s, function () {
            if (this.id === 'this' || this.id === 'arguments') {
                if (strict_mode && funct['(global)']) {
                    warning("Strict violation.", this);
                } else if (option.safe) {
                    warning("ADsafe violation.", this);
                }
            }
            return this;
        });
    }


    function infix(s, f, p, w) {
        var x = symbol(s, p);
        reserveName(x);
        x.led = function (left) {
            if (!w) {
                nobreaknonadjacent(prevtoken, token);
                nonadjacent(token, nexttoken);
            }
            if (typeof f === 'function') {
                return f(left, this);
            } else {
                this.left = left;
                this.right = parse(p);
                return this;
            }
        };
        return x;
    }


    function relation(s, f) {
        var x = symbol(s, 100);
        x.led = function (left) {
            nobreaknonadjacent(prevtoken, token);
            nonadjacent(token, nexttoken);
            var right = parse(100);
            if ((left && left.id === 'NaN') || (right && right.id === 'NaN')) {
                warning("Use the isNaN function to compare with NaN.", this);
            } else if (f) {
                f.apply(this, [left, right]);
            }
            if (left.id === '!') {
                warning("Confusing use of '{a}'.", left, '!');
            }
            if (right.id === '!') {
                warning("Confusing use of '{a}'.", left, '!');
            }
            this.left = left;
            this.right = right;
            return this;
        };
        return x;
    }


    function isPoorRelation(node) {
        return node &&
              ((node.type === '(number)' && +node.value === 0) ||
               (node.type === '(string)' && node.value === ' ') ||
                node.type === 'true' ||
                node.type === 'false' ||
                node.type === 'undefined' ||
                node.type === 'null');
    }


    function assignop(s, f) {
        symbol(s, 20).exps = true;
        return infix(s, function (left, that) {
            var l;
            that.left = left;
            if (predefined[left.value] === false &&
                    scope[left.value]['(global)'] === true) {
                warning('Read only.', left);
            }
            if (option.safe) {
                l = left;
                do {
                    if (typeof predefined[l.value] === 'boolean') {
                        warning('ADsafe violation.', l);
                    }
                    l = l.left;
                } while (l);
            }
            if (left) {
                if (left.id === '.' || left.id === '[') {
                    if (!left.left || left.left.value === 'arguments') {
                        warning('Bad assignment.', that);
                    }
                    that.right = parse(19);
                    return that;
                } else if (left.identifier && !left.reserved) {
                    if (funct[left.value] === 'exception') {
                        warning("Do not assign to the exception parameter.", left);
                    }
                    that.right = parse(19);
                    return that;
                }
                if (left === syntax['function']) {
                    warning(
"Expected an identifier in an assignment and instead saw a function invocation.",
                                token);
                }
            }
            error("Bad assignment.", that);
        }, 20);
    }

    function bitwise(s, f, p) {
        var x = symbol(s, p);
        reserveName(x);
        x.led = (typeof f === 'function') ? f : function (left) {
            if (option.bitwise) {
                warning("Unexpected use of '{a}'.", this, this.id);
            }
            this.left = left;
            this.right = parse(p);
            return this;
        };
        return x;
    }

    function bitwiseassignop(s) {
        symbol(s, 20).exps = true;
        return infix(s, function (left, that) {
            if (option.bitwise) {
                warning("Unexpected use of '{a}'.", that, that.id);
            }
            nonadjacent(prevtoken, token);
            nonadjacent(token, nexttoken);
            if (left) {
                if (left.id === '.' || left.id === '[' ||
                        (left.identifier && !left.reserved)) {
                    parse(19);
                    return that;
                }
                if (left === syntax['function']) {
                    warning(
"Expected an identifier in an assignment, and instead saw a function invocation.",
                                token);
                }
                return that;
            }
            error("Bad assignment.", that);
        }, 20);
    }


    function suffix(s, f) {
        var x = symbol(s, 150);
        x.led = function (left) {
            if (option.plusplus) {
                warning("Unexpected use of '{a}'.", this, this.id);
            } else if ((!left.identifier || left.reserved) && left.id !== '.' && left.id !== '[') {
                warning("Bad operand.", this);
            }
            this.left = left;
            return this;
        };
        return x;
    }


    function optionalidentifier() {
        if (nexttoken.reserved) {
            warning("Expected an identifier and instead saw '{a}' (a reserved word).",
                    nexttoken, nexttoken.id);
        }
        if (nexttoken.identifier) {
            advance();
            return token.value;
        }
    }


    function identifier() {
        var i = optionalidentifier();
        if (i) {
            return i;
        }
        if (token.id === 'function' && nexttoken.id === '(') {
            warning("Missing name in function statement.");
        } else {
            error("Expected an identifier and instead saw '{a}'.",
                    nexttoken, nexttoken.value);
        }
    }

    function reachable(s) {
        var i = 0, t;
        if (nexttoken.id !== ';' || noreach) {
            return;
        }
        for (;;) {
            t = peek(i);
            if (t.reach) {
                return;
            }
            if (t.id !== '(endline)') {
                if (t.id === 'function') {
                    warning(
"Inner functions should be listed at the top of the outer function.", t);
                    break;
                }
                warning("Unreachable '{a}' after '{b}'.", t, t.value, s);
                break;
            }
            i += 1;
        }
    }


    function statement(noindent) {
        var i = indent, r, s = scope, t = nexttoken;

// We don't like the empty statement.

        if (t.id === ';') {
            warning("Unnecessary semicolon.", t);
            advance(';');
            return;
        }

// Is this a labelled statement?

        if (t.identifier && !t.reserved && peek().id === ':') {
            advance();
            advance(':');
            scope = Object.create(s);
            addlabel(t.value, 'label');
            if (!nexttoken.labelled) {
                warning("Label '{a}' on {b} statement.",
                        nexttoken, t.value, nexttoken.value);
            }
            if (jx.test(t.value + ':')) {
                warning("Label '{a}' looks like a javascript url.",
                        t, t.value);
            }
            nexttoken.label = t.value;
            t = nexttoken;
        }

// Parse the statement.

        if (!noindent) {
            indentation();
        }
        if (nexttoken.id === 'new') {
            warning("'new' should not be used as a statement.");
        }
        r = parse(0, true);

// Look for the final semicolon.

        if (!t.block) {
            if (!r || !r.exps) {
                warning(
"Expected an assignment or function call and instead saw an expression.",
                        token);
            }
            if (nexttoken.id !== ';') {
                warningAt("Missing semicolon.", token.line,
                        token.from + token.value.length);
            } else {
                adjacent(token, nexttoken);
                advance(';');
                nonadjacent(token, nexttoken);
            }
        }

// Restore the indentation.

        indent = i;
        scope = s;
        return r;
    }


    function use_strict() {
        if (nexttoken.value === 'use strict') {
            advance();
            advance(';');
            strict_mode = true;
            return true;
        } else {
            return false;
        }
    }


    function statements(begin) {
        var a = [], f, p;
        if (begin && !use_strict() && option.strict) {
            warning('Missing "use strict" statement.', nexttoken);
        }
        if (option.adsafe) {
            switch (begin) {
            case 'script':
                if (!adsafe_may) {
                    if (nexttoken.value !== 'ADSAFE' ||
                            peek(0).id !== '.' ||
                            (peek(1).value !== 'id' &&
                            peek(1).value !== 'go')) {
                        error('ADsafe violation: Missing ADSAFE.id or ADSAFE.go.',
                            nexttoken);
                    }
                }
                if (nexttoken.value === 'ADSAFE' &&
                        peek(0).id === '.' &&
                        peek(1).value === 'id') {
                    if (adsafe_may) {
                        error('ADsafe violation.', nexttoken);
                    }
                    advance('ADSAFE');
                    advance('.');
                    advance('id');
                    advance('(');
                    if (nexttoken.value !== adsafe_id) {
                        error('ADsafe violation: id does not match.', nexttoken);
                    }
                    advance('(string)');
                    advance(')');
                    advance(';');
                    adsafe_may = true;
                }
                break;
            case 'lib':
                if (nexttoken.value === 'ADSAFE') {
                    advance('ADSAFE');
                    advance('.');
                    advance('lib');
                    advance('(');
                    advance('(string)');
                    comma();
                    f = parse(0);
                    if (f.id !== 'function') {
                        error('The second argument to lib must be a function.', f);
                    }
                    p = f.funct['(params)'];
                    p = p && p.join(', ');
                    if (p && p !== 'lib') {
                        error("Expected '{a}' and instead saw '{b}'.",
                            f, '(lib)', '(' + p + ')');
                    }
                    advance(')');
                    advance(';');
                    return a;
                } else {
                    error("ADsafe lib violation.");
                }
            }
        }
        while (!nexttoken.reach && nexttoken.id !== '(end)') {
            if (nexttoken.id === ';') {
                warning("Unnecessary semicolon.");
                advance(';');
            } else {
                a.push(statement());
            }
        }
        return a;
    }


    function block(f) {
        var a, b = inblock, old_indent = indent, s = scope, t;
        inblock = f;
        scope = Object.create(scope);
        nonadjacent(token, nexttoken);
        t = nexttoken;
        if (nexttoken.id === '{') {
            advance('{');
            if (nexttoken.id !== '}' || token.line !== nexttoken.line) {
                indent += option.indent;
                while (!f && nexttoken.from > indent) {
                    indent += option.indent;
                }
                if (!f) {
                    use_strict();
                }
                a = statements();
                indent -= option.indent;
                indentation();
            }
            advance('}', t);
            indent = old_indent;
        } else {
            warning("Expected '{a}' and instead saw '{b}'.",
                    nexttoken, '{', nexttoken.value);
            noreach = true;
            a = [statement()];
            noreach = false;
        }
        funct['(verb)'] = null;
        scope = s;
        inblock = b;
        return a;
    }


// An identity function, used by string and number tokens.

    function idValue() {
        return this;
    }


    function countMember(m) {
        if (membersOnly && typeof membersOnly[m] !== 'boolean') {
            warning("Unexpected /*member '{a}'.", token, m);
        }
        if (typeof member[m] === 'number') {
            member[m] += 1;
        } else {
            member[m] = 1;
        }
    }


    function note_implied(token) {
        var name = token.value, line = token.line, a = implied[name];
        if (typeof a === 'function') {
            a = false;
        }
        if (!a) {
            a = [line];
            implied[name] = a;
        } else if (a[a.length - 1] !== line) {
            a.push(line);
        }
    }

// CSS parsing.


    function cssName() {
        if (nexttoken.identifier) {
            advance();
            return true;
        }
    }

    function cssNumber() {
        if (nexttoken.id === '-') {
            advance('-');
            adjacent();
            nolinebreak();
        }
        if (nexttoken.type === '(number)') {
            advance('(number)');
            return true;
        }
    }

    function cssString() {
        if (nexttoken.type === '(string)') {
            advance();
            return true;
        }
    }

    function cssColor() {
        var i, number;
        if (nexttoken.identifier) {
            if (nexttoken.value === 'rgb') {
                advance();
                advance('(');
                for (i = 0; i < 3; i += 1) {
                    if (i) {
                        advance(',');
                    }
                    number = nexttoken.value;
                    if (nexttoken.type !== '(number)' || number < 0) {
                        warning("Expected a positive number and instead saw '{a}'",
                            nexttoken, number);
                        advance();
                    } else {
                        advance();
                        if (nexttoken.id === '%') {
                            advance('%');
                            if (number > 100) {
                                warning("Expected a percentage and instead saw '{a}'",
                                    token, number);
                            }
                        } else {
                            if (number > 255) {
                                warning("Expected a small number and instead saw '{a}'",
                                    token, number);
                            }
                        }
                    }
                }
                advance(')');
                return true;
            } else if (cssColorData[nexttoken.value] === true) {
                advance();
                return true;
            }
        } else if (nexttoken.type === '(color)') {
            advance();
            return true;
        }
        return false;
    }

    function cssLength() {
        if (nexttoken.id === '-') {
            advance('-');
            adjacent();
            nolinebreak();
        }
        if (nexttoken.type === '(number)') {
            advance();
            if (nexttoken.type !== '(string)' &&
                    cssLengthData[nexttoken.value] === true) {
                adjacent();
                advance();
            } else if (+token.value !== 0) {
                warning("Expected a linear unit and instead saw '{a}'.",
                    nexttoken, nexttoken.value);
            }
            return true;
        }
        return false;
    }

    function cssLineHeight() {
        if (nexttoken.id === '-') {
            advance('-');
            adjacent();
        }
        if (nexttoken.type === '(number)') {
            advance();
            if (nexttoken.type !== '(string)' &&
                    cssLengthData[nexttoken.value] === true) {
                adjacent();
                advance();
            }
            return true;
        }
        return false;
    }

    function cssWidth() {
        if (nexttoken.identifier) {
            switch (nexttoken.value) {
            case 'thin':
            case 'medium':
            case 'thick':
                advance();
                return true;
            }
        } else {
            return cssLength();
        }
    }

    function cssMargin() {
        if (nexttoken.identifier) {
            if (nexttoken.value === 'auto') {
                advance();
                return true;
            }
        } else {
            return cssLength();
        }
    }

    function cssAttr() {
        if (nexttoken.identifier && nexttoken.value === 'attr') {
            advance();
            advance('(');
            if (!nexttoken.identifier) {
                warning("Expected a name and instead saw '{a}'.",
                        nexttoken, nexttoken.value);
            }
            advance();
            advance(')');
            return true;
        }
        return false;
    }

    function cssCommaList() {
        while (nexttoken.id !== ';') {
            if (!cssName() && !cssString()) {
                warning("Expected a name and instead saw '{a}'.",
                        nexttoken, nexttoken.value);
            }
            if (nexttoken.id !== ',') {
                return true;
            }
            comma();
        }
    }

    function cssCounter() {
        if (nexttoken.identifier && nexttoken.value === 'counter') {
            advance();
            advance('(');
            if (!nexttoken.identifier) {
            }
            advance();
            if (nexttoken.id === ',') {
                comma();
                if (nexttoken.type !== '(string)') {
                    warning("Expected a string and instead saw '{a}'.",
                        nexttoken, nexttoken.value);
                }
                advance();
            }
            advance(')');
            return true;
        }
        if (nexttoken.identifier && nexttoken.value === 'counters') {
            advance();
            advance('(');
            if (!nexttoken.identifier) {
                warning("Expected a name and instead saw '{a}'.",
                        nexttoken, nexttoken.value);
            }
            advance();
            if (nexttoken.id === ',') {
                comma();
                if (nexttoken.type !== '(string)') {
                    warning("Expected a string and instead saw '{a}'.",
                        nexttoken, nexttoken.value);
                }
                advance();
            }
            if (nexttoken.id === ',') {
                comma();
                if (nexttoken.type !== '(string)') {
                    warning("Expected a string and instead saw '{a}'.",
                        nexttoken, nexttoken.value);
                }
                advance();
            }
            advance(')');
            return true;
        }
        return false;
    }


    function cssShape() {
        var i;
        if (nexttoken.identifier && nexttoken.value === 'rect') {
            advance();
            advance('(');
            for (i = 0; i < 4; i += 1) {
                if (!cssLength()) {
                    warning("Expected a number and instead saw '{a}'.",
                        nexttoken, nexttoken.value);
                    break;
                }
            }
            advance(')');
            return true;
        }
        return false;
    }

    function cssUrl() {
        var c, url;
        if (nexttoken.identifier && nexttoken.value === 'url') {
            nexttoken = lex.range('(', ')');
            url = nexttoken.value;
            c = url.charAt(0);
            if (c === '"' || c === '\'') {
                if (url.slice(-1) !== c) {
                    warning("Bad url string.");
                } else {
                    url = url.slice(1, -1);
                    if (url.indexOf(c) >= 0) {
                        warning("Bad url string.");
                    }
                }
            }
            if (!url) {
                warning("Missing url.");
            }
            advance();
            if (option.safe && ux.test(url)) {
                error("ADsafe URL violation.");
            }
            urls.push(url);
            return true;
        }
        return false;
    }

    cssAny = [cssUrl, function () {
        for (;;) {
            if (nexttoken.identifier) {
                switch (nexttoken.value.toLowerCase()) {
                case 'url':
                    cssUrl();
                    break;
                case 'expression':
                    warning("Unexpected expression '{a}'.",
                        nexttoken, nexttoken.value);
                    advance();
                    break;
                default:
                    advance();
                }
            } else {
                if (nexttoken.id === ';' || nexttoken.id === '!'  ||
                        nexttoken.id === '(end)' || nexttoken.id === '}') {
                    return true;
                }
                advance();
            }
        }
    }];

    cssBorderStyle = [
        'none', 'hidden', 'dotted', 'dashed', 'solid', 'double', 'ridge',
        'inset', 'outset'
    ];

    cssBreak = [
        'auto', 'always', 'avoid', 'left', 'right'
    ];

    cssOverflow = [
        'auto', 'hidden', 'scroll', 'visible'
    ];

    cssAttributeData = {
        background: [
            true, 'background-attachment', 'background-color',
            'background-image', 'background-position', 'background-repeat'
        ],
        'background-attachment': ['scroll', 'fixed'],
        'background-color': ['transparent', cssColor],
        'background-image': ['none', cssUrl],
        'background-position': [
            2, [cssLength, 'top', 'bottom', 'left', 'right', 'center']
        ],
        'background-repeat': [
            'repeat', 'repeat-x', 'repeat-y', 'no-repeat'
        ],
        'border': [true, 'border-color', 'border-style', 'border-width'],
        'border-bottom': [
            true, 'border-bottom-color', 'border-bottom-style',
            'border-bottom-width'
        ],
        'border-bottom-color': cssColor,
        'border-bottom-style': cssBorderStyle,
        'border-bottom-width': cssWidth,
        'border-collapse': ['collapse', 'separate'],
        'border-color': ['transparent', 4, cssColor],
        'border-left': [
            true, 'border-left-color', 'border-left-style', 'border-left-width'
        ],
        'border-left-color': cssColor,
        'border-left-style': cssBorderStyle,
        'border-left-width': cssWidth,
        'border-right': [
            true, 'border-right-color', 'border-right-style',
            'border-right-width'
        ],
        'border-right-color': cssColor,
        'border-right-style': cssBorderStyle,
        'border-right-width': cssWidth,
        'border-spacing': [2, cssLength],
        'border-style': [4, cssBorderStyle],
        'border-top': [
            true, 'border-top-color', 'border-top-style', 'border-top-width'
        ],
        'border-top-color': cssColor,
        'border-top-style': cssBorderStyle,
        'border-top-width': cssWidth,
        'border-width': [4, cssWidth],
        bottom: [cssLength, 'auto'],
        'caption-side' : ['bottom', 'left', 'right', 'top'],
        clear: ['both', 'left', 'none', 'right'],
        clip: [cssShape, 'auto'],
        color: cssColor,
        content: [
            'open-quote', 'close-quote', 'no-open-quote', 'no-close-quote',
            cssString, cssUrl, cssCounter, cssAttr
        ],
        'counter-increment': [
            cssName, 'none'
        ],
        'counter-reset': [
            cssName, 'none'
        ],
        cursor: [
            cssUrl, 'auto', 'crosshair', 'default', 'e-resize', 'help', 'move',
            'n-resize', 'ne-resize', 'nw-resize', 'pointer', 's-resize',
            'se-resize', 'sw-resize', 'w-resize', 'text', 'wait'
        ],
        direction: ['ltr', 'rtl'],
        display: [
            'block', 'compact', 'inline', 'inline-block', 'inline-table',
            'list-item', 'marker', 'none', 'run-in', 'table', 'table-caption',
            'table-cell', 'table-column', 'table-column-group',
            'table-footer-group', 'table-header-group', 'table-row',
            'table-row-group'
        ],
        'empty-cells': ['show', 'hide'],
        'float': ['left', 'none', 'right'],
        font: [
            'caption', 'icon', 'menu', 'message-box', 'small-caption',
            'status-bar', true, 'font-size', 'font-style', 'font-weight',
            'font-family'
        ],
        'font-family': cssCommaList,
        'font-size': [
            'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large',
            'xx-large', 'larger', 'smaller', cssLength
        ],
        'font-size-adjust': ['none', cssNumber],
        'font-stretch': [
            'normal', 'wider', 'narrower', 'ultra-condensed',
            'extra-condensed', 'condensed', 'semi-condensed',
            'semi-expanded', 'expanded', 'extra-expanded'
        ],
        'font-style': [
            'normal', 'italic', 'oblique'
        ],
        'font-variant': [
            'normal', 'small-caps'
        ],
        'font-weight': [
            'normal', 'bold', 'bolder', 'lighter', cssNumber
        ],
        height: [cssLength, 'auto'],
        left: [cssLength, 'auto'],
        'letter-spacing': ['normal', cssLength],
        'line-height': ['normal', cssLineHeight],
        'list-style': [
            true, 'list-style-image', 'list-style-position', 'list-style-type'
        ],
        'list-style-image': ['none', cssUrl],
        'list-style-position': ['inside', 'outside'],
        'list-style-type': [
            'circle', 'disc', 'square', 'decimal', 'decimal-leading-zero',
            'lower-roman', 'upper-roman', 'lower-greek', 'lower-alpha',
            'lower-latin', 'upper-alpha', 'upper-latin', 'hebrew', 'katakana',
            'hiragana-iroha', 'katakana-oroha', 'none'
        ],
        margin: [4, cssMargin],
        'margin-bottom': cssMargin,
        'margin-left': cssMargin,
        'margin-right': cssMargin,
        'margin-top': cssMargin,
        'marker-offset': [cssLength, 'auto'],
        'max-height': [cssLength, 'none'],
        'max-width': [cssLength, 'none'],
        'min-height': cssLength,
        'min-width': cssLength,
        opacity: cssNumber,
        outline: [true, 'outline-color', 'outline-style', 'outline-width'],
        'outline-color': ['invert', cssColor],
        'outline-style': [
            'dashed', 'dotted', 'double', 'groove', 'inset', 'none',
            'outset', 'ridge', 'solid'
        ],
        'outline-width': cssWidth,
        overflow: cssOverflow,
        'overflow-x': cssOverflow,
        'overflow-y': cssOverflow,
        padding: [4, cssLength],
        'padding-bottom': cssLength,
        'padding-left': cssLength,
        'padding-right': cssLength,
        'padding-top': cssLength,
        'page-break-after': cssBreak,
        'page-break-before': cssBreak,
        position: ['absolute', 'fixed', 'relative', 'static'],
        quotes: [8, cssString],
        right: [cssLength, 'auto'],
        'table-layout': ['auto', 'fixed'],
        'text-align': ['center', 'justify', 'left', 'right'],
        'text-decoration': [
            'none', 'underline', 'overline', 'line-through', 'blink'
        ],
        'text-indent': cssLength,
        'text-shadow': ['none', 4, [cssColor, cssLength]],
        'text-transform': ['capitalize', 'uppercase', 'lowercase', 'none'],
        top: [cssLength, 'auto'],
        'unicode-bidi': ['normal', 'embed', 'bidi-override'],
        'vertical-align': [
            'baseline', 'bottom', 'sub', 'super', 'top', 'text-top', 'middle',
            'text-bottom', cssLength
        ],
        visibility: ['visible', 'hidden', 'collapse'],
        'white-space': [
            'normal', 'nowrap', 'pre', 'pre-line', 'pre-wrap', 'inherit'
        ],
        width: [cssLength, 'auto'],
        'word-spacing': ['normal', cssLength],
        'word-wrap': ['break-word', 'normal'],
        'z-index': ['auto', cssNumber]
    };

    function styleAttribute() {
        var v;
        while (nexttoken.id === '*' || nexttoken.id === '#' ||
                nexttoken.value === '_') {
            if (!option.css) {
                warning("Unexpected '{a}'.", nexttoken, nexttoken.value);
            }
            advance();
        }
        if (nexttoken.id === '-') {
            if (!option.css) {
                warning("Unexpected '{a}'.", nexttoken, nexttoken.value);
            }
            advance('-');
            if (!nexttoken.identifier) {
                warning(
"Expected a non-standard style attribute and instead saw '{a}'.",
                    nexttoken, nexttoken.value);
            }
            advance();
            return cssAny;
        } else {
            if (!nexttoken.identifier) {
                warning("Excepted a style attribute, and instead saw '{a}'.",
                    nexttoken, nexttoken.value);
            } else {
                if (is_own(cssAttributeData, nexttoken.value)) {
                    v = cssAttributeData[nexttoken.value];
                } else {
                    v = cssAny;
                    if (!option.css) {
                        warning("Unrecognized style attribute '{a}'.",
                                nexttoken, nexttoken.value);
                    }
                }
            }
            advance();
            return v;
        }
    }

    function styleValue(v) {
        var i = 0,
            n,
            once,
            match,
            round,
            start = 0,
            vi;
        switch (typeof v) {
        case 'function':
            return v();
        case 'string':
            if (nexttoken.identifier && nexttoken.value === v) {
                advance();
                return true;
            }
            return false;
        }
        for (;;) {
            if (i >= v.length) {
                return false;
            }
            vi = v[i];
            i += 1;
            if (vi === true) {
                break;
            } else if (typeof vi === 'number') {
                n = vi;
                vi = v[i];
                i += 1;
            } else {
                n = 1;
            }
            match = false;
            while (n > 0) {
                if (styleValue(vi)) {
                    match = true;
                    n -= 1;
                } else {
                    break;
                }
            }
            if (match) {
                return true;
            }
        }
        start = i;
        once = [];
        for (;;) {
            round = false;
            for (i = start; i < v.length; i += 1) {
                if (!once[i]) {
                    if (styleValue(cssAttributeData[v[i]])) {
                        match = true;
                        round = true;
                        once[i] = true;
                        break;
                    }
                }
            }
            if (!round) {
                return match;
            }
        }
    }

    function styleChild() {
        if (nexttoken.id === '(number)') {
            advance();
            if (nexttoken.value === 'n' && nexttoken.identifier) {
                adjacent();
                advance();
                if (nexttoken.id === '+') {
                    adjacent();
                    advance('+');
                    adjacent();
                    advance('(number)');
                }
            }
            return;
        } else {
            switch (nexttoken.value) {
            case 'odd':
            case 'even':
                if (nexttoken.identifier) {
                    advance();
                    return;
                }
            }
        }
        warning("Unexpected token '{a}'.", nexttoken, nexttoken.value);
    }

    function substyle() {
        var v;
        for (;;) {
            if (nexttoken.id === '}' || nexttoken.id === '(end)' ||
                    xquote && nexttoken.id === xquote) {
                return;
            }
            while (nexttoken.id === ';') {
                warning("Misplaced ';'.");
                advance(';');
            }
            v = styleAttribute();
            advance(':');
            if (nexttoken.identifier && nexttoken.value === 'inherit') {
                advance();
            } else {
                if (!styleValue(v)) {
                    warning("Unexpected token '{a}'.", nexttoken,
                        nexttoken.value);
                    advance();
                }
            }
            if (nexttoken.id === '!') {
                advance('!');
                adjacent();
                if (nexttoken.identifier && nexttoken.value === 'important') {
                    advance();
                } else {
                    warning("Expected '{a}' and instead saw '{b}'.",
                        nexttoken, 'important', nexttoken.value);
                }
            }
            if (nexttoken.id === '}' || nexttoken.id === xquote) {
                warning("Missing '{a}'.", nexttoken, ';');
            } else {
                advance(';');
            }
        }
    }

    function styleSelector() {
        if (nexttoken.identifier) {
            if (!is_own(htmltag, nexttoken.value)) {
                warning("Expected a tagName, and instead saw {a}.",
                    nexttoken, nexttoken.value);
            }
            advance();
        } else {
            switch (nexttoken.id) {
            case '>':
            case '+':
                advance();
                styleSelector();
                break;
            case ':':
                advance(':');
                switch (nexttoken.value) {
                case 'active':
                case 'after':
                case 'before':
                case 'checked':
                case 'disabled':
                case 'empty':
                case 'enabled':
                case 'first-child':
                case 'first-letter':
                case 'first-line':
                case 'first-of-type':
                case 'focus':
                case 'hover':
                case 'last-of-type':
                case 'link':
                case 'only-of-type':
                case 'root':
                case 'target':
                case 'visited':
                    advance();
                    break;
                case 'lang':
                    advance();
                    advance('(');
                    if (!nexttoken.identifier) {
                        warning("Expected a lang code, and instead saw :{a}.",
                            nexttoken, nexttoken.value);
                    }
                    advance(')');
                    break;
                case 'nth-child':
                case 'nth-last-child':
                case 'nth-last-of-type':
                case 'nth-of-type':
                    advance();
                    advance('(');
                    styleChild();
                    advance(')');
                    break;
                case 'not':
                    advance();
                    advance('(');
                    if (nexttoken.id === ':' && peek(0).value === 'not') {
                        warning("Nested not.");
                    }
                    styleSelector();
                    advance(')');
                    break;
                default:
                    warning("Expected a pseudo, and instead saw :{a}.",
                        nexttoken, nexttoken.value);
                }
                break;
            case '#':
                advance('#');
                if (!nexttoken.identifier) {
                    warning("Expected an id, and instead saw #{a}.",
                        nexttoken, nexttoken.value);
                }
                advance();
                break;
            case '*':
                advance('*');
                break;
            case '.':
                advance('.');
                if (!nexttoken.identifier) {
                    warning("Expected a class, and instead saw #.{a}.",
                        nexttoken, nexttoken.value);
                }
                advance();
                break;
            case '[':
                advance('[');
                if (!nexttoken.identifier) {
                    warning("Expected an attribute, and instead saw [{a}].",
                        nexttoken, nexttoken.value);
                }
                advance();
                if (nexttoken.id === '=' || nexttoken.value === '~=' ||
                        nexttoken.value === '$=' ||
                        nexttoken.value === '|=' ||
                        nexttoken.id === '*=' ||
                        nexttoken.id === '^=') {
                    advance();
                    if (nexttoken.type !== '(string)') {
                        warning("Expected a string, and instead saw {a}.",
                            nexttoken, nexttoken.value);
                    }
                    advance();
                }
                advance(']');
                break;
            default:
                error("Expected a CSS selector, and instead saw {a}.",
                    nexttoken, nexttoken.value);
            }
        }
    }

    function stylePattern() {
        var name;
        if (nexttoken.id === '{') {
            warning("Expected a style pattern, and instead saw '{a}'.", nexttoken,
                nexttoken.id);
        } else if (nexttoken.id === '@') {
            advance('@');
            name = nexttoken.value;
            if (nexttoken.identifier && atrule[name] === true) {
                advance();
                return name;
            }
            warning("Expected an at-rule, and instead saw @{a}.", nexttoken, name);
        }
        for (;;) {
            styleSelector();
            if (nexttoken.id === '</' || nexttoken.id === '{' ||
                    nexttoken.id === '(end)') {
                return '';
            }
            if (nexttoken.id === ',') {
                comma();
            }
        }
    }

    function styles() {
        var i;
        while (nexttoken.id === '@') {
            i = peek();
            if (i.identifier && i.value === 'import') {
                advance('@');
                advance();
                if (!cssUrl()) {
                    warning("Expected '{a}' and instead saw '{b}'.", nexttoken,
                        'url', nexttoken.value);
                    advance();
                }
                advance(';');
            } else {
                break;
            }
        }
        while (nexttoken.id !== '</' && nexttoken.id !== '(end)') {
            stylePattern();
            xmode = 'styleproperty';
            if (nexttoken.id === ';') {
                advance(';');
            } else {
                advance('{');
                substyle();
                xmode = 'style';
                advance('}');
            }
        }
    }


// HTML parsing.

    function doBegin(n) {
        if (n !== 'html' && !option.fragment) {
            if (n === 'div' && option.adsafe) {
                error("ADSAFE: Use the fragment option.");
            } else {
                error("Expected '{a}' and instead saw '{b}'.",
                    token, 'html', n);
            }
        }
        if (option.adsafe) {
            if (n === 'html') {
                error(
"Currently, ADsafe does not operate on whole HTML documents. It operates on <div> fragments and .js files.", token);
            }
            if (option.fragment) {
                if (n !== 'div') {
                    error("ADsafe violation: Wrap the widget in a div.", token);
                }
            } else {
                error("Use the fragment option.", token);
            }
        }
        option.browser = true;
        assume();
    }

    function doAttribute(n, a, v) {
        var u, x;
        if (a === 'id') {
            u = typeof v === 'string' ? v.toUpperCase() : '';
            if (ids[u] === true) {
                warning("Duplicate id='{a}'.", nexttoken, v);
            }
            if (option.adsafe) {
                if (adsafe_id) {
                    if (v.slice(0, adsafe_id.length) !== adsafe_id) {
                        warning("ADsafe violation: An id must have a '{a}' prefix",
                                nexttoken, adsafe_id);
                    } else if (!/^[A-Z]+_[A-Z]+$/.test(v)) {
                        warning("ADSAFE violation: bad id.");
                    }
                } else {
                    adsafe_id = v;
                    if (!/^[A-Z]+_$/.test(v)) {
                        warning("ADSAFE violation: bad id.");
                    }
                }
            }
            x = v.search(dx);
            if (x >= 0) {
                warning("Unexpected character '{a}' in {b}.", token, v.charAt(x), a);
            }
            ids[u] = true;
        } else if (a === 'class' || a === 'type' || a === 'name') {
            x = v.search(qx);
            if (x >= 0) {
                warning("Unexpected character '{a}' in {b}.", token, v.charAt(x), a);
            }
            ids[u] = true;
        } else if (a === 'href' || a === 'background' ||
                a === 'content' || a === 'data' ||
                a.indexOf('src') >= 0 || a.indexOf('url') >= 0) {
            if (option.safe && ux.test(v)) {
                error("ADsafe URL violation.");
            }
            urls.push(v);
        } else if (a === 'for') {
            if (option.adsafe) {
                if (adsafe_id) {
                    if (v.slice(0, adsafe_id.length) !== adsafe_id) {
                        warning("ADsafe violation: An id must have a '{a}' prefix",
                                nexttoken, adsafe_id);
                    } else if (!/^[A-Z]+_[A-Z]+$/.test(v)) {
                        warning("ADSAFE violation: bad id.");
                    }
                } else {
                    warning("ADSAFE violation: bad id.");
                }
            }
        } else if (a === 'name') {
            if (option.adsafe && v.indexOf('_') >= 0) {
                warning("ADsafe name violation.");
            }
        }
    }

    function doTag(n, a) {
        var i, t = htmltag[n], x;
        src = false;
        if (!t) {
            error("Unrecognized tag '<{a}>'.",
                    nexttoken,
                    n === n.toLowerCase() ? n :
                        n + ' (capitalization error)');
        }
        if (stack.length > 0) {
            if (n === 'html') {
                error("Too many <html> tags.", token);
            }
            x = t.parent;
            if (x) {
                if (x.indexOf(' ' + stack[stack.length - 1].name + ' ') < 0) {
                    error("A '<{a}>' must be within '<{b}>'.",
                            token, n, x);
                }
            } else if (!option.adsafe && !option.fragment) {
                i = stack.length;
                do {
                    if (i <= 0) {
                        error("A '<{a}>' must be within '<{b}>'.",
                                token, n, 'body');
                    }
                    i -= 1;
                } while (stack[i].name !== 'body');
            }
        }
        switch (n) {
        case 'div':
            if (option.adsafe && stack.length === 1 && !adsafe_id) {
                warning("ADSAFE violation: missing ID_.");
            }
            break;
        case 'script':
            xmode = 'script';
            advance('>');
            indent = nexttoken.from;
            if (a.lang) {
                warning("lang is deprecated.", token);
            }
            if (option.adsafe && stack.length !== 1) {
                warning("ADsafe script placement violation.", token);
            }
            if (a.src) {
                if (option.adsafe && (!adsafe_may || !approved[a.src])) {
                    warning("ADsafe unapproved script source.", token);
                }
                if (a.type) {
                    warning("type is unnecessary.", token);
                }
            } else {
                if (adsafe_went) {
                    error("ADsafe script violation.", token);
                }
                statements('script');
            }
            xmode = 'html';
            advance('</');
            if (!nexttoken.identifier && nexttoken.value !== 'script') {
                warning("Expected '{a}' and instead saw '{b}'.",
                        nexttoken, 'script', nexttoken.value);
            }
            advance();
            xmode = 'outer';
            break;
        case 'style':
            xmode = 'style';
            advance('>');
            styles();
            xmode = 'html';
            advance('</');
            if (!nexttoken.identifier && nexttoken.value !== 'style') {
                warning("Expected '{a}' and instead saw '{b}'.",
                        nexttoken, 'style', nexttoken.value);
            }
            advance();
            xmode = 'outer';
            break;
        case 'input':
            switch (a.type) {
            case 'radio':
            case 'checkbox':
            case 'button':
            case 'reset':
            case 'submit':
                break;
            case 'text':
            case 'file':
            case 'password':
            case 'file':
            case 'hidden':
            case 'image':
                if (option.adsafe && a.autocomplete !== 'off') {
                    warning("ADsafe autocomplete violation.");
                }
                break;
            default:
                warning("Bad input type.");
            }
            break;
        case 'applet':
        case 'body':
        case 'embed':
        case 'frame':
        case 'frameset':
        case 'head':
        case 'iframe':
        case 'noembed':
        case 'noframes':
        case 'object':
        case 'param':
            if (option.adsafe) {
                warning("ADsafe violation: Disallowed tag: " + n);
            }
            break;
        }
    }


    function closetag(n) {
        return '</' + n + '>';
    }

    function html() {
        var a, attributes, e, n, q, t, v, w = option.white, wmode;
        xmode = 'html';
        xquote = '';
        stack = null;
        for (;;) {
            switch (nexttoken.value) {
            case '<':
                xmode = 'html';
                advance('<');
                attributes = {};
                t = nexttoken;
                if (!t.identifier) {
                    warning("Bad identifier {a}.", t, t.value);
                }
                n = t.value;
                if (option.cap) {
                    n = n.toLowerCase();
                }
                t.name = n;
                advance();
                if (!stack) {
                    stack = [];
                    doBegin(n);
                }
                v = htmltag[n];
                if (typeof v !== 'object') {
                    error("Unrecognized tag '<{a}>'.", t, n);
                }
                e = v.empty;
                t.type = n;
                for (;;) {
                    if (nexttoken.id === '/') {
                        advance('/');
                        if (nexttoken.id !== '>') {
                            warning("Expected '{a}' and instead saw '{b}'.",
                                    nexttoken, '>', nexttoken.value);
                        }
                        break;
                    }
                    if (nexttoken.id && nexttoken.id.substr(0, 1) === '>') {
                        break;
                    }
                    if (!nexttoken.identifier) {
                        if (nexttoken.id === '(end)' || nexttoken.id === '(error)') {
                            error("Missing '>'.", nexttoken);
                        }
                        warning("Bad identifier.");
                    }
                    option.white = true;
                    nonadjacent(token, nexttoken);
                    a = nexttoken.value;
                    option.white = w;
                    advance();
                    if (!option.cap && a !== a.toLowerCase()) {
                        warning("Attribute '{a}' not all lower case.", nexttoken, a);
                    }
                    a = a.toLowerCase();
                    xquote = '';
                    if (is_own(attributes, a)) {
                        warning("Attribute '{a}' repeated.", nexttoken, a);
                    }
                    if (a.slice(0, 2) === 'on') {
                        if (!option.on) {
                            warning("Avoid HTML event handlers.");
                        }
                        xmode = 'scriptstring';
                        advance('=');
                        q = nexttoken.id;
                        if (q !== '"' && q !== "'") {
                            error("Missing quote.");
                        }
                        xquote = q;
                        wmode = option.white;
                        option.white = false;
                        advance(q);
                        statements('on');
                        option.white = wmode;
                        if (nexttoken.id !== q) {
                            error("Missing close quote on script attribute.");
                        }
                        xmode = 'html';
                        xquote = '';
                        advance(q);
                        v = false;
                    } else if (a === 'style') {
                        xmode = 'scriptstring';
                        advance('=');
                        q = nexttoken.id;
                        if (q !== '"' && q !== "'") {
                            error("Missing quote.");
                        }
                        xmode = 'styleproperty';
                        xquote = q;
                        advance(q);
                        substyle();
                        xmode = 'html';
                        xquote = '';
                        advance(q);
                        v = false;
                    } else {
                        if (nexttoken.id === '=') {
                            advance('=');
                            v = nexttoken.value;
                            if (!nexttoken.identifier &&
                                    nexttoken.id !== '"' &&
                                    nexttoken.id !== '\'' &&
                                    nexttoken.type !== '(string)' &&
                                    nexttoken.type !== '(number)' &&
                                    nexttoken.type !== '(color)') {
                                warning("Expected an attribute value and instead saw '{a}'.", token, a);
                            }
                            advance();
                        } else {
                            v = true;
                        }
                    }
                    attributes[a] = v;
                    doAttribute(n, a, v);
                }
                doTag(n, attributes);
                if (!e) {
                    stack.push(t);
                }
                xmode = 'outer';
                advance('>');
                break;
            case '</':
                xmode = 'html';
                advance('</');
                if (!nexttoken.identifier) {
                    warning("Bad identifier.");
                }
                n = nexttoken.value;
                if (option.cap) {
                    n = n.toLowerCase();
                }
                advance();
                if (!stack) {
                    error("Unexpected '{a}'.", nexttoken, closetag(n));
                }
                t = stack.pop();
                if (!t) {
                    error("Unexpected '{a}'.", nexttoken, closetag(n));
                }
                if (t.name !== n) {
                    error("Expected '{a}' and instead saw '{b}'.",
                            nexttoken, closetag(t.name), closetag(n));
                }
                if (nexttoken.id !== '>') {
                    error("Missing '{a}'.", nexttoken, '>');
                }
                xmode = 'outer';
                advance('>');
                break;
            case '<!':
                if (option.safe) {
                    warning("ADsafe HTML violation.");
                }
                xmode = 'html';
                for (;;) {
                    advance();
                    if (nexttoken.id === '>' || nexttoken.id === '(end)') {
                        break;
                    }
                    if (nexttoken.value.indexOf('--') >= 0) {
                        warning("Unexpected --.");
                    }
                    if (nexttoken.value.indexOf('<') >= 0) {
                        warning("Unexpected <.");
                    }
                    if (nexttoken.value.indexOf('>') >= 0) {
                        warning("Unexpected >.");
                    }
                }
                xmode = 'outer';
                advance('>');
                break;
            case '(end)':
                return;
            default:
                if (nexttoken.id === '(end)') {
                    error("Missing '{a}'.", nexttoken,
                            '</' + stack[stack.length - 1].value + '>');
                } else {
                    advance();
                }
            }
            if (stack && stack.length === 0 && (option.adsafe ||
                    !option.fragment || nexttoken.id === '(end)')) {
                break;
            }
        }
        if (nexttoken.id !== '(end)') {
            error("Unexpected material after the end.");
        }
    }


// Build the syntax table by declaring the syntactic elements of the language.

    type('(number)', idValue);
    type('(string)', idValue);

    syntax['(identifier)'] = {
        type: '(identifier)',
        lbp: 0,
        identifier: true,
        nud: function () {
            var v = this.value,
                s = scope[v],
                f;
            if (typeof s === 'function') {
                s = undefined;
            } else if (typeof s === 'boolean') {
                f = funct;
                funct = functions[0];
                addlabel(v, 'var');
                s = funct;
                funct = f;
            }

// The name is in scope and defined in the current function.

            if (funct === s) {

//      Change 'unused' to 'var', and reject labels.

                switch (funct[v]) {
                case 'unused':
                    funct[v] = 'var';
                    break;
                case 'label':
                    warning("'{a}' is a statement label.", token, v);
                    break;
                }

// The name is not defined in the function.  If we are in the global scope,
// then we have an undefined variable.

            } else if (funct['(global)']) {
                if (option.undef && predefined[v] !== 'boolean') {
                    warning("'{a}' is not defined.", token, v);
                }
                note_implied(token);

// If the name is already defined in the current
// function, but not as outer, then there is a scope error.

            } else {
                switch (funct[v]) {
                case 'closure':
                case 'function':
                case 'var':
                case 'unused':
                    warning("'{a}' used out of scope.", token, v);
                    break;
                case 'label':
                    warning("'{a}' is a statement label.", token, v);
                    break;
                case 'outer':
                case 'global':
                    break;
                default:

// If the name is defined in an outer function, make an outer entry, and if
// it was unused, make it var.

                    if (s === true) {
                        funct[v] = true;
                    } else if (s === null) {
                        warning("'{a}' is not allowed.", token, v);
                        note_implied(token);
                    } else if (typeof s !== 'object') {
                        if (option.undef) {
                            warning("'{a}' is not defined.", token, v);
                        } else {
                            funct[v] = true;
                        }
                        note_implied(token);
                    } else {
                        switch (s[v]) {
                        case 'function':
                        case 'var':
                        case 'unused':
                            s[v] = 'closure';
                            funct[v] = s['(global)'] ? 'global' : 'outer';
                            break;
                        case 'closure':
                        case 'parameter':
                            funct[v] = s['(global)'] ? 'global' : 'outer';
                            break;
                        case 'label':
                            warning("'{a}' is a statement label.", token, v);
                        }
                    }
                }
            }
            return this;
        },
        led: function () {
            error("Expected an operator and instead saw '{a}'.",
                    nexttoken, nexttoken.value);
        }
    };

    type('(regexp)', function () {
        return this;
    });

    delim('(endline)');
    delim('(begin)');
    delim('(end)').reach = true;
    delim('</').reach = true;
    delim('<!');
    delim('<!--');
    delim('-->');
    delim('(error)').reach = true;
    delim('}').reach = true;
    delim(')');
    delim(']');
    delim('"').reach = true;
    delim("'").reach = true;
    delim(';');
    delim(':').reach = true;
    delim(',');
    delim('#');
    delim('@');
    reserve('else');
    reserve('case').reach = true;
    reserve('catch');
    reserve('default').reach = true;
    reserve('finally');
    reservevar('arguments');
    reservevar('eval');
    reservevar('false');
    reservevar('Infinity');
    reservevar('NaN');
    reservevar('null');
    reservevar('this');
    reservevar('true');
    reservevar('undefined');
    assignop('=', 'assign', 20);
    assignop('+=', 'assignadd', 20);
    assignop('-=', 'assignsub', 20);
    assignop('*=', 'assignmult', 20);
    assignop('/=', 'assigndiv', 20).nud = function () {
        error("A regular expression literal can be confused with '/='.");
    };
    assignop('%=', 'assignmod', 20);
    bitwiseassignop('&=', 'assignbitand', 20);
    bitwiseassignop('|=', 'assignbitor', 20);
    bitwiseassignop('^=', 'assignbitxor', 20);
    bitwiseassignop('<<=', 'assignshiftleft', 20);
    bitwiseassignop('>>=', 'assignshiftright', 20);
    bitwiseassignop('>>>=', 'assignshiftrightunsigned', 20);
    infix('?', function (left, that) {
        that.left = left;
        that.right = parse(10);
        advance(':');
        that['else'] = parse(10);
        return that;
    }, 30);

    infix('||', 'or', 40);
    infix('&&', 'and', 50);
    bitwise('|', 'bitor', 70);
    bitwise('^', 'bitxor', 80);
    bitwise('&', 'bitand', 90);
    relation('==', function (left, right) {
        if (option.eqeqeq) {
            warning("Expected '{a}' and instead saw '{b}'.",
                    this, '===', '==');
        } else if (isPoorRelation(left)) {
            warning("Use '{a}' to compare with '{b}'.",
                this, '===', left.value);
        } else if (isPoorRelation(right)) {
            warning("Use '{a}' to compare with '{b}'.",
                this, '===', right.value);
        }
        return this;
    });
    relation('===');
    relation('!=', function (left, right) {
        if (option.eqeqeq) {
            warning("Expected '{a}' and instead saw '{b}'.",
                    this, '!==', '!=');
        } else if (isPoorRelation(left)) {
            warning("Use '{a}' to compare with '{b}'.",
                    this, '!==', left.value);
        } else if (isPoorRelation(right)) {
            warning("Use '{a}' to compare with '{b}'.",
                    this, '!==', right.value);
        }
        return this;
    });
    relation('!==');
    relation('<');
    relation('>');
    relation('<=');
    relation('>=');
    bitwise('<<', 'shiftleft', 120);
    bitwise('>>', 'shiftright', 120);
    bitwise('>>>', 'shiftrightunsigned', 120);
    infix('in', 'in', 120);
    infix('instanceof', 'instanceof', 120);
    infix('+', function (left, that) {
        var right = parse(130);
        if (left && right && left.id === '(string)' && right.id === '(string)') {
            left.value += right.value;
            left.character = right.character;
            if (jx.test(left.value)) {
                warning("JavaScript URL.", left);
            }
            return left;
        }
        that.left = left;
        that.right = right;
        return that;
    }, 130);
    prefix('+', 'num');
    infix('-', 'sub', 130);
    prefix('-', 'neg');
    infix('*', 'mult', 140);
    infix('/', 'div', 140);
    infix('%', 'mod', 140);

    suffix('++', 'postinc');
    prefix('++', 'preinc');
    syntax['++'].exps = true;

    suffix('--', 'postdec');
    prefix('--', 'predec');
    syntax['--'].exps = true;
    prefix('delete', function () {
        var p = parse(0);
        if (!p || (p.id !== '.' && p.id !== '[')) {
            warning("Expected '{a}' and instead saw '{b}'.",
                    nexttoken, '.', nexttoken.value);
        }
        this.first = p;
        return this;
    }).exps = true;


    prefix('~', function () {
        if (option.bitwise) {
            warning("Unexpected '{a}'.", this, '~');
        }
        parse(150);
        return this;
    });
    prefix('!', function () {
        this.right = parse(150);
        this.arity = 'unary';
        if (bang[this.right.id] === true) {
            warning("Confusing use of '{a}'.", this, '!');
        }
        return this;
    });
    prefix('typeof', 'typeof');
    prefix('new', function () {
        var c = parse(155), i;
        if (c && c.id !== 'function') {
            if (c.identifier) {
                c['new'] = true;
                switch (c.value) {
                case 'Object':
                    warning("Use the object literal notation {}.", token);
                    break;
                case 'Array':
                    if (nexttoken.id !== '(') {
                        warning("Use the array literal notation [].", token);
                    } else {
                        advance('(');
                        if (nexttoken.id === ')') {
                            warning("Use the array literal notation [].", token);
                        } else {
                            i = parse(0);
                            c.dimension = i;
                            if ((i.id === '(number)' && /[.+\-Ee]/.test(i.value)) ||
                                    (i.id === '-' && !i.right) ||
                                    i.id === '(string)' || i.id === '[' ||
                                    i.id === '{' || i.id === 'true' ||
                                    i.id === 'false' ||
                                    i.id === 'null' || i.id === 'undefined' ||
                                    i.id === 'Infinity') {
                                warning("Use the array literal notation [].", token);
                            }
                            if (nexttoken.id !== ')') {
                                error("Use the array literal notation [].", token);
                            }
                        }
                        advance(')');
                    }
                    this.first = c;
                    return this;
                case 'Number':
                case 'String':
                case 'Boolean':
                case 'Math':
                case 'JSON':
                    warning("Do not use {a} as a constructor.", token, c.value);
                    break;
                case 'Function':
                    if (!option.evil) {
                        warning("The Function constructor is eval.");
                    }
                    break;
                case 'Date':
                case 'RegExp':
                    break;
                default:
                    if (c.id !== 'function') {
                        i = c.value.substr(0, 1);
                        if (option.newcap && (i < 'A' || i > 'Z')) {
                            warning(
                    "A constructor name should start with an uppercase letter.",
                                token);
                        }
                    }
                }
            } else {
                if (c.id !== '.' && c.id !== '[' && c.id !== '(') {
                    warning("Bad constructor.", token);
                }
            }
        } else {
            warning("Weird construction. Delete 'new'.", this);
        }
        adjacent(token, nexttoken);
        if (nexttoken.id !== '(') {
            warning("Missing '()' invoking a constructor.");
        }
        this.first = c;
        return this;
    });
    syntax['new'].exps = true;

    infix('.', function (left, that) {
        adjacent(prevtoken, token);
        var m = identifier();
        if (typeof m === 'string') {
            countMember(m);
        }
        that.left = left;
        that.right = m;
        if (!option.evil && left && left.value === 'document' &&
                (m === 'write' || m === 'writeln')) {
            warning("document.write can be a form of eval.", left);
        } else if (option.adsafe) {
            if (left && left.value === 'ADSAFE') {
                if (m === 'id' || m === 'lib') {
                    warning("ADsafe violation.", that);
                } else if (m === 'go') {
                    if (xmode !== 'script') {
                        warning("ADsafe violation.", that);
                    } else if (adsafe_went || nexttoken.id !== '(' ||
                            peek(0).id !== '(string)' ||
                            peek(0).value !== adsafe_id ||
                            peek(1).id !== ',') {
                        error("ADsafe violation: go.", that);
                    }
                    adsafe_went = true;
                    adsafe_may = false;
                }
            }
        }
        if (!option.evil && (m === 'eval' || m === 'execScript')) {
            warning('eval is evil.');
        } else if (option.safe) {
            for (;;) {
                if (banned[m] === true) {
                    warning("ADsafe restricted word '{a}'.", token, m);
                }
                if (typeof predefined[left.value] !== 'boolean' ||
                        nexttoken.id === '(') {
                    break;
                }
                if (standard_member[m] === true) {
                    if (nexttoken.id === '.') {
                        warning("ADsafe violation.", that);
                    }
                    break;
                }
                if (nexttoken.id !== '.') {
                    warning("ADsafe violation.", that);
                    break;
                }
                advance('.');
                token.left = that;
                token.right = m;
                that = token;
                m = identifier();
                if (typeof m === 'string') {
                    countMember(m);
                }
            }
        }
        return that;
    }, 160, true);

    infix('(', function (left, that) {
        adjacent(prevtoken, token);
        nospace();
        var n = 0,
            p = [];
        if (left) {
            if (left.type === '(identifier)') {
                if (left.value.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {
                    if (left.value !== 'Number' && left.value !== 'String' &&
                            left.value !== 'Boolean' &&
                            left.value !== 'Date') {
                        if (left.value === 'Math') {
                            warning("Math is not a function.", left);
                        } else if (option.newcap) {
                            warning(
"Missing 'new' prefix when invoking a constructor.", left);
                        }
                    }
                }
            } else if (left.id === '.') {
                if (option.safe && left.left.value === 'Math' &&
                        left.right === 'random') {
                    warning("ADsafe violation.", left);
                }
            }
        }
        if (nexttoken.id !== ')') {
            for (;;) {
                p[p.length] = parse(10);
                n += 1;
                if (nexttoken.id !== ',') {
                    break;
                }
                comma();
            }
        }
        advance(')');
        if (option.immed && left.id === 'function' && nexttoken.id !== ')') {
            warning("Wrap the entire immediate function invocation in parens.",
                that);
        }
        nospace(prevtoken, token);
        if (typeof left === 'object') {
            if (left.value === 'parseInt' && n === 1) {
                warning("Missing radix parameter.", left);
            }
            if (!option.evil) {
                if (left.value === 'eval' || left.value === 'Function' ||
                        left.value === 'execScript') {
                    warning("eval is evil.", left);
                } else if (p[0] && p[0].id === '(string)' &&
                       (left.value === 'setTimeout' ||
                        left.value === 'setInterval')) {
                    warning(
    "Implied eval is evil. Pass a function instead of a string.", left);
                }
            }
            if (!left.identifier && left.id !== '.' && left.id !== '[' &&
                    left.id !== '(' && left.id !== '&&' && left.id !== '||' &&
                    left.id !== '?') {
                warning("Bad invocation.", left);
            }
        }
        that.left = left;
        return that;
    }, 155, true).exps = true;

    prefix('(', function () {
        nospace();
        var v = parse(0);
        advance(')', this);
        nospace(prevtoken, token);
        if (option.immed && v.id === 'function') {
            if (nexttoken.id === '(') {
                warning(
"Move the invocation into the parens that contain the function.", nexttoken);
            } else {
                warning(
"Do not wrap function literals in parens unless they are to be immediately invoked.",
                        this);
            }
        }
        return v;
    });

    infix('[', function (left, that) {
        nospace();
        var e = parse(0), s;
        if (e && e.type === '(string)') {
            if (option.safe && banned[e.value] === true) {
                warning("ADsafe restricted word '{a}'.", that, e.value);
            } else if (!option.evil &&
                    (e.value === 'eval' || e.value === 'execScript')) {
                warning("eval is evil.", that);
            } else if (option.safe &&
                    (e.value.charAt(0) === '_' || e.value.charAt(0) === '-')) {
                warning("ADsafe restricted subscript '{a}'.", that, e.value);
            }
            countMember(e.value);
            if (!option.sub && ix.test(e.value)) {
                s = syntax[e.value];
                if (!s || !s.reserved) {
                    warning("['{a}'] is better written in dot notation.",
                            e, e.value);
                }
            }
        } else if (!e || e.type !== '(number)' || e.value < 0) {
            if (option.safe) {
                warning('ADsafe subscripting.');
            }
        }
        advance(']', that);
        nospace(prevtoken, token);
        that.left = left;
        that.right = e;
        return that;
    }, 160, true);

    prefix('[', function () {
        var b = token.line !== nexttoken.line;
        this.first = [];
        if (b) {
            indent += option.indent;
            if (nexttoken.from === indent + option.indent) {
                indent += option.indent;
            }
        }
        while (nexttoken.id !== '(end)') {
            while (nexttoken.id === ',') {
                warning("Extra comma.");
                advance(',');
            }
            if (nexttoken.id === ']') {
                break;
            }
            if (b && token.line !== nexttoken.line) {
                indentation();
            }
            this.first.push(parse(10));
            if (nexttoken.id === ',') {
                comma();
                if (nexttoken.id === ']') {
                    warning("Extra comma.", token);
                    break;
                }
            } else {
                break;
            }
        }
        if (b) {
            indent -= option.indent;
            indentation();
        }
        advance(']', this);
        return this;
    }, 160);

    (function (x) {
        x.nud = function () {
            var b, i, s, seen = {};
            b = token.line !== nexttoken.line;
            if (b) {
                indent += option.indent;
                if (nexttoken.from === indent + option.indent) {
                    indent += option.indent;
                }
            }
            for (;;) {
                if (nexttoken.id === '}') {
                    break;
                }
                if (b) {
                    indentation();
                }
                i = optionalidentifier(true);
                if (!i) {
                    if (nexttoken.id === '(string)') {
                        i = nexttoken.value;
                        if (ix.test(i)) {
                            s = syntax[i];
                        }
                        advance();
                    } else if (nexttoken.id === '(number)') {
                        i = nexttoken.value.toString();
                        advance();
                    } else {
                        error("Expected '{a}' and instead saw '{b}'.",
                                nexttoken, '}', nexttoken.value);
                    }
                }
                if (seen[i] === true) {
                    warning("Duplicate member '{a}'.", nexttoken, i);
                }
                seen[i] = true;
                countMember(i);
                advance(':');
                nonadjacent(token, nexttoken);
                parse(10);
                if (nexttoken.id === ',') {
                    comma();
                    if (nexttoken.id === ',' || nexttoken.id === '}') {
                        warning("Extra comma.", token);
                    }
                } else {
                    break;
                }
            }
            if (b) {
                indent -= option.indent;
                indentation();
            }
            advance('}', this);
            return this;
        };
        x.fud = function () {
            error("Expected to see a statement and instead saw a block.", token);
        };
    }(delim('{')));


    function varstatement(prefix) {

// JavaScript does not have block scope. It only has function scope. So,
// declaring a variable in a block can have unexpected consequences.

        var id, name, value;

        if (funct['(onevar)'] && option.onevar) {
            warning("Too many var statements.");
        } else if (!funct['(global)']) {
            funct['(onevar)'] = true;
        }
        this.first = [];
        for (;;) {
            nonadjacent(token, nexttoken);
            id = identifier();
            if (funct['(global)'] && predefined[id] === false) {
                warning("Redefinition of '{a}'.", token, id);
            }
            addlabel(id, 'unused');
            if (prefix) {
                break;
            }
            name = token;
            this.first.push(token);
            if (nexttoken.id === '=') {
                nonadjacent(token, nexttoken);
                advance('=');
                nonadjacent(token, nexttoken);
                if (peek(0).id === '=' && nexttoken.identifier) {
                    error("Variable {a} was not declared correctly.",
                            nexttoken, nexttoken.value);
                }
                value = parse(0);
                name.first = value;
            }
            if (nexttoken.id !== ',') {
                break;
            }
            comma();
        }
        return this;
    }


    stmt('var', varstatement).exps = true;


    function functionparams() {
        var i, t = nexttoken, p = [];
        advance('(');
        nospace();
        if (nexttoken.id === ')') {
            advance(')');
            nospace(prevtoken, token);
            return;
        }
        for (;;) {
            i = identifier();
            p.push(i);
            addlabel(i, 'parameter');
            if (nexttoken.id === ',') {
                comma();
            } else {
                advance(')', t);
                nospace(prevtoken, token);
                return p;
            }
        }
    }

    function doFunction(i) {
        var s = scope;
        scope = Object.create(s);
        funct = {
            '(name)'    : i || '"' + anonname + '"',
            '(line)'    : nexttoken.line,
            '(context)' : funct,
            '(breakage)': 0,
            '(loopage)' : 0,
            '(scope)'   : scope
        };
        token.funct = funct;
        functions.push(funct);
        if (i) {
            addlabel(i, 'function');
        }
        funct['(params)'] = functionparams();

        block(false);
        scope = s;
        funct['(last)'] = token.line;
        funct = funct['(context)'];
    }


    blockstmt('function', function () {
        if (inblock) {
            warning(
"Function statements cannot be placed in blocks. Use a function expression or move the statement to the top of the outer function.", token);

        }
        var i = identifier();
        adjacent(token, nexttoken);
        addlabel(i, 'unused');
        doFunction(i);
        if (nexttoken.id === '(' && nexttoken.line === token.line) {
            error(
"Function statements are not invocable. Wrap the whole function invocation in parens.");
        }
        return this;
    });

    prefix('function', function () {
        var i = optionalidentifier();
        if (i) {
            adjacent(token, nexttoken);
        } else {
            nonadjacent(token, nexttoken);
        }
        doFunction(i);
        if (funct['(loopage)'] && nexttoken.id !== '(') {
            warning("Be careful when making functions within a loop. Consider putting the function in a closure.");
        }
        return this;
    });

    blockstmt('if', function () {
        var t = nexttoken;
        advance('(');
        nonadjacent(this, t);
        nospace();
        parse(20);
        if (nexttoken.id === '=') {
            warning("Expected a conditional expression and instead saw an assignment.");
            advance('=');
            parse(20);
        }
        advance(')', t);
        nospace(prevtoken, token);
        block(true);
        if (nexttoken.id === 'else') {
            nonadjacent(token, nexttoken);
            advance('else');
            if (nexttoken.id === 'if' || nexttoken.id === 'switch') {
                statement(true);
            } else {
                block(true);
            }
        }
        return this;
    });

    blockstmt('try', function () {
        var b, e, s;
        if (option.adsafe) {
            warning("ADsafe try violation.", this);
        }
        block(false);
        if (nexttoken.id === 'catch') {
            advance('catch');
            nonadjacent(token, nexttoken);
            advance('(');
            s = scope;
            scope = Object.create(s);
            e = nexttoken.value;
            if (nexttoken.type !== '(identifier)') {
                warning("Expected an identifier and instead saw '{a}'.",
                    nexttoken, e);
            } else {
                addlabel(e, 'exception');
            }
            advance();
            advance(')');
            block(false);
            b = true;
            scope = s;
        }
        if (nexttoken.id === 'finally') {
            advance('finally');
            block(false);
            return;
        } else if (!b) {
            error("Expected '{a}' and instead saw '{b}'.",
                    nexttoken, 'catch', nexttoken.value);
        }
        return this;
    });

    blockstmt('while', function () {
        var t = nexttoken;
        funct['(breakage)'] += 1;
        funct['(loopage)'] += 1;
        advance('(');
        nonadjacent(this, t);
        nospace();
        parse(20);
        if (nexttoken.id === '=') {
            warning("Expected a conditional expression and instead saw an assignment.");
            advance('=');
            parse(20);
        }
        advance(')', t);
        nospace(prevtoken, token);
        block(true);
        funct['(breakage)'] -= 1;
        funct['(loopage)'] -= 1;
        return this;
    }).labelled = true;

    reserve('with');

    blockstmt('switch', function () {
        var t = nexttoken,
            g = false;
        funct['(breakage)'] += 1;
        advance('(');
        nonadjacent(this, t);
        nospace();
        this.condition = parse(20);
        advance(')', t);
        nospace(prevtoken, token);
        nonadjacent(token, nexttoken);
        t = nexttoken;
        advance('{');
        nonadjacent(token, nexttoken);
        indent += option.indent;
        this.cases = [];
        for (;;) {
            switch (nexttoken.id) {
            case 'case':
                switch (funct['(verb)']) {
                case 'break':
                case 'case':
                case 'continue':
                case 'return':
                case 'switch':
                case 'throw':
                    break;
                default:
                    warning(
                        "Expected a 'break' statement before 'case'.",
                        token);
                }
                indentation(-option.indent);
                advance('case');
                this.cases.push(parse(20));
                g = true;
                advance(':');
                funct['(verb)'] = 'case';
                break;
            case 'default':
                switch (funct['(verb)']) {
                case 'break':
                case 'continue':
                case 'return':
                case 'throw':
                    break;
                default:
                    warning(
                        "Expected a 'break' statement before 'default'.",
                        token);
                }
                indentation(-option.indent);
                advance('default');
                g = true;
                advance(':');
                break;
            case '}':
                indent -= option.indent;
                indentation();
                advance('}', t);
                if (this.cases.length === 1 || this.condition.id === 'true' ||
                        this.condition.id === 'false') {
                    warning("This 'switch' should be an 'if'.", this);
                }
                funct['(breakage)'] -= 1;
                funct['(verb)'] = undefined;
                return;
            case '(end)':
                error("Missing '{a}'.", nexttoken, '}');
                return;
            default:
                if (g) {
                    switch (token.id) {
                    case ',':
                        error("Each value should have its own case label.");
                        return;
                    case ':':
                        statements();
                        break;
                    default:
                        error("Missing ':' on a case clause.", token);
                    }
                } else {
                    error("Expected '{a}' and instead saw '{b}'.",
                        nexttoken, 'case', nexttoken.value);
                }
            }
        }
    }).labelled = true;

    stmt('debugger', function () {
        if (!option.debug) {
            warning("All 'debugger' statements should be removed.");
        }
        return this;
    }).exps = true;

    (function () {
        var x = stmt('do', function () {
            funct['(breakage)'] += 1;
            funct['(loopage)'] += 1;
            this.first = block(true);
            advance('while');
            var t = nexttoken;
            nonadjacent(token, t);
            advance('(');
            nospace();
            parse(20);
            if (nexttoken.id === '=') {
                warning("Expected a conditional expression and instead saw an assignment.");
                advance('=');
                parse(20);
            }
            advance(')', t);
            nospace(prevtoken, token);
            funct['(breakage)'] -= 1;
            funct['(loopage)'] -= 1;
            return this;
        });
        x.labelled = true;
        x.exps = true;
    }());

    blockstmt('for', function () {
        var f = option.forin, s, t = nexttoken;
        funct['(breakage)'] += 1;
        funct['(loopage)'] += 1;
        advance('(');
        nonadjacent(this, t);
        nospace();
        if (peek(nexttoken.id === 'var' ? 1 : 0).id === 'in') {
            if (nexttoken.id === 'var') {
                advance('var');
                varstatement(true);
            } else {
                switch (funct[nexttoken.value]) {
                case 'unused':
                    funct[nexttoken.value] = 'var';
                    break;
                case 'var':
                    break;
                default:
                    warning("Bad for in variable '{a}'.",
                            nexttoken, nexttoken.value);
                }
                advance();
            }
            advance('in');
            parse(20);
            advance(')', t);
            s = block(true);
            if (!f && (s.length > 1 || typeof s[0] !== 'object' ||
                    s[0].value !== 'if')) {
                warning("The body of a for in should be wrapped in an if statement to filter unwanted properties from the prototype.", this);
            }
            funct['(breakage)'] -= 1;
            funct['(loopage)'] -= 1;
            return this;
        } else {
            if (nexttoken.id !== ';') {
                if (nexttoken.id === 'var') {
                    advance('var');
                    varstatement();
                } else {
                    for (;;) {
                        parse(0, 'for');
                        if (nexttoken.id !== ',') {
                            break;
                        }
                        comma();
                    }
                }
            }
            nolinebreak(token);
            advance(';');
            if (nexttoken.id !== ';') {
                parse(20);
                if (nexttoken.id === '=') {
                    warning("Expected a conditional expression and instead saw an assignment.");
                    advance('=');
                    parse(20);
                }
            }
            nolinebreak(token);
            advance(';');
            if (nexttoken.id === ';') {
                error("Expected '{a}' and instead saw '{b}'.",
                        nexttoken, ')', ';');
            }
            if (nexttoken.id !== ')') {
                for (;;) {
                    parse(0, 'for');
                    if (nexttoken.id !== ',') {
                        break;
                    }
                    comma();
                }
            }
            advance(')', t);
            nospace(prevtoken, token);
            block(true);
            funct['(breakage)'] -= 1;
            funct['(loopage)'] -= 1;
            return this;
        }
    }).labelled = true;


    stmt('break', function () {
        var v = nexttoken.value;
        if (funct['(breakage)'] === 0) {
            warning("Unexpected '{a}'.", nexttoken, this.value);
        }
        nolinebreak(this);
        if (nexttoken.id !== ';') {
            if (token.line === nexttoken.line) {
                if (funct[v] !== 'label') {
                    warning("'{a}' is not a statement label.", nexttoken, v);
                } else if (scope[v] !== funct) {
                    warning("'{a}' is out of scope.", nexttoken, v);
                }
                this.first = nexttoken;
                advance();
            }
        }
        reachable('break');
        return this;
    }).exps = true;


    stmt('continue', function () {
        var v = nexttoken.value;
        if (funct['(breakage)'] === 0) {
            warning("Unexpected '{a}'.", nexttoken, this.value);
        }
        nolinebreak(this);
        if (nexttoken.id !== ';') {
            if (token.line === nexttoken.line) {
                if (funct[v] !== 'label') {
                    warning("'{a}' is not a statement label.", nexttoken, v);
                } else if (scope[v] !== funct) {
                    warning("'{a}' is out of scope.", nexttoken, v);
                }
                this.first = nexttoken;
                advance();
            }
        }
        reachable('continue');
        return this;
    }).exps = true;


    stmt('return', function () {
        nolinebreak(this);
        if (nexttoken.id === '(regexp)') {
            warning("Wrap the /regexp/ literal in parens to disambiguate the slash operator.");
        }
        if (nexttoken.id !== ';' && !nexttoken.reach) {
            nonadjacent(token, nexttoken);
            this.first = parse(20);
        }
        reachable('return');
        return this;
    }).exps = true;


    stmt('throw', function () {
        nolinebreak(this);
        nonadjacent(token, nexttoken);
        this.first = parse(20);
        reachable('throw');
        return this;
    }).exps = true;

    reserve('void');

//  Superfluous reserved words

    reserve('class');
    reserve('const');
    reserve('enum');
    reserve('export');
    reserve('extends');
    reserve('import');
    reserve('super');

    reserve('let');
    reserve('yield');
    reserve('implements');
    reserve('interface');
    reserve('package');
    reserve('private');
    reserve('protected');
    reserve('public');
    reserve('static');

    function jsonValue() {

        function jsonObject() {
            var o = {}, t = nexttoken;
            advance('{');
            if (nexttoken.id !== '}') {
                for (;;) {
                    if (nexttoken.id === '(end)') {
                        error("Missing '}' to match '{' from line {a}.",
                                nexttoken, t.line);
                    } else if (nexttoken.id === '}') {
                        warning("Unexpected comma.", token);
                        break;
                    } else if (nexttoken.id === ',') {
                        error("Unexpected comma.", nexttoken);
                    } else if (nexttoken.id !== '(string)') {
                        warning("Expected a string and instead saw {a}.",
                                nexttoken, nexttoken.value);
                    }
                    if (o[nexttoken.value] === true) {
                        warning("Duplicate key '{a}'.",
                                nexttoken, nexttoken.value);
                    } else if (nexttoken.value === '__proto__') {
                        warning("Stupid key '{a}'.",
                                nexttoken, nexttoken.value);
                    } else {
                        o[nexttoken.value] = true;
                    }
                    advance();
                    advance(':');
                    jsonValue();
                    if (nexttoken.id !== ',') {
                        break;
                    }
                    advance(',');
                }
            }
            advance('}');
        }

        function jsonArray() {
            var t = nexttoken;
            advance('[');
            if (nexttoken.id !== ']') {
                for (;;) {
                    if (nexttoken.id === '(end)') {
                        error("Missing ']' to match '[' from line {a}.",
                                nexttoken, t.line);
                    } else if (nexttoken.id === ']') {
                        warning("Unexpected comma.", token);
                        break;
                    } else if (nexttoken.id === ',') {
                        error("Unexpected comma.", nexttoken);
                    }
                    jsonValue();
                    if (nexttoken.id !== ',') {
                        break;
                    }
                    advance(',');
                }
            }
            advance(']');
        }

        switch (nexttoken.id) {
        case '{':
            jsonObject();
            break;
        case '[':
            jsonArray();
            break;
        case 'true':
        case 'false':
        case 'null':
        case '(number)':
        case '(string)':
            advance();
            break;
        case '-':
            advance('-');
            if (token.character !== nexttoken.from) {
                warning("Unexpected space after '-'.", token);
            }
            adjacent(token, nexttoken);
            advance('(number)');
            break;
        default:
            error("Expected a JSON value.", nexttoken);
        }
    }


// The actual JSLINT function itself.

    var itself = function (s, o) {
        var a, i;
        JSLINT.errors = [];
        
        // aaa - Hack: I don't want to use Object.create because the 'standard'
        // object overrides hasOwnProperty which screws up our Object.create. -- Adam
        // predefined = Object.create(standard);
        predefined = {};
        predefined['__proto__'] = standard;
        
        if (o) {
            a = o.predef;
            if (a instanceof Array) {
                for (i = 0; i < a.length; i += 1) {
                    predefined[a[i]] = true;
                }
            }
            if (o.adsafe) {
                o.safe = true;
            }
            if (o.safe) {
                o.browser = false;
                o.css     = false;
                o.debug   = false;
                o.eqeqeq  = true;
                o.evil    = false;
                o.forin   = false;
                o.nomen   = true;
                o.on      = false;
                o.rhino   = false;
                o.safe    = true;
                o.sidebar = false;
                o.strict  = true;
                o.sub     = false;
                o.undef   = true;
                o.widget  = false;
                predefined.Date = null;
                predefined['eval'] = null;
                predefined.Function = null;
                predefined.Object = null;
                predefined.ADSAFE = false;
                predefined.lib = false;
            }
            option = o;
        } else {
            option = {};
        }
        option.indent = option.indent || 4;
        option.maxerr = option.maxerr || 50;
        adsafe_id = '';
        adsafe_may = false;
        adsafe_went = false;
        approved = {};
        if (option.approved) {
            for (i = 0; i < option.approved.length; i += 1) {
                approved[option.approved[i]] = option.approved[i];
            }
        } else {
            approved.test = 'test';
        }
        tab = '';
        for (i = 0; i < option.indent; i += 1) {
            tab += ' ';
        }
        indent = 1;
        
        // aaa - same hack again, see above
        // global = Object.create(predefined);
        global = {};
        global['__proto__'] = predefined;
        
        scope = global;
        funct = {
            '(global)': true,
            '(name)': '(global)',
            '(scope)': scope,
            '(breakage)': 0,
            '(loopage)': 0
        };
        functions = [funct];
        ids = {};
        urls = [];
        src = false;
        xmode = false;
        stack = null;
        member = {};
        membersOnly = null;
        implied = {};
        inblock = false;
        lookahead = [];
        jsonmode = false;
        warnings = 0;
        lex.init(s);
        prereg = true;
        strict_mode = false;

        prevtoken = token = nexttoken = syntax['(begin)'];
        assume();

        try {
            advance();
            if (nexttoken.value.charAt(0) === '<') {
                html();
                if (option.adsafe && !adsafe_went) {
                    warning("ADsafe violation: Missing ADSAFE.go.", this);
                }
            } else {
                switch (nexttoken.id) {
                case '{':
                case '[':
                    option.laxbreak = true;
                    jsonmode = true;
                    jsonValue();
                    break;
                case '@':
                case '*':
                case '#':
                case '.':
                case ':':
                    xmode = 'style';
                    advance();
                    if (token.id !== '@' || !nexttoken.identifier ||
                            nexttoken.value !== 'charset' || token.line !== 1 ||
                            token.from !== 1) {
                        error('A css file should begin with @charset "UTF-8";');
                    }
                    advance();
                    if (nexttoken.type !== '(string)' &&
                            nexttoken.value !== 'UTF-8') {
                        error('A css file should begin with @charset "UTF-8";');
                    }
                    advance();
                    advance(';');
                    styles();
                    break;

                default:
                    if (option.adsafe && option.fragment) {
                        error("Expected '{a}' and instead saw '{b}'.",
                            nexttoken, '<div>', nexttoken.value);
                    }
                    statements('lib');
                }
            }
            advance('(end)');
        } catch (e) {
            if (e) {
                JSLINT.errors.push({
                    reason    : e.message,
                    line      : e.line || nexttoken.line,
                    character : e.character || nexttoken.from
                }, null);
            }
        }
        return JSLINT.errors.length === 0;
    };

    function is_array(o) {
        return Object.prototype.toString.apply(o) === '[object Array]';
    }

    function to_array(o) {
        var a = [], k;
        for (k in o) {
            if (is_own(o, k)) {
                a.push(k);
            }
        }
        return a;
    }

// Data summary.

    itself.data = function () {

        var data = {functions: []}, fu, globals, implieds = [], f, i, j,
            members = [], n, unused = [], v;
        if (itself.errors.length) {
            data.errors = itself.errors;
        }

        if (jsonmode) {
            data.json = true;
        }

        for (n in implied) {
            if (is_own(implied, n)) {
                implieds.push({
                    name: n,
                    line: implied[n]
                });
            }
        }
        if (implieds.length > 0) {
            data.implieds = implieds;
        }

        if (urls.length > 0) {
            data.urls = urls;
        }

        globals = to_array(scope);
        if (globals.length > 0) {
            data.globals = globals;
        }

        for (i = 1; i < functions.length; i += 1) {
            f = functions[i];
            fu = {};
            for (j = 0; j < functionicity.length; j += 1) {
                fu[functionicity[j]] = [];
            }
            for (n in f) {
                if (is_own(f, n) && n.charAt(0) !== '(') {
                    v = f[n];
                    if (is_array(fu[v])) {
                        fu[v].push(n);
                        if (v === 'unused') {
                            unused.push({
                                name: n,
                                line: f['(line)'],
                                'function': f['(name)']
                            });
                        }
                    }
                }
            }
            for (j = 0; j < functionicity.length; j += 1) {
                if (fu[functionicity[j]].length === 0) {
                    delete fu[functionicity[j]];
                }
            }
            fu.name = f['(name)'];
            fu.param = f['(params)'];
            fu.line = f['(line)'];
            fu.last = f['(last)'];
            data.functions.push(fu);
        }

        if (unused.length > 0) {
            data.unused = unused;
        }

        members = [];
        for (n in member) {
            if (typeof member[n] === 'number') {
                data.member = member;
                break;
            }
        }

        return data;
    };

    itself.report = function (option) {
        var data = itself.data();

        var a = [], c, e, err, f, i, k, l, m = '', n, o = [], s;

        function detail(h, s) {
            if (s) {
                o.push('<div><i>' + h + '</i> ' +
                        s.sort().join(', ') + '</div>');
            }
        }


        if (data.errors || data.implieds || data.unused) {
            err = true;
            o.push('<div id=errors><i>Error:</i>');
            if (data.errors) {
                for (i = 0; i < data.errors.length; i += 1) {
                    c = data.errors[i];
                    if (c) {
                        e = c.evidence || '';
                        o.push('<p>Problem' + (isFinite(c.line) ? ' at line ' +
                                c.line + ' character ' + c.character : '') +
                                ': ' + c.reason.entityify() +
                                '</p><p class=evidence>' +
                                (e && (e.length > 80 ? e.slice(0, 77) + '...' :
                                e).entityify()) + '</p>');
                    }
                }
            }

            if (data.implieds) {
                s = [];
                for (i = 0; i < data.implieds.length; i += 1) {
                    s[i] = '<code>' + data.implieds[i].name + '</code>&nbsp;<i>' +
                        data.implieds[i].line + '</i>';
                }
                o.push('<p><i>Implied global:</i> ' + s.join(', ') + '</p>');
            }

            if (data.unused) {
                s = [];
                for (i = 0; i < data.unused.length; i += 1) {
                    s[i] = '<code><u>' + data.unused[i].name + '</u></code>&nbsp;<i>' +
                        data.unused[i].line + '</i> <code>' +
                        data.unused[i]['function'] + '</code>';
                }
                o.push('<p><i>Unused variable:</i> ' + s.join(', ') + '</p>');
            }
            if (data.json) {
                o.push('<p>JSON: bad.</p>');
            }
            o.push('</div>');
        }

        if (!option) {

            o.push('<br><div id=functions>');

            if (data.urls) {
                detail("URLs<br>", data.urls, '<br>');
            }

            if (data.json && !err) {
                o.push('<p>JSON: good.</p>');
            } else if (data.globals) {
                o.push('<div><i>Global</i> ' +
                        data.globals.sort().join(', ') + '</div>');
            } else {
                o.push('<div><i>No new global variables introduced.</i></div>');
            }

            for (i = 0; i < data.functions.length; i += 1) {
                f = data.functions[i];

                o.push('<br><div class=function><i>' + f.line + '-' +
                        f.last + '</i> ' + (f.name || '') + '(' +
                        (f.param ? f.param.join(', ') : '') + ')</div>');
                detail('<big><b>Unused</b></big>', f.unused);
                detail('Closure', f.closure);
                detail('Variable', f['var']);
                detail('Exception', f.exception);
                detail('Outer', f.outer);
                detail('Global', f.global);
                detail('Label', f.label);
            }

            if (data.member) {
                a = to_array(data.member);
                if (a.length) {
                    a = a.sort();
                    m = '<br><pre id=members>/*members ';
                    l = 10;
                    for (i = 0; i < a.length; i += 1) {
                        k = a[i];
                        n = k.name();
                        if (l + n.length > 72) {
                            o.push(m + '<br>');
                            m = '    ';
                            l = 1;
                        }
                        l += n.length + 2;
                        if (data.member[k] === 1) {
                            n = '<i>' + n + '</i>';
                        }
                        if (i < a.length - 1) {
                            n += ', ';
                        }
                        m += n;
                    }
                    o.push(m + '<br>*/</pre>');
                }
                o.push('</div>');
            }
        }
        return o.join('');
    };
    itself.jslint = itself;

    itself.edition = '2009-10-04';

    return itself;

}());

Global.JSLINT = JSLINT
})
avocado.transporter.module.onLoadCallbacks["jslint"] = 'done';

avocado.transporter.module.onLoadCallbacks["core/dom_stuff"] = function() {};
avocado.transporter.module.create('core/dom_stuff', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('DOMStuff', {}, {category: ['DOM stuff']});

});


thisModule.addSlots(avocado.DOMStuff, function(add) {

  add.method('isDOMNode', function (o) {
    // http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
    try {
      if (!o) { return false; }
      
      if (typeof Node === "object" && o instanceof Node) { return true; }
      if (typeof o === "object" && typeof o.nodeType === "number" && typeof o.nodeName === "string") { return true; }
    } catch (ex) {
      // Firefox sometimes throws an exception here. Don't know why.
    }
    return false;
  });

  add.method('isDOMElement', function (o) {
    try {
      if (!o) { return false; }
      
      if (typeof HTMLElement       === "object" && o instanceof HTMLElement          ) { return true; }
      if (typeof HTMLIFrameElement === "object" && o instanceof HTMLIFrameElement    ) { return true; }
      if (typeof o === "object" && o.nodeType === 1 && typeof o.nodeName === "string") { return true; }
    } catch (ex) {
      // Firefox sometimes throws an exception here. Don't know why.
    }
    return false;
  });

});


thisModule.addSlots(Node.prototype, function(add) {

  add.method('removeAllChildren', function () {
    if (this.hasChildNodes()) {
      while (this.childNodes.length > 0) {
        this.removeChild(this.firstChild);
      }
    }
    return this;
  }, {category: ['removing']});

  add.method('copy', function () {
    // aaa - There's probably a better way to do this. Heck, I'm not even completely sure this works right in all cases. -- Adam
    var thisNodeAsString = new XMLSerializer().serializeToString(this);
    return new DOMParser().parseFromString(thisNodeAsString, "text/xml").documentElement;
  }, {category: ['copying']});

  add.method('storeStringWithoutChildren', function () {
    return this.copy().removeAllChildren().storeStringIncludingChildren();
  }, {category: ['printing']});

  add.method('storeStringIncludingChildren', function () {
    return [
      'document.importNode(new DOMParser().parseFromString(',
      new XMLSerializer().serializeToString(this).inspect(),
      ', "text/xml").documentElement, false)'
    ].join('');
  }, {category: ['printing']});

});


});

avocado.transporter.module.onLoadCallbacks["core/naming"] = function() {};
avocado.transporter.module.create('core/naming', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('namingScheme', {}, {category: ['naming']});

});


thisModule.addSlots(avocado.namingScheme, function(add) {

  add.method('enclosingObjectInContext', function (context) {
    if (context) {
      if (typeof(context.enclosingObjectHavingANameInScheme) === 'function') {
        return context.enclosingObjectHavingANameInScheme(this);
      }
    }
    return null;
  });

  add.method('nameInContext', function (obj, context) {
    var enclosingObject = this.enclosingObjectInContext(context);
    return obj.nameWithinEnclosingObject(enclosingObject);
  });

});


});

avocado.transporter.module.onLoadCallbacks["core/testFramework"] = function() {};
avocado.transporter.module.create('core/testFramework', function(requires) {

requires('core/naming');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('testCase', {}, {category: ['test framework']}, {comment: 'Copied a lot of this from the LK test framework. Don\'t want\nto just use theirs because we might not always be using LK.'});

});


thisModule.addSlots(avocado.testCase, function(add) {

  add.method('initialize', function (optTestSelector) {
		this._currentSelector = optTestSelector;
		this.clearResults();
	});

  add.method('log', function (aString) {
    console.log(aString);
  }, {category: ['logging']});

  add.method('name', function () {
    return this._currentSelector || this.wholeTestCaseName();
  }, {category: ['naming']});

  add.method('wholeTestCaseName', function () {
    return reflect(this).name();
  }, {category: ['naming']});

  add.creator('namingScheme', Object.create(avocado.namingScheme), {category: ['naming']});

  add.method('nameWithinEnclosingObject', function (enclosingObject) {
    var n = this.name();
    if (enclosingObject) {
      if (enclosingObject.testToBeRun().name() === n) { return ""; }
    }
    return n;
  }, {category: ['naming']});

  add.method('testToBeRun', function () { return this; }, {category: ['accessing']});

  add.method('id', function () {
    return this.wholeTestCaseName() + '>>' + this._currentSelector;
  }, {category: ['accessing']});

  add.method('copy', function () {
    var c = Object.newChildOf(this['__proto__'], this._currentSelector);
    c._result = this._result.copy();
    c._previousRun = this;
    return c;
  }, {category: ['creating']});

  add.method('toString', function ($super) {
    return this.name();
  }, {category: ['printing']});

  add.method('inspect', function () {
    return this.name();
  }, {category: ['printing']});

  add.method('immediateContents', function () {
    var r = this.result();
    if (r.hasStarted() && r.anyFailed()) {
      var cs = [r];
      // I like the idea, but this doesn't come out quite right yet.
      // var e = r._error;
      // if (e && e.objectsToShow) { e.objectsToShow.forEach(function(o) { cs.push(o); }); }
      return cs;
    } else {
      return [];
    }
  }, {category: ['contents']});

  add.method('setUp', function () {});

  add.method('tearDown', function () {});

  add.method('createAssertionFailureException', function (msg) {
    var e = new Error(msg);
    e.isAssertion = true;
    return e;
  }, {category: ['assertions']});

  add.method('assert', function (bool, msg) {
    if (bool) { return; }
    msg = " assert failed " + (msg ? '(' + msg + ')' : '');
		this.show(this.id() + msg);
    throw this.createAssertionFailureException(msg);
  }, {category: ['assertions']});

  add.method('assertEqual', function (firstValue, secondValue, msg) {
    if (! this.areEqual(firstValue, secondValue)) {
      throw this.createAssertionFailureException((msg || "") + " (" + firstValue + " != " + secondValue + ") ");
    }
  }, {category: ['assertions']});

  add.method('assertIdentity', function (firstValue, secondValue, msg) {
		if (firstValue === secondValue) { return; }
		this.assert(false, (msg ? msg : '') + ' (' + firstValue +' !== ' + secondValue +')');
  }, {category: ['assertions']});

  add.method('assertEqualJSON', function (firstValue, secondValue, msg) {
    this.assertEqual(JSON.stringify(firstValue), JSON.stringify(secondValue), msg);
  }, {category: ['assertions']});

  add.method('areEqual', function (firstValue, secondValue) {
    if (firstValue === secondValue) { return true; }
    if (firstValue && firstValue.equals && firstValue.equals(secondValue)) { return true; } // changed this to check a general 'equals' method. -- Adam
    if (firstValue == secondValue) { return true; }
    return false;
  }, {category: ['assertions']});

  add.method('assertNotEqual', function (firstValue, secondValue, msg) {
    if (this.areEqual(firstValue, secondValue)) {
      throw this.createAssertionFailureException((msg || "") + " (" + firstValue + " == " + secondValue + ") ");
    }
  }, {category: ['assertions']});

  add.method('assertThrowsException', function (func, msg) {
    var thrown = false;
    try {
      func();
    } catch (ex) {
      thrown = true;
    }
    this.assert(thrown, msg); // can't put this inside the try because it works by throwing an exception;
  }, {category: ['assertions']});

  add.method('show', function (string) { this.log(string); }, {category: ['logging']});

  add.method('allTestSelectors', function () {
    var functionNames = [];
    for (var name in this) {
      if ((name.startsWith('test') || name.startsWith('asynchronouslyTest')) && typeof this[name] === 'function') {
        functionNames.push(name);
      }
    }
    return functionNames;
  }, {category: ['finding test methods']});

  add.method('copyForTestSelector', function (optTestSelector) {
    return Object.newChildOf(this, optTestSelector);
  });

  add.method('eachLeaf', function (f) {
    f(this);
  }, {category: ['iterating']});

  add.method('leaves', function () {
    return avocado.enumerator.create(this, 'eachLeaf');
  }, {category: ['iterating']});

  add.method('runTest', function (callback) {
    this.clearResults();
    this._result.recordStarted();
		var t1 = this._result.timestamp();
		try {
			this.setUp();
			this.runTestFunction(function() {
    		var t2 = new Date().getTime();
  			this._result.recordFinished(null, t2 - t1);
  			callback();
			}.bind(this), function(e) {
    		var t2 = new Date().getTime();
  			this._result.recordFinished(e, t2 - t1);
  		  callback();
			}.bind(this));
		} catch (e) {
  		var t2 = new Date().getTime();
			this._result.recordFinished(e, t2 - t1);
		  callback();
		} finally {
		  this.doTearDown();
		}
	});

  add.method('runTestFunction', function (successCallback, failureCallback) {
		var testFn = this[this._currentSelector];
		if (this._currentSelector.startsWith('asynchronouslyTest')) {
		  testFn.call(this, successCallback, failureCallback);
	  } else {
	    testFn.call(this);
	    successCallback();
	  }
  });

  add.method('doTearDown', function () {
		try {
			this.tearDown();
		} catch(e) {
      var errStr = "" + e.constructor.name + ": ";
      for (var i in e) { s += i + ": " + String(e[i]) + ", " }; // get everything out....
			this.log('Couldn\'t run tearDown for ' + this.id() + ' ' + printError(errStr));
		}
  });

  add.method('createAndRunAndUpdateAppearance', function (callback) {
    avocado.ui.justChanged(this);
		this.runTest(function() {
      avocado.ui.justChanged(this);
  		if (callback) { callback(this._result); }
		}.bind(this));
  }, {category: ['user interface', 'commands']});

  add.creator('singleOrCompositeResult', {}, {category: ['results']});

});


thisModule.addSlots(avocado.testCase.singleOrCompositeResult, function(add) {

  add.method('initialize', function (test) {
		this._test = test;
	}, {category: ['creating']});

  add.method('passFailSummaryString', function () {
	  var summary = { passed: 0, failed: 0, total: 0 };
	  this._test.leaves().forEach(function(leaf) {
	    summary.total += 1;
	    if (leaf.result().passed()) { summary.passed += 1; }
	    if (leaf.result().failed()) { summary.failed += 1; }
	  });
	  return summary.passed + " passed, " + summary.failed + " failed";
	}, {category: ['printing']});

});


thisModule.addSlots(avocado.testCase, function(add) {

  add.creator('singleResult', Object.create(avocado.testCase.singleOrCompositeResult), {category: ['results']});

});


thisModule.addSlots(avocado.testCase.singleResult, function(add) {

  add.method('result', function () {
    // for setting the morph's fill
    return this;
  }, {category: ['accessing']});

  add.method('copy', function () {
    return Object.deepCopyRecursingIntoCreatorSlots(this);
  }, {category: ['copying']});

  add.method('hasStarted', function () {
    return this._hasStarted;
  }, {category: ['accessing']});

  add.method('hasFinished', function () {
    return this._hasFinished;
  }, {category: ['accessing']});

  add.method('passed', function () {
    return this.hasFinished() && ! this._error;
  }, {category: ['accessing']});

  add.method('allPassed', function () {
    return this.passed();
  }, {category: ['accessing']});

  add.method('failed', function () {
    return this.hasFinished() && ! this.passed();
  }, {category: ['accessing']});

  add.method('anyFailed', function () {
    return this.failed();
  }, {category: ['accessing']});

  add.method('timeToRun', function () {
    return this._timeToRun;
  }, {category: ['accessing']});

  add.method('recordStarted', function () {
    this._hasStarted = true;
    this._timestamp = new Date().getTime();
  }, {category: ['accessing']});

  add.method('timestamp', function () {
    return this._timestamp;
  }, {category: ['accessing']});

  add.method('recordFinished', function (error, time) {
    this._error = error;
    this._timeToRun = time;
    this.recordStarted(); // since this method might be called without having already called recordStarted, if we're displaying pre-computed test results
    this._hasFinished = true;
    this._test.justRecordedFinishing(error, time);
  }, {category: ['accessing']});

  add.method('toString', function () {
    if (! this.hasStarted()) {
      return "";
    } else if (! this.hasFinished()) {
      return "running...";
    } else if (this.allPassed()) {
      return "passed";
    } else {
      var s = ["failed "];
      if (this._error.sourceURL !== undefined) {
        s.push("(", this.getFileNameFromError(this._error));
        if (this._error.line !== undefined) {
          s.push(":", this._error.line);
        }
        s.push("): ");
      }
      s.push(typeof(this._error.message) !== 'undefined' ? this._error.message : this._error);
      return s.join("");
    }
  }, {category: ['printing']});

  add.method('getFileNameFromError', function (err) {
    if (!err.sourceURL) { return ""; }
    var path = err.sourceURL.split("/");
    return path[path.length - 1].split("?")[0];
  }, {category: ['printing']});

  add.method('logFailures', function (log) {
    if (this.anyFailed()) {
      log(this._error);
    }
  }, {category: ['printing']});

  add.method('isTheSameAs', function (other) {
    if (this.passed()) {
      return other.passed();
    } else {
      return "" + this._error === "" + other._error;
    }
  }, {category: ['comparing']});

  add.method('commands', function () {
    var cmdList = avocado.command.list.create(this);
    if (this._error) {
      if (this._error.objectsToShow) {
        cmdList.addItem(avocado.command.create("show failure information", function(evt) {
          avocado.ui.showObjects(this._error.objectsToShow, "failure information", evt);
        }));
      }
    }
    return cmdList;
  }, {category: ['user interface', 'commands']});

});


thisModule.addSlots(avocado.testCase, function(add) {

  add.creator('compositeResult', Object.create(avocado.testCase.singleOrCompositeResult), {category: ['results']});

  add.creator('resultHistory', {}, {category: ['results']});

  add.method('clearResults', function () {
		this._result = Object.newChildOf(avocado.testCase.singleResult, this);
		return this;
  }, {category: ['running']});

  add.method('justRecordedFinishing', function (error, time) {
    if (this._notifier) { this._notifier.notifyAllObservers(error); }
    avocado.ui.justChanged(this);
  }, {category: ['results']});

  add.method('notifier', function () {
    return this._notifier || (this._notifier = avocado.notifier.on(this));
  }, {category: ['accessing']});

  add.method('result', function () {
    return this._result;
  }, {category: ['accessing']});

  add.method('timestamp', function () {
    // aaa - kind of weird, should really just be on the result object
    return this._result.timestamp();
  }, {category: ['accessing']});

  add.method('getTestCaseObject', function (evt) {
    avocado.ui.grab(reflect(this), evt);
  }, {category: ['user interface', 'commands']});

  add.method('commands', function () {
    var cmdList = avocado.command.list.create(this);
    cmdList.addItem({label: 'run', pluralLabel: 'run tests', go: function(evt) { this.createAndRunAndUpdateAppearance(); }});
    cmdList.addLine();
    cmdList.addItem({label: 'get test case object', go: this.getTestCaseObject});
    return cmdList;
  }, {category: ['user interface', 'commands']});

  add.method('addGlobalCommandsTo', function (cmdList) {
    cmdList.addLine();

    cmdList.addItem(["get tests", function(evt) {
      var testSuite = this.suite.forTestingAvocado();
      avocado.ui.grab(testSuite, evt);
    }.bind(this)]);
  }, {category: ['user interface', 'commands']});

  add.creator('suite', {}, {category: ['suites']});

  add.creator('subset', {}, {category: ['suites']});

});


thisModule.addSlots(avocado.testCase.compositeResult, function(add) {

  add.method('timeToRun', function () {
    var total = 0;
    this._test.subtests().forEach(function(subtest) {
      var r = subtest.result();
      total += (r && r.hasFinished() ? r.timeToRun() : 0);
    });
    return total;
	}, {category: ['accessing']});

  add.method('hasFinished', function () {
    return this._test.subtests().all(function(t) { return t.result() && t.result().hasFinished(); });
  });

  add.method('allPassed', function () {
    return this._test.subtests().all(function(t) { return t.result() && t.result().allPassed(); });
  });

  add.method('anyFailed', function () {
    return this._test.subtests().any(function(t) { return t.result() && t.result().anyFailed(); });
  });

  add.method('passes', function () {
    return this._test.subtests().select(function(t) { return t.result() && t.result().allPassed(); });
  });

  add.method('failures', function () {
    return this._test.subtests().select(function(t) { return t.result() && t.result().anyFailed(); });
  });

  add.method('passingLeaves', function () {
    return this._test.leaves().select(function(t) { return t.result() && t.result().allPassed(); });
  });

  add.method('failingLeaves', function () {
    return this._test.leaves().select(function(t) { return t.result() && t.result().anyFailed(); });
  });

  add.method('changedLeaves', function () {
    return this._test.leaves().select(function(t) { return t._previousRun && t.result() && ! t.result().isTheSameAs(t._previousRun.result()); });
  });

  add.method('logFailures', function (log) {
    this.failures().forEach(function(t) {
      t.result().logFailures(log);
    });
  });

  add.method('timestamp', function () {
    // I dunno, maybe the composite one should get its own timestamp.
    var timestamp = null;
    this._test.subtests().forEach(function(t) {
      var subTimestamp = t.result().timestamp();
      if (!timestamp || (subTimestamp && subTimestamp < timestamp)) {
        timestamp = subTimestamp;
      }
    });
    return timestamp;
  }, {category: ['accessing']});

  add.method('summarySentence', function (parts) {
    var s = avocado.activeSentence.create(parts);
    //s._aaa_hack_minimumExtent = pt(1000, 200);
    //s._aaa_hack_style = "background-color: red";
    s._aaa_hack_linkStyleClass = "summaryLink";
    s._aaa_hack_style = "font-family: sans-serif";
    s._aaa_hack_desiredSpace = pt(null, 50);
    s._aaa_hack_desiredScale = 12;
    s._aaa_hack_desiredWidth = 100;
    return s;
  }, {category: ['printing']});

  add.method('summarySentences', function (history) {
    var   totalPart = avocado.testCase.subset.create(history, this._test, history.isStillRunning(this._test) ? "so far" : "in total", this._test. leaves().toArray());
    var  failedPart = avocado.testCase.subset.create(history, this._test, "failed",                                                   this.failingLeaves().toArray());
    var  passedPart = avocado.testCase.subset.create(history, this._test, "passed",                                                   this.passingLeaves().toArray());
    var changedPart = avocado.testCase.subset.create(history, this._test, "changed",                                                  this.changedLeaves().toArray());
    // return [this.summarySentence([totalPart, ". ", passedPart, ", ", failedPart, ". ", changedPart])];
    return [
      this.summarySentence([  totalPart]),
      this.summarySentence([ passedPart]),
      this.summarySentence([ failedPart]),
      this.summarySentence([changedPart]),
    ];
  }, {category: ['printing']});

});


thisModule.addSlots(avocado.testCase.resultHistory, function(add) {

  add.method('initialize', function (entries) {
    this._entries = entries;
  }, {category: ['creating']});

  add.method('toString', function () {
    return "History of " + this.testToBeRun();
  }, {category: ['printing']});

  add.method('entries', function () { return this._entries; }, {category: ['accessing']});

  add.method('setEntries', function (entries) { this._entries = entries; return this; }, {category: ['accessing']});

  add.method('testToBeRun', function () { return this._entries[0]; }, {category: ['accessing']});

  add.data('namingScheme', avocado.testCase.namingScheme, {category: ['naming']});

  add.method('nameWithinEnclosingObject', function (enclosingObject) {
    var n = this.testToBeRun().nameWithinEnclosingObject(enclosingObject);
    return n ? "History of " + n : "History";
  }, {category: ['naming']});

  add.method('immediateContents', function () {
    var indexTable = Object.newChildOf(this.indexTable);
    var headerRow = [null, "total", "passed", "failed", "changed"].map(function(h) {
      var s = avocado.activeSentence.create([h || ""]);
      s._aaa_hack_style = "font-family: sans-serif";
      s._aaa_hack_desiredSpace = pt(null, 50);
      s._aaa_hack_desiredScale = 12;
      s._aaa_hack_desiredWidth = h ? 100 : 63;
      return s;
    });
    var rows = [];
    rows.push(headerRow);
    this._entries.forEach(function(test, rowIndex) {
      var leaves = test.leaves().toArray();
      var row;
      if (rowIndex === 0) {
        row = this.sortRowByStatus(leaves);
        row.forEach(function(leaf, index) {
          indexTable.recordNewIndexForID(leaf.id());
        });
      } else {
        row = [];
        var metaIndexByTestID = {};
        leaves.forEach(function(leaf) {
          row[indexTable.findOrCreateIndexForID(leaf.id(), metaIndexByTestID)] = leaf;
        });
      }
      
      // aaa - I want the summary, but it needs to be a constant readable size, not dependent on the number of leaves.
      row = [null].concat(test.result().summarySentences(this), row);
      rows.push(row);
    }.bind(this));

    if (this._isOKToRunItAgain && typeof(this.runItAgain) === 'function') {
      var s = avocado.activeSentence.create([{getValue: function() { return "Run"; }, doAction: function(evt) { this.runItAgain(evt); }.bind(this)}]);
      s._aaa_hack_desiredSpace = pt(null, 50);
      s._aaa_hack_desiredScale = 15;
      s._aaa_hack_desiredWidth = 50;
      rows.push([s]);
    }
    
    var table = avocado.table.contents.createWithRows(rows);
    table._desiredSpaceToScaleTo = pt(800, null); // aaa hack; I think what I need is some way to combine a Table Layout with an Auto-Scaling Layout
    return table;
  }, {category: ['contents']});

  add.method('enableRunning', function () {
    this._isOKToRunItAgain = true;
    avocado.ui.justChanged(this);
    return this;
  }, {category: ['running']});

  add.method('disableRunning', function () {
    this._isOKToRunItAgain = false;
    avocado.ui.justChanged(this);
    return this;
  }, {category: ['running']});

  add.method('isStillRunning', function (test) {
    return test === this.entries().last() && typeof(this.runItAgain) === 'function' && !this._isOKToRunItAgain;
  }, {category: ['running']});

  add.creator('indexTable', {}, {category: ['contents']}, {comment: 'I think maybe what we want is to sort the first row by status\n(so all the passing ones are together), but then use\nthe same order for subsequent rows, so that you\ncan see at a glance whether something has changed from\nthe previous run. -- Adam'});

  add.method('sortRowByStatus', function (originalRow) {
    var unfinished = [], passed = [], failed = [];
    originalRow.forEach(function(test) {
      var result = test.result();
      var section = result.hasFinished() ? (result.anyFailed() ? failed : passed) : unfinished;
      section.push(test);
    });
    return passed.concat(failed, unfinished);
  }, {category: ['contents']});

  add.method('titleModel', function () {
    if (! this._titleSentence) {
      var displayOptions = Object.newChildOf(avocado.testCase.resultHistory.displayOptions, this);
      var resultNumberHolder = avocado.accessors.forMethods(displayOptions, 'numberOfEntriesBeingShown');
      var daysNumberHolder   = avocado.accessors.forMethods(displayOptions, 'numberOfDaysBeingShown');
      this._titleSentence = avocado.activeSentence.create(["You're viewing the last ", resultNumberHolder, " results, which span ", daysNumberHolder, " days."]);
    }
    return this._titleSentence;
  }, {category: ['user interface']});

  add.creator('interestingEntriesProto', {});

  add.method('createInterestingEntriesList', function () {
    return Object.newChildOf(this.interestingEntriesProto, this);
  }, {category: ['user interface']});

  add.creator('displayOptions', {}, {category: ['user interface']});

  add.method('makeUpSomeRandomResults', function (suite, numberOfRuns, newPassFrequency, newFailFrequency, maxDelay) {
    suite.setExtraDescription("Trial " + 0);
    this.entries().push(suite);
    for (var i = 1; i <= numberOfRuns - 1; ++i) {
      suite = suite.copy().randomlyChangeSomeResults(newPassFrequency, newFailFrequency, maxDelay);
      suite.setExtraDescription("Trial " + i);
      this.entries().push(suite);
    }
    return this;
  }, {category: ['making up fake results']});

  add.method('makeUpAnotherRowOfRandomResults', function (newPassFrequency, newFailFrequency, maxDelay, callbackForEachIndividualTestFinishing, callbackForWholeThingFinishing) {
    var newEntry = this.entries().last().copy().clearResults().setExtraDescription("Trial " + this.entries().size());
    this.entries().push(newEntry);
    avocado.ui.justChanged(this, function() {
      newEntry.randomlyChangeSomeResults(newPassFrequency, newFailFrequency, maxDelay, callbackForEachIndividualTestFinishing, callbackForWholeThingFinishing);
    });
  }, {category: ['making up fake results']});

});


thisModule.addSlots(avocado.testCase.resultHistory.indexTable, function(add) {

  add.method('initialize', function () {
    this._indicesByID = {};
    this._nextFreeIndex = 0;
  }, {category: ['creating']});

  add.method('indicesForID', function (id) {
    return this._indicesByID[id] || (this._indicesByID[id] = []);
  }, {category: ['accessing']});

  add.method('recordNewIndexForID', function (id) {
    var index = this._nextFreeIndex++;
    this.indicesForID(id).push(index);
    //console.log("First row, putting " + id + " at " + index);
    return index;
  }, {category: ['accessing']});

  add.method('findOrCreateIndexForID', function (id, metaIndexByID) {
    // aaa - This has got to be some of the most confusing code I've ever written.
    // The basic problem is that we can't count on the tests all having unique IDs.
    // They probably have names that can serve as sorta-almost-unique IDs, though.
    // So _indicesByID will keep track of *all* the indices corresponding to a
    // particular ID. And so as the next set of test results comes in, we need to
    // keep track of how *many* tests with ID 42 we've seen so far. That's what
    // the "meta index" is.
    //
    // But... yikes.
    // -- Adam
    var indexOfIndex = metaIndexByID[id] || 0;
    var indices = this.indicesForID(id);
    var index = indices[indexOfIndex];
    if (typeof(index) === 'undefined') {
      index = this._nextFreeIndex++;
      indices[indexOfIndex] = index;
    }
    metaIndexByID[id] = indexOfIndex + 1;
    //console.log("Later row, putting " + id + " at " + index);
    return index;
  }, {category: ['accessing']});

});


thisModule.addSlots(avocado.testCase.resultHistory.interestingEntriesProto, function(add) {

  add.method('initialize', function (history) {
    this._history = history;
  }, {category: ['creating']});

  add.method('subset', function () {
    return this.titleModel().content();
  }, {category: ['accessing']});

  add.method('setSubset', function (subset) {
    this.titleModel().setContent(subset);
    return this;
  }, {category: ['accessing']});

  add.method('titleModel', function () {
    if (! this._titleSentence) {
      this._titleSentence = avocado.activeSentence.create([
        function() { return this.content() ? this.content().tests().size() : ""; },
        function() { return this.content() ? " tests " : ""; },
        function() { return this.content() ? this.content().fullDescription() : ""; },
        function() { return this.content() ? "." : ""; }
      ]);
    }
    return this._titleSentence;
  }, {category: ['user interface']});

});


thisModule.addSlots(avocado.testCase.resultHistory.displayOptions, function(add) {

  add.method('initialize', function (history) {
    this._history = history;
  }, {category: ['creating']});

  add.method('numberOfEntriesBeingShown', function () {
    return typeof(this._numberOfEntriesBeingShown) === 'number' ? this._numberOfEntriesBeingShown : this._history.entries().size();
  }, {category: ['accessing']});

  add.method('setNumberOfEntriesBeingShown', function (n) {
    this._numberOfEntriesBeingShown = n;
    return this;
  }, {category: ['accessing']});

  add.method('amountOfTimeBeingShown', function () {
    var oldestEntry = this._history.entries()[this._history.entries().size() - this.numberOfEntriesBeingShown()];
    if (!oldestEntry) { return 0; }
    return new Date().getTime() - oldestEntry.timestamp();
  }, {category: ['accessing']});

  add.method('setAmountOfTimeBeingShown', function (durationInMilliseconds) {
    var cutoff = new Date().getTime() - durationInMilliseconds;
    var oldestEntryIndex = this._history.entries().size();
    this._history.entries().forEach(function(e, i) { if (e.timestamp() >= cutoff) { oldestEntryIndex = i; throw $break; }; });
    this.setNumberOfEntriesBeingShown(this._history.entries().size() - oldestEntryIndex);
    return this;
  }, {category: ['accessing']});

  add.method('numberOfDaysBeingShown', function () {
    return Math.floor(this.amountOfTimeBeingShown() / (1000 * 60 * 60 * 24));
  }, {category: ['accessing']});

  add.method('setNumberOfDaysBeingShown', function (n) {
    return this.setAmountOfTimeBeingShown(1000 * 60 * 60 * 24 * n);
  }, {category: ['accessing']});

});


thisModule.addSlots(avocado.testCase.suite, function(add) {

  add.method('create', function () {
    var s = Object.create(this);
    s.initialize.apply(s, arguments);
    return s;
  }, {category: ['creating']});

  add.method('createForTestCasePrototypes', function (testCasePrototypes, name) {
    return this.create(testCasePrototypes.map(function(t) { return avocado.testCase.suite.createForAppropriatelyPrefixedMethodsOf(t); }), name);
  }, {category: ['creating']});

  add.method('createForAppropriatelyPrefixedMethodsOf', function (testCasePrototype) {
    var testCases = testCasePrototype.allTestSelectors().map(function(sel) { return testCasePrototype.copyForTestSelector(sel); });
    return this.create(testCases, testCasePrototype.wholeTestCaseName());
  }, {category: ['creating']});

  add.method('initialize', function (subtests, name) {
    this._subtests = subtests;
    this._name = name || "some tests";
    this._result = Object.newChildOf(avocado.testCase.compositeResult, this);
  }, {category: ['creating']});

  add.method('subtests', function () { return this._subtests; }, {category: ['accessing']});

  add.method('result', function () { return this._result; }, {category: ['accessing']});

  add.method('copy', function () {
    var c = avocado.testCase.suite.create(this._subtests.map(function(t) { return t.copy(); }), this._name);
    c._previousRun = this;
    return c;
  }, {category: ['creating']});

  add.method('timestamp', function () {
    // aaa - kind of weird, should really just be on the result object
    return this._result.timestamp();
  }, {category: ['accessing']});

  add.method('name', function () { return this._name; }, {category: ['accessing']});

  add.method('extraDescription', function () { return this._extraDescription; }, {category: ['accessing']});

  add.method('setExtraDescription', function (d) { this._extraDescription = d; return this; }, {category: ['accessing']});

  add.method('testToBeRun', function () { return this; }, {category: ['accessing']});

  add.method('toString', function () { return this.name(); }, {category: ['printing']});

  add.method('inspect', function () { return this.toString(); }, {category: ['printing']});

  add.data('namingScheme', avocado.testCase.namingScheme, {category: ['naming']});

  add.method('nameWithinEnclosingObject', function (enclosingObject) {
    var n = this.name();
    var d = this.extraDescription() || "";
    if (enclosingObject) {
      if (enclosingObject.testToBeRun().name() === n) { return d || ""; }
    }
    return n + (d ? ": " + d : "");
  }, {category: ['naming']});

  add.method('immediateContents', function () {
    return this.subtests();
  }, {category: ['contents']});

  add.method('requiresContentsSummary', function () {
    return false;
  }, {category: ['user interface']});

  add.data('_forTestingAvocado', null, {category: ['Avocado tests'], initializeTo: 'null'});

  add.method('forTestingAvocado', function () {
    // aaa - This should be replaced with a more general mechanism for finding tests.
    return this._forTestingAvocado || (this._forTestingAvocado = this.createForTestCasePrototypes(this.testCasePrototypesForTestingAvocado(), "Avocado tests"));
  }, {category: ['Avocado tests']});

  add.method('testCasePrototypesForTestingAvocado', function () {
    return [
      avocado.dictionary.tests,
      avocado.set.tests,
      avocado.accessors.tests,
      avocado.mirror.tests,
      avocado.transporter.tests,
      avocado.objectGraphWalker.tests,
      exitValueOf.tests,
      avocado.enumerator.tests,
      avocado.compositeCollection.tests,
      avocado.range.tests,
      avocado.notifier.tests,
      avocado.stringBuffer.tests,
      avocado.deepCopier.tests,
      String.prototype.tests,
      Array.prototype.tests,
      avocado.command.tests,
      avocado.dependencies.tests,
      avocado.list.tests,
      avocado.graphs.tests,
      //avocado.prettyPrinter.tests, // aaa - not yet working on Safari, jsparse uses regex(input) instead of regex.exec(input)
      // avocado.process.tests, // aaa - not working yet on Chrome, overflows the stack, not sure why
      avocado.remoteMirror.tests,
      // avocado.couch.db.tests, // aaa - I think these should still work, but I don't have Couch installed at the moment
    ];
  }, {category: ['Avocado tests']});

  add.method('commands', function () {
    var cmdList = avocado.command.list.create(this);
    cmdList.addItem({label: 'run', pluralLabel: 'run tests', go: function() {
      this.createAndRunAndUpdateAppearance();
    }});
    return cmdList;
  }, {category: ['user interface', 'commands']});

  add.method('dragAndDropCommands', function () {
    var cmdList = avocado.command.list.create(this);
    // aaa - allow adding and removing from the list of tests?
    return cmdList;
  }, {category: ['user interface', 'drag and drop']});

  add.method('clearResults', function () {
    this._subtests.forEach(function(t) { t.clearResults(); });
    return this;
  }, {category: ['running']});

  add.method('createAndRunAndUpdateAppearance', function (callback) {
    var thisSuite = this;
    
    this.clearResults();
    avocado.ui.justChanged(this);
    
    avocado.callbackWaiter.on(function(generateIntermediateCallback) {
      thisSuite.subtests().each(function(t) {
        var callbackForThisOne = generateIntermediateCallback();
        // Use setTimeout so that the UI thread doesn't freeze while the tests are running. Though it's not actually multithreading. -- Adam
        setTimeout(function() {
          t.createAndRunAndUpdateAppearance(function() {
            avocado.ui.justChanged(thisSuite);
            callbackForThisOne();
          });
        }, 0)
      });
    }, function() {
      avocado.ui.justChanged(thisSuite);
      if (callback) { callback(); }
    }, "running test suite");
  }, {category: ['running']});

  add.method('eachLeaf', function (f) {
    this.subtests().forEach(function(t) { t.eachLeaf(f); });
  }, {category: ['iterating']});

  add.method('leaves', function () {
    return avocado.enumerator.create(this, 'eachLeaf');
  }, {category: ['iterating']});

  add.method('makeUpSomeRandomResults', function (failureFrequency) {
    if (typeof(failureFrequency) !== 'number') { failureFrequency = 0.1; }
    this.clearResults();
    this.eachLeaf(function(test) {
      var timeToRun = Math.random() * 200;
      if (Math.random() < failureFrequency) {
        test._result.recordFinished(new Error("who knows why?"), timeToRun);
      } else {
        test._result.recordFinished(null, timeToRun);
      }
    });
    return this;
  }, {category: ['making up fake results']});

  add.method('randomlyChangeSomeResults', function (newPassFrequency, newFailFrequency, maxDelay, callbackForEachIndividualTestFinishing, callbackForWholeThingFinishing) {
    if (typeof(newPassFrequency) !== 'number') { newPassFrequency = 0.05; }
    if (typeof(newFailFrequency) !== 'number') { newFailFrequency = 0.05; }
    
    avocado.callbackWaiter.on(function(generateIntermediateCallback) {
      this.eachLeaf(function(test) {
        var timeToRun = Math.random() * 200;
        var error;
        if (test._previousRun._result.failed()) {
          error = Math.random() < newPassFrequency ? null : test._previousRun._result._error;
        } else {
          error = Math.random() < newFailFrequency ? new Error("who knows why?") : null;
        }

        var intermediateCallback = generateIntermediateCallback();
        var doThisOne = function() {
          test._result.recordFinished(error, timeToRun);
          if (callbackForEachIndividualTestFinishing) { callbackForEachIndividualTestFinishing(test); }
          intermediateCallback();
        };
        
        if (!maxDelay) {
          doThisOne();
        } else {
          setTimeout(doThisOne, Math.random() * maxDelay);
        }
      });
    }.bind(this), callbackForWholeThingFinishing, "randomly changing some test results");
    return this;
  }, {category: ['making up fake results']});

  add.method('makeUpARandomResultHistory', function (numberOfRuns, newPassFrequency, newFailFrequency) {
    var history = Object.newChildOf(avocado.testCase.resultHistory, []);
    history.makeUpSomeRandomResults(this, numberOfRuns, newPassFrequency, newFailFrequency);
    return history;
  }, {category: ['making up fake results']});

});


thisModule.addSlots(avocado.testCase.subset, function(add) {

  add.method('create', function () {
    var s = Object.create(this);
    s.initialize.apply(s, arguments);
    return s;
  }, {category: ['creating']});

  add.method('initialize', function (history, suite, kind, tests) {
    this._history = history;
    this._suite = suite;
    this._kind  = kind;
    this._tests = tests || [];
  }, {category: ['creating']});

  add.method('tests', function () {
    return this._tests;
  }, {category: ['accessing']});

  add.method('setTests', function (tests) {
    this._tests = tests;
    return this;
  }, {category: ['accessing']});

  add.method('toString', function () {
    return this._tests.size().toString(); // + " " + this._kind;
  }, {category: ['printing']});

  add.method('fullDescription', function () {
    return this._kind + (this._suite ? " in " + this._suite.nameWithinEnclosingObject(this._history) : "");
  }, {category: ['printing']});

  add.method('getValue', function () {
    return this;
  }, {category: ['accessing']});

  add.method('doAction', function (evt, linkNode) {
    this._history.showInterestingSubset(evt, this, linkNode);
  }, {category: ['linking']});

});


});

avocado.transporter.module.onLoadCallbacks["transporter/object_graph_walker"] = function() {};
avocado.transporter.module.create('transporter/object_graph_walker', function(requires) {

requires('core/testFramework');
requires('core/dom_stuff');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('objectGraphWalker', {}, {category: ['object graph']});

  add.creator('senders', {}, {category: ['object graph']});

});


thisModule.addSlots(avocado.objectGraphWalker, function(add) {

  add.method('create', function () {
    var w = Object.create(this);
    w.initialize.apply(w, arguments);
    return w;
  });

  add.method('initialize', function () {
    this._objectCount = 0; // just for fun;
  });

  add.method('visitor', function () {
    return this._visitor;
  });

  add.method('setVisitor', function (v) {
    this._visitor = v;
    return this;
  });

  add.creator('visitors', {});

  add.data('namesToIgnore', ["__annotation__", "_annotationsForObjectsThatShouldNotHaveAttributesAddedToThem", "_creatorSlotHolder", "localStorage", "sessionStorage", "globalStorage", "enabledPlugin"], {comment: 'Having enabledPlugin in here is just for now - the right solution is to figure out what\'s this clientInformation thing, and what are these arrays that aren\'t really arrays?', initializeTo: '["__annotation__", "_annotationsForObjectsThatShouldNotHaveAttributesAddedToThem", "_creatorSlotHolder", "localStorage", "sessionStorage", "globalStorage", "enabledPlugin"]'});

  add.method('go', function (root) {
    this.reset();
    this._startTime = new Date().getTime();
    this.walk(root === undefined ? window : root);
    if (this._shouldAlsoWalkSpecialUnreachableObjects) { this.walkSpecialUnreachableObjects(); }
    if (!this._shouldNotUndoMarkingsWhenDone) { this.undoAllMarkings(); }
    return this.results();
  });

  add.method('goStartingAtRootSlots', function (rootSlots) {
    this.reset();
    this._startTime = new Date().getTime();
    rootSlots.each(function(rootSlot) {
      this.walkAttribute(rootSlot.holder().reflectee(), rootSlot.name());
    }.bind(this));
    if (this._shouldAlsoWalkSpecialUnreachableObjects) { this.walkSpecialUnreachableObjects(); }
    if (!this._shouldNotUndoMarkingsWhenDone) { this.undoAllMarkings(); }
    return this.results();
  });

  add.method('reset', function () {
    // children can override
    this._marked = [];
    this._objectCount = 0;
    if (this._visitor) { this._visitor.reset(); }
  });

  add.method('results', function () {
    return this._visitor.results();
  });

  add.method('resultsAreSlots', function () {
    return this._visitor.resultsAreSlots();
  });

  add.method('objectCount', function () { return this._objectCount; });

  add.method('beInDebugMode', function () {
    this._debugMode = true;
    return this;
  });

  add.method('alsoWalkSpecialUnreachableObjects', function () {
    this._shouldAlsoWalkSpecialUnreachableObjects = true;
    return this;
  });

  add.method('doNotUndoMarkingsWhenDone', function () {
    this._shouldNotUndoMarkingsWhenDone = true;
    return this;
  });

  add.method('doNotIgnoreDOMObjects', function () {
    this._shouldNotIgnoreDOMObjects = true;
    return this;
  });

  add.method('useDOMChildNodePseudoSlots', function () {
    this.doNotIgnoreDOMObjects();
    this._shouldUseDOMChildNodePseudoSlots = true;
    return this;
  });

  add.method('ignoreSimpleMethods', function () {
    this._shouldIgnoreSimpleMethods = true;
    return this;
  });

  add.method('ignoreObjectsWithAStoreString', function () {
    this._shouldIgnoreObjectsWithAStoreString = true;
    return this;
  });

  add.method('alsoRevisitAlreadyVisitedObjects', function () {
    this._shouldRevisitAlreadyVisitedObjects = true;
    return this;
  });

  add.creator('path', {});

  add.method('walkSpecialUnreachableObjects', function () {
    var walker = this;
    
    // 'for' loops don't see String and Number and Array and their 'prototype' slots.
    ['Object', 'String', 'Number', 'Boolean', 'Array', 'Function', 'Error', 'Node', 'Text'].forEach(function(typeName) {
        var type = window[typeName];
        var pathToType          = avocado.objectGraphWalker.path.create(window, typeName);
        var pathToTypePrototype = pathToType.extendWith(type, 'prototype');
        walker.markObject(type, pathToType, true);
        walker.markObject(type.prototype, pathToTypePrototype, true);
        walker.walk(type);
        walker.walk(type.prototype);
        walker.visitor().reachedSlot(window, typeName, type); // aaa - if I do this, maybe I don't need the above line where I walk the type?
    });
    
    // another special case, I think
    this.markObject(window['__proto__'], avocado.objectGraphWalker.path.create(window, '__proto__'), true);
  });

  add.method('setShouldWalkIndexables', function (b) {
    this.shouldWalkIndexables = b;
    return this;
  });

  add.method('nameOfObjectWithPath', function (howDidWeGetHere) {
    // useful for debugging
    var s = [];
    var p = howDidWeGetHere;
    while (p) {
      s.unshift(p.slotName);
      p = p.previous;
    }
    return s.join('.');
  });

  add.creator('tests', Object.create(avocado.testCase), {category: ['tests']});

  add.method('inspect', function () {
    return this._visitor.inspect();
  });

  add.method('canHaveSlots', function (o) {
    if (o === null) { return false; }
    var t = typeof o;
    return t === 'object' || t === 'function';
  });

  add.method('shouldIgnoreObject', function (o) {
    // the DOM is a nightmare, stay away
    if (!this._shouldNotIgnoreDOMObjects && (avocado.DOMStuff.isDOMNode(o) || avocado.DOMStuff.isDOMElement(o))) { return true; }
    
    if (this._shouldIgnoreSimpleMethods && avocado.annotator.isSimpleMethod(o)) { return true; }
    
    if (this._shouldIgnoreObjectsWithAStoreString && avocado.transporter.canUseStoreStringToTransportObject(o)) { return true; }
    
    return false;
  });

  add.method('markObject', function (object, howDidWeGetHere, shouldExplicitlySetIt) {
    if (this._debugMode) { console.log("Marking object " + this.nameOfObjectWithPath(howDidWeGetHere)); }
    if (this._shouldRevisitAlreadyVisitedObjects) { // in case this is a shorter path
      this._visitor.reachedObject(object, howDidWeGetHere, shouldExplicitlySetIt);
    }
    
    // Return false if this object has already been marked; otherwise mark it and return true.
    //
    // Would use an identity dictionary here, if JavaScript could do one. As it is, we'll
    // have to mark the annotation and then come by again and unmark it.
    var objectAnno;
    try { objectAnno = avocado.annotator.annotationOf(object); } catch (ex) { return false; } // FireFox bug
    
    if (! this._visitor.shouldContinueRecursingIntoObject(object, objectAnno, howDidWeGetHere)) { return false; }
    
    var walkers = objectAnno.walkers = objectAnno.walkers || (window.avocado && avocado.set && Object.newChildOf(avocado.set, avocado.hashTable.identityComparator)) || [];
    if (walkers.include(this)) { return false; }
    walkers.push(this);
    this._marked.push(object);
    return true;
  });

  add.method('undoAllMarkings', function () {
    // Could walk the graph again so that we don't need to create this big
    // list of marked stuff. But for now this'll do.
    if (! this._marked) { return; }
    this._marked.each(function(obj) {
      var anno = avocado.annotator.actualExistingAnnotationOf(obj);
      if (anno) {
        if (anno.walkers) {
          if (anno.walkers.remove) {
            anno.walkers.remove(this);
          } else {
            anno.walkers = anno.walkers.without(this);
          }

          // Probably better to remove the walkers collection, so it doesn't stick around as a memory leak.
          if (anno.walkers.size() === 0) { delete anno.walkers; }
        }

        anno.deleteIfRedundant(obj);
      }
    }.bind(this));
    this._marked = [];
  });

  add.method('walk', function (currentObj, howDidWeGetHere) {
    if (this.shouldIgnoreObject(currentObj, howDidWeGetHere)) { return; }
    if (! this.markObject(currentObj, howDidWeGetHere)) { return; }

    this._objectCount += 1;
    this._visitor.reachedObject(currentObj, howDidWeGetHere);

    if (typeof(currentObj.hasOwnProperty) === 'function') {
      if (this._debugMode) { console.log("About to walk through the properties of object " + this.nameOfObjectWithPath(howDidWeGetHere)); }
      
      if (this._shouldUseDOMChildNodePseudoSlots && (avocado.DOMStuff.isDOMNode(currentObj) || avocado.DOMStuff.isDOMElement(currentObj))) {
        // Treat DOM nodes specially because the DOM is a nightmare.
        var childNodes = currentObj.childNodes;
        for (var i = 0, n = childNodes.length; i < n; ++i) {
          this.walkDOMChildNode(currentObj, i, childNodes[i], howDidWeGetHere);
        }
      } else {
        for (var name in currentObj) {
          if (currentObj.hasOwnProperty(name) && ! this.namesToIgnore.include(name) && !this._visitor.shouldIgnoreSlot(currentObj, name, howDidWeGetHere)) {
            this.walkAttribute(currentObj, name, howDidWeGetHere);
          }
        }
        
        if (currentObj !== null && typeof(currentObj) !== 'undefined') {
          this.walkAttribute(currentObj, '__proto__', howDidWeGetHere);
        }

        // Workaround for Chrome. -- Adam
        if (! avocado.javascript.prototypeAttributeIsEnumerable) {
          if (currentObj.hasOwnProperty("prototype")) {
            this.walkAttribute(currentObj, "prototype", howDidWeGetHere);
          }
        }
      }
    }
  });

  add.method('walkAttribute', function (currentObj, name, howDidWeGetHere) {
    if (this._debugMode) { console.log("About to walk attribute " + name + " of " + this.nameOfObjectWithPath(howDidWeGetHere)); }
    var contents;
    var encounteredFirefoxBug = false;
    try { contents = currentObj[name]; } catch (ex) { encounteredFirefoxBug = true; }
    if (! encounteredFirefoxBug) {
      this._visitor.reachedSlot(currentObj, name, contents);
      if (this._visitor.shouldContinueRecursingIntoSlot(currentObj, name, howDidWeGetHere)) {
        if (this.canHaveSlots(contents)) {
          var shouldWalkContents;
          // aaa - this isn't right. But I don't wanna walk all the indexables.
          try { shouldWalkContents = contents.constructor !== Array || this.shouldWalkIndexables; }
          catch (ex) { shouldWalkContents = true; } // another FireFox problem?
          if (shouldWalkContents) {
            this.walk(contents, avocado.objectGraphWalker.path.create(currentObj, name, howDidWeGetHere));
          }
        }
      }
    }
  });

  add.method('walkDOMChildNode', function (parentNode, index, childNode, howDidWeGetHere) {
    this._visitor.reachedDOMChildNode(parentNode, index, childNode);
    
    this.walk(childNode, avocado.objectGraphWalker.path.create(parentNode, "childnode" + index, howDidWeGetHere));
  });

});


thisModule.addSlots(avocado.objectGraphWalker.path, function(add) {

  add.method('create', function () {
    var p = Object.create(this);
    p.initialize.apply(p, arguments);
    return p;
  });

  add.method('initialize', function (slotHolder, slotName, previous) {
    this.slotHolder = slotHolder;
    this.slotName = slotName;
    this.previous = previous;
  });

  add.method('extendWith', function (slotHolder, slotName) {
    return avocado.objectGraphWalker.path.create(slotHolder, slotName, this);
  });

});


thisModule.addSlots(avocado.objectGraphWalker.tests, function(add) {

  add.method('testIncremental', function () {
    var w1 = avocado.objectGraphWalker.visitors.testingObjectGraphWalker.create().createWalker();
    w1.go();
    var n = 'objectGraphWalker_tests___extraSlotThatIAmAdding';
    var o = {};
    window[n] = o;
    var w2 = avocado.objectGraphWalker.visitors.testingObjectGraphWalker.create().createWalker();
    w2.go();
    this.assertEqual(w1.objectCount() + 1, w2.objectCount());
    delete window[n];
  });

});


thisModule.addSlots(avocado.senders, function(add) {

  add.data('byID', {}, {initializeTo: '{}'});

  add.method('of', function (id) {
    return this.byID[id] || [];
  });

  add.creator('finder', {});

  add.method('rememberIdentifiersUsedBy', function (f) {
    if (typeof(f) !== 'function') { return; }
    var str = f.toString();
    var idRegex = /[A-Z_$a-z][A-Z_$0-9a-z]*/g;
    var ids = str.match(idRegex);
    if (!ids) { return; }
    var sendersByID = this.byID;
    for (var i = 0, n = ids.length; i < n; ++i) {
      var id = ids[i];
      if (id !== '__annotation__' && !avocado.javascript.reservedWords[id]) {
        var senders = sendersByID[id];
        if (!senders) {
          senders = [];
          sendersByID[id] = senders;
        }
        senders.push(f);
      }
    }
  });

});


thisModule.addSlots(avocado.senders.finder, function(add) {

  add.method('create', function (id) {
    return Object.newChildOf(this, id);
  });

  add.method('initialize', function (id) {
    this._id = id;
  });

  add.method('inspect', function () { return "senders of " + this._id; });

  add.method('go', function () {
    return avocado.senders.of(this._id).map(function(x) {
      return reflect(x).probableCreatorSlot();
    });
  });

  add.method('resultsAreSlots', function () { return true; });

});


thisModule.addSlots(avocado.objectGraphWalker.visitors, function(add) {

  add.creator('general', {});

});


thisModule.addSlots(avocado.objectGraphWalker.visitors.general, function(add) {

  add.method('create', function () {
    var v = Object.create(this);
    v.initialize.apply(v, arguments);
    return v;
  });

  add.method('initialize', function () {
    this._results = [];
  });

  add.method('inspect', function () {
    return reflect(this).name();
  });

  add.method('createWalker', function () {
    return avocado.objectGraphWalker.create().setVisitor(this);
  });

  add.method('reset', function () {
    // children can override;
  });

  add.method('results', function () {
    return this._results;
  });

  add.method('resultsAreSlots', function () {
    return this._resultsAreSlots;
  });

  add.method('shouldContinueRecursingIntoObject', function (object, objectAnno, howDidWeGetHere) {
    // children can override
    return true;
  });

  add.method('shouldContinueRecursingIntoSlot', function (holder, slotName, howDidWeGetHere) {
    // children can override
    return true;
  });

  add.method('shouldIgnoreSlot', function (holder, slotName, contents) {
    // children can override;
    return false;
  });

  add.method('reachedObject', function (o) {
    // children can override;
  });

  add.method('reachedSlot', function (holder, slotName, contents) {
    // children can override;
  });

  add.method('reachedDOMChildNode', function (parentNode, index, childNode) {
    // children can override;
  });

});


thisModule.addSlots(avocado.objectGraphWalker.visitors, function(add) {

  add.creator('objectGraphAnnotator', Object.create(avocado.objectGraphWalker.visitors.general));

});


thisModule.addSlots(avocado.objectGraphWalker.visitors.objectGraphAnnotator, function(add) {

  add.method('createWalker', function ($super) {
    return $super().ignoreSimpleMethods().ignoreObjectsWithAStoreString().alsoRevisitAlreadyVisitedObjects();
  });

  add.method('alsoMakeCreatorSlots', function () {
    this._shouldMakeCreatorSlots = true;
    return this;
  });

  add.method('alsoBuildListsOfUsedIdentifiers', function () {
    this._shouldBuildListsOfUsedIdentifiers = true;
    return this;
  });

  add.method('alsoAssignUnownedSlotsToModule', function (moduleOrFn) {
    return this.alsoAssignSlotsToModule(function(holder, slotName, contents) {
      var holderAnno = avocado.annotator.existingAnnotationOf(holder);
      var slotAnno = holderAnno && holderAnno.existingSlotAnnotation(slotName);
      var alreadyAssignedToModule = avocado.annotator.getModuleAssignedExplicitlyOrImplicitlyTo(slotAnno, holder);
      if (alreadyAssignedToModule) {
        return undefined;
      } else {
        if (typeof(moduleOrFn) === 'function') {
          return moduleOrFn(holder, slotName, contents);
        } else {
          return moduleOrFn;
        }
      }
    });
  });

  add.method('alsoAssignSlotsToModule', function (moduleOrFn) {
    this.moduleToAssignSlotsTo = moduleOrFn;
    return this;
  });

  add.method('makeCreatorSlotIfNecessary', function (contents, howDidWeGetHere, shouldExplicitlySetIt) {
    if (! howDidWeGetHere) { return; }
    if (contents === window) { return; }
    var contentsAnno;
    var slotHolder = howDidWeGetHere.slotHolder;
    var slotName   = howDidWeGetHere.slotName;
    
    if (slotName === '__proto__') { return; } // not sure this is the right thing to do, but for now let's go with it

    // Optimization: don't bother creating an annotation just to set its creator slot if that creator
    // slot is already determinable from the object itself.
    var implicitCS = avocado.annotator.creatorSlotDeterminableFromTheObjectItself(contents);
    if (implicitCS && implicitCS.holder === slotHolder && implicitCS.name === slotName) {
      // no need to do anything
    } else {
      try { contentsAnno = avocado.annotator.annotationOf(contents); } catch (ex) { return; } // FireFox bug

      if (shouldExplicitlySetIt) {
        contentsAnno.setCreatorSlot(slotName, slotHolder);
      } else {
        var existingCS = contentsAnno.explicitlySpecifiedCreatorSlot();
        if (existingCS && existingCS.contentsObject() === contents) {
          // no need to do anything
        } else {
          contentsAnno.addPossibleCreatorSlot(slotName, slotHolder);
        }
      }
    }
  });

  add.method('reachedObject', function (contents, howDidWeGetHere, shouldExplicitlySetIt) {
    if (this._shouldMakeCreatorSlots) {
      this.makeCreatorSlotIfNecessary(contents, howDidWeGetHere, shouldExplicitlySetIt);
    }
    
    if (this._shouldBuildListsOfUsedIdentifiers) {
      // Remember identifiers so we can search for "senders".
      avocado.senders.rememberIdentifiersUsedBy(contents);
    }
  });

  add.method('reachedSlot', function (holder, slotName, contents) {
    if (! this.moduleToAssignSlotsTo) { return; }
    if (slotName === '__proto__') { return; }
    
    var module;
    if (typeof(this.moduleToAssignSlotsTo) === 'function') {
      module = this.moduleToAssignSlotsTo(holder, slotName, contents);
    } else {
      module = this.moduleToAssignSlotsTo;
    }
    
    if (module) {
      if (this._debugMode) { console.log("Setting module of " + slotName + " to " + module); }
      avocado.annotator.setModuleIfNecessary(holder, slotName, module);
    } else {
      if (this._debugMode) { console.log("NOT setting module of " + slotName); }
    }
  });

});


thisModule.addSlots(avocado.objectGraphWalker.visitors, function(add) {

  add.creator('implementorsFinder', Object.create(avocado.objectGraphWalker.visitors.general));

});


thisModule.addSlots(avocado.objectGraphWalker.visitors.implementorsFinder, function(add) {

  add.method('initialize', function ($super, slotName) {
    $super();
    this._slotNameToSearchFor = slotName;
  });

  add.method('inspect', function () { return "Well-known implementors of '" + this._slotNameToSearchFor + "'"; });

  add.method('reachedSlot', function (holder, slotName, contents) {
    if (slotName === this._slotNameToSearchFor && holder !== avocado.senders.byID && reflect(holder).isWellKnown('probableCreatorSlot')) {
      this._results.push(reflect(holder).slotAt(slotName));
    }
  });

  add.data('_resultsAreSlots', true);

});


thisModule.addSlots(avocado.objectGraphWalker.visitors, function(add) {

  add.creator('unownedSlotFinder', Object.create(avocado.objectGraphWalker.visitors.general));

});


thisModule.addSlots(avocado.objectGraphWalker.visitors.unownedSlotFinder, function(add) {

  add.method('inspect', function () { return "Unowned attributes"; });

  add.method('shouldContinueRecursingIntoObject', function (object, objectAnno, howDidWeGetHere) {
    // Factor the system better, so that this object-graph-walker
    // can do exactly what the transporter does.
    if (avocado.annotator.isSimpleMethod(object)) { return false; }
    
    if (avocado.transporter.canUseStoreStringToTransportObject(object)) { return false; }
    
    return true;
  });

  add.method('shouldContinueRecursingIntoSlot', function (holder, slotName, howDidWeGetHere) {
    var slot = reflect(holder).slotAt(slotName);
    var isCreator = slot.equals(slot.contents().explicitlySpecifiedCreatorSlot());
    if (!isCreator) { return false; }
    if (slot.getModuleAssignedToMeExplicitly()) { return false; } // since all the objects under it will implicitly have that module
    return true;
  });

  add.method('shouldIgnoreSlot', function (holder, slotName, howDidWeGetHere) {
    var slotAnno = avocado.annotator.annotationOf(holder).slotAnnotation(slotName);
    if (slotAnno.initializationExpression()) { return true; }
    return false;
  });

  add.method('reachedSlot', function (holder, slotName, contents) {
    if (slotName === '__proto__') { return; }
    var slotAnno = avocado.annotator.annotationOf(holder).existingSlotAnnotation(slotName); // for performance, don't create the annotation if it's not needed
    if (! avocado.annotator.getModuleAssignedExplicitlyOrImplicitlyTo(slotAnno, holder)) {
      if (avocado.annotator.isMagicSlotNameOnFunction(holder, slotName)) { return; }
      var slot = reflect(holder).slotAt(slotName);
      if (slot.isFromACopyDownParent()) { return; }
      
      console.log("Found unowned slot: " + slot.holder().name() + "." + slot.name());
      this._results.push(slot);
    }
  });

  add.data('_resultsAreSlots', true);

});


thisModule.addSlots(avocado.objectGraphWalker.visitors, function(add) {

  add.creator('referenceFinder', Object.create(avocado.objectGraphWalker.visitors.general));

});


thisModule.addSlots(avocado.objectGraphWalker.visitors.referenceFinder, function(add) {

  add.method('initialize', function ($super, o) {
    $super();
    this._objectToSearchFor = o;
  });

  add.method('inspect', function () { return "Well-known references to " + reflect(this._objectToSearchFor).inspect(); });

  add.method('reachedSlot', function (holder, slotName, contents) {
    if (contents === this._objectToSearchFor) {
      var holderMir = reflect(holder);
      if (holderMir.isWellKnown('probableCreatorSlot')) {
        this._results.push(holderMir.slotAt(slotName));
      }
    }
  });

  add.method('reachedObject', function (o) {
    var mir = reflect(o);
    if (mir.parent().reflectee() === this._objectToSearchFor && mir.isWellKnown('probableCreatorSlot')) {
      this._results.push(mir.parentSlot());
    }
  });

  add.data('_resultsAreSlots', true);

});


thisModule.addSlots(avocado.objectGraphWalker.visitors, function(add) {

  add.creator('childFinder', Object.create(avocado.objectGraphWalker.visitors.general));

});


thisModule.addSlots(avocado.objectGraphWalker.visitors.childFinder, function(add) {

  add.method('initialize', function ($super, o) {
    $super();
    this._objectToSearchFor = o;
  });

  add.method('reachedObject', function (o) {
    var mir = reflect(o);
    if (mir.parent().reflectee() === this._objectToSearchFor && mir.isWellKnown('probableCreatorSlot')) {
      this._results.push(o);
    }
  });

});


thisModule.addSlots(avocado.objectGraphWalker.visitors, function(add) {

  add.creator('annotationWalker', Object.create(avocado.objectGraphWalker.visitors.general));

});


thisModule.addSlots(avocado.objectGraphWalker.visitors.annotationWalker, function(add) {

  add.method('initialize', function ($super) {
    $super();
    this._simpleFunctionCount = 0;
    this._simpleFunctionPrototypeCount = 0;
    this._emptyObjectCount = 0;
    this._otherObjectCount = 0;
    this._otherObjects = [];
    this._emptyObjects = [];
  });

  add.method('reachedObject', function (o) {
    if (o && typeof(o.hasOwnProperty) === 'function' && avocado.annotator.actualExistingAnnotationOf(o)) {
      var mir = reflect(o);
      if (mir.isReflecteeSimpleMethod()) {
        this._simpleFunctionCount += 1;
      } else {
        var cs = mir.theCreatorSlot();
        if (cs && cs.name() === 'prototype' && cs.holder().isReflecteeSimpleMethod()) {
          this._simpleFunctionPrototypeCount += 1;
        } else if (mir.size() === 0 && mir.reflectee().__proto__ === Object.prototype) {
          this._emptyObjectCount += 1;
          this._emptyObjects.push(mir.reflectee());
        } else {
          this._otherObjectCount += 1;
          this._otherObjects.push(mir.reflectee());
        }
      }
    }
  });

});


thisModule.addSlots(avocado.objectGraphWalker.visitors, function(add) {

  add.creator('testingObjectGraphWalker', Object.create(avocado.objectGraphWalker.visitors.general));

});


thisModule.addSlots(avocado.objectGraphWalker.visitors.testingObjectGraphWalker, function(add) {

  add.method('createWalker', function ($super) {
    return $super().doNotUndoMarkingsWhenDone(); // so that the tests can examine the _marked list;
  });

  add.method('reset', function ($super) {
    $super();
    this._objectsReached = [];
    this._slotsReached = [];
  });

  add.method('reachedObject', function (o) {
    this._objectsReached.push(o);
  });

  add.method('reachedSlot', function (holder, slotName, contents) {
    var slot = reflect(holder).slotAt(slotName);
    this._slotsReached.push(slot);
  });

  add.method('slotCount', function () {
    return this._slotsReached.length;
  });

});


});

avocado.transporter.putUnownedSlotsInInitModule();
avocado.transporter.module.onLoadCallbacks["core/functions"] = function() {};
avocado.transporter.module.create('core/functions', function(requires) {

}, function(thisModule) {


thisModule.addSlots(Function.prototype, function(add) {

  add.method('memoize', function () {
    // aaa - this isn't really a full memoize, it's just for functions that take no arguments
    var originalFunction = this;
    var memoizingFunction = function() {
      if (! memoizingFunction.hasRun) {
        memoizingFunction.hasRun = true;
        memoizingFunction.result = originalFunction();
      }
      return memoizingFunction.result;
    };
    return memoizingFunction;
  }, {category: ['avocado']});

});


});

avocado.transporter.module.onLoadCallbacks["core/deep_copy"] = function() {};
avocado.transporter.module.create('core/deep_copy', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('deepCopier', {}, {category: ['core']}, {comment: 'Does a deep copy, recursing into creator slots. This is not *always* what you want in a deep copy, but often it is.'});

});


thisModule.addSlots(avocado.deepCopier, function(add) {

  add.method('create', function () {
    return Object.newChildOf(this);
  }, {category: ['creating']});

  add.method('initialize', function () {
    this._originalsAndCopies = [];
  }, {category: ['creating']});

  add.method('copy', function (o) {
    var c = this.createCopyOf(o);
    this.fixInternalReferences(c);
    return c;
  }, {category: ['copying']});

  add.method('createCopyOf', function (o) {
    if (o === null) { return o; }
    
    if (this._debugMode) { console.log("Calling createCopyOf " + reflect(o).inspect()); }
    
    var t = typeof(o);
    var isObj  = t === 'object';
    var isFunc = t === 'function';
    if (isObj || isFunc) {
      var c;
      if (typeof(o.duplicate) === 'function') { // aaa hack, just for now until morphs can be copied the normal way
        c = o.duplicate(this);
      } else {
        var isArray = isObj && (o instanceof Array);
        c = isObj ? (isArray ? [] : Object.create(o['__proto__'])) : eval("(" + o.toString() + ")");
        var thisCopier = this;
        for (var n in o) {
          if (o.hasOwnProperty(n)) {
            var contents = o[n];
            if (n === '__annotation__') {
              c[n] = contents.copy();
            } else {
              var contentsType = typeof(contents);
              var contentsCreatorSlot = (contentsType === 'object' || contentsType === 'function') && avocado.annotator.theCreatorSlotOf(contents);
              if (contentsCreatorSlot && contentsCreatorSlot.name === n && contentsCreatorSlot.holder === o) {
                c[n] = thisCopier.createCopyOf(contents);
                avocado.annotator.annotationOf(c[n]).setCreatorSlot(n, c);
              } else {
                c[n] = contents;
              }
            }
          }
        }
      }
      this.recordOriginalAndCopy(o, c);
      return c;
    } else {
      return o;
    }
  }, {category: ['copying']});

  add.method('recordOriginalAndCopy', function (o, c) {
    if (! this._originalsAndCopies) { this._originalsAndCopies = []; }
    this._originalsAndCopies.push({original: o, copy: c});
    return this;
  }, {category: ['internal references']});

  add.method('fixInternalReferences', function (c) {
    if (! this._originalsAndCopies) { return; }
    
    if (c === null) { return c; }
    
    if (this._debugMode) { console.log("Calling fixInternalReferences " + reflect(c).inspect()); }
    
    var t = typeof(c);
    var isObj  = t === 'object';
    var isFunc = t === 'function';
    if (isObj || isFunc) {
      var thisCopier = this;
      var originalsAndCopies = this._originalsAndCopies;
      var originalsAndCopiesCount = originalsAndCopies.length;
      for (var n in c) {
        if (c.hasOwnProperty(n)) {
          if (n === '__annotation__') {
            // just ignore it, no refs to fix up, I think - oh, actually, could do the creator slot, but we've already done it up above
          } else {
            var contents = c[n];
            var contentsType = typeof(contents);
            if (contentsType === 'object' || contentsType === 'function') {
              var wasInternalRef = false;
              for (var i = 0; i < originalsAndCopiesCount; ++i) {
                var r = originalsAndCopies[i];
                if (contents === r.original) {
                  c[n] = r.copy;
                  wasInternalRef = true;
                  break;
                }
              }
              var contentsCreatorSlot = avocado.annotator.theCreatorSlotOf(contents);
              if (contentsCreatorSlot && contentsCreatorSlot.name === n && contentsCreatorSlot.holder === c) {
                thisCopier.fixInternalReferences(c[n]);
              }
            }
          }
        }
      }
    }
  }, {category: ['internal references']});

  add.creator('tests', Object.create(avocado.testCase), {category: ['tests']});

});


thisModule.addSlots(avocado.deepCopier.tests, function(add) {

  add.creator('objectWithNoSubObjects', {});

  add.creator('objectWithSubObjects', {});

  add.creator('objectWithSubObjectsAndInternalReferences', {});

  add.method('testSimpleObject', function () {
    var o = this.objectWithNoSubObjects;
    var c = Object.deepCopyRecursingIntoCreatorSlots(o);
    this.assert(c !== o);
    this.assertEqual(3, c.x);
    this.assertEqual('four', c.y);
    this.assert(c.externalRef === avocado.deepCopier.tests.objectWithSubObjects);
  });

  add.method('testObjectWithSubObjects', function () {
    var o = this.objectWithSubObjects;
    var c = Object.deepCopyRecursingIntoCreatorSlots(o);
    this.assert(c !== o);
    this.assertEqual(5, c.x);
    this.assertEqual(true, c.b);
    this.assert(c.m !== o.m);
    this.assertEqual(o.m.toString(), c.m.toString());
    this.assertEqual(15, o.m(4, 5, 6));
    this.assertEqual(15, c.m(4, 5, 6));
    this.assert(c.subObj !== o.subObj);
    this.assertEqual('uiop', c.subObj.qwerty);
    this.assert(c.subObj.subSubObj !== o.subObj.subSubObj);
    this.assertEqual(111, c.subObj.subSubObj.zxcv);
  });

  add.method('testObjectWithSubObjectsAndInternalReferences', function () {
    var o = this.objectWithSubObjectsAndInternalReferences;
    var c = Object.deepCopyRecursingIntoCreatorSlots(o);
    this.assert(c !== o);
    this.assertEqual(1, c.a);
    this.assert(c.subObj !== o.subObj);
    this.assertEqual(24, c.subObj.x);
    this.assert(c.subObj === c.internalRefToSubObj);
    this.assert(c === c.subObj.internalRefToRootObj);
  });

});


thisModule.addSlots(avocado.deepCopier.tests.objectWithNoSubObjects, function(add) {

  add.data('x', 3);

  add.data('y', 'four');

  add.data('externalRef', avocado.deepCopier.tests.objectWithSubObjects);

});


thisModule.addSlots(avocado.deepCopier.tests.objectWithSubObjects, function(add) {

  add.data('x', 5);

  add.data('b', true);

  add.method('m', function (a1, a2, a3) {
    return a1 + a2 + a3;
  });

  add.creator('subObj', {});

});


thisModule.addSlots(avocado.deepCopier.tests.objectWithSubObjects.subObj, function(add) {

  add.data('qwerty', 'uiop');

  add.creator('subSubObj', {});

});


thisModule.addSlots(avocado.deepCopier.tests.objectWithSubObjects.subObj.subSubObj, function(add) {

  add.data('zxcv', 111);

});


thisModule.addSlots(avocado.deepCopier.tests.objectWithSubObjectsAndInternalReferences, function(add) {

  add.data('a', 1);

  add.creator('subObj', {});

  add.data('internalRefToSubObj', avocado.deepCopier.tests.objectWithSubObjectsAndInternalReferences.subObj);

});


thisModule.addSlots(avocado.deepCopier.tests.objectWithSubObjectsAndInternalReferences.subObj, function(add) {

  add.data('x', 24);

  add.data('internalRefToRootObj', avocado.deepCopier.tests.objectWithSubObjectsAndInternalReferences);

});


thisModule.addSlots(Object, function(add) {

  add.method('deepCopyRecursingIntoCreatorSlots', function (o) {
    return avocado.deepCopier.create().copy(o);
  });

});


});

avocado.transporter.module.onLoadCallbacks["core/string_buffer"] = function() {};
avocado.transporter.module.create('core/string_buffer', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('stringBuffer', {}, {category: ['core']}, {comment: 'Lets you append a whole bunch of strings and then join them all at once, so you don\'t get quadratic behavior.'});

});


thisModule.addSlots(avocado.stringBuffer, function(add) {

  add.method('create', function (initialString) {
    return Object.newChildOf(this, initialString);
  }, {category: ['creating']});

  add.method('initialize', function (initialString) {
    this._buffer = [];
    if (initialString !== undefined && initialString !== null) { this.append(initialString); }
  }, {category: ['creating']});

  add.method('append', function (string) {
    this._buffer.push(string);
    if (this._shouldNotifyUIWheneverChanged) { avocado.ui.justChanged(this); }
    return this;
  }, {category: ['adding']});

  add.method('prepend', function (string) {
    this._buffer.unshift(string);
    if (this._shouldNotifyUIWheneverChanged) { avocado.ui.justChanged(this); }
    return this;
  }, {category: ['adding']});

  add.method('isEmpty', function () {
    return this._buffer.length === 0;
  }, {category: ['testing']});

  add.method('toString', function () {
    return this._buffer.join("");
  }, {category: ['converting']});

  add.method('concat', function (other1, other2) {
    var newOne = this.create();
    newOne._buffer = this._buffer.concat(other1._buffer, other2 ? other2._buffer : undefined);
    return newOne;
  }, {category: ['concatenating']});

  add.creator('tests', Object.create(avocado.testCase), {category: ['tests']});

  add.method('startNotifyingUIWheneverChanged', function () {
    this._shouldNotifyUIWheneverChanged = true;
    return this;
  }, {category: ['user interface']});

});


thisModule.addSlots(avocado.stringBuffer.tests, function(add) {

  add.method('testStuff', function (initialString) {
    var s = avocado.stringBuffer.create('The');
    this.assertEqual('The', s.toString());
    s.append(' quick').append(' brown fox');
    this.assertEqual('The quick brown fox', s.toString());
  });

});


});

avocado.transporter.module.onLoadCallbacks["core/string_extensions"] = function() {};
avocado.transporter.module.create('core/string_extensions', function(requires) {

}, function(thisModule) {


thisModule.addSlots(String.prototype, function(add) {

  add.method('capitalize', function () {
     return this.replace( /(^|\s)([a-z])/g , function(m, p1, p2) { return p1+p2.toUpperCase(); } );
  });

  add.method('startsWithVowel', function () {
    return (/^[AEIOUaeiou]/).exec(this);
  });

  add.method('prependAOrAn', function () {
    return this.startsWithVowel() ? "an " + this : "a " + this;
  });

  add.method('withoutSuffix', function (suffix) {
    return this.endsWith(suffix) ? this.substr(0, this.length - suffix.length) : this;
  });

  add.method('replaceAt', function (i, n, s) {
    return this.substr(0, i).concat(s, this.substr(i + n));
  });

  add.method('attemptToInsertALineBreak', function () {
    // Hack. Really not sure this is gonna work, or be worth it. :) But try it and see.
    var middle = this.length / 2;
    var i1 = this.indexOf(' ', middle);
    var i2 = this.lastIndexOf(' ', middle);
    var i = (Math.abs(middle - i1) > Math.abs(middle - i2)) ? i2 : i1;
    if (i < 0) { return this.substring(0); } // I have ABSOLUTELY NO IDEA why the call to substring is necessary; VM bug in Chrome?
    return this.replaceAt(i, 1, '\n');
  });

  add.creator('tests', Object.create(avocado.testCase), {category: ['tests']});

});


thisModule.addSlots(String.prototype.tests, function(add) {

  add.method('testPrependAOrAn', function () {
    this.assertEqual('an aardvark',      'aardvark'     .prependAOrAn());
    this.assertEqual('a potato',         'potato'       .prependAOrAn());
    this.assertEqual('an Ugly Aardvark', 'Ugly Aardvark'.prependAOrAn());
    this.assertEqual('a Kumquat',        'Kumquat'      .prependAOrAn());
  });

  add.method('testWithoutSuffix', function () {
    this.assertEqual('argle', 'arglebargle'.withoutSuffix('bargle'));
    this.assertEqual('argleb', 'arglebargle'.withoutSuffix('argle'));
    this.assertEqual('arglebargle', 'arglebargle'.withoutSuffix('cargle'));
  });

  add.method('testCapitalize', function () {
    this.assertEqual('Argle', 'argle'.capitalize());
    this.assertEqual('Argle', 'Argle'.capitalize());
    this.assertEqual('ArgleBargle', 'argleBargle'.capitalize());
    this.assertEqual('Argle Bargle', 'argle bargle'.capitalize());
    this.assertEqual('  \t\n ', '  \t\n '.capitalize());
  });

  add.method('testReplaceAt', function () {
    this.assertEqual('arxle', 'argle'.replaceAt(2, 1, 'x'));
    this.assertEqual('xngle', 'argle'.replaceAt(0, 2, 'xn'));
  });

  add.method('testInsertingLineBreaks', function () {
    this.assertEqual('abcdef', 'abcdef'.attemptToInsertALineBreak());
    this.assertEqual('abc\ndef', 'abc def'.attemptToInsertALineBreak());
    this.assertEqual('ab\ncdef', 'ab cdef'.attemptToInsertALineBreak());
    this.assertEqual('ab cd\nef', 'ab cd ef'.attemptToInsertALineBreak());
  });

});


});

avocado.transporter.module.onLoadCallbacks["core/array_extensions"] = function() {};
avocado.transporter.module.create('core/array_extensions', function(requires) {

}, function(thisModule) {


thisModule.addSlots(Array.prototype, function(add) {

  add.method('selectThenMap', function (selectFn, mapFn) {
    var a = [];
    for (var i = 0, n = this.length; i < n; ++i) {
      var o = this[i];
      if (selectFn(o)) {
        a.push(mapFn(o));
      }
    }
    return a;
  }, {category: ['transforming']});

  add.method('remove', function (element) {
    var i = this.indexOf(element);
    if (i < 0) { return false; }
    this.splice(i, 1);
    return true;
  }, {category: ['transforming']});

  add.method('isEmpty', function () {
    return this.length === 0;
  }, {category: ['testing']});

});


});

avocado.transporter.module.onLoadCallbacks["core/value_holder"] = function() {};
avocado.transporter.module.create('core/value_holder', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('generalValueHolder', {}, {category: ['core']});

});


thisModule.addSlots(avocado.generalValueHolder, function(add) {

  add.method('notifier', function () {
    return this._notifier || (this._notifier = Object.newChildOf(avocado.notifier, this));
  }, {category: ['observing']});

  add.method('addObserver', function (o) {
    this.notifier().addObserver(o);
    return this;
  }, {category: ['observing']});

});


thisModule.addSlots(avocado, function(add) {

  add.creator('valueHolder', Object.create(avocado.generalValueHolder), {category: ['core']}, {comment: 'Stores a value and notifies you when someone changes it.'});

});


thisModule.addSlots(avocado.valueHolder, function(add) {

  add.method('containing', function (v) {
    return Object.newChildOf(this, v);
  }, {category: ['creating']});

  add.method('initialize', function (v) {
    this.setValue(v);
  }, {category: ['creating']});

  add.method('getValue', function () {
    return this._value;
  }, {category: ['value']});

  add.method('setValue', function (v, evt) {
    var changed = this.justSetValue(v);
    if (changed && this._notifier) {this._notifier.notifyAllObservers(evt);}
    return v;
  }, {category: ['value']});

  add.method('justSetValue', function (v) {
    if (! this.checkType(v)) {
      throw new Error("Type mismatch for " + this.name() + ": " + v);
    }
    
    var oldValue = this._value;
    var changed = this.areValuesDifferent(oldValue, v);
    this._value = v;
    return changed;
  }, {category: ['value']});

  add.method('get', function () {
    return this.getValue.apply(this, arguments);
  }, {category: ['compatibility with accessors']});

  add.method('set', function (v) {
    return this.setValue.apply(this, arguments);
  }, {category: ['compatibility with accessors']});

  add.method('canGet', function () {
    return true;
  }, {category: ['testing']});

  add.method('canSet', function () {
    return true;
  }, {category: ['testing']});

  add.method('areValuesDifferent', function (v1, v2) {
    return v1 !== v2;
  }, {category: ['testing']});

  add.method('name', function () {
    return this._name || "";
  }, {category: ['naming']});

  add.method('setName', function (n) {
    this._name = n;
    return this;
  }, {category: ['naming']});

  add.method('readableName', function () {
    return this.name();
  }, {category: ['naming']});

  add.method('title', function () {
    return this.readableName();
  }, {category: ['naming']});

  add.method('toString', function () {
    return this.readableName();
  }, {category: ['naming']});

  add.method('type', function () {
    return this._type;
  }, {category: ['types']});

  add.method('setType', function (t) {
    this._type = t;
    return this;
  }, {category: ['types']});

  add.method('checkType', function (value) {
    if (! this._type) { return true; }
    if (typeof(this._type.doesTypeMatch) !== 'function') { return true; }
    return this._type.doesTypeMatch(value);
  }, {category: ['types']});

  add.method('commands', function () {
    var cmdList = avocado.command.list.create();
    return cmdList;
  }, {category: ['commands']});

});


thisModule.addSlots(avocado, function(add) {

  add.creator('booleanHolder', Object.create(avocado.valueHolder), {category: ['core']}, {comment: 'A valueHolder for booleans.'});

});


thisModule.addSlots(avocado.booleanHolder, function(add) {

  add.method('isChecked', function () { return this.getValue();     });

  add.method('setChecked', function (b, evt) { return this.setValue(b, evt);    });

  add.method('toggle', function (evt) { return this.setValue(! this.getValue(), evt); });

  add.method('areValuesDifferent', function (v1, v2) { return (!!v1) !== (!!v2); });

});


});

avocado.transporter.module.onLoadCallbacks["core/accessors"] = function() {};
avocado.transporter.module.create('core/accessors', function(requires) {

requires('core/value_holder');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('accessors', Object.create(avocado.generalValueHolder), {category: ['core']});

});


thisModule.addSlots(avocado.accessors, function(add) {

  add.method('forAttribute', function (obj, n) {
    return avocado.attributeAccessors.create(obj, n);
  }, {category: ['creating']});

  add.method('forMethods', function (obj, getterName, setterName) {
    return avocado.methodAccessors.create(obj, getterName, setterName);
  }, {category: ['creating']});

  add.method('create', function () {
    var c = Object.create(this);
    c.initialize.apply(c, arguments);
    return c;
  }, {category: ['creating']});

  add.method('initialize', function (getter, setter) {
    this.get = getter;
    this.set = setter;
  }, {category: ['creating']});

  add.method('canGet', function () {
    return !! this.get;
  }, {category: ['testing']});

  add.method('canSet', function () {
    return !! this.set;
  }, {category: ['testing']});

  add.method('getValue', function () {
    return this.get();
  }, {category: ['accessing']});

  add.method('setValue', function (v) {
    this.set(v);
    return this;
  }, {category: ['accessing']});

  add.creator('tests', Object.create(avocado.testCase), {category: ['tests']});

});


thisModule.addSlots(avocado.accessors.tests, function(add) {

  add.method('testRawFunctions', function () {
    var i = 0;
    var a = avocado.accessors.create(function() { return i; }, function(n) { i = n; });
    this.assertEqual(0, a.get());
    a.set(77);
    this.assertEqual(77, a.get());
    this.assertEqual(77, i);
    this.assert(a.canGet());
    this.assert(a.canSet());
    
    var a2 = avocado.accessors.create(function() { return i + 6; });
    this.assertEqual(83, a2.get());
    this.assert( a2.canGet());
    this.assert(!a2.canSet());
    this.assertThrowsException(function() { a2.set(11); });
    this.assertEqual(77, i);

    var a3 = avocado.accessors.create(null, function(n) { i = n - 8; });
    this.assert(!a3.canGet());
    this.assert( a3.canSet());
    a3.set(55);
    this.assertEqual(47, i);
  });

  add.method('testAttributeAccessors', function () {
    var o = {i: 0};
    var a = avocado.accessors.forAttribute(o, 'i');
    this.assertEqual(0, a.get());
    a.set(77);
    this.assertEqual(77, a.get());
    this.assertEqual(77, o.i);
    this.assert(a.canGet());
    this.assert(a.canSet());
  });

  add.method('testMethodAccessors', function () {
    var o = { _v: 0, value: function() { return this._v; }, setValue: function(v) { this._v = v; }, setValueToHalfOf: function(w) { this._v = w / 2; } };
    var a = avocado.accessors.forMethods(o, 'value');
    this.assertEqual(0, a.get());
    a.set(77);
    this.assertEqual(77, a.get());
    this.assertEqual(77, o._v);
    this.assert(a.canGet());
    this.assert(a.canSet());
    
    var a2 = avocado.accessors.forMethods(o, 'value', 'setValueToHalfOf');
    this.assertEqual(77, a2.get());
    this.assert(a2.canGet());
    this.assert(a2.canSet());
    a2.set(66);
    this.assertEqual(33, a2.get());
    this.assertEqual(33, o._v);

    var a3 = avocado.accessors.forMethods(o, 'bleh', 'argle');
    this.assert(!a3.canGet());
    this.assert(!a3.canSet());
    this.assertThrowsException(function() { a3.get(  ); });
    this.assertThrowsException(function() { a3.set(22); });
  });

});


thisModule.addSlots(avocado, function(add) {

  add.creator('methodAccessors', Object.create(avocado.accessors), {category: ['core']});

});


thisModule.addSlots(avocado.methodAccessors, function(add) {

  add.method('initialize', function (obj, getterName, setterName) {
    this._object = obj;
    this._getterName = getterName;
    this._setterName = setterName || "set" + getterName.capitalize();
  }, {category: ['creating']});

  add.method('get', function () {
    var obj = this._object;
    var getter = obj[this._getterName];
    if (!getter) { throw new Error("No attribute named " + this._getterName + " on " + obj); }
    return getter.apply(obj, arguments);
  }, {category: ['accessing']});

  add.method('set', function (v) {
    var obj = this._object;
    var setter = obj[this._setterName];
    if (!setter) { throw new Error("No attribute named " + this._setterName + " on " + obj); }
    setter.apply(obj, arguments);
    if (this._notifier) { this._notifier.notifyAllObservers(); }
    return obj;
  }, {category: ['accessing']});

  add.method('canGet', function () {
    return !! this._object[this._getterName];
  }, {category: ['testing']});

  add.method('canSet', function () {
    return !! this._object[this._setterName];
  }, {category: ['testing']});

});


thisModule.addSlots(avocado, function(add) {

  add.creator('attributeAccessors', Object.create(avocado.accessors), {category: ['core']});

});


thisModule.addSlots(avocado.attributeAccessors, function(add) {

  add.method('initialize', function (obj, attrName) {
    this._object = obj;
    this._attrName = attrName;
  }, {category: ['creating']});

  add.method('get', function () {
    return this._object[this._attrName];
  }, {category: ['accessing']});

  add.method('set', function (v) {
    this._object[this._attrName] = v;
  }, {category: ['accessing']});

  add.method('canGet', function () {
    return true;
  }, {category: ['testing']});

  add.method('canSet', function () {
    return true;
  }, {category: ['testing']});

});


});

avocado.transporter.module.onLoadCallbacks["core/dependencies"] = function() {};
avocado.transporter.module.create('core/dependencies', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('dependencies', {}, {category: ['collections']});

});


thisModule.addSlots(avocado.dependencies, function(add) {

  add.method('copyRemoveAll', function () {
    return Object.newChildOf(this);
  }, {category: ['creating']});

  add.method('initialize', function () {
    this._dependeesByDepender = avocado.dictionary.copyRemoveAll();
    this._dependersByDependee = avocado.dictionary.copyRemoveAll();
  }, {category: ['creating']});

  add.method('dependeesByDepender', function () {
    return this._dependeesByDepender;
  }, {category: ['accessing']});

  add.method('dependersByDependee', function () {
    return this._dependersByDependee;
  }, {category: ['accessing']});

  add.method('dependeesOf', function (depender) {
    return this.dependeesByDepender().get(depender) || [];
  }, {category: ['accessing']});

  add.method('dependersOf', function (dependee) {
    return this.dependersByDependee().get(dependee) || [];
  }, {category: ['accessing']});

  add.method('addDependency', function (depender, dependee) {
    if (depender.equals(dependee)) { return; }
    this.dependeesByDepender().getOrIfAbsentPut(depender, function() { return avocado.set.copyRemoveAll(); }).add(dependee);
    this.dependersByDependee().getOrIfAbsentPut(dependee, function() { return avocado.set.copyRemoveAll(); }).add(depender);
  }, {category: ['adding']});

  add.method('removeDependency', function (depender, dependee, isOKIfItDoesntExist) {
    if (depender.equals(dependee)) { return; }
    var dependees = this.dependeesByDepender().get(depender);
    var dependers = this.dependersByDependee().get(dependee);
    if (! isOKIfItDoesntExist) {
      if (! dependees.includes(dependee) || ! dependers.includes(depender)) {
        throw new Error("Trying to remove a dependency that doesn't exist");
      }
    }
    dependees.remove(dependee);
    dependers.remove(depender);
  }, {category: ['removing']});

  add.method('eachDependency', function (f) {
    this.dependeesByDepender().eachKeyAndValue(function(depender, dependees) {
      dependees.each(function(dependee) {
        f(depender, dependee);
      });
    });
  }, {category: ['iterating']});

  add.method('removeDependee', function (dependee) {
    var dependers = this.dependersByDependee().removeKey(dependee);
    if (! dependers) { return; }
    dependers.each(function(depender) { this.dependeesByDepender().get(depender).remove(dependee); }.bind(this));
  }, {category: ['removing']});

  add.creator('tests', Object.create(avocado.testCase), {category: ['tests']});

  add.method('printToConsole', function () {
    this.eachDependency(function(depender, dependee) {
      console.log("" + depender + " -> " + dependee);
    });
  }, {category: ['printing']});

});


thisModule.addSlots(avocado.dependencies.tests, function(add) {

  add.method('testStuff', function () {
    var deps = avocado.dependencies.copyRemoveAll();
    deps.addDependency(4, 2);
    deps.addDependency(6, 2);
    deps.addDependency(6, 3);
    deps.addDependency(8, 4);
    // aaa - should really move the ordering stuff to the dependencies object itself;
  });

});


});

avocado.transporter.module.onLoadCallbacks["core/little_profiler"] = function() {};
avocado.transporter.module.create('core/little_profiler', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('littleProfiler', {}, {category: ['profiling']}, {comment: 'Nothing clever, just a little object for helping to see where the time is going in a method.'});

});


thisModule.addSlots(avocado.littleProfiler, function(add) {

  add.method('named', function (name) {
    return Object.newChildOf(this, name);
  });

  add.method('initialize', function (name) {
    this._name = name;
    this._times = [];
    this.recordTime();
  });

  add.method('recordTime', function () {
    this._times.push(new Date().getTime());
  });

  add.method('totalTime', function () {
    return this._times.last() - this._times.first();
  });

  add.method('printTimes', function () {
    this.recordTime();
    var s = avocado.stringBuffer.create("Profile of ").append(this._name).append(": total time ").append(this.totalTime());
    s.append(", in-between times: ");
    sep = "";
    for (var i = 0; i < this._times.length - 1; ++i) {
      s.append(sep).append(this._times[i+1] - this._times[i]);
      sep = ", ";
    }
    console.log(s.toString());
  });

});


});

avocado.transporter.module.onLoadCallbacks["core/math"] = function() {};
avocado.transporter.module.create('core/math', function(requires) {

}, function(thisModule) {


thisModule.addSlots(Number.prototype, function(add) {

  add.method('plus', function (n) { return this + n; });

  add.method('minus', function (n) { return this - n; });

  add.method('scaleBy', function (n) { return this * n; });

  add.method('divideBy', function (n) { return this / n; });

  add.method('equals', function (n) { return this === n; });

  add.method('isZero', function () { return this === 0; });

  add.method('closerToZeroBy', function (n) {
    if (this < 0) {
      return (this > -n) ? 0 : this + n;
    } else {
      return (this <  n) ? 0 : this - n;
    }
  });

  add.method('sign', function () {
    if (this === 0) { return  0; }
    if (this  <  0) { return -1; }
    return 1;
  });

});


thisModule.addSlots(Point.prototype, function(add) {

  add.method('r', function () {
    // Optimization: don't create a new Point object in the process of calculating this.
    return Math.sqrt(this.rSquared());
  });

  add.method('equals', function (other) {
    return other && other.constructor && this.constructor === other.constructor && this.eqPt(other);
  });

  add.method('hashCode', function () {
    return this.x.hashCode() + this.y.hashCode();
  });

  add.method('approximatelyEqualsPt', function (other, maxDifference) {
    return Math.abs(this.x - other.x) < maxDifference && Math.abs(this.y - other.y) < maxDifference;
  });

  add.method('toString', function () {
    // Overriding the one in LK, because I want Points to be able to contain things other than numbers.
    return ["pt(", this.x, ", ", this.y, ")"].join('');
	});

  add.method('storeString', function () {
    return ['new Point(', this.x, ', ', this.y, ')'].join('');
  }, {category: ['transporting']});

  add.method('plus', function (p) { return this.addPt(p); });

  add.method('minus', function (p) { return this.subPt(p); });

  add.method('divideBy', function (n) { return this.scaleBy(1.0 / n); });

  add.method('isZero', function () { return this.x === 0 && this.y === 0; });

  add.method('round', function () { return new Point(Math.round(this.x), Math.round(this.y)); });

  add.method('closerToZeroBy', function (p) {
    return new Point(this.x.closerToZeroBy(p.x), this.y.closerToZeroBy(p.y));
  });

  add.method('unitVector', function () {
    var r = this.r();
    if (r === 0) {return null;}
    return this.scaleBy(1.0 / r);
  });

  add.method('scaleToLength', function (n) {
    return this.unitVector().scaleBy(n);
  });

  add.method('perpendicularVector', function () {
    return new Point(-this.y, this.x);
  });

  add.method('abs', function () {
    return new Point(Math.abs(this.x), Math.abs(this.y));
  });

  add.method('minMaxPt', function (pMin, pMax) {
    return new Point(Math.max(Math.min(this.x,pMin.x), pMax.x), Math.max(Math.min(this.y,pMin.y), pMax.y));
  });

  add.method('destructively_addXY', function (dx, dy) {this.x += dx; this.y += dy; return this;});

  add.method('destructively_addPt', function (p) {return this.destructively_addXY(p.x, p.y);});

  add.method('destructively_scaleBy', function (scale) {this.x *= scale; this.y *= scale; return this;});

  add.method('destructively_minPt', function (p) {this.x = Math.min(this.x,p.x); this.y = Math.min(this.y,p.y); return this;});

  add.method('destructively_maxPt', function (p) {this.x = Math.max(this.x,p.x); this.y = Math.max(this.y,p.y); return this;});

  add.method('destructively_closerToZeroBy', function (p) {this.x = this.x.closerToZeroBy(p.x); this.y = this.y.closerToZeroBy(p.y); return this;});

  add.method('rSquared', function () {
    var x = this.x;
    var y = this.y;
    return x*x + y*y;
  });

});


thisModule.addSlots(Rectangle.prototype, function(add) {

  add.method('area', function () {return this.width * this.height;});

  add.method('vertices', function () {return [this.topLeft(), this.topRight(), this.bottomLeft(), this.bottomRight()];});

  add.method('originCorner', function () { return this.topLeft(); });

  add.method('storeString', function () {
    return ['new Rectangle(', this.x, ', ', this.y, ', ', this.width, ', ', this.height, ')'].join('');
  }, {category: ['transporting']});

});


thisModule.addSlots(avocado, function(add) {

  add.creator('geometry', {}, {category: ['geometry']});

});


thisModule.addSlots(avocado.geometry, function(add) {

  add.creator('planes', {});

  add.creator('circle', {});

  add.creator('quickhull', {}, {}, {comment: 'http://en.literateprograms.org/Quickhull_(Javascript)'});

});


thisModule.addSlots(avocado.geometry.planes, function(add) {

  add.creator('twoD', {});

  add.creator('threeD', {});

});


thisModule.addSlots(avocado.geometry.planes.threeD, function(add) {

  add.method('createFromThreePoints', function (pointA, pointB, pointC) {
    var normal = pointB.subPt(pointA).crossProduct(pointC.subPt(pointA));
    if (normal.x === 0 && normal.y === 0 && normal.z === 0) { return null; }
    return Object.newChildOf(this, normal, pointA);
  }, {category: ['creating']});

  add.method('initialize', function (normalVector, referencePoint) {
    this._normalVector = normalVector.scaleToLength(1);
    this._referencePoint = referencePoint;
  }, {category: ['creating']});

  add.method('normalVector', function () {
    return this._normalVector;
  }, {category: ['accessing']});

  add.method('referencePoint', function () {
    return this._referencePoint;
  }, {category: ['accessing']});

});


thisModule.addSlots(avocado.geometry.circle, function(add) {

  add.method('initialize', function (center, radius, plane) {
    this._center = center;
    this._radius = radius;
    this._plane  = plane || avocado.geometry.planes.twoD;
  }, {category: ['creating']});

  add.method('center', function () { return this._center; }, {category: ['accessing']});

  add.method('radius', function () { return this._radius; }, {category: ['accessing']});

  add.method('pointAtAngle', function (angle) {
    var vector;
    if (this._plane === avocado.geometry.planes.twoD) {
      vector = pt(Math.cos(angle), Math.sin(angle));
    } else {
      var vectorToReferencePoint = this._plane.referencePoint().subPt(this.center()).scaleToLength(1);
      var aaa = this._plane.normalVector().crossProduct(vectorToReferencePoint).scaleBy(Math.sin(angle));
      vector = vectorToReferencePoint.scaleBy(Math.cos(angle)).addPt(aaa);
    }
    return this.center().addPt(vector.scaleToLength(this.radius()));
  });

  add.method('angleAtPoint', function (p) {
    var vector = p.subPt(this.center());
    if (this._plane === avocado.geometry.planes.twoD) {
      return vector.theta();
    } else {
      if (p.eqPt(this._plane.referencePoint())) { return 0; } // aaa is this right? and why is it necessary? I'm confused.  -- Adam
      var vectorToReferencePoint = this._plane.referencePoint().subPt(this.center());
      var angle = Math.acos(vector.dotProduct(vectorToReferencePoint) / (vector.r() * vectorToReferencePoint.r()));
      return angle;
    }
  });

});


thisModule.addSlots(avocado.geometry.quickhull, function(add) {

  add.method('getDistance', function (cpt, bl) {
    var Vy = bl.pointB.x - bl.pointA.x;
    var Vx = bl.pointA.y - bl.pointB.y;
    return Vx * (cpt.x - bl.pointA.x) + Vy * (cpt.y - bl.pointA.y);
  });

  add.method('findMostDistantPointFromBaseLine', function (baseLine, points) {
    var maxD = 0;
    var maxPt = null;
    var newPoints = [];
    for (var i = 0, n = points.length; i < n; ++i) {
        var p = points[i];
        var d = this.getDistance(p, baseLine);
        if (d > 0) {
          newPoints.push(p);
          if (d > maxD) {
            maxD = d;
            maxPt = p;
          }
        }
    } 
    return {maxPoint: maxPt, newPoints: newPoints};
  });

  add.method('buildConvexHull', function (baseLine, points, iterator) {
    var t = this.findMostDistantPointFromBaseLine(baseLine, points);
    if (t.maxPoint) { // if there is still a point "outside" the base line
      this.buildConvexHull( this.createLine(baseLine.pointA,  t.maxPoint), t.newPoints, iterator );
      this.buildConvexHull( this.createLine(t.maxPoint,  baseLine.pointB), t.newPoints, iterator );
    } else {  // if there is no more point "outside" the base line, the current base line is part of the convex hull
      iterator(baseLine);
    }
  });

  add.method('createLine', function (pointA, pointB) {
    return {pointA: pointA, pointB: pointB};
  });

  add.method('getConvexHull', function (points) {
    // find first baseline
    var maxPt, minPt;
    points.each(function(p) {
      if (!maxPt || p.x > maxPt.x) { maxPt = p; }
      if (!minPt || p.x < minPt.x) { minPt = p; }
    });
    var convexHullBaseLines = [];
    this.buildConvexHull(this.createLine(minPt, maxPt), points, function(p) { convexHullBaseLines.push(p); });
    this.buildConvexHull(this.createLine(maxPt, minPt), points, function(p) { convexHullBaseLines.push(p); });
    return convexHullBaseLines;
  });

});


});

avocado.transporter.module.onLoadCallbacks["core/sound"] = function() {};
avocado.transporter.module.create('core/sound', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('sound', {}, {category: ['sound']}, {comment: 'Uses the HTML5 <audio> tag to play sound files.'});

});


thisModule.addSlots(avocado.sound, function(add) {

  add.method('fromFile', function (path) {
    return Object.newChildOf(this, path);
  }, {category: ['creating']});

  add.method('initialize', function (path) {
    this._audioElement = document.createElement('audio');
    this._audioElement.setAttribute('src', path);
  }, {category: ['creating']});

  add.method('play', function () { this._audioElement.play();             }, {category: ['playing']});

  add.method('pause', function () { this._audioElement.play();             }, {category: ['playing']});

  add.method('volume', function () { return this._audioElement.volume;      }, {category: ['volume']});

  add.method('setVolume', function (v) { this._audioElement.volume      = v;    }, {category: ['volume']});

  add.method('currentTime', function (t) { return this._audioElement.currentTime; }, {category: ['seeking']});

  add.method('setCurrentTime', function (t) { this._audioElement.currentTime = t;    }, {category: ['seeking']});

  add.method('load', function (callback) {
    this._audioElement.addEventListener("load", callback, true);
    this._audioElement.load();
  }, {category: ['playing']});

});


});

avocado.transporter.module.onLoadCallbacks["core/types"] = function() {};
avocado.transporter.module.create('core/types', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('types', {}, {category: ['core']});

});


thisModule.addSlots(avocado.types, function(add) {

  add.method('checkToSeeIfTypeMatches', function (type, obj) {
    if (!type) { return false; } // Or should it return true? But I think I'd kinda rather have to explicitly specify an "anything" type.
    if (typeof(type.doesTypeMatch) === 'function') {
      return type.doesTypeMatch(obj);
    } else if (typeof(type) === 'function') {
      return type(obj);
    } else {
      return Object.inheritsFrom(type, obj);
    }
  }, {category: ['checking']});

  add.creator('general', {});

});


thisModule.addSlots(avocado.types.general, function(add) {

  add.method('defaultValue', function () {
    return undefined;
  }, {category: ['default values']});

});


thisModule.addSlots(avocado.types, function(add) {

  add.creator('bool', Object.create(avocado.types.general), {}, {comment: 'Some JS tools don\'t like it if I call it "boolean" - reserved word or something.'});

});


thisModule.addSlots(avocado.types.bool, function(add) {

  add.method('defaultValue', function () {
    return false;
  }, {category: ['default values']});

  add.method('doesTypeMatch', function (o) {
    return typeof(o) === 'boolean';
  }, {category: ['testing']});

});


thisModule.addSlots(avocado.types, function(add) {

  add.creator('number', Object.create(avocado.types.general));

});


thisModule.addSlots(avocado.types.number, function(add) {

  add.method('doesTypeMatch', function (o) {
    return typeof(o) === 'number';
  }, {category: ['testing']});

  add.method('objectForString', function (s) {
    return Number(s);
  }, {category: ['converting']});

});


thisModule.addSlots(avocado.types, function(add) {

  add.creator('string', Object.create(avocado.types.general));

});


thisModule.addSlots(avocado.types.string, function(add) {

  add.method('doesTypeMatch', function (o) {
    return typeof(o) === 'string';
  }, {category: ['testing']});

  add.method('objectForString', function (s) {
    return s;
  }, {category: ['converting']});

});


thisModule.addSlots(avocado.types, function(add) {

  add.creator('shortString', Object.create(avocado.types.string));

  add.creator('longString', Object.create(avocado.types.string));

  add.creator('collection', Object.create(avocado.types.general));

});


thisModule.addSlots(avocado.types.collection, function(add) {

  add.method('of', function (elemType) {
    return Object.newChildOf(this, elemType);
  }, {category: ['creating']});

  add.method('initialize', function (elemType) {
    this._elemType = elemType;
  }, {category: ['creating']});

  add.method('doesTypeMatch', function (o) {
    if (!o) { return false; }
    if (typeof(o.each) !== 'function') { return false; }
    var elemType = this._elemType;
    return exitValueOf(function(exit) {
      o.each(function(elem) {
        if (! elemType.doesTypeMatch(elem)) { exit(false); }
      });
      return true;
    });
  }, {category: ['testing']});

});


thisModule.addSlots(avocado.types, function(add) {

  add.creator('mirror', Object.create(avocado.types.general));

});


thisModule.addSlots(avocado.types.mirror, function(add) {

  add.method('onReflecteeOfType', function (reflecteeType) {
    return Object.newChildOf(this, reflecteeType);
  }, {category: ['creating']});

  add.method('initialize', function (reflecteeType) {
    this._reflecteeType = reflecteeType;
  }, {category: ['creating']});

  add.method('doesTypeMatch', function (o) {
    if (!o) { return false; }
    if (typeof(o.reflectee) !== 'function') { return false; }
    return !this._reflecteeType || this._reflecteeType.doesTypeMatch(o.reflectee());
  }, {category: ['testing']});

});


thisModule.addSlots(avocado.types, function(add) {

  add.creator('enumeration', Object.create(avocado.types.general));

});


thisModule.addSlots(avocado.types.enumeration, function(add) {

  add.method('forPossibilities', function (possibilities) {
    return Object.newChildOf(this, possibilities);
  }, {category: ['creating']});

  add.method('initialize', function (possibilities) {
    this._possibilities = possibilities;
  }, {category: ['creating']});

  add.method('doesTypeMatch', function (o) {
    return this._possibilities.include(o);
  }, {category: ['testing']});

  add.creator('prompterProto', {}, {category: ['prompting']});

  add.method('prompter', function () {
    return Object.newChildOf(this.prompterProto, this._possibilities);
  });

});


thisModule.addSlots(avocado.types.enumeration.prompterProto, function(add) {

  add.method('initialize', function (possibilities) {
    this._possibilities = possibilities;
  });

});


});

avocado.transporter.module.onLoadCallbacks["core/modification_flag"] = function() {};
avocado.transporter.module.create('core/modification_flag', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('modificationFlag', {}, {category: ['core']});

});


thisModule.addSlots(avocado.modificationFlag, function(add) {

  add.method('create', function (object, children) {
    return Object.newChildOf(this, object, children);
  }, {category: ['creating']});

  add.method('initialize', function (object, children) {
    this._object = object;
    this._children = children;
    this._hasChanged = false;
  }, {category: ['creating']});

  add.method('object', function () {
    return this._object;
  }, {category: ['accessing']});

  add.method('children', function () {
    return this._children;
  }, {category: ['accessing']});

  add.method('toString', function () {
    return ["modificationFlag(", this.hasJustThisOneChanged(), ") for ", this.object().toString()].join("");
  }, {category: ['printing']});

  add.method('hasChanged', function () {
    return this.hasThisOneOrChildrenChanged();
  }, {category: ['testing']});

  add.method('hasThisOneOrChildrenChanged', function () {
    if (this.hasJustThisOneChanged()) { return true; }
    if (this._children) {
      if (this._children.detect(function(c) { return c.hasChanged(); })) { return true; }
    }
    return false;
  }, {category: ['testing']});

  add.method('hasJustThisOneChanged', function () {
    return !! this._hasChanged;
  }, {category: ['testing']});

  add.method('notifier', function () {
    return this._notifier || (this._notifier = avocado.notifier.on(this.object()));
  }, {category: ['notification']});

  add.method('markAsChanged', function () {
    this._hasChanged = true;
    if (this._notifier) { this._notifier.notifyAllObservers(); }
  }, {category: ['marking']});

  add.method('markAsUnchanged', function () {
    this._hasChanged = false;
    if (this._notifier) { this._notifier.notifyAllObservers(); }
  }, {category: ['marking']});

});


});

avocado.transporter.module.onLoadCallbacks["core/http"] = function() {};
avocado.transporter.module.create('core/http', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('asyncRequest', {}, {category: ['HTTP']});

});


thisModule.addSlots(avocado.asyncRequest, function(add) {

  add.method('mapping', function (req, mapFn) {
    return this.create(req, function(result, callback, errback, partback) { callback(mapFn(result)); }, null, null);
  }, {category: ['creating']});

  add.method('mappingPartialResults', function (req, mapFn) {
    return this.create(req, null, null, function(partialResult, callback, errback, partback) { partback(mapFn(partialResult)); });
  }, {category: ['creating']});

  add.method('create', function () {
    var c = Object.create(this);
    c.initialize.apply(c, arguments);
    return c;
  }, {category: ['creating']});

  add.method('initialize', function (req, callbackTransformer, errbackTransformer, partbackTransformer) {
    this._originalRequest = req;
    this._callbackTransformer = callbackTransformer;
    this._errbackTransformer = errbackTransformer;
    this._partbackTransformer = partbackTransformer;
  }, {category: ['creating']});

  add.method('get', function (callback, errback, partback) {
    var callbackTransformer = this._callbackTransformer;
    var errbackTransformer = this._errbackTransformer;
    var partbackTransformer = this._partbackTransformer;
    this._originalRequest.get(function(result) {
      callbackTransformer ? callbackTransformer(result, callback, errback, partback) : (callback ? callback(result) : null);
    }, function(err) {
       errbackTransformer ?  errbackTransformer(err, callback, errback, partback) :  (errback ? errback(err) : null);
    }, function(partialResult) {
      partbackTransformer ? partbackTransformer(partialResult, callback, errback, partback) : (partback ? partback(partialResult) : null);
    });
  }, {category: ['sending']});

  add.method('send', function (callback, errback, partback) {
    this.get(callback, errback, partback);
  }, {category: ['sending']});

  add.method('map', function (f) {
    return avocado.asyncRequest.mapping(this, f);
  }, {category: ['transforming']});

  add.method('transform', function (f) {
    // aaa this method needs a better name
    return avocado.asyncRequest.create(this, f);
  }, {category: ['transforming']});

});


thisModule.addSlots(avocado.http, function(add) {

  add.creator('jsonp', {}, {category: ['script tags', 'JSONP']});

});


thisModule.addSlots(avocado.http.jsonp, function(add) {

  add.data('callbacks', {}, {category: ['JSONP'], initializeTo: '{}'});

  add.creator('request', Object.create(avocado.http.scriptTagRequest), {category: ['JSONP']});

});


thisModule.addSlots(avocado.http.jsonp.request, function(add) {

  add.method('initialize', function ($super, path) {
    $super(path);
    this.changeTimeoutSeconds(10);
  }, {category: ['creating']});

  add.method('changeTimeoutSeconds', function (seconds) {
    this._timeoutSeconds = seconds;
    return this;
  }, {category: ['accessing']});

  add.method('findUnusedCallbackName', function () {
    var i = 0;
    var jsonp;
    var callbackHolder = avocado.http.jsonp.callbacks;
    while (true) {
      jsonp = "jsonpCallback_" + (++i);
      if (! callbackHolder.hasOwnProperty(jsonp)) { return jsonp; }
    }
  }, {category: ['callbacks']});

  add.method('fullPath', function ($super, jsonp) {
    return $super() + '&jsonp=' + jsonp;
  }, {category: ['sending']});

  add.method('send', function (callback, errback) {
    var path = this._path;
    var callbackName = this.findUnusedCallbackName();
    var jsonp = "avocado.http.jsonp.callbacks." + callbackName;
    var jsonpFunction = avocado.http.jsonp.callbacks[callbackName] = function(json) {
      delete avocado.http.jsonp.callbacks[callbackName];
      jsonpFunction.hasReturned = true;
      callback(json);
    }
    
    var script = document.createElement('script');
    script.setAttribute('src', this.fullPath(jsonp));
    document.getElementsByTagName('head')[0].appendChild(script);
    
    // I don't believe there's any way to get a proper error message if the request fails,
    // but we can at least do a timeout thing.
    if (this._timeoutSeconds) {
      setTimeout(function() {
        if (! jsonpFunction.hasReturned) {
          errback(new Error("Timeout on JSONP request").setImmediateContents([avocado.messageNotifier.create(path, Color.red, "path")]));
        }
      }, this._timeoutSeconds * 1000);
    }
  }, {category: ['sending']});

});


thisModule.addSlots(avocado.http.request, function(add) {

  add.method('create', function () {
    var c = Object.create(this);
    c.initialize.apply(c, arguments);
    return c;
  }, {category: ['creating']});

  add.method('setParams', function (params) {
    this._params = params;
    return this;
  }, {category: ['accessing']});

  add.method('beSynchronous', function (params) {
    this._isSynchronous = true;
    return this;
  }, {category: ['accessing']});

  add.method('beAsynchronous', function (params) {
    this._isSynchronous = false;
    return this;
  }, {category: ['accessing']});

  add.method('setIsAsynchronous', function (b) {
    this._isSynchronous = !b;
    return this;
  }, {category: ['accessing']});

  add.method('setIsSynchronous', function (b) {
    this._isSynchronous = !!b;
    return this;
  }, {category: ['accessing']});

  add.method('setHTTPMethod', function (httpMethod) {
    this._httpMethod = httpMethod;
    return this;
  }, {category: ['accessing']});

  add.method('setPostBody', function (str) {
    this._postBody = str;
    return this;
  }, {category: ['accessing']});

  add.method('setHeaders', function (headers) {
    this._headers = headers;
    return this;
  }, {category: ['accessing']});

  add.method('beInDebugMode', function () {
    this._debugMode = true;
    return this;
  }, {category: ['debugging']});

  add.method('get', function (callback, errback, partback) {
    // For compatibility with other kinds of asynchronousRequests.
    return this.send(callback, errback, partback);
  }, {category: ['sending']});

  add.method('map', function (f) {
    return avocado.asyncRequest.mapping(this, f);
  }, {category: ['transforming']});

  add.method('transform', function (f, e, p) {
    // aaa this method needs a better name
    return avocado.asyncRequest.create(this, f, e, p);
  }, {category: ['transforming']});

  add.method('logPartialResultsToBuffer', function (buffer) {
    return avocado.asyncRequest.mappingPartialResults(function(nextPart) {
      if (buffer) { buffer.append(nextPart); }
      return nextPart;
    });
  }, {category: ['transforming']});

  add.method('expectJSON', function () {
    return this.map(function(responseText) { return JSON.parse(responseText); });
  }, {category: ['transforming']});

});


thisModule.addSlots(avocado.http.scriptTagRequest, function(add) {

  add.method('create', function () {
    var c = Object.create(this);
    c.initialize.apply(c, arguments);
    return c;
  }, {category: ['creating']});

  add.method('get', function (callback, errback) {
    // For compatibility with other kinds of asynchronousRequests.
    return this.send(callback, errback);
  }, {category: ['sending']});

  add.method('map', function (f) {
    return avocado.asyncRequest.mapping(this, f);
  }, {category: ['transforming']});

  add.method('transform', function (f) {
    // aaa this method needs a better name
    return avocado.asyncRequest.create(this, f);
  }, {category: ['transforming']});

});


});

avocado.transporter.module.onLoadCallbacks["core/tree_node"] = function() {};
avocado.transporter.module.create('core/tree_node', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('treeNode', {}, {category: ['tree nodes']});

});


thisModule.addSlots(avocado.treeNode, function(add) {

  add.method('create', function () {
    var n = Object.create(this);
    n.initialize.apply(n, arguments);
    return n;
  }, {category: ['creating']});

  add.method('initialize', function (name, contents) {
    this._name = name;
    this._immediateContents = contents;
  }, {category: ['creating']});

  add.method('name', function () {
    return this._name;
  }, {category: ['accessing']});

  add.method('setName', function (n) {
    this._name = n;
    return this;
  }, {category: ['accessing']});

  add.method('toString', function () {
    return this._name;
  }, {category: ['printing']});

  add.method('immediateContents', function () {
    return this._immediateContents;
  }, {category: ['accessing']});

  add.method('eachOfImmediateContents', function (f) {
    if (typeof(this._immediateContents.forEach) === 'function') {
      this._immediateContents.forEach(f);
    } else {
      f(this._immediateContents);
    }
  }, {category: ['iterating']});

  add.method('setImmediateContents', function (contents) {
    this._immediateContents = contents;
    return this;
  }, {category: ['accessing']});

  add.method('getNewContentsFrom', function (request, callback) {
    request.get(callback, function(err) { callback([Error.create(err)]); });
  }, {category: ['accessing']});

  add.method('asynchronousContentRequest', function () {
    return this._asynchronousContentRequest;
  }, {category: ['updating']});

  add.method('setAsynchronousContentRequest', function (req) {
    this._asynchronousContentRequest = req;
    return this;
  }, {category: ['updating']});

  add.method('getRemoteData', function () {
    this.eachOfImmediateContents(function(c) {
      if (c && typeof(c.getRemoteData) === 'function') { c.getRemoteData(); }
    });
    
    var req = this.asynchronousContentRequest();
    if (req) {
      this.getNewContentsFrom(req, function(newContents) {
        this.setImmediateContents(newContents);
        avocado.ui.justChanged(this);
      }.bind(this));
    }
    
    return this;
  }, {category: ['updating']});

  add.method('commands', function () {
    // aaa - this might be a bad idea; do I really want the commands to be on the tree node rather than on the contents?
    return this._immediateContents.commands && this._immediateContents.commands();
  }, {category: ['user interface', 'commands']});

});


});

avocado.transporter.module.onLoadCallbacks["transporter/writing"] = function() {};
avocado.transporter.module.create('transporter/writing', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado.transporter.module, function(add) {

  add.creator('filerOuters', {}, {category: ['transporting']});

  add.method('codeToFileOut', function (filerOuter) {
    if (this.preFileInFunctionName) {
      filerOuter.writePreFileInFunction(this.preFileInFunctionName);
    }
    
    filerOuter.writeModule(this.name(), this._requirements, function() {
      filerOuter.fileOutSlots(this.slotsInOrderForFilingOut());
    }.bind(this));

    return filerOuter.fullText();
  }, {category: ['transporting']});

  add.method('codeOfMockFileOut', function () {
    return this.codeToFileOut(Object.newChildOf(this.filerOuters.mock)).toString();
  }, {category: ['transporting']});

  add.method('fileOutAndReportErrors', function (evt, repo, filerOuterProto) {
    avocado.transporter.fileOutPlural([{moduleVersion: this.currentVersion()}], evt, repo, filerOuterProto);
  }, {category: ['user interface', 'commands', 'filing out']});

  add.method('fileOutWithoutAnnotations', function (evt) {
    this.fileOutAndReportErrors(evt, null, avocado.transporter.module.filerOuters.annotationless);
  }, {category: ['user interface', 'commands', 'filing out']});

  add.method('printToConsole', function (evt) {
    this.fileOutAndReportErrors(evt, avocado.transporter.repositories.console, avocado.transporter.module.filerOuters.annotationless);
  }, {category: ['user interface', 'commands', 'filing out']});

  add.method('emailTheSource', function (evt) {
    this.fileOutAndReportErrors(evt, this.repository().copyWithSavingScript(avocado.transporter.emailingScriptURL));
  }, {category: ['user interface', 'commands', 'filing out']});

});


thisModule.addSlots(avocado.transporter.module.filerOuters, function(add) {

  add.creator('general', {}, {category: ['transporting']});

});


thisModule.addSlots(avocado.transporter.module.filerOuters.general, function(add) {

  add.method('create', function () {
    var o = Object.create(this);
    o.initialize.apply(o, arguments);
    return o;
  }, {category: ['creating']});

  add.method('initialize', function () {
    this._buffer = avocado.stringBuffer.create();
    this._currentHolder = null;
    this._currentHolderExpr = null;
    this._errors = [];
  }, {category: ['creating']});

  add.method('fullText', function () {
    return this._buffer.toString();
  }, {category: ['accessing']});

  add.method('fileOutSlots', function (slots) {
    slots.each(function(s) {
      try {
        if (s.isCycleBreaker) { throw new Error("Haven't finished implementing cycle-breaking yet. Need to file out a cycle-breaker."); }
        if (s.wasReplacedByCycleBreakers) { throw new Error("Haven't finished implementing cycle-breaking yet. Need to file out a slot that was replaced by a cycle-breaker."); }
        var h = s.holder();
        this.nextSlotIsIn(h, s);
        var info = s.transportableInfo();
        this.rememberNestedObjectInfoIfNecessary(s, info); // aaa HACK
        this.fileOutSlotWithInfo(info);
      } catch (ex) {
        this.errors().push(ex);
      }
    }.bind(this));
    this.doneWithThisObject();
  }, {category: ['writing']});

  add.method('rememberNestedObjectInfoIfNecessary', function (slot, info) {
    // children can override;
  }, {category: ['writing']});

  add.method('fileOutSlotWithInfo', function (info) {
    var slotAnno = info.rawAnnotation;
    var slotAnnoExpr = slotAnno ? reflect(slotAnno).expressionEvaluatingToMe() : '{}';
    var objectAnnoExpr = info.isCreator && info.contentsRawAnnotation ? reflect(info.contentsRawAnnotation).expressionEvaluatingToMe() : null;
    
    // The fileout looks a bit prettier if we don't bother showing ", {}, {}" all over the place.
    var optionalArgs = "";
    if (objectAnnoExpr && objectAnnoExpr !== '{}') {
      optionalArgs = ", " + objectAnnoExpr + optionalArgs;
    }
    if (optionalArgs !== '' || (slotAnnoExpr && slotAnnoExpr !== '{}')) {
      optionalArgs = ", " + slotAnnoExpr + optionalArgs;
    }

    this.writeSlot(info, optionalArgs);

    // aaa - hack: some browsers won't let you set __proto__ so we have to treat it specially.
    if (info.parentCreatorSlotChainExpression) {
      this.writeParentAnnotation(info);
    }
  }, {category: ['transporting']});

  add.method('setCurrentHolder', function (holder) {
    this._currentHolder = holder;
    this._currentHolderExpr = holder.creatorSlotChainExpression();
  }, {category: ['writing']});

  add.method('nextSlotIsIn', function (holder, slot) {
    if (!this._currentHolder || ! holder.equals(this._currentHolder)) {
      this.doneWithThisObject();
      avocado.transporter.reasonsForNeedingCreatorPath.recordIfExceptionDuring(function() {
        this.setCurrentHolder(holder);
      }.bind(this), avocado.transporter.reasonsForNeedingCreatorPath.objectContainsSlotInTheModule.create(slot));
      this.writeObjectStarter();
    }
  }, {category: ['writing']});

  add.method('doneWithThisObject', function () {
    if (this._currentHolder) {
      this.writeObjectEnder();
      this._currentHolder = null;
      this._currentHolderExpr = null;
    }
  }, {category: ['writing']});

  add.method('errors', function () {
    return this._errors;
  }, {category: ['error handling']});

  add.method('writePreFileInFunction', function (fnName) {
    // This is basically just a hack to let us file out the bootstrap module.
    var f = window[fnName];
    this._buffer.append("window.").append(fnName).append(" = ").append(f.toString()).append(";\n");
    this._buffer.append(fnName).append("();\n\n\n\n");
  }, {category: ['writing']});

});


thisModule.addSlots(avocado.transporter.module.filerOuters, function(add) {

  add.creator('normal', Object.create(avocado.transporter.module.filerOuters.general), {category: ['transporting']});

});


thisModule.addSlots(avocado.transporter.module.filerOuters.normal, function(add) {

  add.method('writeModule', function (name, reqs, bodyBlock) {
    //this._buffer.append("//@ sourceURL=").append(name).append(".js    so that the debugger shows the right file name when we load it using eval\n\n");
    this._buffer.append("avocado.transporter.module.create(").append(name.inspect()).append(", function(requires) {\n\n");
    
    if (reqs && reqs.length > 0) {
      reqs.each(function(req) {
        this._buffer.append("requires(").append(req.inspect()).append(");\n");
      }.bind(this));
      this._buffer.append("\n");
    }

    this._buffer.append("}, function(thisModule) {\n\n\n");

    bodyBlock();

    this._buffer.append("});\n");
  }, {category: ['writing']});

  add.method('writeObjectStarter', function () {
    this._buffer.append("thisModule.addSlots(").append(this._currentHolderExpr).append(", function(add) {\n\n");
  }, {category: ['writing']});

  add.method('writeObjectEnder', function () {
    this._buffer.append("});\n\n\n");
  }, {category: ['writing']});

  add.method('writeSlot', function (info, optionalArgs) {
    this._buffer.append("  add.").append(info.creationMethod).append("('").append(info.name).append("', ").append(info.contentsExpr);
    this._buffer.append(optionalArgs);
    this._buffer.append(");\n\n");
  }, {category: ['writing']});

  add.method('writeParentAnnotation', function (info) {
    var objectAnnoExpr = info.parentRawAnnotation ? reflect(info.parentRawAnnotation).expressionEvaluatingToMe() : 'null';
    
    this._buffer.append("  avocado.annotator.loadObjectAnnotation(");
    this._buffer.append(info.parentCreatorSlotChainExpression);
    this._buffer.append(", ").append(objectAnnoExpr);
    this._buffer.append(", ").append(info.parentSlotName.inspect());
    this._buffer.append(", ").append(info.parentHolderCreatorSlotChainExpression);
    this._buffer.append(");\n\n");
    
    /* aaa - Hmm, maybe it's OK for parent slots to have annotations, now that I have this hack?
    var slotAnnoExpr = info.parentRawSlotAnnotation ? reflect(info.parentRawSlotAnnotation).expressionEvaluatingToMe() : null;
    if (slotAnnoExpr) {
      this._buffer.append("  Object.extend(avocado.annotator.annotationOf(");
      this._buffer.append(info.parentHolderCreatorSlotChainExpression);
      this._buffer.append(").slotAnnotation(").append(info.parentSlotName.inspect());
      this._buffer.append("), ").append(slotAnnoExpr).append(");\n");
    }
    */
    
    this._buffer.append("\n");
  }, {category: ['writing']});

});


thisModule.addSlots(avocado.transporter.module.filerOuters, function(add) {

  add.creator('justBody', Object.create(avocado.transporter.module.filerOuters.normal), {category: ['transporting']});

});


thisModule.addSlots(avocado.transporter.module.filerOuters.justBody, function(add) {

  add.method('writeModule', function (name, reqs, bodyBlock) {
    this._buffer.append("function(thisModule) {\n\n\n");

    bodyBlock();

    this._buffer.append("}");
  }, {category: ['writing']});

});


thisModule.addSlots(avocado.transporter.module.filerOuters, function(add) {

  add.creator('annotationless', Object.create(avocado.transporter.module.filerOuters.general), {category: ['transporting']});

});


thisModule.addSlots(avocado.transporter.module.filerOuters.annotationless, function(add) {

  add.method('writeModule', function (name, reqs, bodyBlock) {
    this._buffer.append("if (typeof(window.modules) === 'object') { modules[").append(name.inspect()).append("] = {}; }\n\n");
    bodyBlock();
  }, {category: ['writing']});

  add.method('writeObjectStarter', function () {
    // I don't like having to depend on an 'extend' method. Either we
    // define 'extend' as a local function at the start of the file, or
    // we just keep writing out the name of the object over and over.
    // Let's try the latter for now; it actually kinda looks cleaner. -- Adam
    // this._buffer.append("Object.extend(").append(this._currentHolderExpr).append(", {\n\n");
  }, {category: ['writing']});

  add.method('writeObjectEnder', function () {
    // this._buffer.append("});\n\n\n");
    this._buffer.append("\n\n");
  }, {category: ['writing']});

  add.method('writeSlot', function (info, optionalArgs) {
    this._buffer.append(this._currentHolderExpr).append(".").append(info.name).append(" = ").append(info.contentsExpr).append(";\n\n");
  }, {category: ['writing']});

  add.method('writeParentAnnotation', function (info) {
    // nothing to do here, I think;
  }, {category: ['writing']});

});


thisModule.addSlots(avocado.transporter.module.filerOuters, function(add) {

  add.creator('json', Object.create(avocado.transporter.module.filerOuters.general), {category: ['transporting']});

});


thisModule.addSlots(avocado.transporter.module.filerOuters.json, function(add) {

  add.method('initialize', function ($super, db) {
    $super();
    this._db = db;
    this._indention = 0;
  }, {category: ['creating']});

  add.method('writeModule', function (name, reqs, bodyBlock) {
    throw new Error("Can we do modules with the JSON filer outer?");
  }, {category: ['writing']});

  add.method('indent', function () {
    for (var i = 0; i < this._indention; ++i) { this._buffer.append("  "); }
  }, {category: ['writing']});

  add.method('rememberNestedObjectInfoIfNecessary', function (slot, info) {
    // aaa - hack for nested objects, since JSON isn't flexible about the order - gotta
    // do sub-objects right there in the middle of the container object.
    if (info.isCreator) {
      info.slotsOfNestedObject = slot.contents().normalSlots();
    }
  }, {category: ['writing']});

  add.method('writeObjectStarter', function () {
    this._buffer.append(this._currentHolder.isReflecteeArray() ? "[" : "{");
    this._indention += 1;
    this._slotSeparator = "";
  }, {category: ['writing']});

  add.method('writeObjectEnder', function () {
    this._indention -= 1;
    this._buffer.append("\n");
    this.indent();
    this._buffer.append(this._currentHolder.isReflecteeArray() ? "]" : "}");
  }, {category: ['writing']});

  add.method('setCurrentHolder', function (holder) {
    this._currentHolder = holder;
    // don't actually need this._currentHolderExpr, and trying to get the holder's
    // creatorSlotChainExpression will cause an error if we're doing the __creatorPath thing. -- Adam;
  }, {category: ['writing']});

  add.method('temporarilySwitchHolder', function (f) {
    var currentHolder = this._currentHolder;
    this._currentHolder = null;
    var result = f();
    this.doneWithThisObject();
    this._currentHolder = currentHolder;
    return result;
  }, {category: ['writing']});

  add.method('writeSlot', function (info, optionalArgs) {
    this._buffer.append(this._slotSeparator).append("\n");
    this.indent();
    
    var slotName = info.name;
    if (this._currentHolder.isReflecteeArray()) {
      if (parseInt(slotName, 10).toString() !== slotName) {
        throw new Error("Trying to file out an array that has a slot named " + slotName);
      }
    } else {
      var slotNameToWrite = slotName;
      if (slotNameToWrite[0] === '_' && !info.isHardWired) { slotNameToWrite = 'underscoreReplacement' + slotNameToWrite; }
      if (info.isReferenceToWellKnownObjectThatIsCreatedElsewhere) { slotNameToWrite = slotNameToWrite + "__creatorPath"; }
      if (info.remoteReference) { slotNameToWrite = slotNameToWrite + "__id"; }
      this._buffer.append(slotNameToWrite.inspect(true)).append(": ");
    }
    
    if (info.isCreator) {
      this.temporarilySwitchHolder(function() {
        this.fileOutSlots(info.slotsOfNestedObject);
      }.bind(this));
    } else if (info.isReferenceToWellKnownObjectThatIsCreatedElsewhere) {
      this.temporarilySwitchHolder(function() {
        this.fileOutSlots(reflect(info.isReferenceToWellKnownObjectThatIsCreatedElsewhere).normalSlots());
      }.bind(this));
    } else if (info.remoteReference) {
      var ref = info.remoteReference;
      if (! (ref.realm() && typeof(ref.id()) !== 'undefined')) { throw new Error("Trying to file out a remote reference, but not sure where it lives. The object is " + ref.object()); }
      if (ref.realm() === this._db) {
        this._buffer.append(("" + ref.id()).inspect(true));
      } else {
        throw new Error("Not implemented yet: how do we file out a remote ref to an object in a whole nother DB?");
      }
    } else {
      // JSON only accepts double-quotes.
      // aaa - Should probably do something to avoid the "eval".
      if (info.contentsExpr[0] === "'" && info.contentsExpr[info.contentsExpr.length - 1] === "'") {
        info.contentsExpr = eval(info.contentsExpr).inspect(true);
      }
      
      this._buffer.append(info.contentsExpr);
    }
    this._slotSeparator = ",";
  }, {category: ['writing']});

  add.method('writeParentAnnotation', function (info) {
    // nothing to do here, I think;
  }, {category: ['writing']});

});


thisModule.addSlots(avocado.transporter.module.filerOuters, function(add) {

  add.creator('mock', Object.create(avocado.transporter.module.filerOuters.general), {category: ['transporting']});

});


thisModule.addSlots(avocado.transporter.module.filerOuters.mock, function(add) {

  add.method('writeModule', function (name, reqs, bodyBlock) {
    this._buffer.append("start module ").append(name).append("\n");
    bodyBlock();
  }, {category: ['writing']});

  add.method('writeObjectStarter', function () {
    this._buffer.append("  start object ").append(this._currentHolderExpr).append("\n");
  }, {category: ['writing']});

  add.method('writeObjectEnder', function () {
    this._buffer.append("  end object ").append(this._currentHolderExpr).append("\n");
  }, {category: ['writing']});

  add.method('writeSlot', function (info, optionalArgs) {
    this._buffer.append("    slot ").append(info.name).append(": ").append(info.contentsExpr).append("\n");
  }, {category: ['writing']});

  add.method('writeParentAnnotation', function (info) {
    this._buffer.append("    parent slot ").append(info.parentCreatorSlotChainExpression).append("\n");
  }, {category: ['writing']});

});


});

avocado.transporter.module.onLoadCallbacks["transporter/ordering"] = function() {};
avocado.transporter.module.create('transporter/ordering', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado.transporter.module, function(add) {

  add.creator('slotOrderizer', {}, {category: ['transporting']});

  add.method('slotsInOrderForFilingOut', function (f) {
    return Object.newChildOf(this.slotOrderizer, this).calculateDependencies().determineOrder();
  }, {category: ['transporting']});

});


thisModule.addSlots(avocado.transporter.module.slotOrderizer, function(add) {

  add.method('initialize', function (m) {
    this._module = m;
  }, {category: ['creating']});

  add.method('calculateDependencies', function () {
    this.calculateSlotDependencies();
    this._remainingSlotsByMirror = this.buildDictionaryOfRemainingSlotsByMirror();
    this.recalculateObjectDependencies();
    return this;
  }, {category: ['dependencies']});

  add.method('buildDictionaryOfRemainingSlotsByMirror', function () {
    var d = avocado.dictionary.copyRemoveAll();
    this._module.eachSlot(function(s) {
      var holder = s.holder();
      var slots = d.getOrIfAbsentPut(holder, function() { return avocado.set.copyRemoveAll(); });
      slots.add(s);
      if (s.equals(s.contents().theCreatorSlot())) { slots.add(s.contents().parentSlot()); }
      // aaa what about the parent's parent?
    });
    return d;
  }, {category: ['dependencies']});

  add.method('beInDebugMode', function () {
    this._debugMode = true;
    return this;
  });

  add.method('addSlotDependenciesFor', function (s) {
      var contents = s.contents();
      var contentsCreatorSlot = contents.theCreatorSlot();
      if (s.equals(contentsCreatorSlot)) {
        var parentSlot = contents.parentSlot();
        this.addSlotDependenciesFor(parentSlot);
        var parentCreatorSlot = parentSlot.contents().theCreatorSlot();
        if (parentCreatorSlot && parentCreatorSlot.isIncludedInModule(this._module)) {
          this._slotDeps.contentDeps.addDependency(s, parentSlot);
        }
        // aaa what about the parent's parent?
        
        var cdps = contents.copyDownParents();
        cdps.each(function(cdp) {
          var copyDownParent = reflect(cdp.parent);
          var slotsToOmit = avocado.annotator.adjustSlotsToOmit(cdp.slotsToOmit);
          var copyDownParentCreatorSlot = copyDownParent.theCreatorSlot();
          if (copyDownParentCreatorSlot && copyDownParentCreatorSlot.isIncludedInModule(this._module)) {
            this._slotDeps.contentDeps.addDependency(s, copyDownParentCreatorSlot);
          }

          // aaa - For now, make every slot in the copy-down parent exist before the child,
          // because we don't yet have a mechanism to update the copy-down children on
          // the fly as the copy-down parent changes.
          this._module.slotsInMirror(copyDownParent).each(function(slotInCopyDownParent) {
            if (! slotsToOmit.include(slotInCopyDownParent.name())) {
              this._slotDeps.contentDeps.addDependency(s, slotInCopyDownParent);
            }
          }.bind(this));

        }.bind(this));
              
        this._module.slotsInMirror(contents).each(function(slotInContents) {
          this._slotDeps.holderDeps.addDependency(slotInContents, s);
        }.bind(this));
      } else if (! s.initializationExpression()) {
        if (contentsCreatorSlot && contentsCreatorSlot.isIncludedInModule(this._module)) {
          // Need to walk back along the chain and look for storeStrings - if the contents object is part
          // of some larger object that has a storeString, we want to depend on that one (since that's the
          // one that actually creates the object we're referring to).
          var contentsCreatorSlotChain = contents.creatorSlotChain('probableCreatorSlot');
          var creatorSlotToDependOn = contentsCreatorSlot;
          contentsCreatorSlotChain.forEach(function(creatorSlotInChain) { if (creatorSlotInChain.contents().reflecteeStoreString()) { creatorSlotToDependOn = creatorSlotInChain; } });
          this._slotDeps.contentDeps.addDependency(s, creatorSlotToDependOn);
        }
      }
  }, {category: ['dependencies']});

  add.method('calculateSlotDependencies', function () {
    this._slotDeps = {  holderDeps: avocado.dependencies.copyRemoveAll(),
                       contentDeps: avocado.dependencies.copyRemoveAll() };
    
    this._module.slots().each(function(s) { this.addSlotDependenciesFor(s); }.bind(this));
    
    if (this._debugMode) { this.printDependencies(); }
  }, {category: ['dependencies'], comment: 'If Javascript could do "become", this would be unnecessary, since we could just put in a placeholder and then swap it for the real object later.'});

  add.method('printDependencies', function () {
    console.log("Holder dependencies:");
    this._slotDeps.holderDeps.printToConsole();
    console.log("Content dependencies:");
    this._slotDeps.contentDeps.printToConsole();
  }, {category: ['printing']});

  add.method('recalculateObjectDependencies', function () {
    this._objDeps = avocado.dependencies.copyRemoveAll();

    this._slotDeps.holderDeps.eachDependency(function(depender, dependee) {
      this._objDeps.addDependency(depender.holder(), dependee.holder());
    }.bind(this));

    this._slotDeps.contentDeps.eachDependency(function(depender, dependee) {
      this._objDeps.addDependency(depender.holder(), dependee.holder());
    }.bind(this));
  }, {category: ['dependencies']});

  add.method('chooseAMirrorWithThisManyDependees', function (n) {
    return exitValueOf(function(exit) {
      this._remainingSlotsByMirror.eachKeyAndValue(function(mir, slots) {
        if (slots.size() === 0) { throw new Error("Assertion failure: we were supposed to remove the mirror from the dictionary if it had no slots left"); }
        if (this._objDeps.dependeesOf(mir).size() === n) { exit(mir); }
      }.bind(this));
      return null;
    }.bind(this));
  }, {category: ['dependencies']});

  add.method('chooseASlotWithThisManyDependees', function (n, slotsToChooseFrom) {
    if (slotsToChooseFrom) {
      return slotsToChooseFrom.find(function(s) {
        return this._slotDeps.holderDeps.dependeesOf(s).size() === 0 && this._slotDeps.contentDeps.dependeesOf(s).size() === 0;
      }.bind(this));
    } else {
      // choose any remaining slot
      return exitValueOf(function(exit) {
        this._remainingSlotsByMirror.eachKeyAndValue(function(mir, slots) {
          var s = this.chooseASlotWithThisManyDependees(n, slots);
          if (s) { exit(s); }
        }.bind(this));
        return null;
      }.bind(this));
    }
  }, {category: ['dependencies']});

  add.method('chooseSlotToTryToBreakCycle', function () {
    return exitValueOf(function(exit) {
      this._remainingSlotsByMirror.eachKeyAndValue(function(mir, slots) {
        var s = slots.find(function(s) {
          var dependees = this._slotDeps.contentDeps.dependeesOf(s);
          if (this._debugMode) { console.log(s + " depends on " + dependees.toArray().map(function(d) { return d.fullName(); }).join(" and ")); }
          return dependees.size() === 0;
        }.bind(this));
        if (s) { exit(s); }
      }.bind(this));
      return null;
    }.bind(this));
  }, {category: ['dependencies']});

  add.method('rememberCycleBreakerSlot', function (cycleBreakerSlot, originalSlot) {
    console.log("Created cycle-breaker slot for " + originalSlot + ": " + cycleBreakerSlot);
    this._remainingSlotsByMirror.getOrIfAbsentPut(this._cycleBreakersMir, function() {return avocado.set.copyRemoveAll();}).add(cycleBreakerSlot);
    this._cycleBreakersByOriginalSlot.getOrIfAbsentPut(originalSlot, function() {return [];}).push(cycleBreakerSlot);
  }, {category: ['dependencies']});

  add.method('insertCycleBreakerSlot', function () {
    // aaa - This code hasn't been properly tested; I don't trust it yet.
    var slot = this.chooseSlotToTryToBreakCycle();
    if (!slot) {
      var err = new Error("there is a cycle in the slot dependency graph; could not find a slot to use as a cycle-breaker");
      var remainingSlots = this.allRemainingSlots().toArray();
      var deps = remainingSlots.map(function(s) { return this._slotDeps.contentDeps.dependeesOf(s); }.bind(this));
      err.objectsToShow = [avocado.searchResultsPresenter.createForSlots(remainingSlots, "Slots containing cycle"), reflect(deps)];
      console.log("There is a cycle in the slot dependency graph; could not find a slot to use as a cycle-breaker.\n" +
                  "Remaining slots: " + remainingSlots.map(function(s) { return s.fullName(); }).join(", ") + "\n" + 
                  "Dependees: " + deps.map(function(dependees) { return dependees.map(function(dependee) { return dependee.fullName(); }).join(", "); }).join("; "));
      throw err;
    }
    var cycleBreakerSlot = slot.copyTo(this._cycleBreakersMir.rootCategory()).rename(this._cycleBreakersMir.findUnusedSlotName('breaker'));
    var initExpr = slot.initializationExpression();
    if (initExpr) { cycleBreakerSlot.setInitializationExpression(initExpr); }
    this._slotDeps.contentDeps.   addDependency(slot, cycleBreakerSlot);
    this._slotDeps.contentDeps.dependersOf(slot).each(function(depender) {
      this._slotDeps.contentDeps.removeDependency(depender, slot);
      this._slotDeps.contentDeps.   addDependency(depender, cycleBreakerSlot);
      if (this._debugMode) { console.log(depender + " no longer depends on " + slot + ", but on " + cycleBreakerSlot + " instead"); }
    }.bind(this));
    this.rememberCycleBreakerSlot(cycleBreakerSlot, slot);
    this.recalculateObjectDependencies();
  }, {category: ['dependencies']});

  add.method('allRemainingSlots', function () {
    var ss = avocado.set.copyRemoveAll();
    this._remainingSlotsByMirror.eachKeyAndValue(function(mir, slots) {
      slots.each(function(s) { ss.add(s); });
    });
    return ss;
  }, {category: ['accessing']});

  add.method('allSlotsInDependencyLists', function () {
    var ss = avocado.set.copyRemoveAll();
    [this._slotDeps.contentDeps, this._slotDeps.holderDeps].forEach(function(deps) {
      deps.eachDependency(function(depender, dependee) {
        ss.add(depender);
        ss.add(dependee);
      });
    });
    return ss;
  }, {category: ['accessing']});

  add.method('determineOrder', function () {
    if (this._debugMode && false) { // aaa - This seems like it might be broken, it's giving me error messages when I think it shouldn't.
      this._remainingSlotsByMirror.eachKeyAndValue(function(mir, slots) {
        console.log(mir.name() + " contains slots: " + slots);
      });
      
      var remaining = this.allRemainingSlots();
      var inDepLists = this.allSlotsInDependencyLists();
      inDepLists.each(function(s) {
        if (! remaining.include(s)) {
          avocado.ui.grab(s.holder());

          var reason = "I have no idea why";
          if (! s.holder().isWellKnown('probableCreatorSlot')) {
            reason = "its holder is not well-known";
          } else if (! s.isIncludedInModule(this._module)) {
            reason = "it's not included in the " + this._module.name() + " module";
          }

          throw new Error("Found a slot in the dependency lists that isn't in the list of slots to file out, because " + reason + ": " + s.fullName());
        }
      }.bind(this));
    }
    
    this._slotsInOrder = [];
    this._cycleBreakersMir = reflect({});
    this._cycleBreakersByOriginalSlot = avocado.dictionary.copyRemoveAll();

    while (! this._remainingSlotsByMirror.isEmpty()) {
      var nextMirrorToFileOut = this.chooseAMirrorWithThisManyDependees(0);
      if (nextMirrorToFileOut) {
        if (this._debugMode) { console.log("Choosing mirror " + nextMirrorToFileOut + " because it has no dependees."); }
        this.nextObjectIs(nextMirrorToFileOut);
      } else {
        var nextSlotToFileOut = this.chooseASlotWithThisManyDependees(0);
        if (nextSlotToFileOut) {
          if (this._debugMode) { console.log("There is no mirror with no dependees; choosing slot " + nextSlotToFileOut + " because it has no dependees."); }
          this.nextSlotIs(nextSlotToFileOut, true);
        } else {
          this.insertCycleBreakerSlot();
        }
      }
    }
    return this._slotsInOrder;
  }, {category: ['transporting']});

  add.method('nextObjectIs', function (nextMirrorToFileOut) {
    var slots = this._remainingSlotsByMirror.get(nextMirrorToFileOut);
    while (! slots.isEmpty()) {
      var nextSlotToFileOut = this.chooseASlotWithThisManyDependees(0, slots);
      if (nextSlotToFileOut) {
        this.nextSlotIs(nextSlotToFileOut, false);
      } else {
        throw "there is a cycle in the slot dependency graph within an object; breaking the cycle is not implemented yet";
      }
    }
    this._objDeps.removeDependee(nextMirrorToFileOut);
  }, {category: ['transporting']});

  add.method('nextSlotIs', function (s, shouldUpdateObjDeps) {
    if (this._debugMode) { console.log("Next slot is " + s.fullName()); }
    var holder;
    if (s.isParent()) {
      // __proto__ slots need to be in there to make the dependency graph come out right, but shouldn't
      // actually be included in the final ordering; an object's __proto__ is actually done with the
      // object's creator slot. (Necessary in order to support browsers that don't allow __proto__ to be
      // set directly.)
      holder = s.holder().theCreatorSlot().holder();
    } else {
      this._slotsInOrder.push(s);
      holder = s.holder();
    }
    var slots = this._remainingSlotsByMirror.get(holder);
    slots.remove(s);
    if (slots.isEmpty()) { this._remainingSlotsByMirror.removeKey(holder); }
    this._slotDeps. holderDeps.removeDependee(s);
    this._slotDeps.contentDeps.removeDependee(s);
    if (shouldUpdateObjDeps) { this.recalculateObjectDependencies(); }
    
    // aaa - hack: mark the slot as being a cycle-breaker so that the filer-outer
    // can do the right thing.
    if (holder.equals(this._cycleBreakersMir)) {
      s.isCycleBreaker = true;
    }
    var cbs = this._cycleBreakersByOriginalSlot.get(s);
    if (cbs) {
      s.wasReplacedByCycleBreakers = cbs;
    }
  }, {category: ['transporting']});

});


});

avocado.transporter.module.onLoadCallbacks["transporter/loading_and_saving"] = function() {};
avocado.transporter.module.create('transporter/loading_and_saving', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado.transporter, function(add) {

  add.method('fileOut', function (moduleVersion, repo, codeToFileOut, successBlock, failBlock) {
    var m = moduleVersion.module();
    var r = repo || m._repository;
    if (!r) { throw new Error("Don't have a repository for: " + m); }
    r.fileOutModuleVersion(moduleVersion, codeToFileOut.replace(/[\r]/g, "\n"), function() {
      m.markAsUnchanged();
      if (successBlock) { successBlock(); }
    }, function(errorMessage) {
      if (failBlock) {
        failBlock(errorMessage);
      } else {
        throw new Error(errorMessage);
      }
    });
  }, {category: ['saving']});

});


thisModule.addSlots(avocado.transporter.repositories, function(add) {

  add.creator('prompter', {}, {category: ['user interface']});

});


thisModule.addSlots(avocado.transporter.repositories.prompter, function(add) {

  add.method('prompt', function (caption, context, evt, callback) {
    if (avocado.transporter.availableRepositories.length === 1) {
      callback(avocado.transporter.availableRepositories[0], evt);
    } else {
      var repoCmdList = this.commandListForRepositories(function(repo) { return function() { callback(repo, evt); }});
      avocado.ui.showMenu(repoCmdList, context, caption, evt);
    }
  });

  add.method('commandListForRepositories', function (f) {
    var cmdList = avocado.command.list.create();
    avocado.transporter.availableRepositories.each(function(repo) {
      var c = f(repo);
      if (c) {
        cmdList.addItem([repo.toString(), c]);
      }
    });
    return cmdList;
  });

});


thisModule.addSlots(avocado.transporter.repositories.http, function(add) {

  add.method('menuItemsForLoadMenu', function () {
    return this.menuItemsForLoadMenuForDir(new FileDirectory(new URL(this._url)), "");
  }, {category: ['user interface', 'commands']});

  add.method('menuItemsForLoadMenuForDir', function (dir, pathFromModuleSystemRootDir) {
    var menuItems = [];

    var subdirURLs = this.subdirectoriesIn(dir);
    subdirURLs.each(function(subdirURL) {
      var subdir = new FileDirectory(subdirURL);
      var subdirName = subdirURL.filename().withoutSuffix('/');
      menuItems.push([subdirName, this.menuItemsForLoadMenuForDir(subdir, pathFromModuleSystemRootDir ? pathFromModuleSystemRootDir + "/" + subdirName : subdirName)]);
    }.bind(this));
        
    var jsFileNames = this.filenamesIn(dir).select(function(n) {return n.endsWith(".js");});
    jsFileNames.each(function(n) {
      menuItems.push([n, function(evt) {
        var moduleName = n.substring(0, n.length - 3);
        avocado.ui.showMessageIfErrorDuring(function() {
          this.fileIn(pathFromModuleSystemRootDir ? (pathFromModuleSystemRootDir + '/' + moduleName) : moduleName);
        }.bind(this), evt);
      }.bind(this)]);
    }.bind(this));

    return menuItems;
  }, {category: ['user interface', 'commands']});

  add.method('copyWithSavingScript', function (savingScriptURL) {
    return Object.newChildOf(avocado.transporter.repositories.httpWithSavingScript, this.url(), savingScriptURL);
  }, {category: ['copying']});

});


thisModule.addSlots(avocado.transporter.repositories.httpWithWebDAV, function(add) {

  add.method('fileOutModuleVersion', function (moduleVersion, codeToFileOut, successBlock, failBlock) {
    var url = this.urlForModuleName(moduleVersion.module().name());
    this.saveFile(url, codeToFileOut, successBlock, failBlock);
  }, {category: ['saving']});

  add.method('saveFile', function (url, fileContents, successBlock, failBlock) {
    var repoURL = this.url();
    if (url.substring(0, repoURL.length) !== repoURL) { url = repoURL + url; }
    var isAsync = true;
    var req = new XMLHttpRequest();
    req.open("PUT", url, isAsync);
    req.onreadystatechange = function() {
      if (req.readyState === 4) {
        try {
          if (req.status >= 200 && req.status < 300) {
            console.log("Saved " + url);
            successBlock();
          } else {
            failBlock("Failed to save to " + url + ", HTTP status code is " + req.status + ", statusText is " + req.statusText);
          }
        } catch (e) {
          failBlock("Failed to save to " + url + " --- exception was " + e);
        }
      }
    };
    req.send(fileContents);
  }, {category: ['saving']});

  add.data('canListDirectoryContents', true, {category: ['directories']});

  add.method('subdirectoriesIn', function (dir) {
    return dir.subdirectories();
  }, {category: ['directories']});

  add.method('filenamesIn', function (dir) {
    return dir.filenames();
  }, {category: ['directories']});

});


thisModule.addSlots(avocado.transporter.repositories.httpWithSavingScript, function(add) {

  add.method('fileOutModuleVersion', function (moduleVersion, codeToFileOut, successBlock, failBlock) {
    var m = moduleVersion.module();
    var repoURL = this.url();
    if (repoURL.endsWith("/")) { repoURL = repoURL.substring(0, repoURL.length - 1); }
    var url = this._savingScriptURL;
    var postBody = "repoURL=" + encodeURIComponent(repoURL) + "&module=" + encodeURIComponent(m.name()) + "&code=" + encodeURIComponent(codeToFileOut);
    //console.log("About to fileOutModuleVersion " + moduleVersion + " using saving script URL " + url + " and POST body:\n" + postBody);
    var req = new Ajax.Request(url, {
      method: 'post',
      postBody: postBody,
      contentType: 'application/x-www-form-urlencoded',
          
      asynchronous: true,
      onSuccess:   function(transport) { this.onSuccess(m, transport, successBlock); }.bind(this),
      onFailure:   function(t        ) { failBlock("Failed to file out module " + m + " to repository " + this + "; HTTP status code was " + req.getStatus()); }.bind(this),
      onException: function(r,      e) { failBlock("Failed to file out module " + m + " to repository " + this + "; exception was " + e); }.bind(this)
    });
  }, {category: ['saving']});

  add.data('shouldShowNewFileContentsInNewWindow', false, {category: ['downloading']});

  add.method('onSuccess', function (m, transport, callWhenDone) {
    var statusCodeIfAny = parseInt(transport.responseText);
    if (!isNaN(statusCodeIfAny)) {
      avocado.ui.showError("Failed to file out " + m + " module; status code " + statusCodeIfAny);
    } else {
      if (this.shouldShowNewFileContentsInNewWindow) {
        var urlToDownload = transport.responseText;
        window.open(urlToDownload);
      }
      callWhenDone();
    }
  }, {category: ['downloading']});

  add.method('subdirectoriesIn', function (dir) {
    return []; // aaa;
  }, {category: ['directories']});

  add.method('filenamesIn', function (dir) {
    return []; // aaa;
  }, {category: ['directories']});

});


thisModule.addSlots(avocado.transporter.repositories.console, function(add) {

  add.method('fileOutModuleVersion', function (moduleVersion, codeToFileOut, successBlock, failBlock) {
    console.log(codeToFileOut);
  });

});


});

avocado.transporter.module.onLoadCallbacks["core/collections/linked_list"] = function() {};
avocado.transporter.module.create('core/collections/linked_list', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('list', Object.create({}), {category: ['collections']});

  avocado.annotator.loadObjectAnnotation(avocado.list['__proto__'], {copyDownParents: [{parent: Enumerable, slotsToOmit: ['size', '__annotation__']}]}, '__proto__', avocado.list);


});


thisModule.addSlots(avocado.list, function(add) {

  add.data('_size', 0);

});


thisModule.addSlots(avocado.list['__proto__'], function(add) {

  add.creator('linkProto', Object.create({}), {category: ['links']});

  avocado.annotator.loadObjectAnnotation(avocado.list['__proto__'].linkProto['__proto__'], {}, '__proto__', avocado.list['__proto__'].linkProto);


  add.method('copyRemoveAll', function () {
  var c = Object.shallowCopy(this);
  c._rep = this._rep.copy();
  c.removeAll();
  return c;
}, {category: ['copying']});

  add.method('add', function (elem) {
  this.addLast(elem);
}, {category: ['adding']});

  add.method('removeAll', function () {
  this._size = 0;
  this._rep.removeAll();
}, {category: ['removing']});

  add.creator('tests', Object.create(avocado.testCase), {category: ['tests']});

  add.method('size', function () { return this._size; }, {category: ['accessing']});

  add.method('_each', function (f) {
  this._rep.eachLink(function(lnk) {
    f(lnk.value());
  });
}, {category: ['iterating']});

  add.method('addLast', function (elem) {
  this._size += 1;
  this._rep.addPrevLink(this.linkProto.copyWithValue(elem));
}, {category: ['adding']});

  add.method('addFirst', function (elem) {
  this._size += 1;
  this._rep.addNextLink(this.linkProto.copyWithValue(elem));
}, {category: ['adding']});

  add.method('hashCode', function () {
  return [
    avocado.hashTable.equalityComparator.hashCodeForKey(this.first()),
    avocado.hashTable.equalityComparator.hashCodeForKey(this.last()),
    avocado.hashTable.equalityComparator.hashCodeForKey(this.size())
  ].join();
}, {category: ['comparing']});

  add.method('addAll', function (c) {
  this.addAllLast(c);
}, {category: ['adding']});

  add.method('addAllLast', function (c) {
  c.each(function(elem) { this.addLast(elem); }.bind(this));
}, {category: ['adding']});

  add.method('addAllFirst', function (c) {
  c.reverseEach(function(elem) { this.addFirst(elem); }.bind(this));
}, {category: ['adding']});

  add.method('copyContaining', function (otherCollection) {
  var c = this.copyRemoveAll();
  c.addAllLast(otherCollection);
  return c;
}, {category: ['copying']});

  add.method('equals', function (other) {
  return exitValueOf(function(exit) {
    if (this === other) { return true; }
    if (this.size() !== other.size()) { return false; }
    this.simultaneousEach(other, function(e1, e2) {
      if (! avocado.hashTable.equalityComparator.keysAreEqual(e1, e2)) {
        return false;
      }
    });
    return true;
  }.bind(this));
}, {category: ['comparing']});

  add.method('simultaneousEach', function (other, f) {
  this._rep.simultaneousEachLink(other, function(lnk, otherValue) {
    f(lnk.value(), otherValue);
  });
}, {category: ['iterating']});

  add.method('first', function () {
  return this._rep.firstLink().value();
}, {category: ['accessing']});

  add.method('last', function () {
  return this._rep.lastLink().value();
}, {category: ['accessing']});

  add.method('isEmpty', function () { return this._rep.isEmpty(); }, {category: ['accessing']});

  add.method('reverseEach', function (f) {
  this._rep.reverseEachLink(function(lnk) {
    f(lnk.value());
  });
}, {category: ['iterating']});

  add.method('reverseSimultaneousEach', function (other, f) {
  this._rep.reverseSimultaneousEachLink(other, function(lnk, otherValue) {
    f(lnk.value(), otherValue);
  });
}, {category: ['iterating']});

  add.method('removeFirst', function () {
  this._size -= 1;
  return this._rep.removeFirstLink().value();
}, {category: ['removing']});

  add.method('removeLast', function () {
  this._size -= 1;
  return this._rep.removeLastLink().value();
}, {category: ['removing']});

  add.method('remove', function (elem, absentFn) {
  return this.findFirstLinkFor(elem, function(lnk) {
    lnk.remove();
    this._size -= 1;
  }.bind(this), absentFn);
}, {category: ['removing']});

  add.method('findFirstLinkFor', function (elem, presentFn, absentFn) {
  return this.findFirstLinkSatisfying(
    function(lnk) { return avocado.hashTable.equalityComparator.keysAreEqual(elem, lnk.value()); },
    presentFn,
    absentFn
  );
}, {category: ['searching']});

  add.method('findFirstLinkSatisfying', function (conditionFn, presentFn, absentFn) {
  return exitValueOf(function(exit) {
    this._rep.eachLink(function(lnk) {
      if (conditionFn(lnk)) { exit(presentFn(lnk)); }
    });
    return absentFn();
  }.bind(this));
}, {category: ['searching']});

  add.method('toString', function () {
  if (this.size() > 10) { return ""; }
  return this.toArray().join(", ");
}, {category: ['printing']});

});


thisModule.addSlots(avocado.list, function(add) {

  add.data('_rep', avocado.list['__proto__'].linkProto);

});


thisModule.addSlots(avocado.list['__proto__'].linkProto, function(add) {

  add.data('_prev', null);

  add.data('_next', null);

  add.data('_value', null);

});


thisModule.addSlots(avocado.list['__proto__'].linkProto['__proto__'], function(add) {

  add.method('copy', function () {
  return Object.shallowCopy(this);
}, {category: ['copying']});

  add.method('removeAll', function () {
  this._next = this;
  this._prev = this;
}, {category: ['removing']});

  add.method('isEmpty', function () {
  return this._next === this;
}, {category: ['accessing']});

  add.method('firstLink', function () {
  if (this.isEmpty()) { throw new Error("first is absent"); }
  return this._next;
}, {category: ['accessing']});

  add.method('lastLink', function () {
  if (this.isEmpty()) { throw new Error("first is absent"); }
  return this._prev;
}, {category: ['accessing']});

  add.method('removeFirstLink', function () {
  return this._next.remove();
}, {category: ['removing']});

  add.method('removeLastLink', function () {
  return this._prev.remove();
}, {category: ['removing']});

  add.method('remove', function () {
  if (this.isEmpty()) { throw new Error("cannot remove from an empty list"); }
  this._prev._next = this._next;
  this._next._prev = this._prev;
  return this;
}, {category: ['removing']});

  add.method('eachLink', function (f) {
  var head = this._next._prev;
  var lnk = this._next;
  while (head !== lnk) {
    var saveNextToPermitRemoving = lnk._next;
    f(lnk);
    lnk = saveNextToPermitRemoving;
  }
}, {category: ['iterating']});

  add.method('copyWithValue', function (v) {
  var c = this.copy();
  c._value = v;
  return c;
}, {category: ['copying']});

  add.method('addNextLink', function (lnk) {
  lnk._next = this._next;
  this._next._prev = lnk;
  lnk._prev = this;
  this._next = lnk;
}, {category: ['adding']});

  add.method('addPrevLink', function (lnk) {
  lnk._prev = this._prev;
  this._prev._next = lnk;
  lnk._next = this;
  this._prev = lnk;
}, {category: ['adding']});

  add.method('simultaneousEachLink', function (other, f) {
  exitValueOf(function(exit) {
    var head = this._next._prev;
    var lnk = this._next;
    other.each(function(otherValue) {
      if (head === lnk) { exit(); }
      var saveNextToPermitRemoving = lnk._next;
      f(lnk, otherValue);
      lnk = saveNextToPermitRemoving;
    });
  }.bind(this));
}, {category: ['iterating']});

  add.method('value', function () { return this._value; }, {category: ['accessing']});

  add.method('reverseEachLink', function (f) {
  var head = this._next._prev;
  var lnk = this._prev;
  while (head !== lnk) {
    var savePrevToPermitRemoving = lnk._prev;
    f(lnk);
    lnk = savePrevToPermitRemoving;
  }
}, {category: ['iterating']});

  add.method('reverseSimultaneousEachLink', function (other, f) {
  exitValueOf(function(exit) {
    var head = this._next._prev;
    var lnk = this._prev;
    other.reverseEach(function(otherValue) {
      if (head === lnk) { exit(); }
      var savePrevToPermitRemoving = lnk._prev;
      f(lnk, otherValue);
      lnk = savePrevToPermitRemoving;
    });
  }.bind(this));
}, {category: ['iterating']});

});


thisModule.addSlots(avocado.list['__proto__'].tests, function(add) {

  add.method('testBasicStuff', function () {
  var c = avocado.list.copyRemoveAll();
  this.assertEqual(0, c.size());
  this.assert(c.isEmpty());
  c.each(function(elem) {this.fail();}.bind(this));
  this.assertEqual([], c.toArray());
  
  c.add('one');
  this.assertEqual(1, c.size());
  this.assertEqual(['one'], c.toArray());

  c.addLast(2);
  c.addFirst('zero');
  this.assertEqual(3, c.size());
  this.assertEqual(['zero', 'one', 2], c.toArray());

  var c2 = avocado.list.copyContaining(['zero', 'one', 2]);
  this.assertEqual(c, c2);
  
  var s = avocado.set.copyRemoveAll();
  s.add(c);
  s.add(c2);
  this.assertEqual(1, s.size());
  this.assert(s.include(c));

  c.addAllFirst(avocado.list.copyContaining([-2, -1]));
  this.assertEqual(-2, c.first());
  this.assertEqual(2, c.last());
  this.assertEqual(5, c.size());

  this.assertEqual(-2, c.removeFirst());
  this.assertEqual(2, c.removeLast());
  this.assertEqual(3, c.size());
  c.remove('zero', function() {this.fail();}.bind(this));
  this.assertEqual(2, c.size());
  this.assertEqual([-1, 'one'], c.toArray());

  var wasAbsent = false;
  c.remove('not in there', function() {wasAbsent = true;});
  this.assert(wasAbsent);
});

});


});

avocado.transporter.module.onLoadCallbacks["core/collections/range"] = function() {};
avocado.transporter.module.create('core/collections/range', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('range', {}, {category: ['collections']}, {comment: 'A range of numbers.', copyDownParents: [{parent: Enumerable}]});

});


thisModule.addSlots(avocado.range, function(add) {

  add.method('create', function () {
    var r = Object.create(this);
    r.initialize.apply(r, arguments);
    return r;
  }, {category: ['creating']});

  add.method('initialize', function (start, end, step) {
    this._start = start;
    this._end   = end;
    this._step  = step || 1;
    this._shouldIncludeStart = true;
    this._shouldIncludeEnd   = false;
  }, {category: ['creating']});

  add.method('start', function () { return this._start;    }, {category: ['accessing']});

  add.method('setStart', function (s) {        this._start = s;}, {category: ['accessing']});

  add.method('end', function () { return this._end;    }, {category: ['accessing']});

  add.method('setEnd', function (e) {        this._end = e;}, {category: ['accessing']});

  add.method('step', function () { return this._step;    }, {category: ['accessing']});

  add.method('setStep', function (s) {        this._step = s;}, {category: ['accessing']});

  add.method('includeStart', function () {
    this._shouldIncludeStart = true;
    return this;
  }, {category: ['including or excluding endpoints']});

  add.method('doNotIncludeStart', function () {
    this._shouldIncludeStart = false;
    return this;
  }, {category: ['including or excluding endpoints']});

  add.method('includeEnd', function () {
    this._shouldIncludeEnd = true;
    return this;
  }, {category: ['including or excluding endpoints']});

  add.method('doNotIncludeEnd', function () {
    this._shouldIncludeEnd = false;
    return this;
  }, {category: ['including or excluding endpoints']});

  add.method('_each', function (f) {
    var step  = this._step;
    var end   = this._end;
    var start = this._shouldIncludeStart ? this._start : this._start + step;
    if (this._shouldIncludeEnd) {
      for (var i = start; i <= end; i += step) { f(i); }
    } else {
      for (var i = start; i <  end; i += step) { f(i); }
    }
  }, {category: ['iterating']});

  add.creator('tests', Object.create(avocado.testCase), {category: ['tests']});

});


thisModule.addSlots(avocado.range.tests, function(add) {

  add.method('testStuff', function () {
    var r = avocado.range.create(3, 10);
    this.assertEqual([3, 4, 5, 6, 7, 8, 9], r.toArray());
    r.includeEnd();
    this.assertEqual([3, 4, 5, 6, 7, 8, 9, 10], r.toArray());
    r.doNotIncludeStart();
    this.assertEqual([4, 5, 6, 7, 8, 9, 10], r.toArray());
    r.doNotIncludeEnd();
    this.assertEqual([4, 5, 6, 7, 8, 9], r.toArray());
    r.includeStart();
    this.assertEqual([3, 4, 5, 6, 7, 8, 9], r.toArray());

    r.setStep(2);
    this.assertEqual([3, 5, 7, 9], r.toArray());
  });

});


});

avocado.transporter.module.onLoadCallbacks["core/collections/enumerator"] = function() {};
avocado.transporter.module.create('core/collections/enumerator', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('enumerator', {}, {category: ['collections']}, {comment: 'An Enumerable whose contents are whatever is yielded by calling the specified method.', copyDownParents: [{parent: Enumerable}]});

});


thisModule.addSlots(avocado.enumerator, function(add) {

  add.method('map', function (transformer) {
    return avocado.enumerator.create(this, 'eachMappedBy', transformer);
  }, {category: ['transforming']});

  add.method('select', function (condition) {
    return avocado.enumerator.create(this, 'eachFilteredBy', condition);
  }, {category: ['transforming']});

  add.method('toArray', function () {
    var a = [];
    this.each(function(x) { a.push(x); });
    return a;
  }, {category: ['transforming']});

  add.method('create', function () {
    var e = Object.create(this);
    e.initialize.apply(e, arguments);
    return e;
  }, {category: ['creating']});

  add.method('initialize', function () {
    var args = $A(arguments);
    this._object = args.shift();
    this._methodName = args.shift();
    this._methodArgs = args;
  }, {category: ['creating']});

  add.method('toString', function () {
    var s = [this._object.toString(), ".", this._methodName, "("];
    this._methodArgs.each(function(arg) { s.push("" + arg); });
    s.push(")");
    return s.join("");
  }, {category: ['printing']});

  add.method('forEach', function (f) {
    return this._each(f);
  }, {category: ['iterating']});

  add.method('_each', function (f) {
    var method = this._object[this._methodName];
    if (this._methodArgs.length === 0) { // just an optimization to avoid creating unnecessary arrays
      return method.call(this._object, f);
    } else {
      return method.apply(this._object, this._methodArgs.concat([f]));
    }
  }, {category: ['iterating']});

  add.method('sort', function (f) {
    return this.toArray().sort(f);
  }, {category: ['sorting']});

  add.method('eachFilteredBy', function (condition, f) {
    this.each(function(x) { if (condition(x)) { f(x); }; });
  }, {category: ['transforming']});

  add.method('eachMappedBy', function (transformer, f) {
    this.each(function(x) { f(transformer(x)); });
  }, {category: ['transforming']});

  add.creator('tests', Object.create(avocado.testCase), {category: ['tests']});

});


thisModule.addSlots(avocado.enumerator.tests, function(add) {

  add.method('eachInteger', function (start, end, f) {
    this._startedIterating = true;
    for (var i = start; i < end; ++i) { f(i); }
  });

  add.method('testToArray', function () {
    var e = avocado.enumerator.create(this, 'eachInteger', 3, 10);
    this.assertEqual([3, 4, 5, 6, 7, 8, 9].join(','), e.toArray().join(','));
  });

  add.method('testSelectAndMap', function () {
    var ints = avocado.enumerator.create(this, 'eachInteger', 1, 10);
    
    var odds = ints.select(function(i) { return i % 2 === 1; });
    this.assert(! this._startedIterating, "select() should return another enumerator; don't actually iterate until we have to");
    this.assertEqual([1, 3, 5, 7, 9].join(','), odds.toArray().join(','));
    this.assert(this._startedIterating);
    this._startedIterating = false;
    
    var squares = ints.map(function(i) { return i * i; });
    this.assert(! this._startedIterating, "map() should return another enumerator; don't actually iterate until we have to");
    this.assertEqual([1, 4, 9, 16, 25, 36, 49, 64, 81].join(','), squares.toArray().join(','));
    this.assert(this._startedIterating);
    this._startedIterating = false;
  });

});


});

avocado.transporter.module.onLoadCallbacks["core/collections/composite_collection"] = function() {};
avocado.transporter.module.create('core/collections/composite_collection', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('compositeCollection', {}, {category: ['collections']}, {comment: 'A collection made up of multiple subcollections', copyDownParents: [{parent: Enumerable}]});

});


thisModule.addSlots(avocado.compositeCollection, function(add) {

  add.method('include', function (e) {
    return this._subcollections.any(function(subcollection) { return subcollection.include(e); });
  }, {category: ['testing']});

  add.method('toArray', function () {
    var a = [];
    this.each(function(x) { a.push(x); });
    return a;
  }, {category: ['transforming']});

  add.method('size', function () {
    var s = 0;
    this._subcollections.each(function(subcollection) { s += subcollection.size(); });
    return s;
  }, {category: ['accessing']});

  add.method('create', function () {
    var c = Object.create(this);
    c.initialize.apply(c, arguments);
    return c;
  }, {category: ['creating']});

  add.method('initialize', function (subcollections) {
    this._subcollections = subcollections;
  }, {category: ['creating']});

  add.method('_each', function (f) {
    this._subcollections._each(function(subcollection) {
      subcollection._each(f);
    });
  }, {category: ['iterating']});

  add.method('forEach', function (f) {
    return this.each(f);
  }, {category: ['iterating']});

  add.method('sort', function (f) {
    return this.toArray().sort(f);
  }, {category: ['sorting']});

  add.creator('tests', Object.create(avocado.testCase), {category: ['tests']});

});


thisModule.addSlots(avocado.compositeCollection.tests, function(add) {

  add.method('testSimple', function () {
    var c = avocado.compositeCollection.create([[1, 2, 3], [4], [5, 6, 7]]);
    this.assertEqual([1, 2, 3, 4, 5, 6, 7].join(' '), c.toArray().join(' '));
    this.assert(c.include(1));
    this.assert(c.include(3));
    this.assert(c.include(7));
    this.assert(! c.include(8));
    this.assertEqual(7, c.size());
  });

});


});

avocado.transporter.module.onLoadCallbacks["core/collections/typed_collection"] = function() {};
avocado.transporter.module.create('core/collections/typed_collection', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('typedCollection', {}, {category: ['collections']}, {copyDownParents: [{parent: Enumerable}]});

});


thisModule.addSlots(avocado.typedCollection, function(add) {

  add.method('size', function () {
    return this._elements.size();
  }, {category: ['accessing']});

  add.method('create', function () {
    var c = Object.create(this);
    c.initialize.apply(c, arguments);
    return c;
  }, {category: ['creating']});

  add.method('initialize', function (elementType, elements) {
    this._elementType = elementType;
    this._elements = elements || [];
  }, {category: ['creating']});

  add.method('elementType', function () {
    return this._elementType;
  }, {category: ['accessing']});

  add.method('elements', function () {
    return this._elements;
  }, {category: ['accessing']});

  add.method('setElements', function (c) {
    this._elements = c;
    return this;
  }, {category: ['accessing']});

  add.method('forEach', function (f) {
    this._elements.forEach(f);
  }, {category: ['iterating']});

  add.method('_each', function (f) {
    this.forEach(f);
  }, {category: ['iterating']});

  add.method('remove', function (element) {
    this._elements.remove(element);
  }, {category: ['accessing']});

  add.method('mapElementsAndType', function (elementMapFn, typeMapFn) {
    return avocado.typedCollection.create(typeMapFn(this.elementType()), this.elements().map(elementMapFn));
  }, {category: ['accessing']});

  add.method('push', function (element) {
    this.elements().push(element);
  }, {category: ['adding']});

  add.method('addANewOne', function () {
    var newOne = this.elementType().createForAddingTo ? this.elementType().createForAddingTo(this) : this.elementType().create();
    this.push(newOne);
    return newOne;
  }, {category: ['adding']});

  add.method('ifNotAlreadyPresentAdd', function (element) {
    if (! this._elements.include(element)) {
      this.push(element);
    }
  }, {category: ['accessing']});

  add.method('commands', function () {
    var cmdList = avocado.command.list.create(this);
    cmdList.addItem(avocado.command.create("add", function(evt) {
      var newOne = this.addANewOne();
      avocado.ui.justChanged(this, function(morph) {
        avocado.ui.setInputFocus(newOne, evt);
      }, evt);
    }));
    return cmdList;
  }, {category: ['user interface', 'commands']});

});


});

avocado.transporter.module.onLoadCallbacks["core/identity_hash"] = function() {};
avocado.transporter.module.create('core/identity_hash', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.method('identityHashFor', function (o) {
    // Why, oh why doesn't JavaScript have a proper built-in identity-hash mechanism?;
    try {
      if (o === undefined) { return "undefined"; }
      if (o === null     ) { return "null";      }
      var t = typeof(o);
      if (t === 'string') { return o; }
      if (t === 'number') { return o.toString(); }
      if (t === 'boolean') { return o.toString(); }
      if (typeof(o.identityHashCode) === 'function') { return o.identityHashCode(); }
      return avocado.annotator.oidOf(o).toString();
    } catch (ex) {
      // don't want to crash if the object is broken
    }
    return "broken identity hash";
  }, {category: ['hashing']});

});


});

avocado.transporter.module.onLoadCallbacks["core/collections/hash_table"] = function() {};
avocado.transporter.module.create('core/collections/hash_table', function(requires) {

requires('core/identity_hash');
requires('core/testFramework');

}, function(thisModule) {


thisModule.addSlots(Array.prototype, function(add) {

  add.method('equals', function (other) {
    if (this.size() !== other.size()) { return false; }
    for (var i = 0, n = this.size(); i < n; ++i) {
      if (! avocado.hashTable.equalityComparator.keysAreEqual(this[i], other[i])) { return false; }
    }
    return true;
  }, {category: ['comparing']});

  add.method('hashCode', function () {
    var s = [];
    for (var i = 0, n = Math.min(this.length, 5); i < n; ++i) {
      s.push(avocado.hashTable.equalityComparator.hashCodeForKey(this[i]));
    }
    return s.join();
  }, {category: ['comparing']});

  add.method('toSet', function () {
    var s = avocado.set.copyRemoveAll();
    s.addAll(this);
    return s;
  });

  add.creator('tests', Object.create(avocado.testCase), {category: ['tests']});

});


thisModule.addSlots(Array.prototype.tests, function(add) {

  add.creator('someObject', {});

  add.method('testComparing', function () {
    this.assertEqual([], []);
    this.assertEqual(['a'], ['a']);
    this.assertNotEqual(['a'], ['ab']);
    this.assertNotEqual(['a', 'b'], ['ab']);
    this.assertNotEqual(['a'], ['a', 'b']);
    this.assertNotEqual(['a', 'b'], ['b', 'a']);
    this.assertEqual([reflect(this.someObject)], [reflect(this.someObject)]);
  });

});


thisModule.addSlots(Number.prototype, function(add) {

  add.method('hashCode', function () {return this;}, {category: ['hashing']});

  add.method('identityHashCode', function () {return this;}, {category: ['hashing']});

});


thisModule.addSlots(String.prototype, function(add) {

  add.method('hashCode', function () {return this;}, {category: ['hashing']});

  add.method('identityHashCode', function () {return this;}, {category: ['hashing']});

});


thisModule.addSlots(avocado, function(add) {

  add.creator('hashTable', {}, {category: ['collections']}, {comment: 'I don\'t mean to keep this class around forever - hopefully sooner or later Javascript will\rhave a working hash table that can handle arbitrary objects (rather than just strings) as\rkeys. Maybe it exists already, but I couldn\'t find it. So for now I\'ll just use this bloody\rthing. -- Adam', copyDownParents: [{parent: Enumerable}]});

});


thisModule.addSlots(avocado.hashTable, function(add) {

  add.method('size', function () {
    return this._size;
  }, {category: ['accessing']});

  add.method('copyRemoveAll', function (comparator) {
    // Should this be called copyRemoveAll or cloneRemoveAll or create or what?
    return Object.newChildOf(this, comparator); // aaa - blecch, why again can't I put a "create" method directly on Object.prototype?;
  }, {category: ['creating']});

  add.creator('bucketHolder', {}, {category: ['prototypes']});

  add.method('initialize', function (comparator) {
    this._buckets = Object.create(this.bucketHolder);
    this._size = 0;
    if (comparator) { this._comparator = comparator; }
  }, {category: ['initializing']});

  add.creator('equalityComparator', {}, {category: ['hashing']});

  add.creator('identityComparator', {}, {category: ['hashing']});

  add.data('_comparator', avocado.hashTable.equalityComparator, {category: ['hashing'], initializeTo: 'avocado.hashTable.equalityComparator'});

  add.method('isEmpty', function () {
    return this.size() === 0;
  }, {category: ['testing']});

  add.method('bucketForKey', function (k) {
    var bucketName = "bucket_" + this._comparator.hashCodeForKey(k);
    var b = this._buckets[bucketName];
    if (typeof b === "undefined") {
      this._buckets[bucketName] = b = [];
    }
    else {
      if (! this._buckets.hasOwnProperty(bucketName)) {
        // console.log("Bad bucket name: " + bucketName);
        return this.bucketForKey("replacementForInvalidBucketName");
      }
    }
    return b;
  }, {category: ['hashing']});

  add.method('entryForKey', function (k) {
    var b = this.bucketForKey(k);
    return this.entryForKeyInBucket(k, b);
  }, {category: ['hashing']});

  add.method('entryForKeyInBucket', function (k, b) {
    var i = this.indexOfEntryForKeyInBucket(k, b);
    return i === null ? null : b[i];
  }, {category: ['hashing']});

  add.method('indexOfEntryForKeyInBucket', function (k, b) {
    for (var i = 0, n = b.length; i < n; ++i) {
      var entry = b[i];
      if (this._comparator.keysAreEqual(k, this.keyOfEntry(entry))) {
        return i;
      }
    }
    return null;
  }, {category: ['hashing']});

  add.method('put', function (k, v) {
    var b = this.bucketForKey(k);
    var entry = this.entryForKeyInBucket(k, b);
    if (entry) {
      this.setValueOfEntry(entry, v);
      return v;
    } else {
      b.push(this.newEntry(k, v));
      ++this._size;
      return v;
    }
  }, {category: ['accessing']});

  add.method('removeKey', function (k) {
    var b = this.bucketForKey(k);
    var i = this.indexOfEntryForKeyInBucket(k, b);
    if (i !== null) {
      var entry = b.splice(i, 1)[0];
      --this._size;
      return this.valueOfEntry(entry);
    } else {
      return null;
    }
  }, {category: ['accessing']});

  add.method('_each', function (iterator) {
    for (var h in this._buckets) {
      if (this._buckets.hasOwnProperty(h)) {
        var b = this._buckets[h];
        if (b instanceof Array) {
          for (var i = 0, n = b.length; i < n; ++i) {
            var entry = b[i];
            iterator(entry);
          }
        }
      }
    }
  }, {category: ['iterating']});

  add.method('typeName', function () { return "hash table"; }, {category: ['printing']});

  add.method('toString', function () {
    var s = ["a ", this.typeName()];
    if (this._size <= 5) {
      var sep = "";
      s.push("(");
      this._each(function(entry) {
        s.push(sep, this.printEntry(entry));
        sep = ", ";
      }.bind(this));
      s.push(")");
    }
    return s.join("");
  }, {category: ['printing']});

});


thisModule.addSlots(avocado.hashTable.equalityComparator, function(add) {

  add.method('keysAreEqual', function (k1, k2) {
    if (k1 === k2) {return true;}
    if (k1 === null || typeof(k1) === 'undefined') {return k2 === null || typeof(k2) === 'undefined';}
    if (k2 === null || typeof(k2) === 'undefined') {return false;}
    if (typeof(k1) !== typeof(k2)) {return false;}
    if (typeof(k1.equals) === 'function') {
      return k1.equals(k2);
    } else {
      return k1 == k2;
    }
  }, {category: ['hashing']});

  add.method('hashCodeForKey', function (k) {
    if (k === null || typeof(k) === 'undefined') {return 'null';}
    if (typeof(k.hashCode) === 'function') { return k.hashCode(); }
    return avocado.hashTable.identityComparator.hashCodeForKey(k);
  }, {category: ['hashing']});

});


thisModule.addSlots(avocado.hashTable.identityComparator, function(add) {

  add.method('keysAreEqual', function (k1, k2) {
    return k1 === k2;
  }, {category: ['hashing']});

  add.method('hashCodeForKey', function (k) {
    try {
      return avocado.identityHashFor(k);
    } catch (ex) {
      return "broken identity hash";
    }
  }, {category: ['hashing']});

});


thisModule.addSlots(avocado, function(add) {

  add.creator('dictionary', Object.create(avocado.hashTable), {category: ['collections']});

});


thisModule.addSlots(avocado.dictionary, function(add) {

  add.method('keyOfEntry', function (entry) {
    return entry.key;
  }, {category: ['entries']});

  add.method('valueOfEntry', function (entry) {
    return entry.value;
  }, {category: ['entries']});

  add.method('setValueOfEntry', function (entry, v) {
    entry.value = v;
  }, {category: ['entries']});

  add.creator('entry', {}, {category: ['entries']});

  add.method('newEntry', function (k, v) {
    return Object.newChildOf(this.entry, k, v);
  }, {category: ['entries']});

  add.method('printEntry', function (entry) {
    return this.keyOfEntry(entry) + ": " + this.valueOfEntry(entry);
  }, {category: ['entries']});

  add.method('typeName', function () { return "dictionary"; }, {category: ['printing']});

  add.method('get', function (k) {
    var entry = this.entryForKey(k);
    return entry !== null ? this.valueOfEntry(entry) : null;
  }, {category: ['accessing']});

  add.method('set', function (k, v) {
    return this.put(k, v);
  }, {category: ['accessing']});

  add.method('containsKey', function (k) {
    return this.entryForKey(k) !== null;
  }, {category: ['testing']});

  add.creator('tests', Object.create(avocado.testCase), {category: ['tests']});

  add.method('keys', function () {
    var ks = [];
    this._each(function(pair) {
      ks.push(pair.key);
    });
    return ks;
  }, {category: ['accessing']});

  add.method('values', function () {
    var vs = [];
    this._each(function(pair) {
      vs.push(pair.value);
    });
    return vs;
  }, {category: ['accessing']});

  add.method('getOrIfAbsent', function (key, functionWhoseValueToReturnIfAbsent) {
    var v = this.get(key);
    if (v === null) {
      return functionWhoseValueToReturnIfAbsent();
    }
    return v;
  }, {category: ['accessing']});

  add.method('getOrIfAbsentPut', function (key, functionReturningTheValueToPutIfAbsent) {
    // aaa - optimize this to only do one hash lookup?
    var v = this.get(key);
    if (v === null) {
      v = functionReturningTheValueToPutIfAbsent();
      this.set(key, v);
    }
    return v;
  }, {category: ['accessing']});

  add.method('eachKeyAndValue', function (f) {
    return this._each(function(pair) {return f(pair.key, pair.value);});
  }, {category: ['iterating']});

  add.method('eachValue', function (f) {
    return this._each(function(pair) {return f(pair.value);});
  }, {category: ['iterating']});

  add.method('eachKey', function (f) {
    return this._each(function(pair) {return f(pair.key);});
  }, {category: ['iterating']});

  add.method('createPathTree', function (pathsAndObjects) {
    var dictProto = this;
    var createNewDict = function() { return dictProto.copyRemoveAll(); };
    var d = createNewDict();
    pathsAndObjects.each(function(pathAndObject) {
      var currentDictionary = d;
      var path = pathAndObject.path;
      var object = pathAndObject.object;
      for (var i = 0; i < path.length - 1; ++i) {
        currentDictionary = currentDictionary.getOrIfAbsentPut(path[i], createNewDict);
      }
      currentDictionary.put(path[path.length - 1], object);
    });
    return d;
  }, {category: ['path dictionaries']});

  add.method('menuItemsForPathTree', function (pathDict, evt, callback) {
    if (pathDict.keys) { // aaa is there a better way to do a type test?
      return pathDict.keys().sort().map(function(k) {
        return [k, this.menuItemsForPathTree(pathDict.get(k), evt, callback)];
      }.bind(this));
    } else {
      // the leaves of the tree are the objects we want
      return function(evt) { callback(pathDict, evt); };
    }
  }, {category: ['path dictionaries']});

});


thisModule.addSlots(avocado.dictionary.entry, function(add) {

  add.method('initialize', function (k, v) {
    this.key = k;
    this.value = v;
  });

});


thisModule.addSlots(avocado.dictionary.tests, function(add) {

  add.method('testGettingAndSetting', function () {
    var h = avocado.dictionary.copyRemoveAll();
    var k1 = {};
    var k2 = {};
    var k3 = pt(5, 6);
    h.put(k1, "One");
    h.put(k2, 2);
    h.put(k3, "the point (5, 6)");
    this.assertEqual("One", h.get(k1));
    this.assertEqual(2, h.get(k2));
    this.assertEqual("the point (5, 6)", h.get(k3));
    this.assertEqual("the point (5, 6)", h.get(pt(5, 6)), "uses equals() rather than ===");
    this.assertEqual(null, h.get({}));
    this.assertEqual(3, h.size());
    h.put(k1, "Un");
    this.assertEqual("Un", h.get(k1));
    this.assertEqual(3, h.size());
    this.assertEqual("the point (5, 6)", h.removeKey(k3));
    this.assertEqual(2, h.size());
  });

});


thisModule.addSlots(avocado, function(add) {

  add.creator('set', Object.create(avocado.hashTable), {category: ['collections']});

});


thisModule.addSlots(avocado.set, function(add) {

  add.method('keyOfEntry', function (entry) {
    return entry;
  }, {category: ['entries']});

  add.method('valueOfEntry', function (entry) {
    return entry;
  }, {category: ['entries']});

  add.method('setValueOfEntry', function (entry, v) {
  }, {category: ['entries']});

  add.method('newEntry', function (k, v) {
    return k;
  }, {category: ['entries']});

  add.method('printEntry', function (entry) {
    return entry.toString();
  }, {category: ['entries']});

  add.method('typeName', function () { return "set"; }, {category: ['printing']});

  add.method('push', function (v) {
    return this.add(v);
  }, {category: ['compatibility with arrays']});

  add.method('add', function (v) {
    return this.put(v, v);
  }, {category: ['accessing']});

  add.method('addAll', function (vs) {
    vs.each(function(v) { this.add(v); }.bind(this));
    return this;
  }, {category: ['accessing']});

  add.method('remove', function (v) {
    return this.removeKey(v);
  }, {category: ['accessing']});

  add.method('contains', function (k) {
    return this.entryForKey(k) !== null;
  }, {category: ['testing']});

  add.method('includes', function (k) {
    return this.contains(k);
  }, {category: ['testing']});

  add.method('include', function (k) {
    return this.contains(k);
  }, {category: ['testing']});

  add.creator('tests', Object.create(avocado.testCase), {category: ['tests']});

  add.method('toArray', function () {
    var vs = [];
    this._each(function(entry) {
      vs.push(entry);
    });
    return vs;
  }, {category: ['converting']});

  add.method('copyContaining', function (vs) {
    var s = this.copyRemoveAll();
    s.addAll(vs);
    return s;
  }, {category: ['creating']});

});


thisModule.addSlots(avocado.set.tests, function(add) {

  add.method('testGettingAndSetting', function () {
    var s = avocado.set.copyRemoveAll();
    var k1 = {};
    var k2 = {};
    var k3 = pt(5, 6);
    s.add(k1);
    s.add(k2);
    s.add(k3);
    this.assert(s.contains(k1));
    this.assert(s.contains(k2));
    this.assert(s.contains(k3));
    this.assert(! s.contains({}));
    this.assertEqual(3, s.size());
    s.remove(k2);
    this.assert(  s.contains(k1));
    this.assert(! s.contains(k2));
    this.assert(  s.contains(k3));
    this.assertEqual(2, s.size());
    
  });

});


});

avocado.transporter.module.onLoadCallbacks["core/collections/collections"] = function() {};
avocado.transporter.module.create('core/collections/collections', function(requires) {

requires('core/collections/hash_table');
requires('core/collections/linked_list');
requires('core/collections/range');
requires('core/collections/enumerator');
requires('core/collections/composite_collection');
requires('core/collections/typed_collection');

}, function(thisModule) {


});

avocado.transporter.module.onLoadCallbacks["core/notifier"] = function() {};
avocado.transporter.module.create('core/notifier', function(requires) {

requires('core/collections/hash_table');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('notifier', {}, {category: ['core']}, {comment: 'Keeps track of a list of observers and notifies them when requested.'});

});


thisModule.addSlots(avocado.notifier, function(add) {

  add.method('on', function (s) {
    return Object.newChildOf(this, s);
  });

  add.method('initialize', function (s) {
    this.subject = s;
    this.observers = Object.newChildOf(avocado.set, avocado.set.identityComparator);
  });

  add.method('addObserver', function (o) {
    this.observers.add(o);
  });

  add.method('removeObserver', function (o) {
    this.observers.remove(o);
  });

  add.method('notifyAllObservers', function (arg) {
    var s = this.subject;
    this.observers.each(function(o) {o(s, arg);});
  });

  add.creator('tests', Object.create(avocado.testCase), {category: ['tests']});

});


thisModule.addSlots(avocado.notifier.tests, function(add) {

  add.method('testStuff', function (o) {
    var n = avocado.notifier.on(3);
    var sum = 0;
    n.notifyAllObservers(1);
    n.addObserver(function(s, arg) { sum += (arg * s); });
    n.notifyAllObservers(2);
    this.assertEqual(6, sum);
    n.notifyAllObservers(3);
    this.assertEqual(15, sum);
    n.addObserver(function(s, arg) { sum += (arg - s); });
    n.notifyAllObservers(4);
    this.assertEqual(28, sum);
  });

});


});

avocado.transporter.module.onLoadCallbacks["core/graphs"] = function() {};
avocado.transporter.module.create('core/graphs', function(requires) {

requires('core/testFramework');
requires('core/collections/hash_table');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('graphs', {}, {category: ['graphs']});

});


thisModule.addSlots(avocado.graphs, function(add) {

  add.creator('directed', {});

  add.creator('tests', Object.create(avocado.testCase), {category: ['tests']});

});


thisModule.addSlots(avocado.graphs.directed, function(add) {

  add.method('create', function (roots, adjacencyFn) {
    return Object.newChildOf(this, roots, adjacencyFn);
  }, {category: ['creating']});

  add.method('initialize', function (roots, adjacencyFn) {
    this._roots = roots;
    this._adjacencyFn = adjacencyFn;
  }, {category: ['creating']});

  add.method('verticesPointedToBy', function (v) {
    return this._adjacencyFn(v);
  }, {category: ['accessing']});

  add.method('topologicalSort', function () {
    var sorted = [];
    var visited = avocado.set.copyRemoveAll();
    
    var visit = function (n) {
      if (! visited.includes(n)) {
        visited.add(n);
        this.verticesPointedToBy(n).each(function(m) {
          visit(m);
        });
        sorted.push(n);
      }
    }.bind(this);
            
    this._roots.each(function(r) { visit(r); });
    return sorted;
  }, {category: ['sorting']});

});


thisModule.addSlots(avocado.graphs.tests, function(add) {

  add.method('checkTopologicalSort', function (graph) {
    var sorted = graph.topologicalSort();
    for (var i = 0; i < sorted.length; ++i) {
      var v = sorted[i];
      var adj = graph.verticesPointedToBy(v);
      adj.each(function(adjV) {
        this.assert(sorted.indexOf(adjV) < i, "" + v + " should come before " + adjV);
      }.bind(this));
    }
  });

  add.method('testTopologicalSort', function () {
    var adjacencyLists = {
      a: ['b', 'c'],
      b: ['d'],
      c: ['d', 'e']
    };
    
    var graph = avocado.graphs.directed.create(['a'], function(v) { return adjacencyLists[v] || []; });
    this.checkTopologicalSort(graph);
  });

});


});

avocado.transporter.module.onLoadCallbacks["reflection/mirror"] = function() {};
avocado.transporter.module.create('reflection/mirror', function(requires) {

requires('core/collections/enumerator');
requires('core/identity_hash');
requires('core/testFramework');
requires('core/dom_stuff');
requires('core/naming');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('mirror', {}, {category: ['reflection']});

});


thisModule.addSlots(avocado.mirror, function(add) {

  add.method('initialize', function (o) {
    this._reflectee = o;
  }, {category: ['creating']});

  add.method('forObjectNamed', function (chainNames) {
    var obj = window;
    for (var i = 0; i < chainNames.length; ++i) {
      var slotName = chainNames[i];
      obj = obj[slotName];
      if (obj === undefined || obj === null) { return null; }
    }
    return reflect(obj);
  }, {category: ['creating']});

  add.method('reflectee', function () { return this._reflectee; }, {category: ['accessing reflectee']});

  add.method('equals', function (m) {
    if (!m) { return false; }
    if (this.reflectee !== m.reflectee) { return false; }
    return this.reflectee() === m.reflectee();
  }, {category: ['comparing']});

  add.method('hashCode', function () {
    try {
      return avocado.identityHashFor(this.reflectee());
    } catch (ex) {
      return "broken identity hash";
    }
  }, {category: ['comparing']});

  add.creator('namingScheme', Object.create(avocado.namingScheme), {category: ['naming']});

  add.method('reflecteeToString', function () {
    try {
      var o = this.reflectee();
      if (! this.canHaveSlots()) { return "" + o; }

      // Ignore the default toString because it just says [object Object] all the time and it's annoying.
      if (o.toString === Object.prototype.toString) { return ""; } 
      if (o.toString === window.toString) { return ""; } 
      
      return o.toString();
    } catch (ex) {
      return "";
    }
  }, {category: ['naming']});

  add.method('toString', function () {
    return this.inspect();
  }, {category: ['naming']});

  add.method('storeString', function () {
    // aaa - This is not a good long-term solution. The transporter should be able to handle mirrors.
    var expr = this.reflectee().storeString ? this.reflectee().storeString() : this.expressionEvaluatingToMe();
    return ["reflect(", expr, ")"].join("");
  }, {category: ['transporting']});

  add.method('isRootOfGlobalNamespace', function () {
    return this.reflectee() === window;
  }, {category: ['naming']});

  add.method('primitiveReflectee', function () {
    return this.reflectee();
  }, {category: ['accessing']});

  add.method('inspect', function () {
    var name = this.name();
    var desc = this.shortDescription();
    if (desc) {
      return [name, "(", desc, ")"].join("");
    } else {
      return name;
    }
  }, {category: ['naming']});

  add.method('fullName', function () {
    return this.name();
  }, {category: ['naming']});

  add.method('immediateName', function () {
    var cs = this.probableCreatorSlot();
    if (cs) { return cs.immediateName(); }
    return "";
  }, {category: ['naming']});

  add.method('shortDescription', function () {
    if (! this.canHaveSlots()) { return ""; }
    if (this.isReflecteeFunction()) { return ""; }
    
    var maxToStringLength = 40;
    var toString;
    if (this.isReflecteeArray()) {
      var len = this.reflecteeLength();
      toString = len.toString() + " elements";
      if (len <= 5) {
        var firstElems = "[" + avocado.range.create(0, len).map(function(i) { return this.contentsAt(i).inspect(); }.bind(this)).join(", ") + "]";
        if (firstElems.length < maxToStringLength) { toString = firstElems; }
      }
    } else {
      toString = this.reflecteeToString();
    }
    if (typeof toString === 'string' && toString.length < maxToStringLength) {
      return toString;
    }
    return "";
  }, {category: ['naming']});

  add.method('convertCreatorSlotChainToString', function (chain) {
    if (chain.length === 0) {return "";}
    var isThePrototype = chain[0].contents().equals(this);
    var s = avocado.stringBuffer.create(isThePrototype ? "" : chain[chain.length - 1].name().startsWithVowel() ? "an " : "a ");

    var sep = "";
    for (var i = chain.length - 1; i >= 0; i -= 1) {
      var n = chain[i].name();
      // HACK - Recognize class-like patterns and show names like "a WobulatorMorph" rather than "a WobulatorMorph.prototype",
      // because, well, that's really annoying. Not sure this is the right way to fix this. But the reality is that in JS code
      // it'll probably be common to have both class-like and prototype-like inheritance and naming patterns.
      if ((n !== 'prototype' && n !== '__proto__') || (i === 0 && (isThePrototype || chain.length === 1))) {
        s.append(sep).append(n);
      }
      sep = ".";
    }
    return s.toString();
  }, {category: ['naming']});

  add.method('name', function () {
    return this.nameWithinEnclosingObject(undefined);
  }, {category: ['naming']});

  add.method('nameWithinEnclosingObject', function (enclosingMirrorOrSlot) {
    if (this.isRootOfGlobalNamespace()) { return "window"; }
    if (! this.canHaveCreatorSlot()) {return Object.inspect(this.primitiveReflectee());}
    if (! this.canHaveSlots()) { return Object.inspect(this.primitiveReflectee()); }

    var chain = this.creatorSlotChainOfMeOrAnAncestor('probableCreatorSlot', enclosingMirrorOrSlot);

    // aaa - Not sure whether this is a hack or not. I don't like that we end up with morphs
    // named, for example, "WorldMorph.current.submorphs.3". So use the parent's chain instead.
    if (chain && chain.length > 0 && chain[0].isArrayIndex() && this.hasAccessibleParent()) {
      chain = this.parent().creatorSlotChainOfMeOrAnAncestor('probableCreatorSlot');
    }

    if (chain) {
      return this.convertCreatorSlotChainToString(chain);
    } else {
      return this.isReflecteeFunction() ? "a function" : this.isReflecteeArray() ? "an array" : "an object";
    }
  }, {category: ['naming']});

  add.method('hasMultiplePossibleNames', function () {
    // Someday we could have a mechanism for remembering arbitrary names.
    return this.hasMultiplePossibleCreatorSlots();
  }, {category: ['naming']});

  add.method('isWellKnown', function (kindOfCreatorSlot) {
    var chain = this.creatorSlotChain(kindOfCreatorSlot);
    return chain && (chain.length === 0 || chain[0].contents().equals(this));
  }, {category: ['testing']});

  add.method('isReflecteeProbablyAClass', function () {
    // Let's see whether this is a good enough test for now.
    var r = this.reflectee();
    if (r === Object || r === String || r === Function || r === Boolean || r === Array || r === Number) { return true; }
    if (this.isReflecteeFunction() && this.reflecteeHasOwnProperty('superclass')) { return true; }
    return false;
  }, {category: ['testing']});

  add.method('canSlotNameBeUsedAsJavascriptToken', function (n) {
    if (avocado.javascript.reservedWords[n]) { return false; }
    // aaa - What about Unicode?
    return /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(n);
  }, {category: ['testing']});

  add.method('creatorSlotChainExpression', function (kindOfCreatorSlot) {
    if (! this.canHaveCreatorSlot()) {throw this.inspect() + " cannot have a creator slot chain.";}
    return this.expressionForCreatorSlotChain(this.creatorSlotChain(kindOfCreatorSlot || 'probableCreatorSlot'));
  }, {category: ['annotations', 'creator slot']});

  add.method('expressionForCreatorSlotChain', function (chain) {
    if (! chain) {
      var err = new Error(this.name() + " does not have a creator slot chain");
      err.mirrorWithoutCreatorPath = this;
      err.objectsToShow = [this];
      throw err;
    }
    if (chain.length === 0) {return "window";}

    var s = avocado.stringBuffer.create();
    var sep = "";
    if (this.canSlotNameBeUsedAsJavascriptToken(chain[chain.length - 1].name())) {
      // don't need to say "window"
    } else {
      s.append("window");
      sep = ".";
    }
    
    for (var i = chain.length - 1; i >= 0; i -= 1) {
      var n = chain[i].name();
      if (this.canSlotNameBeUsedAsJavascriptToken(n)) {
        s.append(sep).append(n);
      } else {
        s.append('[').append(n.inspect()).append(']');
      }
      sep = ".";
    }
    return s.toString();
  }, {category: ['annotations', 'creator slot']});

  add.method('creatorSlotChain', function (kindOfCreatorSlot, stopAt) {
    if (! this.canHaveCreatorSlot()) {return null;}

    var chain = [];
    var mir = this;
    var cs;
    kindOfCreatorSlot = kindOfCreatorSlot || 'explicitlySpecifiedCreatorSlot';
    var windowMirror = reflect(window);
    var stopAtMirror, stopAtSlot;
    if (stopAt) {
      if (Object.inheritsFrom(avocado.mirror, stopAt)) {
        stopAtMirror = stopAt;
      } else {
        stopAtSlot = stopAt;
      }
    }

    for (var i = 0; true; ++i) {
      if (mir.equals(windowMirror)) { return chain; }
      if (stopAtMirror && mir.equals(stopAtMirror)) { return chain; }
      cs = mir[kindOfCreatorSlot].call(mir);
      if (! cs) { return null; }
      if (! cs.contents().equals(mir)) { return null; } // probably obsolete or something
      if (stopAtSlot && cs.equals(stopAtSlot)) { return chain; }
      chain.push(cs);
      if (i >= 100) {
        console.log("WARNING: Really long (" + i + " so far) chain of creator slots; giving up because it's probably a loop. " +
                    "Here it is so far, starting from the end: " + chain.map(function(s) { return s.name(); }).join(", "));
        return null;
      }
      mir = cs.holder();
    }
  }, {category: ['annotations', 'creator slot']});

  add.method('creatorSlotChainOfMeOrAnAncestor', function (kindOfCreatorSlot, stopAt) {
    var mir = this;
    while (true) {
      var chain = mir.creatorSlotChain(kindOfCreatorSlot, stopAt);
      if (chain) { return chain; }
      if (! mir.hasAccessibleParent()) { return null; }
      mir = mir.parent();
    }
  }, {category: ['annotations', 'creator slot']});

  add.method('alreadyContainsSlotWithNameAndContents', function (name, contents) {
    return this.slotAt(name).contents().equals(contents);
  }, {category: ['testing']});

  add.method('eachSlot', function (f) {
    this.eachFakeSlot(f);
    this.eachNormalSlot(f);
  }, {category: ['iterating']});

  add.method('slots', function () {
    return avocado.enumerator.create(this, 'eachSlot');
  }, {category: ['iterating']});

  add.method('eachFakeSlot', function (f) {
    if (this.isReflecteeFunction()) { f(this.functionBodySlot()); }
    
    // I think we don't want this here anymore, because we're putting the parent slot right
    // into the object's header. This may be the wrong place to fix it, though.
    // if (this.hasAccessibleParent()) { f(this.      parentSlot()); }
  }, {category: ['iterating']});

  add.method('functionBodySlot', function () {
    return Object.create(avocado.slots.functionBody).initialize(this);
  }, {category: ['functions']});

  add.method('parentSlot', function () {
    return Object.create(avocado.slots.parent).initialize(this);
  }, {category: ['accessing parent']});

  add.method('eachNormalSlot', function (f) {
    this.normalSlotNames().each(function(n) { f(this.slotAt(n)); }.bind(this));
  }, {category: ['iterating']});

  add.method('normalSlots', function () {
    return this.normalSlotNames().map(function(n) { return this.slotAt(n); }.bind(this));
  }, {category: ['iterating']});

  add.method('eachNormalSlotName', function (f) {
    if (! this.canHaveSlots()) {return;}
    var o = this.reflectee();
    if (typeof(o.hasOwnProperty) === 'function') {
      for (var name in o) {
        if (o.hasOwnProperty(name)) {
          if (name !== '__annotation__') { // shh! pretend it's not there.
            f(name);
          }
        }
      }

      // Workaround for Chrome bug. -- Adam
      if (! avocado.javascript.prototypeAttributeIsEnumerable) {
        if (o.hasOwnProperty("prototype")) {
          f("prototype");
        }
      }
    }
  }, {category: ['iterating']});

  add.method('normalSlotNames', function () {
    return avocado.enumerator.create(this, 'eachNormalSlotName');
  }, {category: ['iterating']});

  add.method('normalNonCopiedDownSlots', function () {
    return this.normalSlots().select(function(s) { return ! s.isFromACopyDownParent(); });
  }, {category: ['iterating']});

  add.method('canHaveIndexableSlots', function () {
    return this.isReflecteeArray() || this.isReflecteeDOMNode();
  }, {category: ['testing']});

  add.method('eachIndexableSlot', function (f) {
    if (this.isReflecteeArray()) {
      for (var i = 0, n = this.reflecteeLength(); i < n; ++i) {
        f(this.slotAt(i.toString()));
      }
    } else {
      // I'm not completely sure it makes sense to treat DOM nodes as indexable, but
      // for now let's try it. -- Adam, March 2011
      this.eachDOMChildNode(f);
    }
  }, {category: ['iterating']});

  add.method('eachDOMChildNode', function (f) {
    if (this.isReflecteeDOMNode()) {
      var parentNode = this.reflectee();
      var childNodes = parentNode.childNodes;
      for (var i = 0, n = childNodes.length; i < n; ++i) {
        f(avocado.slots.domChildNode.create(this, "childnode" + i, reflect(childNodes[i])));
      }
    }
  }, {category: ['iterating']});

  add.method('indexableSlots', function () {
    return avocado.enumerator.create(this, 'eachIndexableSlot');
  }, {category: ['iterating']});

  add.method('category', function (parts) {
    // aaa shouldn't need this test after I'm done refactoring to eliminate the raw category objects
    return avocado.category.ofAParticularMirror.create(this, parts.parts ? parts.parts() : parts);
  }, {category: ['categories']});

  add.method('rootCategory', function () {
    return this.category([]);
  }, {category: ['categories']});

  add.method('updateCategoryCache', function () {
    // This is the old slow way. The problem is that slots can be added to the object
    // (e.g. by doing "obj.x = 3") without there being any way for the category
    // cache to know about it. Also, since slots can now inherit their category from
    // a parent, even slots in a non-root category might not have their category
    // stored correctly in this object's category cache. So this method can be used
    // to make sure that this object's category cache is up-to-date.
    
    var anno;
    this.normalSlots().each(function(s) {
      var c = s.category();
      anno = anno || this.annotationForWriting();
      var catCache = anno.getCategoryCache(c.parts());
      catCache.addSlotName(s.name());
    }.bind(this));
  }, {category: ['categories']});

  add.method('updateCategoryCacheIfOlderThan', function (maxStalenessInMilliseconds) {
    var now;
    if (!this._categoryCacheTimestamp || (now = new Date().getTime()) - this._categoryCacheTimestamp > maxStalenessInMilliseconds) {
      this._categoryCacheTimestamp = now;
      this.updateCategoryCache();
    }
  }, {category: ['categories']});

  add.method('possiblyStaleSlotsInCategory', function (c) {
    var anno = this.annotationForReading();
    if (!anno) { return []; }
    var catCache = anno.getCategoryCache(c.parts());
    var thisMirror = this;
    var slots = [];
    catCache.eachSlotName(function(n) {
      if (thisMirror.reflecteeHasOwnProperty(n)) {
        slots.push(thisMirror.slotAt(n));
      }
    });
    return slots;
  }, {category: ['iterating']});

  add.method('possiblyStaleSlotsNestedSomewhereUnderCategory', function (c) {
    // aaa old way, remove this once the new way works:
    // return this.normalSlots().select(function(s) { return s.category().isEqualToOrSubcategoryOf(c); });
    return avocado.enumerator.create(this, 'possiblyStaleEachSlotNestedSomewhereUnderCategory', c);
  }, {category: ['iterating']});

  add.method('possiblyStaleEachSlotNestedSomewhereUnderCategory', function (c, f) {
    if (c.isRoot()) {
      this.eachNormalSlot(f);
    } else {
      this.possiblyStaleSlotsInCategory(c).each(f);
      this.eachImmediateSubcategoryOf(c, function(subcat) {
        this.possiblyStaleEachSlotNestedSomewhereUnderCategory(subcat, f);
      }.bind(this));
    }
  }, {category: ['iterating']});

  add.method('eachImmediateSubcategoryOf', function (c, f) {
    var anno = this.annotationForReading();
    if (!anno) { return; }
    var catCache = anno.getCategoryCache(c.parts());
    catCache.eachSubcategoryName(function(n) {
      f(c.subcategory(n));
    });
  }, {category: ['iterating']});

  add.method('immediateSubcategoriesOf', function (c) {
    return avocado.enumerator.create(this, 'eachImmediateSubcategoryOf', c);
  }, {category: ['iterating']});

  add.method('slotAt', function (n) {
    if (n === '__proto__') { return this.parentSlot(); }
    return Object.create(avocado.slots.plain).initialize(this, n.toString());
  }, {category: ['accessing slot contents']});

  add.method('contentsAt', function (n) {
    return reflect(this.primitiveContentsAt(n));
  }, {category: ['accessing slot contents']});

  add.method('setContentsAt', function (n, mir) {
    return this.primitiveSetContentsAt(n, mir.reflectee());
  }, {category: ['accessing slot contents']});

  add.method('primitiveContentsAt', function (n) {
    return this.reflectee()[n];
  }, {category: ['accessing slot contents']});

  add.method('primitiveSetContentsAt', function (n, o) {
    this.reflectee()[n] = o;
    return o;
  }, {category: ['accessing slot contents']});

  add.method('removeSlotAt', function (n) {
    delete this.reflectee()[n];
  }, {category: ['accessing slot contents']});

  add.method('findUnusedSlotName', function (prefix) {
    if (! this.canHaveSlots()) { throw this.name() + " cannot have slots"; }
    var pre = prefix || "slot";
    var i = 0;
    var name;
    do {
      i += 1;
      name = pre + i;
    } while (this.reflecteeHasOwnProperty(name));
    return name;
  }, {category: ['accessing slot contents']});

  add.method('reflecteeHasOwnProperty', function (n) {
    if (! this.canHaveSlots()) { return false; }
    return this.reflecteeObjectHasOwnProperty(n);
  }, {category: ['accessing reflectee']});

  add.method('reflecteeObjectHasOwnProperty', function (n) {
    var o = this.reflectee();
    return typeof(o.hasOwnProperty) === 'function' && o.hasOwnProperty(n);
  }, {category: ['accessing reflectee']});

  add.method('parent', function () {
    if (! this.canAccessParent()) { throw "Sorry, you can't access an object's parent in this browser. Try Firefox or Safari."; }
    if (! this.hasParent()) { throw this.name() + " does not have a parent."; }
    return this.contentsAt('__proto__');
  }, {category: ['accessing parent']});

  add.method('parentOrNull', function () {
    if (! this.canAccessParent()) { return null; }
    if (! this.hasParent()) { return null; }
    return this.contentsAt('__proto__');
  }, {category: ['accessing parent']});

  add.method('eachAncestorIncludingMeButNotIncludingNull', function (f) {
    var m = this;
    while (m) {
      f(m);
      m = m.parentOrNull();
      if (m && m.isReflecteeNull()) { m = null; }
    }
  }, {category: ['accessing parent']});

  add.method('meAndAncestors', function () {
    return avocado.enumerator.create(this, 'eachAncestorIncludingMeButNotIncludingNull');
  }, {category: ['accessing parent']});

  add.method('canAccessParent', function () {
    return String.prototype['__proto__'] !== undefined; // using [] to fool JSLint;
  }, {category: ['accessing parent']});

  add.method('hasParent', function () { return ! (this.isReflecteeNull() || this.isReflecteeUndefined()); }, {category: ['accessing parent']});

  add.method('hasAccessibleParent', function () { return this.canAccessParent() && this.hasParent(); }, {category: ['accessing parent']});

  add.method('setParent', function (pMir) {
    if (! this.canAccessParent()) { throw "Sorry, you can't change an object's parent in this browser. Try Firefox or Safari."; }
    this.setContentsAt('__proto__', pMir);
  }, {category: ['accessing parent']});

  add.method('createChild', function () {
    return reflect(Object.create(this.reflectee()));
  }, {category: ['children']});

  add.method('createSubclass', function () {
    var subclass = reflect(this.reflectee().subclass());
    subclass.slotAt('prototype').beCreator();
    return subclass;
  }, {category: ['children']});

  add.method('interposeNewParent', function () {
    var p = this.parent().createChild();
    this.setParent(p);
    this.parentSlot().beCreator();
    return p;
  }, {category: ['children']});

  add.method('addData', function (slotName, slotContents) {
    var s = this.slotAt(slotName);
    s.setContents(reflect(slotContents));
    return s;
  }, {category: ['shortcuts']});

  add.method('addCreator', function (slotName, slotContents) {
    var s = this.addData(slotName, slotContents);
    s.beCreator();
    return s;
  }, {category: ['shortcuts']});

  add.method('addMethod', function (slotName, slotContents) {
    this.addCreator(slotName, slotContents);
  }, {category: ['shortcuts']});

  add.method('source', function () {
    if (! this.isReflecteeFunction()) { throw "not a function"; }
    return this.reflecteeToString();
  }, {category: ['functions']});

  add.method('expressionEvaluatingToMe', function (shouldNotUseCreatorSlotChainExpression) {
    if (! this.canHaveCreatorSlot()) { return Object.inspect(this.reflectee()); }
    if (!shouldNotUseCreatorSlotChainExpression && this.isWellKnown('probableCreatorSlot')) { return this.creatorSlotChainExpression(); }
    if (this.isReflecteeFunction()) { return this.source(); }
    if (this.isReflecteeArray()) { return "[" + avocado.range.create(0, this.reflecteeLength()).map(function(i) {return this.contentsAt(i).expressionEvaluatingToMe();}.bind(this)).join(", ") + "]"; }

    // aaa not thread-safe
    if (this.reflectee().__already_calculating_expressionEvaluatingToMe__) { throw "encountered circular structure"; }
    try {
      this.reflectee().__already_calculating_expressionEvaluatingToMe__ = true;

      var str = avocado.stringBuffer.create("{");
      var sep = "";
      this.normalSlots().each(function(slot) {
        if (slot.name() !== '__already_calculating_expressionEvaluatingToMe__') {
          str.append(sep).append(slot.name()).append(": ").append(slot.contents().expressionEvaluatingToMe());
          sep = ", ";
        }
      });
      str.append("}");
    } finally {
      delete this.reflectee().__already_calculating_expressionEvaluatingToMe__;
    }

    return str.toString();

    // aaa - try something like Self's 1 _AsObject, except of course in JS it'll have to be a hack;
  }, {category: ['naming']});

  add.method('reflecteeStoreString', function () {
    if (! this.canHaveSlots()) { return null; }
    if (! avocado.transporter.canUseStoreStringToTransportObject(this.reflectee())) { return null; }
    return this.reflectee().storeString();
  }, {category: ['transporting']});

  add.method('size', function () {
    return this.normalSlots().size();
  }, {category: ['accessing slot contents']});

  add.method('reflecteeType', function () {
    return typeof(this.reflectee());
  }, {category: ['accessing']});

  add.method('canHaveSlots', function () {
    var t = this.reflecteeType();
    return t === 'function' || (t === 'object' && ! this.isReflecteeNull());
  }, {category: ['accessing slot contents']});

  add.method('canHaveChildren', function () {
    // aaa - Is this correct? I think maybe inheriting from arrays doesn't work so well in some browsers.
    var o = this.reflectee();
    var t = typeof o;
    return t === 'function' || (t === 'object' && o !== null);
  }, {category: ['children']});

  add.method('isReflecteeNull', function () { return this.reflectee() === null;      }, {category: ['testing']});

  add.method('isReflecteeUndefined', function () { return this.reflecteeType() === 'undefined'; }, {category: ['testing']});

  add.method('isReflecteeString', function () { return this.reflecteeType() === 'string';  }, {category: ['testing']});

  add.method('isReflecteeNumber', function () { return this.reflecteeType() === 'number';  }, {category: ['testing']});

  add.method('isReflecteeBoolean', function () { return this.reflecteeType() === 'boolean'; }, {category: ['testing']});

  add.method('isReflecteeArray', function () { return this.reflecteeType() === 'object' && this.reflectee() instanceof Array; }, {category: ['testing']});

  add.method('isReflecteeFunction', function () {
    return this.reflecteeType() === 'function';
  }, {category: ['testing']});

  add.method('isReflecteeSimpleMethod', function () {
    if (! this.isReflecteeFunction()) {return false;}

    var LK_slotNamesAttachedToMethods = ['declaredClass', 'methodName', 'displayName', '_creatorSlotHolder'];
    var LK_slotNamesUsedForMakingSuperWork = ['valueOf', 'toString', 'originalFunction'];

    var hasSuper = this.reflectee().argumentNames && this.reflectee().argumentNames().first() === '$super';

    var nonTrivialSlot = this.normalSlots().find(function(s) {
      if (            LK_slotNamesAttachedToMethods.include(s.name())) {return false;}
      if (hasSuper && LK_slotNamesUsedForMakingSuperWork .include(s.name())) {return false;}
        
      // Firefox seems to have a 'prototype' slot on every function (whereas Safari is lazier about it). I think.
      if (s.name() === 'prototype') {
        var proto = s.contents();
        return ! (proto.size() === 0 && proto.parent().reflectee() === Object.prototype);
      }
      
      return true;
    });
    return ! nonTrivialSlot;
  }, {category: ['testing']});

  add.method('reflecteeRemoteReference', function () {
    var anno = this.annotationForReading();
    if (!anno) { return null; }
    return anno.getRemoteRef();
  }, {category: ['testing']});

  add.method('isReflecteeDOMNode', function () {
    return avocado.DOMStuff.isDOMNode(this.reflectee());
  }, {category: ['testing']});

  add.method('reflecteeLength', function () {
    return this.primitiveContentsAt('length');
  }, {category: ['arrays']});

  add.method('canHaveCreatorSlot', function () {
    return this.canHaveSlots();
  }, {category: ['annotations', 'creator slot']});

  add.method('convertAnnotationCreatorSlotToRealSlot', function (s) {
    return s ? reflect(s.holder).slotAt(s.name) : null;
  }, {category: ['annotations', 'creator slot']});

  add.method('probableCreatorSlot', function () {
    if (! this.canHaveCreatorSlot()) { return null; }
    var a = this.annotationForReading();
    if (!a) { return null; }
    return this.convertAnnotationCreatorSlotToRealSlot(a.probableCreatorSlot());
  }, {category: ['annotations', 'creator slot']});

  add.method('possibleCreatorSlots', function () {
    if (! this.canHaveCreatorSlot()) { return []; }
    var a = this.annotationForReading();
    if (!a) { return []; }
    return a.arrayOfPossibleCreatorSlots().map(function(s) { return this.convertAnnotationCreatorSlotToRealSlot(s); }.bind(this));
  }, {category: ['annotations', 'creator slot']});

  add.method('creatorSlotChainLength', function () {
    return avocado.annotator.creatorChainLength(this.reflectee());
  }, {category: ['annotations', 'creator slot']});

  add.method('hasMultiplePossibleCreatorSlots', function () {
    if (! this.canHaveCreatorSlot()) { return false; }
    var a = this.annotationForReading();
    if (!a) { return false; }
    return a.numberOfPossibleCreatorSlots() > 1;
  }, {category: ['annotations', 'creator slot']});

  add.method('possibleCreatorSlotsSortedByLikelihood', function () {
    var explicitOne = this.explicitlySpecifiedCreatorSlot();
    
    return this.possibleCreatorSlots().sortBy(function(s) {
      if (explicitOne && explicitOne.equals(s)) { return -1; }
      var chainLength = s.holder().creatorSlotChainLength();
      if (typeof(chainLength) !== 'number') { return 1000000; }
      return chainLength;
    });
  }, {category: ['annotations', 'creator slot']});

  add.method('theCreatorSlot', function () {
    if (! this.canHaveCreatorSlot()) { return null; }
    var a = this.annotationForReading();
    if (!a) { return null; }
    return this.convertAnnotationCreatorSlotToRealSlot(a.theCreatorSlot());
  }, {category: ['annotations', 'creator slot']});

  add.method('explicitlySpecifiedCreatorSlot', function () {
    if (! this.canHaveCreatorSlot()) { return null; }
    var a = this.annotationForReading();
    if (! a) { return null; }
    return this.convertAnnotationCreatorSlotToRealSlot(a.explicitlySpecifiedCreatorSlot());
  }, {category: ['annotations', 'creator slot']});

  add.method('setCreatorSlot', function (s) {
    if (s) {
      this.annotationForWriting().setCreatorSlot(s.name(), s.holder().reflectee());
    } else {
      this.annotationForWriting().setCreatorSlot(undefined, undefined);
    }
  }, {category: ['annotations', 'creator slot']});

  add.method('addPossibleCreatorSlot', function (s) {
    this.annotationForWriting().addPossibleCreatorSlot(s.name(), s.holder().reflectee());
  }, {category: ['annotations', 'creator slot']});

  add.method('comment', function () {
    return avocado.organization.current.commentForReflecteeOf(this);
  }, {category: ['annotations', 'comment']});

  add.method('setComment', function (c) {
    avocado.organization.current.setCommentForReflecteeOf(this, c);
  }, {category: ['annotations', 'comment']});

  add.method('copyDownParents', function () {
    var a = this.annotationForReading();
    if (! a) { return []; }
    return a.copyDownParents || [];
  }, {category: ['annotations', 'copy-down parents']});

  add.method('setCopyDownParents', function (cdps) {
    this.markCreatorModuleAsChanged();
    // aaa - Of course, we should be removing slots copied in by the previous list of copy-down parents. But never mind that for now.
    var cdpsMir = reflect(cdps);
    if (! cdpsMir.isReflecteeArray()) { throw "Must be an array; e.g. [{parent: Enumerable}]"; }
    var a = this.annotationForWriting();
    a.copyDownParents = cdps;
    a.copyDownSlotsFromAllCopyDownParents(this.reflectee());
  }, {category: ['annotations', 'copy-down parents']});

  add.method('markCreatorModuleAsChanged', function () {
    var cs = this.theCreatorSlot();
    if (cs) { cs.markModuleAsChanged(); }
  }, {category: ['annotations', 'module']});

  add.method('setModuleRecursively', function (m) {
    this.normalSlots().each(function(slot) { slot.setModuleRecursively(m); });
    
    var ps = this.parentSlot();
    var p = ps.contents();
    if (ps.equals(p.theCreatorSlot())) {
      p.setModuleRecursively(m);
    }
  }, {category: ['annotations', 'module']});

  add.method('slotsInModuleNamed', function (moduleName) {
    var filterizer = avocado.slots['abstract'].filterizer.create().excludeCopyDowns();
    if (moduleName === '-' || !moduleName) { filterizer.excludeSlotsAlreadyAssignedToAModule(); }
    else if (typeof(moduleName) === 'string') { filterizer.excludeSlotsNotInModuleNamed(moduleName); }
    
    return this.normalSlots().select(function(slot) { return filterizer.matchesSlot(slot); });
  }, {category: ['annotations', 'module']});

  add.method('getModuleAssignedToMeImplicitly', function () {
    // For now, only implicit. Later, maybe we'll want a mechanism for explicitly
    // saying "the slots on this object should belong to module M." But maybe not.
    // Maybe it'll be enough that we can set it for the object's creator slot.
    // -- Adam, June 2011
    var cs = this.probableCreatorSlot();
    if (cs && this.equals(cs.contents())) { return cs.getModuleAssignedToMeExplicitlyOrImplicitly(); }
    return undefined;
  }, {category: ['annotations', 'module']});

  add.method('modules', function () {
    var modules = [];
    var implicitModule = this.getModuleAssignedToMeImplicitly();
    this.normalNonCopiedDownSlots().each(function(s) {
      var m = s.getModuleAssignedToMeExplicitly();
      if (!m) { m = implicitModule; }
      if (! modules.include(m)) { modules.push(m); }
    });
    return modules.sort();
  }, {category: ['annotations', 'module']});

  add.method('getParent', function (evt) {
    avocado.ui.grab(this.parent(), evt);
  }, {category: ['menu']});

  add.method('chooseSourceModule', function (caption, callback, evt) {
    var which = avocado.command.list.create();
    which.addItem(["All", function(evt) {callback({}, evt);}]);
    which.addLine();
    this.modules().map(function(m) { return m ? m.name() : '-'; }).sort().each(function(moduleName) {
      which.addItem([moduleName, function(evt) {callback(moduleName, evt);}]);
    });
    avocado.ui.showMenu(which, this, caption, evt);
  }, {category: ['user interface', 'setting modules']});

  add.method('likelyModules', function () {
    return this.modules();
  }, {category: ['user interface', 'setting modules']});

  add.creator('sourceModulePrompter', {}, {category: ['user interface', 'setting modules']});

  add.method('chooseAmongPossibleCreatorSlotChains', function (callback, evt) {
    var akaMenu = avocado.command.list.create();
    this.possibleCreatorSlotsSortedByLikelihood().each(function(s) {
      var chain = s.creatorSlotChainEndingWithMe('theCreatorSlot');
      if (chain) {
        var chainName = this.convertCreatorSlotChainToString(chain);
        akaMenu.addItem([chainName, function(evt) {
          s.beCreator();
          avocado.ui.justChanged(this, null, evt);
          if (callback) { callback(); }
        }.bind(this)]);
      }
    }.bind(this));
    avocado.ui.showMenu(akaMenu, this, "Other possible names:", evt);
  }, {category: ['user interface', 'creator slots']});

  add.method('automaticallyChooseDefaultNameAndAddNewSlot', function (initialContentsMir, cat) {
    var name = this.findUnusedSlotName(initialContentsMir.isReflecteeFunction() ? "function" : "attribute");
    var s = this.slotAt(name);
    s.setContents(initialContentsMir);
    if (cat) { s.setCategory(cat); }
    if (initialContentsMir.isReflecteeFunction()) { s.beCreator(); }

    // aaa - UI-related, but hopefully not a problem
    avocado.ui.currentWorld().morphFor(s).wasJustAdded(Event.createFake());
    if (cat) { avocado.ui.justChangedContent(cat); }
    
    return s;
  }, {category: ['user interface', 'slots']});

  add.method('shouldAllowModification', function () {
    return !window.isInCodeOrganizingMode;
  }, {category: ['user interface']});

  add.method('deepCopyOfReflecteeRecursingIntoCreatorSlots', function () {
    return reflect(Object.deepCopyRecursingIntoCreatorSlots(this.reflectee()));
  }, {category: ['user interface']});

  add.method('eachAssociatedObject', function (f) {
    f(this.reflectee());
  }, {category: ['associated objects']});

  add.method('commands', function () {
    var cmdList = avocado.command.list.create(this);

    if (this.canHaveAnnotation()) {
      cmdList.addLine();

      if (this.shouldAllowModification()) {
        cmdList.addItem(avocado.command.create("set module", function(evt, slotsToReassign, targetModule) {
          slotsToReassign.each(function(slot) { slot.setModule(targetModule); });
        }).setArgumentSpecs([
          avocado.command.argumentSpec.create("Of which slots?").onlyAcceptsType(avocado.types.collection.of(avocado.slots['abstract'])).setPrompter(avocado.mirror.sourceModulePrompter),
          avocado.command.argumentSpec.create("To which module?").onlyAcceptsType(avocado.transporter.module)
        ]));
      }
    }

    cmdList.addLine();

    cmdList.addItem(["find", [
      avocado.command.create("well-known references", function(evt) {
        avocado.ui.grab(avocado.searchResultsPresenter.create(avocado.objectGraphWalker.visitors.referenceFinder.create(this.reflectee()).createWalker(), evt)).redo();
      }, this),
      avocado.command.create("well-known children", function(evt) {
        avocado.ui.showObjects(this.wellKnownChildren().map(reflect), "well-known children of " + this.name(), evt);
      }, this)
    ]]);
    
    cmdList.addLine();

    cmdList.addItem(avocado.command.create("duplicate", function(evt) {
      avocado.ui.grab(this.deepCopyOfReflecteeRecursingIntoCreatorSlots(), evt);
    }, this));
    
    if (this.shouldAllowModification()) {
      var creationCommands = [];
      if (this.canHaveChildren()) {
        creationCommands.push(avocado.command.create("create child", function(evt) { this.createAndShowChild(evt); }, this));
      }

      if (this.isReflecteeProbablyAClass()) {
        creationCommands.push(avocado.command.create("create subclass", function(evt) { this.createAndShowSubclass(evt); }, this));
      }

      if (this.hasAccessibleParent()) {
        creationCommands.push(avocado.command.create("interpose new parent", function(evt) { this.interposeAndShowNewParent(evt); }, this));
      }

      if (creationCommands.length > 0) {
        cmdList.addItem(avocado.command.create("create", creationCommands));
      }
    }

    cmdList.addLine();
    
    cmdList.addItem(avocado.command.create("show inheritance hierarchy", function(evt) {
      this.showInheritanceHierarchy(evt);
    }));
    
    return cmdList;
  }, {category: ['user interface', 'commands']});

  add.method('createAndShowChild', function (evt) {
    var world = avocado.ui.worldFor(evt);
    var child = this.createChild();
    var childMirMorph = world.morphFor(child);
    
    // might as well show the arrow from the child to the parent

    evt.hand.world().addMorphAt(childMirMorph, pt(-1000, -1000));
    childMirMorph.assumeUIState({isExpanded: true}, function() {
      childMirMorph.growFromNothing(evt, function() {
        childMirMorph.assumeUIState({isAnnotationOpen: true}, function() {
          var parentSlotMorph = world.morphFor(child.parentSlot());
          parentSlotMorph.assumeUIState({isArrowVisible: true});
        }, evt);
      });
    }, evt);
  }, {category: ['user interface', 'commands']});

  add.method('createAndShowSubclass', function (evt) {
    var subclass = this.createSubclass();
    var subclassMirMorph = avocado.ui.grab(subclass, evt);

    // might as well show the arrow from the subclass to the superclass
    subclassMirMorph.assumeUIState({isExpanded: true}, function() {
      var superclassSlotMorph = avocado.ui.currentWorld().morphFor(subclass.slotAt('superclass'));
      superclassSlotMorph.assumeUIState({isArrowVisible: true});
    }, evt);
  }, {category: ['user interface', 'commands']});

  add.method('interposeAndShowNewParent', function (evt) {
    var world = avocado.ui.worldFor(evt);
    var oldParent = this.parent();
    var newParent = oldParent.createChild();
    var oldParentMorph  = world.morphFor(oldParent);
    var newParentMorph  = world.morphFor(newParent);
    var thisMirrorMorph = world.morphFor(this);
    
    oldParentMorph.ensureIsInWorld(world, thisMirrorMorph.getPosition().addXY(0, -150), false, false, false, function() {
      world.addMorphAt(newParentMorph, pt(-1000, -1000));
      thisMirrorMorph.assumeUIState({isExpanded: true}, null, evt);
       newParentMorph.assumeUIState({isExpanded: true}, null, evt);
      newParentMorph.growFromNothingAt(thisMirrorMorph.getPosition().midPt(oldParentMorph.getPosition()).addPt(newParentMorph.getExtent().scaleBy(0.5)), function() {
        this.setParent(newParent);
        this.parentSlot().beCreator();
        newParentMorph.refreshContentOfMeAndSubmorphs(); // just so that the proper name shows up immediately
        
        newParentMorph._annotationToggler.beOn(evt);
        //newParentMorph.assumeUIState({isAnnotationOpen: true}, function() {
          world.morphFor(newParent.parentSlot()).assumeUIState({isArrowVisible: true});
        //}, evt);
        
        thisMirrorMorph._annotationToggler.beOn(evt);
        //thisMirrorMorph.assumeUIState({isAnnotationOpen: true}, function() {
          world.morphFor(this.parentSlot()).assumeUIState({isArrowVisible: true});
        //}.bind(this), evt);
      }.bind(this));
    }.bind(this));
  }, {category: ['user interface', 'commands']});

  add.method('showCreatorPath', function (evt, callWhenDone) {
    var world = avocado.ui.worldFor(evt);
    if (this.equals(reflect(window))) {
      var mirMorph = world.morphFor(this);
      mirMorph.ensureIsInWorld(world, pt(50,50), true, false, true, callWhenDone);
    } else {
      var creatorSlot = this.probableCreatorSlot();
      var mirMorphForCreator = world.morphFor(creatorSlot.holder());
      mirMorphForCreator.showCreatorPath(evt, function() {
        avocado.ui.ensureVisible(creatorSlot.category(), evt);
        world.morphFor(creatorSlot).assumeUIState({isArrowVisible: true}, callWhenDone);
      });
    }
  }, {category: ['user interface', 'commands']});

  add.method('showInheritanceHierarchy', function (evt, callWhenDone) {
    var w = evt.hand.world();
    var parentFunction = function(o) { return o.mirror().hasParent() ? w.morphFor(o.mirror().parent()) : null; };
    var childrenFunction = function(o) { return o.mirror().wellKnownChildren().map(function(child) { return w.morphFor(reflect(child)); }); };
    var pose = Object.newChildOf(avocado.poses.tree, this.inspect() + " inheritance tree", [w.morphFor(this)], parentFunction, childrenFunction);
    avocado.ui.poseManager(evt).assumePose(pose, undefined, callWhenDone);
  }, {category: ['user interface', 'commands']});

  add.method('canHaveAnnotation', function () {
    return this.canHaveSlots();
  }, {category: ['annotations']});

  add.method('hasAnnotation', function () {
    return !!this.annotationForReading();
  }, {category: ['annotations']});

  add.method('annotationForReading', function () {
    if (this._cachedAnnotation) { return this._cachedAnnotation; }
    if (! this.canHaveAnnotation()) { return null; }
    var a = this.getExistingAnnotation();
    if (a) { this._cachedAnnotation = a; }
    return a;
  }, {category: ['annotations']});

  add.method('getExistingAnnotation', function () {
    return avocado.annotator.existingAnnotationOf(this.reflectee());
  }, {category: ['annotations']});

  add.method('annotationForWriting', function () {
    if (this._cachedAnnotation) { return this._cachedAnnotation; }
    if (! this.canHaveAnnotation()) { throw this.name() + " cannot have an annotation"; }
    var a = avocado.annotator.annotationOf(this.reflectee());
    if (a) { this._cachedAnnotation = a; }
    return a;
  }, {category: ['annotations']});

  add.method('functionFromCodeString', function (__codeToRun__) {
    // JavaScript doesn't return the result of the last statement in a function,
    // so gotta try this a couple of ways. First see if the code is an expression,
    // then see if it's a sequence of statements. (Could do this more elegantly if
    // we had a JS parser handy, but for now we don't.)
    
    // first, get rid of any trailing semicolons (in case it's a single expression with a semicolon at the end)
    while (true) {
      __codeToRun__ = __codeToRun__.strip();
      if (! __codeToRun__.endsWith(';')) { break; }
      __codeToRun__ = __codeToRun__.substr(0, __codeToRun__.length - 1);
    }
    
    var __functionToRun__;
    try {
      // Try it as an expression first.
      __functionToRun__ = eval("//@ sourceURL=evaluator\n(function __evaluator__() { return (" + __codeToRun__ + "); })");
    } catch (e) {
      // Try it as a list of statements.
      // Also, put a 'return' after the last semicolon, to return the result of the last statement.
      // Oh, and make sure to put parentheses around the last statement, because if there's a 'return'
      // followed by a newline, JS's semicolon insertion "feature" will just assume that it doesn't
      // need to look at the stuff after the newline.
      var __lastSemicolon__ = __codeToRun__.lastIndexOf(';');
      __codeToRun__ = __codeToRun__.substr(0, __lastSemicolon__ + 1) + ' return (' + __codeToRun__.substr(__lastSemicolon__ + 1) + ')';
      __functionToRun__ = eval("//@ sourceURL=evaluator\n(function __evaluator__() { " + __codeToRun__ + " })");
    }
    
    return __functionToRun__;
  }, {category: ['evaluating']});

  add.method('evalCodeString', function (__codeToRun__) {
    return this.callFunction(this.functionFromCodeString(__codeToRun__));
  }, {category: ['evaluating']});

  add.method('callFunction', function (__functionToRun__) {
    return __functionToRun__.call(this.reflectee());
  }, {category: ['evaluating']});

  add.method('wellKnownChildren', function () {
    return avocado.objectGraphWalker.visitors.childFinder.create(this.reflectee()).createWalker().go();
  }, {category: ['searching']});

  add.method('wellKnownReferences', function () {
    return avocado.objectGraphWalker.visitors.referenceFinder.create(this.reflectee()).createWalker().go().toArray();
  }, {category: ['searching']});

  add.method('categorizeUncategorizedSlotsAlphabetically', function () {
    avocado.organizationUsingAnnotations.alphabeticallyCategorizeUncategorizedSlotsOf(this);
  }, {category: ['organizing']});

  add.creator('tests', Object.create(avocado.testCase), {category: ['tests']});

});


thisModule.addSlots(avocado.mirror.sourceModulePrompter, function(add) {

  add.method('prompt', function (caption, context, evt, callback) {
    context.chooseSourceModule(caption, function(sourceModuleName) {
      callback(context.slotsInModuleNamed(sourceModuleName));
    }, evt);
  }, {category: ['prompting']});

});


thisModule.addSlots(avocado.mirror.tests, function(add) {

  add.method('testEquality', function () {
    this.assertEqual(reflect(3), reflect(3), "number mirror");
    this.assertEqual(reflect(null), reflect(null), "null mirror");
    this.assertEqual(reflect("noodle"), reflect("noodle"), "string mirror");

    this.assert(! reflect(3).equals(reflect(4)), "number mirror inequality");
    this.assert(! reflect({}).equals(reflect({})), "object mirror inequality");
    this.assert(! reflect(3).equals(reflect({})), "object/number mirror inequality");
    this.assert(! reflect("noodle").equals(reflect("needle")), "string mirror inequality");
    this.assert(! reflect(null).equals(reflect(undefined)), "null/undefined mirror inequality");
  });

  add.method('checkCanHaveSlots', function (mir) {
    var obj = mir.reflectee();
    if (mir.canHaveSlots()) {
      obj.blah = 42;
      this.assert(obj.blah === 42);
    } else {
      var threw;
      try {
        obj.blah = 42;
      } catch (ex) {
        threw = ex;
      }
      if (threw) {
        // fine
      } else {
        this.assert(obj.blah === undefined, "JS doesn't complain when you assign to slots on numbers or strings; it just doesn't do anything");
      }
    }
  });

  add.method('testCanHaveSlots', function () {
    this.checkCanHaveSlots(reflect(null));
    this.checkCanHaveSlots(reflect(undefined));
    this.checkCanHaveSlots(reflect(42));
    this.checkCanHaveSlots(reflect(true));
    this.checkCanHaveSlots(reflect('null'));
    this.checkCanHaveSlots(reflect({}));
    this.checkCanHaveSlots(reflect([]));
    this.checkCanHaveSlots(reflect(function() {}));
  });

  add.method('testIsWellKnown', function () {
    this.assert(reflect(avocado.mirror).isWellKnown());
    this.assert(reflect(avocado.mirror.tests).isWellKnown());
    this.assert(! reflect({}).isWellKnown());

    // Try an object that has a creator slot, but isn't actually connected to
    // the window object by a whole chain of creator slots.
    window.argle = {bargle: {}};
    reflect(argle).slotAt('bargle').beCreator();
    this.assert(! reflect(argle).isWellKnown());
    this.assert(! reflect(argle.bargle).isWellKnown());
    delete window.argle;
  });

  add.method('testIsReflecteeProbablyAClass', function () {
    this.assert(reflect(Object).isReflecteeProbablyAClass());
    this.assert(reflect(Boolean).isReflecteeProbablyAClass());
    this.assert(! reflect(null).isReflecteeProbablyAClass());
    this.assert(! reflect(3).isReflecteeProbablyAClass());
    this.assert(! reflect({}).isReflecteeProbablyAClass());
    this.assert(! reflect(avocado.testCase).isReflecteeProbablyAClass());
    this.assert(! reflect(avocado.stringBuffer).isReflecteeProbablyAClass());
  });

  add.method('testSize', function () {
    avocado.organization.temporarilySetCurrent(avocado.organizationUsingAnnotations, function() {
      var mir = reflect({});
      this.assertEqual(0, mir.size());
      mir.setComment("Set a comment so that there's an annotation.");
      this.assertEqual(0, mir.size(), "annotation doesn't count");
      mir.slotAt('argle').setContents(reflect('whatever'));
      this.assertEqual(1, mir.size());
      mir.slotAt('bargle').setContents(reflect('bleh'));
      this.assertEqual(2, mir.size());
      mir.slotAt('argle').remove();
      this.assertEqual(1, mir.size());
    }.bind(this));
  });

  add.method('testRemovingSlots', function () {
    avocado.organization.temporarilySetCurrent(avocado.organizationUsingAnnotations, function() {
      var obj = {};
      var mir = reflect(obj);
      mir.slotAt('argle').setContents(reflect('whatever'));
      this.assertEqual("whatever", obj.argle);
      mir.slotAt('argle').setComment("make sure there's a slot annotation");
      this.assert(mir.slotAt('argle').annotationIfAny());
      mir.slotAt('argle').remove();
      this.assertEqual(undefined, obj.argle);
      this.assert(! mir.slotAt('argle').annotationIfAny());
    }.bind(this));
  });

  add.method('testRenamingSlots', function () {
    avocado.organization.temporarilySetCurrent(avocado.organizationUsingAnnotations, function() {
      var obj = {};
      var mir = reflect(obj);
      
      mir.slotAt('argle').setContents(reflect('whatever'));
      mir.slotAt('argle').setComment("the comment");
      this.assertEqual("whatever", obj.argle);
      this.assertEqual("the comment", mir.slotAt('argle').comment());
      
      mir.slotAt('argle').rename('bargle');
      this.assertEqual(undefined,  obj. argle);
      this.assertEqual(undefined, obj.argle);
      this.assertEqual("whatever", obj.bargle);
      this.assertEqual("",            mir.slotAt( 'argle').comment());
      this.assertEqual("the comment", mir.slotAt('bargle').comment());
      this.assert(! mir.slotAt( 'argle').annotationIfAny());
      this.assert(  mir.slotAt('bargle').annotationIfAny());
    }.bind(this));
  });

  add.method('testTypeTesting', function () {
    this.assert(  reflect(null     ).isReflecteeNull());
    this.assert(! reflect(undefined).isReflecteeNull());
    this.assert(! reflect(false    ).isReflecteeNull());
    this.assert(! reflect(''       ).isReflecteeNull());

    this.assert(  reflect(undefined).isReflecteeUndefined());
    this.assert(! reflect(null     ).isReflecteeUndefined());
    this.assert(! reflect(false    ).isReflecteeUndefined());
    this.assert(! reflect(0        ).isReflecteeUndefined());

    this.assert(  reflect(3   ).isReflecteeNumber());
    this.assert(  reflect(NaN ).isReflecteeNumber());
    this.assert(! reflect(null).isReflecteeNumber());
    this.assert(! reflect('3' ).isReflecteeNumber());

    this.assert(  reflect('3' ).isReflecteeString());
    this.assert(! reflect(null).isReflecteeString());
    this.assert(! reflect(3   ).isReflecteeString());
    this.assert(! reflect({}  ).isReflecteeString());

    this.assert(  reflect(true     ).isReflecteeBoolean());
    this.assert(  reflect(false    ).isReflecteeBoolean());
    this.assert(! reflect(null     ).isReflecteeBoolean());
    this.assert(! reflect(undefined).isReflecteeBoolean());
    this.assert(! reflect(3        ).isReflecteeBoolean());
    this.assert(! reflect({}       ).isReflecteeBoolean());

    this.assert(  reflect([]           ).isReflecteeArray());
    this.assert(  reflect([3]          ).isReflecteeArray());
    this.assert(! reflect({lalala: 54} ).isReflecteeArray());
    this.assert(! reflect('hmm'        ).isReflecteeArray());
    this.assert(! reflect(function() {}).isReflecteeArray());
    this.assert(! reflect(null         ).isReflecteeArray());
    this.assert(! reflect(3            ).isReflecteeArray());
    this.assert(! reflect(true         ).isReflecteeArray());

    this.assert(  reflect(function() {}).isReflecteeFunction());
    this.assert(  reflect(exitValueOf  ).isReflecteeFunction());
    this.assert(! reflect({}           ).isReflecteeFunction());
    this.assert(! reflect('hmm'        ).isReflecteeFunction());
    this.assert(! reflect(null         ).isReflecteeFunction());

    this.assert(  reflect(function() {     }        ).isReflecteeSimpleMethod());
    this.assert(  reflect(function() {ok();}        ).isReflecteeSimpleMethod());
    this.assert(  reflect(this.setUp                ).isReflecteeSimpleMethod(), "methods with $super still count");
    this.assert(! reflect(exitValueOf               ).isReflecteeSimpleMethod());
    this.assert(! reflect({}                        ).isReflecteeSimpleMethod());
    this.assert(! reflect('hmm'                     ).isReflecteeSimpleMethod());
    this.assert(! reflect(null                      ).isReflecteeSimpleMethod());

    var functionWithASlot = function() {};
    functionWithASlot.something = 41;
    this.assert(! reflect(functionWithASlot).isReflecteeSimpleMethod());
  });

  add.method('setUp', function ($super) {
    // This method is just here so that I can make sure that methods that
    // call $super still respond with true to isReflecteeSimpleMethod().
    return $super();
  });

  add.method('createNestedClasses', function (f) {
    Object.subclass("Argle", {});
    Object.subclass("Argle.prototype.Bargle", {});
    reflect(window).slotAt( 'Argle').beCreator();
    reflect(Argle).slotAt('prototype').beCreator();
    reflect(Argle.prototype).slotAt('Bargle').beCreator();
    reflect(Argle.prototype.Bargle).slotAt('prototype').beCreator();
    try {
      f();
    } finally {
      reflect(window).slotAt('Argle').remove();
    }
  });

  add.method('testNaming', function () {
    this.assertEqual("3", reflect(3).name());
    this.assertEqual("null", reflect(null).name());
    this.assertEqual("undefined", reflect(undefined).name());
    this.assertEqual("'lalala'", reflect("lalala").name());
    this.assertEqual("a Function", reflect(function() {}).name());
    this.assertEqual("an Object", reflect({}).name());
    this.assertEqual("an Array", reflect([1, 'two', 3]).name());
    this.assertEqual("avocado.transporter", reflect(avocado.transporter).name());
    this.assertEqual("avocado.transporter.module", reflect(avocado.transporter.module).name());
    this.assertEqual("window", reflect(window).name());
    
    this.createNestedClasses(function() {
      this.assertEqual("an Argle.Bargle", reflect(new Argle.prototype.Bargle()).name());
    }.bind(this));
  });

  add.method('testInspect', function () {
    this.assertEqual("3", reflect(3).inspect());
    this.assertEqual("null", reflect(null).inspect());
    this.assertEqual("undefined", reflect(undefined).inspect());
    this.assertEqual("'lalala'", reflect("lalala").inspect());
    this.assertEqual("a Function", reflect(function() {}).inspect());
    this.assertEqual("an Object", reflect({}).inspect());
    this.assertEqual("an Array([1, 'two', 3])", reflect([1, 'two', 3]).inspect());
    this.assertEqual("avocado.transporter", reflect(avocado.transporter).inspect());
    this.assertEqual("avocado.transporter.module", reflect(avocado.transporter.module).inspect());
    this.assertEqual("window", reflect(window).inspect());
    
    var mirWithBadCreatorSlot = reflect({});
    mirWithBadCreatorSlot.setCreatorSlot(reflect(window).slotAt('doesntExist'));
    this.assertEqual("an Object", mirWithBadCreatorSlot.inspect());
  });

  add.method('testCreatorSlotChainExpression', function () {
    this.assertThrowsException(function() { reflect(3).creatorSlotChainExpression(); });
    this.assertThrowsException(function() { reflect(null).creatorSlotChainExpression(); });
    this.assertThrowsException(function() { reflect(undefined).creatorSlotChainExpression(); });
    this.assertThrowsException(function() { reflect("lalala").creatorSlotChainExpression(); });
    this.assertThrowsException(function() { reflect(function() {}).creatorSlotChainExpression(); });
    this.assertThrowsException(function() { reflect({}).creatorSlotChainExpression(); });
    this.assertThrowsException(function() { reflect([1, 'two', 3]).creatorSlotChainExpression(); });
    this.assertEqual("avocado.transporter", reflect(avocado.transporter).creatorSlotChainExpression());
    this.assertEqual("avocado.transporter.module", reflect(avocado.transporter.module).creatorSlotChainExpression());
    this.assertEqual("window", reflect(window).creatorSlotChainExpression());
    
    avocado['!=!'] = {};
    reflect(avocado).slotAt(['!=!']).beCreator();
    this.assertEqual("avocado['!=!']", reflect(avocado['!=!']).creatorSlotChainExpression());
    
    this.createNestedClasses(function() {
      this.assertEqual("Argle.prototype.Bargle.prototype", reflect(Argle.prototype.Bargle.prototype).creatorSlotChainExpression());
    }.bind(this));
  });

  add.method('testMorphDuplication', function () {
    // aaa - at first I thought this was a mirror bug, but it wasn't, so this test should maybe live elsewhere
    var s = reflect(window).slotAt('argleBargleMorph');
    var mMir = reflect(Morph.makeRectangle(pt(100,200), pt(60, 30)));
    s.setContents(mMir);
    s.beCreator();
    var m2Mir = reflect(mMir.reflectee().duplicate());
    this.assert(mMir.annotationForReading() !== m2Mir.annotationForReading(), "the annotation should not be shared");
    s.remove();
  });

  add.method('createSlot', function (mir, name, contents, catParts) {
    var slot = mir.slotAt(name);
    slot.setContents(reflect(contents));
    if (catParts) { slot.setCategory(mir.category(catParts)); }
    return slot;
  });

  add.method('checkComment', function (x, comment) {
    x.setComment(comment);
    this.assertEqual(comment, x.comment(), "Comment didn't work: " + comment);
  });

  add.method('testComments', function () {
    avocado.organization.temporarilySetCurrent(avocado.organizationUsingAnnotations, function() {
      this.checkComment(reflect({})            , "an object comment");
      this.checkComment(reflect({}).slotAt('a'), "a slot comment");
    }.bind(this));
  });

  add.method('testCategories', function () {
    avocado.organization.temporarilySetCurrent(avocado.organizationUsingAnnotations, function() {
      var o = {};
      var mir = reflect(o);
      this.createSlot(mir, 'a', 42, ['letters', 'vowels']);
      this.createSlot(mir, 'b', 43, ['letters', 'consonants']);
      this.createSlot(mir, 'c', 44, ['letters', 'consonants']);
      this.createSlot(mir, 'd', 45, ['letters', 'consonants']);
      this.createSlot(mir, 'e', 46, ['letters', 'vowels']);
      this.createSlot(mir, 'y', 47, ['letters']);
      
      var root = mir.rootCategory();
      this.assertEqual('letters', mir.immediateSubcategoriesOf(root).toArray().join(', '));
      this.assertEqual('letters consonants, letters vowels', mir.immediateSubcategoriesOf(root.subcategory('letters')).sort().join(', '));
      this.assertEqual('', mir.immediateSubcategoriesOf(root.subcategory('letters').subcategory('vowels')).sort().join(', '));
      
      this.assertEqual('', root.possiblyStaleSlots().sort().join(', '));
      this.assertEqual('y', root.subcategory('letters').possiblyStaleSlots().sort().join(', '));
      this.assertEqual('a, e', root.subcategory('letters').subcategory('vowels').possiblyStaleSlots().sort().join(', '));
      
      this.assertEqual('b, c, d', root.subcategory('letters').subcategory('consonants').possiblyStaleNormalSlotsInMeAndSubcategories().sort().join(', '));
      this.assertEqual('a, b, c, d, e, y', root.possiblyStaleNormalSlotsInMeAndSubcategories().sort().join(', '));
      
      var o2 = {};
      var mir2 = reflect(o2);
      mir.category(['letters']).copyInto(mir2.category(['glyphs']));
      this.assertEqual(42, o2.a);
      this.assertEqual(mir2.category(['glyphs', 'letters', 'vowels']), mir2.slotAt('a').category());
      
      mir.category(['letters', 'vowels']).copyInto(mir2.rootCategory());
      this.assertEqual(42, o2.a);
      this.assertEqual(mir2.category(['vowels']), mir2.slotAt('a').category());
      
      mir.rootCategory().copyContentsInto(mir2.category(['stuff']));
      this.assertEqual(42, o2.a);
      this.assertEqual(mir2.category(['stuff', 'letters', 'vowels']), mir2.slotAt('a').category());
    }.bind(this));
  });

  add.method('testExpressionEvaluatingToMe', function () {
    this.assertEqual('3', reflect(3).expressionEvaluatingToMe());
    this.assertEqual('null', reflect(null).expressionEvaluatingToMe());
    this.assertEqual('false', reflect(false).expressionEvaluatingToMe());
    this.assertEqual("'pleh'", reflect('pleh').expressionEvaluatingToMe());
    this.assertEqual("[1, 2, 'three']", reflect([1, 2, 'three']).expressionEvaluatingToMe());
    
    // Don't wanna test the text directly because different browsers print the function slightly differently.
    var functionText = reflect(function(a) { return a + 4; }).expressionEvaluatingToMe();
    var recreatedFunction = eval("(" + functionText + ")");
    this.assertEqual(19, recreatedFunction(15));

    this.assertEqual('3', reflect(3).expressionEvaluatingToMe(true));
    this.assertEqual('null', reflect(null).expressionEvaluatingToMe(true));
    this.assertEqual('false', reflect(false).expressionEvaluatingToMe(true));

    window.argle = {bargle: 42};
    this.assertEqual('{bargle: 42}',    reflect(argle).expressionEvaluatingToMe());
    reflect(window).slotAt('argle').beCreator();
    this.assertEqual('argle',           reflect(argle).expressionEvaluatingToMe());
    this.assertEqual('{bargle: 42}',    reflect(argle).expressionEvaluatingToMe(true));
    delete window.argle;
  });

  add.method('testCopyDownParents', function () {
    var mirA = reflect({a: 1, aa: 11});
    this.assertEqual(2, mirA.size());
    var mirB = reflect({b: 2, bb: 22, bbb: 222});
    var mirC = reflect({c: 3, bleh: 'bleh!'});
    mirB.slotAt('b').setCategory(mirB.category(['categories should be copied down']));
    mirA.setCopyDownParents([{parent: mirB.reflectee()}, {parent: mirC.reflectee(), slotsToOmit: ['bleh']}]);
    this.assertEqual(3, mirB.size());
    this.assertEqual(2, mirC.size());
    this.assertEqual(6, mirA.size());
    this.assertEqual(1,   mirA.reflectee().a  );
    this.assertEqual(11,  mirA.reflectee().aa );
    this.assertEqual(2,   mirA.reflectee().b  );
    this.assertEqual(22,  mirA.reflectee().bb );
    this.assertEqual(222, mirA.reflectee().bbb);
    this.assertEqual(3,   mirA.reflectee().c  );

    this.assertEqual(null,                      mirA.slotAt('a'  ).copyDownParentThatIAmFrom());
    this.assertEqual(null,                      mirA.slotAt('aa' ).copyDownParentThatIAmFrom());
    this.assertEqual(mirA.copyDownParents()[0], mirA.slotAt('b'  ).copyDownParentThatIAmFrom());
    this.assertEqual(mirA.copyDownParents()[0], mirA.slotAt('bb' ).copyDownParentThatIAmFrom());
    this.assertEqual(mirA.copyDownParents()[0], mirA.slotAt('bbb').copyDownParentThatIAmFrom());
    this.assertEqual(mirA.copyDownParents()[1], mirA.slotAt('c'  ).copyDownParentThatIAmFrom());
    
    this.assertEqual(mirA.category(['categories should be copied down']).parts(), mirA.slotAt('b').category().parts());
  });

  add.method('testIndexableCreatorSlots', function () {
    if (avocado.shouldBreakCreatorSlotsInOrderToImprovePerformance) { return; } // feature is turned off, can't be tested
      
    var a = [], aMir = reflect(a);
    var oA = {}, oB = {}, oC = {}, oD = {}, oE = {}, oX = {};
    a.pushAndAdjustCreatorSlots(oX);
    this.assertEqual(aMir.slotAt('0'), reflect(oX).theCreatorSlot());
    a.pushAndAdjustCreatorSlots(oE);
    this.assertEqual(aMir.slotAt('0'), reflect(oX).theCreatorSlot());
    this.assertEqual(aMir.slotAt('1'), reflect(oE).theCreatorSlot());
    a.unshiftAndAdjustCreatorSlots(oA);
    this.assertEqual(aMir.slotAt('0'), reflect(oA).theCreatorSlot());
    this.assertEqual(aMir.slotAt('1'), reflect(oX).theCreatorSlot());
    this.assertEqual(aMir.slotAt('2'), reflect(oE).theCreatorSlot());
    this.assertEqual([oX], a.spliceAndAdjustCreatorSlots(1, 1, oB, oC, oD));
    this.assertEqual(aMir.slotAt('0'), reflect(oA).theCreatorSlot());
    this.assertEqual(aMir.slotAt('1'), reflect(oB).theCreatorSlot());
    this.assertEqual(aMir.slotAt('2'), reflect(oC).theCreatorSlot());
    this.assertEqual(aMir.slotAt('3'), reflect(oD).theCreatorSlot());
    this.assertEqual(aMir.slotAt('4'), reflect(oE).theCreatorSlot());
    this.assert(! reflect(oX).theCreatorSlot());

    this.assertEqual(reflect(avocado).slotAt('dictionary'), reflect(avocado.dictionary).theCreatorSlot());
    a.pushAndAdjustCreatorSlots(avocado.dictionary); // a well-known object shouldn't have its creator slot changed
    this.assertEqual(reflect(avocado).slotAt('dictionary'), reflect(avocado.dictionary).theCreatorSlot());
  });

  add.method('testGettingSlotsByModule', function () {
    var o = {};
    var p = {copiedDown1: 'copiedDown1', copiedDown2: 'copiedDown2'};
    var m1 = avocado.transporter.module.named('temp_mod_1');
    var m2 = avocado.transporter.module.named('temp_mod_2');
    var m3 = avocado.transporter.module.named('temp_mod_3');
    var mir  = reflect(o);
    var pMir = reflect(p);
    mir.setCopyDownParents([{parent: p}]);
    pMir.slotAt('copiedDown1').setModule(m3);
    var s1 = this.createSlot(mir, 'a', 1);
    var s2 = this.createSlot(mir, 'b', 2);
    var s3 = this.createSlot(mir, 'c', 3);
    var s4 = this.createSlot(mir, 'd', 4);
    var s5 = this.createSlot(mir, 'e', 5);
    this.assertEqual([null], mir.modules());
    this.assertEqual([s1, s2, s3, s4, s5], mir.slotsInModuleNamed({}          ).sort());
    this.assertEqual([s1, s2, s3, s4, s5], mir.slotsInModuleNamed(null        ).sort());
    this.assertEqual([                  ], mir.slotsInModuleNamed('temp_mod_1').sort());
    this.assertEqual([                  ], mir.slotsInModuleNamed('temp_mod_2').sort());
    this.assertEqual([                  ], mir.slotsInModuleNamed('temp_mod_3').sort());
    s3.setModule(m1);
    s5.setModule(m1);
    s2.setModule(m2);
    this.assertEqual([m1, m2, null], mir.modules().sort());
    this.assertEqual([s1, s2, s3, s4, s5], mir.slotsInModuleNamed({}          ).sort());
    this.assertEqual([s1,         s4    ], mir.slotsInModuleNamed(null        ).sort());
    this.assertEqual([        s3,     s5], mir.slotsInModuleNamed('temp_mod_1').sort());
    this.assertEqual([    s2            ], mir.slotsInModuleNamed('temp_mod_2').sort());
    this.assertEqual([                  ], mir.slotsInModuleNamed('temp_mod_3').sort());
    m1.uninstall();
    m2.uninstall();
    m3.uninstall();
  });

  add.method('testSettingModuleRecursively', function () {
    var m = avocado.transporter.module.named('temp_mod');
    var cdp = {copiedDown: true};
    var p = {c: 3};
    var o = Object.create(p);
    window.tempObj = o;
    Object.extend(o, {a: 1, b: 2, x: {xa: 'one', xb: 'two'}, y: {ya: 'un'}});
    
    reflect(window).slotAt('tempObj').beCreator();
    reflect(o).setCopyDownParents([{parent: cdp}]);
    reflect(o).slotAt('x').beCreator();
    reflect(o).parentSlot().beCreator();
    reflect(window).slotAt('tempObj').setModuleRecursively(m);
    
    // Slots accessible through creator slots should be included.
    // Copied-down slots should not be included.
    this.assertEqual('a, b, c, tempObj, x, xa, xb, y', m.slots().map(function(s) { return s.name(); }).sort().join(', '));
    
    m.uninstall();
  });

  add.method('testFindingUnusedSlotNames', function () {
    var i;
    var o = {};
    var mir = reflect(o);
    this.assertEqual(0, mir.size());
    for (i = 0; i < 20; ++i) { o[mir.findUnusedSlotName()] = i; }
    this.assertEqual(20, mir.size());
    for (i = 0; i < 30; ++i) { o[mir.findUnusedSlotName("prefix_")] = i + 1000; }
    this.assertEqual(50, mir.size());
  });

  add.method('testCreatingMirrorsByObjectName', function () {
    this.assertIdentity(null,                 avocado.mirror.forObjectNamed(['blahblahnothing'           ])            );
    this.assertIdentity(avocado,              avocado.mirror.forObjectNamed(['avocado'                   ]).reflectee());
    this.assertIdentity(avocado.mirror,       avocado.mirror.forObjectNamed(['avocado', 'mirror'         ]).reflectee());
    this.assertIdentity(avocado.mirror.tests, avocado.mirror.forObjectNamed(['avocado', 'mirror', 'tests']).reflectee());
  });

  add.method('testHashing', function () {
    var d = avocado.dictionary.copyRemoveAll();
    var o1 = {};
    var o2 = {};
    d.put(reflect(3), 'three');
    d.put(reflect(false), 'false');
    d.put(reflect(null), 'null');
    d.put(reflect(undefined), 'undefined');
    d.put(reflect(o1), 'an object');
    d.put(reflect(o2), 'another object');
    this.assertIdentity('three', d.get(reflect(3)));
    this.assertIdentity('false', d.get(reflect(false)));
    this.assertIdentity('null', d.get(reflect(null)));
    this.assertIdentity('undefined', d.get(reflect(undefined)));
    this.assertIdentity('an object', d.get(reflect(o1)));
    this.assertIdentity('another object', d.get(reflect(o2)));
  });

  add.method('testInheritingSlotAnnotations', function () {
    var o1 = {};
    var o2 = Object.create(o1);
    var o3 = Object.create(o2);
    var s1_a = reflect(o1).addData('a', 1).setComment('comment 1a');
    var s1_b = reflect(o1).addData('b', 1).setComment('comment 1b');
    var s2_a = reflect(o2).addData('a', 2).setComment('comment 2a');
    var s2_c = reflect(o2).addData('c', 2).setComment('comment 2c');
    var s2_d = reflect(o2).addData('d', 2).setComment('comment 2d');
    
    this.assertIdentity('comment 2a', reflect(o3).slotAt('a').comment());
    this.assertIdentity('comment 1b', reflect(o3).slotAt('b').comment());
    this.assertIdentity('comment 2c', reflect(o3).slotAt('c').comment());
    this.assertIdentity('comment 2d', reflect(o3).slotAt('d').comment());
    this.assert(! reflect(o3).slotAt('e').comment());
    
    var s3_a = reflect(o3).addData('a', 3).setComment('comment 3a');
    var s3_b = reflect(o3).addData('b', 3).setComment('comment 3b');
    var s3_c = reflect(o3).addData('c', 3).setComment('comment 3c');
    var s3_e = reflect(o3).addData('e', 3).setComment('comment 3e');
    
    this.assertIdentity('comment 3a', reflect(o3).slotAt('a').comment());
    this.assertIdentity('comment 3b', reflect(o3).slotAt('b').comment());
    this.assertIdentity('comment 3c', reflect(o3).slotAt('c').comment());
    this.assertIdentity('comment 2d', reflect(o3).slotAt('d').comment());
    this.assertIdentity('comment 3e', reflect(o3).slotAt('e').comment());
    
    this.assertIdentity('comment 2a', reflect(o3).slotAt('a').inheritedAnnotation().getComment());
    this.assertIdentity('comment 1b', reflect(o3).slotAt('b').inheritedAnnotation().getComment());
    this.assertIdentity('comment 2c', reflect(o3).slotAt('c').inheritedAnnotation().getComment());
    this.assertIdentity('comment 2d', reflect(o3).slotAt('d').inheritedAnnotation().getComment());
    this.assert(! reflect(o3).slotAt('e').inheritedAnnotation());
  });

});


thisModule.addSlots(window, function(add) {

  add.method('reflect', function (o) {
    var m = Object.create(avocado.mirror);
    m.initialize(o);
    return m;
  }, {category: ['avocado', 'reflection']});

});


thisModule.addSlots(Array.prototype, function(add) {

  add.method('makeAllCreatorSlots', function () {
    this.makeCreatorSlots(0, this.length);
    return this;
  }, {category: ['reflection', 'creator slots']});

  add.method('makeCreatorSlots', function (start, end) {
    var thisMir = reflect(this);
    for (var i = start; i < end; ++i) {
      // Only make the indexable slot be the creator if the object
      // isn't already well-known. (Not sure this is what we
      // want in all cases, but for now it is.)
      var mir = reflect(this[i]);
      if (! mir.isWellKnown('probableCreatorSlot')) {
        thisMir.slotAt(i).beCreator();
      }
    }
    return this;
  }, {category: ['reflection', 'creator slots']});

  add.method('unmakeCreatorSlots', function (start, end) {
    var thisMir = reflect(this);
    for (var i = start; i < end; ++i) {
      var o = this[i];
      // aaa this doesNotNeedACreatorSlot thing is a HACK
      if (o && !o.doesNotNeedACreatorSlot) {
        var s = thisMir.slotAt(i);
        var contents = s.contents();
        if (s.equals(contents.theCreatorSlot())) {
          contents.setCreatorSlot(null);
        }
      }
    }
    return this;
  }, {category: ['reflection', 'creator slots']});

  add.method('adjustCreatorSlots', function (start, end, shiftAmount) {
    if (shiftAmount === 0) { return this; }
    if (shiftAmount === undefined) { shiftAmount = 1; }
    var thisMir = reflect(this);
    for (var i = start; i < end; ++i) {
      if (thisMir.slotAt(i - shiftAmount).equals(reflect(this[i]).theCreatorSlot())) {
        thisMir.slotAt(i).beCreator();
      }
    }
    return this;
  }, {category: ['reflection', 'creator slots']});

  add.method('unshiftAndAdjustCreatorSlots', function (newElem) {
    this.unshift(newElem);

		if (! avocado.shouldBreakCreatorSlotsInOrderToImprovePerformance) {
      if (newElem && !newElem.doesNotNeedACreatorSlot) {
        this.makeCreatorSlots(0, 1);
        this.adjustCreatorSlots(1, this.length);
      }
    }
  }, {category: ['reflection', 'creator slots']});

  add.method('pushAndAdjustCreatorSlots', function (newElem) {
    this.push(newElem);

		if (! avocado.shouldBreakCreatorSlotsInOrderToImprovePerformance) {
      if (newElem && !newElem.doesNotNeedACreatorSlot) {
        this.makeCreatorSlots(this.length - 1, this.length);
      }
    }
  }, {category: ['reflection', 'creator slots']});

  add.method('spliceAndAdjustCreatorSlots', function () {
		if (avocado.shouldBreakCreatorSlotsInOrderToImprovePerformance) {
		  return this.splice.apply(this, arguments);
	  }
		  
    var index = arguments[0];
    var howMany = arguments[1];
    this.unmakeCreatorSlots(index, index + howMany);
    var result = this.splice.apply(this, arguments);
    var args = $A(arguments);
    args.shift();
    args.shift();
    this.makeCreatorSlots(index, index + args.length);
    this.adjustCreatorSlots(index + args.length, this.length, args.length - howMany);
    return result;
  }, {category: ['reflection', 'creator slots']});

});


});

avocado.transporter.module.onLoadCallbacks["reflection/slot"] = function() {};
avocado.transporter.module.create('reflection/slot', function(requires) {

requires('reflection/mirror');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('slots', {}, {category: ['reflection']});

});


thisModule.addSlots(avocado.slots, function(add) {

  add.creator('abstract', {});

});


thisModule.addSlots(avocado.slots['abstract'], function(add) {

  add.method('create', function () {
    var s = Object.create(this);
    s.initialize.apply(s, arguments);
    return s;
  });

  add.method('initialize', function (m) {
    this._mirror = m;
    return this;
  }, {category: ['creating']});

  add.data('_mirror', reflect({}), {category: ['accessing'], initializeTo: 'reflect({})'});

  add.method('mirror', function () { return this._mirror; }, {category: ['accessing']});

  add.method('holder', function () { return this._mirror; }, {category: ['accessing']});

  add.method('inspect', function () { return this.toString(); }, {category: ['printing']});

  add.method('toString', function () {
    var n = this.name();
    if (n === undefined) { return ""; }
    return n;
  }, {category: ['printing']});

  add.method('fullName', function () {
    var n = this.immediateName();
    if (n === undefined) { return ""; }
    return this.holder().name() + "." + n;
  }, {category: ['printing']});

  add.method('readableName', function () {
    return this.name();
  }, {category: ['printing']});

  add.method('immediateName', function () {
    return this.name();
  }, {category: ['printing']});

  add.data('namingScheme', avocado.mirror.namingScheme, {category: ['printing']});

  add.method('nameWithinEnclosingObject', function (enclosingMirrorOrSlot) {
    var n = this.immediateName();
    if (n === undefined) { return ""; }
    var enclosingName = this.holder().nameWithinEnclosingObject(enclosingMirrorOrSlot);
    return enclosingName ? enclosingName + "." + n : n;
  }, {category: ['printing']});

  add.method('get', function () {
    return this.contents();
  }, {category: ['compatibility with value holders']});

  add.method('set', function (c) {
    return this.setContents(c);
  }, {category: ['compatibility with value holders']});

  add.method('canGet', function () {
    return typeof(this.contents) === 'function';
  }, {category: ['compatibility with value holders']});

  add.method('canSet', function () {
    return typeof(this.setContents) === 'function';
  }, {category: ['compatibility with value holders']});

  add.method('sortOrder', function () { return this.name().toUpperCase(); }, {category: ['sorting']});

  add.method('type', function () { return null; }, {category: ['types']});

  add.method('isFunctionBody', function () { return false; }, {category: ['testing']});

  add.method('isHardWired', function () { return false; }, {category: ['testing']});

  add.method('isDOMChildNode', function () { return false; }, {category: ['testing']});

  add.method('isParent', function () { return false; }, {category: ['testing']});

  add.method('isSimpleMethod', function () {
    return this.contents().isReflecteeSimpleMethod();
  }, {category: ['testing']});

  add.method('shouldBeShownAsJustSourceCode', function () {
    return this.isSimpleMethod();
  }, {category: ['user interface']});

  add.method('shouldBeShownAsContainingItsContents', function () {
    return this.equals(this.contents().probableCreatorSlot());
  }, {category: ['user interface']});

  add.data('isAvocadoSlot', true, {category: ['testing']});

  add.method('doesTypeMatch', function (obj) { return obj && obj.isAvocadoSlot; }, {category: ['testing']});

  add.method('canBeAddedToCategory', function (cat) {
    if (window.isInCodeOrganizingMode) {
      return cat.mirror().alreadyContainsSlotWithNameAndContents(this.name(), this.contents());
    } else {
      return true;
    }
  }, {category: ['testing']});

  add.method('copyDownParentThatIAmFrom', function () { return null; }, {category: ['copy-down parents']});

  add.method('isFromACopyDownParent', function () { return !! this.copyDownParentThatIAmFrom(); }, {category: ['copy-down parents']});

  add.method('isReallyPartOfHolder', function () {
    // I don't like the name of this method.
    return ! this.isFromACopyDownParent();
  }, {category: ['copy-down parents']});

  add.method('isArrayIndex', function () {
    if (! this.holder().isReflecteeArray()) { return false; }
    var i = parseInt(this.name(), 10);
    return ! isNaN(i);
  }, {category: ['testing']});

  add.method('getModuleAssignedToMeImplicitly', function () {
    if (this.isFromACopyDownParent()) { return null; }
    return this.holder().getModuleAssignedToMeImplicitly();
  }, {category: ['accessing annotation', 'module']});

  add.method('getModuleAssignedToMeExplicitlyOrImplicitly', function () {
    return this.getModuleAssignedToMeExplicitly() || this.getModuleAssignedToMeImplicitly();
  }, {category: ['accessing annotation', 'module']});

  add.method('isIncludedInModule', function (m) {
    var myModule = this.getModuleAssignedToMeExplicitlyOrImplicitly();
    if (m) {
      return myModule === m;
    } else {
      return !myModule;
    }
  }, {category: ['accessing annotation', 'module']});

  add.method('markModuleAsChanged', function () {
    var module = this.getModuleAssignedToMeExplicitlyOrImplicitly();
    if (module) { module.markAsChanged(); }
  }, {category: ['accessing annotation', 'module']});

  add.method('creatorSlotChainEndingWithMe', function (kindOfCreatorSlot) {
    var chain = this.holder().creatorSlotChain(kindOfCreatorSlot);
    if (!chain) { return null; }
    chain.unshift(this);
    return chain;
  }, {category: ['creator slots']});

  add.method('sourceCode', function () {
    try {
      var contentsMir = this.contents();
      
      // used to also say  || this.equals(contentsMir.probableCreatorSlot())  but I don't think I like it. -- Adam
      return contentsMir.expressionEvaluatingToMe(this.isSimpleMethod()); 
    } catch (ex) {
      return "cannot display contents";
    }
  }, {category: ['user interface']});

  add.method('newContentsForSourceCode', function (s) {
    //avocado.ui.showMessageIfWarningDuring(function() {
      // need the assignment and the semicolon so that JSLint doesn't gripe about seeing a naked expression
      var ok = JSLINT(avocado.stringBuffer.create('var ___contents___ = (').append(s).append(');').toString());
      if (!ok) {
        JSLINT.errors.each(function(error) {
          throw new Error("JSLint says: " + error.reason);
        });
      }
    //}.bind(this));

    var newContents = avocado.ui.showMessageIfErrorDuring(function() {
      return reflect(eval("(" + s + ")"));
    }.bind(this));
    
    return newContents;
  }, {category: ['user interface']});

  add.method('bePossibleCreatorSlotIfNoneAlreadySpecified', function () {
    var c = this.contents();
    if ((!c.explicitlySpecifiedCreatorSlot()) && c.canHaveCreatorSlot()) {
      c.addPossibleCreatorSlot(this);
    }
  }, {category: ['user interface', 'creator slots']});

  add.method('justExplicitlySetContents', function (evt) {
    // Just to help make it easier and more intuitive to set creator slots.
    this.bePossibleCreatorSlotIfNoneAlreadySpecified();
  }, {category: ['user interface']});

  add.method('interactivelyBeCreator', function (evt) {
    // aaa - Maybe the justChanged stuff should be put into the regular beCreator method.
    this.beCreator();
    avocado.ui.justChanged(this.contents());
    avocado.ui.justChanged(this);
  }, {category: ['user interface', 'creator slots']});

  add.method('likelyModules', function () {
    return this.holder().likelyModules();
  }, {category: ['user interface', 'modules']});

  add.creator('filterizer', {}, {category: ['filtering']});

  add.method('commands', function () {
    var cmdList = avocado.command.list.create(this);
    
    var copyDown = this.copyDownParentThatIAmFrom();
    if (copyDown) {
      var copyDownParentMir = reflect(copyDown.parent);
      cmdList.addItem({label: "copied down from " + copyDownParentMir.name(), go: function(evt) {
        avocado.ui.grab(copyDownParentMir, evt);
      }});
    } else {
      var isModifiable = !window.isInCodeOrganizingMode;
      
      if (isModifiable && this.beCreator && this.contents().canHaveCreatorSlot()) {
        var cs = this.contents().explicitlySpecifiedCreatorSlot();
        if (!cs || ! cs.equals(this)) {
          cmdList.addItem({label: "be creator", go: function(evt) { this.interactivelyBeCreator(evt); }});
        }
      }

      if (isModifiable && this.setModule) {
        cmdList.addItem(avocado.command.create("set module", function(evt, module) {
          this.setModule(module);
        }).setArgumentSpecs([
          avocado.command.argumentSpec.create("To which module?").onlyAcceptsType(avocado.transporter.module)
        ]));
      }
    }

    cmdList.addLine();
    
    if (this.wellKnownImplementors) {
      cmdList.addItem({label: "implementors", go: function(evt) {
        avocado.ui.grab(avocado.searchResultsPresenter.create(avocado.objectGraphWalker.visitors.implementorsFinder.create(this.name()).createWalker(), evt)).redo();
      }});
    }

    if (this.wellKnownSenders) {
      cmdList.addItem({label: "senders", go: function(evt) {
        avocado.ui.grab(avocado.searchResultsPresenter.create(avocado.senders.finder.create(this.name()), evt)).redo();
      }});
    }
    
    // pretty-printer isn't working yet
    if (false && isModifiable && this.contents().prettyPrint) {
      cmdList.addSection([{label: "pretty-print", go: function(evt) {
        avocado.ui.grab(reflect(this.contents().prettyPrint()), evt);
      }}]);
    }
    
    return cmdList;
  }, {category: ['user interface', 'commands']});

});


thisModule.addSlots(avocado.slots['abstract'].filterizer, function(add) {

  add.method('create', function () {
    return Object.newChildOf(this);
  }, {category: ['creating']});

  add.method('initialize', function () {
  }, {category: ['creating']});

  add.method('excludeSlotsNotInModuleNamed', function (moduleName) {
    this._moduleName = moduleName;
    return this;
  }, {category: ['filtering']});

  add.method('excludeSlotsAlreadyAssignedToAModule', function () {
    this._wantOnlyUnowned = true;
    return this;
  }, {category: ['filtering']});

  add.method('excludeCopyDowns', function () {
    this._shouldExcludeCopyDowns = true;
    return this;
  }, {category: ['filtering']});

  add.method('matchesSlot', function (slot) {
    if (this._shouldExcludeCopyDowns && slot.isFromACopyDownParent()) { return false; }
    
    var m = slot.getModuleAssignedToMeExplicitlyOrImplicitly();
    if (this._wantOnlyUnowned) { return !m; }
    if (this._moduleName) { return m && m.name() === this._moduleName; }
    
    return true;
  }, {category: ['matching']});

});


thisModule.addSlots(avocado.slots, function(add) {

  add.creator('plain', Object.create(avocado.slots['abstract']));

});


thisModule.addSlots(avocado.slots.plain, function(add) {

  add.method('initialize', function (m, n) {
    this._mirror = m;
    this._name = n;
    return this;
  }, {category: ['creating']});

  add.data('_name', 'argleBargle', {category: ['accessing']});

  add.method('name', function () { return this._name; }, {category: ['accessing']});

  add.method('contents', function () {
    return this._mirror.contentsAt(this.name());
  }, {category: ['accessing']});

  add.method('setContents', function (m) {
    this.markModuleAsChanged();
    return this._mirror.setContentsAt(this.name(), m);
  }, {category: ['accessing']});

  add.method('equals', function (s) {
    if (!s) { return false; }
    if (typeof(s.name) !== 'function' || typeof(s.mirror) !== 'function') { return false; }
    return this.name() === s.name() && this.mirror().equals(s.mirror());
  }, {category: ['comparing']});

  add.method('hashCode', function () {
    return this.name().hashCode() + this.mirror().hashCode();
  }, {category: ['comparing']});

  add.method('copyToNewHolder', function () {
    return this.copyTo(reflect({}).rootCategory());
  }, {category: ['copying']});

  add.method('copyTo', function (targetCatOfNewMir) {
    var newSlot = targetCatOfNewMir.mirror().slotAt(this.name());
    newSlot.setContents(this.contents());
    newSlot.setCategory(targetCatOfNewMir);
    return newSlot;
  }, {category: ['copying']});

  add.method('copyInto', function (targetCatOfNewMir) {
    // for compatibility with categories
    return this.copyTo(targetCatOfNewMir);
  }, {category: ['copying']});

  add.method('remove', function () {
    this.markModuleAsChanged();
    this.mirror().removeSlotAt(this.name());
    this.removeAnnotation();
  }, {category: ['removing']});

  add.method('rename', function (newName) {
    var oldName = this.name();
    if (oldName === newName) {return;}
    var contentsMir = this.contents();
    var holder = this.holder();
    if (  holder.reflecteeHasOwnProperty(newName)) { throw holder.reflecteeToString() + " already has a slot named " + newName; }
    if (! holder.reflecteeHasOwnProperty(oldName)) { throw holder.reflecteeToString() + " has no slot named "        + oldName; }

    var isCreator = this.equals(this.contents().explicitlySpecifiedCreatorSlot());
    var holderAnno = holder.annotationForWriting();
    var slotAnno = this.annotationIfAny();

    var newSlot = holder.slotAt(newName);
    this.remove();
    newSlot.setContents(contentsMir);
    newSlot.setAnnotation(slotAnno);

    if (isCreator) {newSlot.beCreator();}
    
    return newSlot;
  }, {category: ['accessing']});

  add.method('hasInheritedOrUninheritedAnnotation', function () {
    var hasUninheritedOne = this.hasUninheritedAnnotation();
    if (hasUninheritedOne) { return hasUninheritedOne; }
    return this.inheritedAnnotation();
  }, {category: ['accessing annotation']});

  add.method('hasUninheritedAnnotation', function () {
    return this.holder().hasAnnotation() && this.holder().annotationForReading().existingSlotAnnotation(this.name());
  }, {category: ['accessing annotation']});

  add.method('annotationForWriting', function () {
    return this.holder().annotationForWriting().slotAnnotation(this.name());
  }, {category: ['accessing annotation']});

  add.method('setAnnotation', function (a) {
    return this.holder().annotationForWriting().setSlotAnnotation(this.name(), a);
  }, {category: ['accessing annotation']});

  add.method('removeAnnotation', function () {
    this.holder().annotationForWriting().removeSlotAnnotation(this.name());
  }, {category: ['accessing annotation']});

  add.method('annotationIfAny', function () {
    if (! this.holder().hasAnnotation()) { return null; }
    return this.holder().annotationForWriting().existingSlotAnnotation(this.name());
  }, {category: ['accessing annotation']});

  add.method('annotationForReading', function () {
    return this.annotationIfAny() || this.inheritedAnnotation();
  }, {category: ['accessing annotation']});

  add.method('inheritedAnnotation', function () {
    var h = this.holder();
    while (true) {
      h = h.parentOrNull();
      if (!h) { return null; }
      var s = h.slotAt(this.name());
      if (s) {
        var a = s.annotationIfAny();
        if (a) { return a; }
      }
    }
  }, {category: ['accessing annotation']});

  add.method('beCreator', function () {
    this.markModuleAsChanged();
    this.contents().setCreatorSlot(this);
    return this;
  }, {category: ['creator slots']});

  add.method('getModuleAssignedToMeExplicitly', function () {
    if (! this.hasUninheritedAnnotation()) { return undefined; }
    return this.annotationForWriting().getModuleAssignedToMeExplicitly();
  }, {category: ['accessing annotation', 'module']});

  add.method('setModule', function (m) {
    var oldModule = this.getModuleAssignedToMeExplicitlyOrImplicitly();
    var holderObj = this.holder().reflectee();
    avocado.annotator.setModuleIfNecessary(holderObj, this.name(), m);
    
    if (m)         {         m.markAsChanged(); }
    if (oldModule) { oldModule.markAsChanged(); }

    avocado.ui.justChanged(this);
    return this;
  }, {category: ['accessing annotation', 'module']});

  add.method('setModuleRecursively', function (m) {
    if (this.isFromACopyDownParent()) { return this; }
    this.setModule(m);
    var c = this.contents();
    if (!c.reflecteeStoreString() && !c.isReflecteeSimpleMethod() && !c.isReflecteeDOMNode() && !this.initializationExpression()) { // no need if we're not going to be filing in the object slot-by-slot anyway
      if (this.equals(c.theCreatorSlot())) {
        c.setModuleRecursively(m);
      }
    }
    return this;
  }, {category: ['accessing annotation', 'module']});

  add.method('moduleName', function () {
    var module = this.getModuleAssignedToMeExplicitlyOrImplicitly();
    return module ? module.name() : "";
  }, {category: ['user interface', 'accessing annotation', 'module']});

  add.method('setModuleName', function (n) {
    var module = avocado.transporter.module.existingOneNamed(n);
    if (module) { return this.setModule(module); }
    avocado.ui.confirm("The '" + n + "' module does not exist. Create it?", function(b) {
      if (b) {
        this.setModule(avocado.transporter.module.named(n));
      }
    }.bind(this));
  }, {category: ['user interface', 'accessing annotation', 'module']});

  add.method('initializationExpression', function () {
    if (! this.hasInheritedOrUninheritedAnnotation()) { return ""; }
    return this.annotationForReading().initializationExpression() || "";
  }, {category: ['accessing annotation', 'initialization expression']});

  add.method('setInitializationExpression', function (e) {
    this.annotationForWriting().setInitializationExpression(e);
    return this;
  }, {category: ['accessing annotation', 'initialization expression']});

  add.method('comment', function () {
    return avocado.organization.current.commentForSlot(this);
  }, {category: ['accessing annotation', 'comment']});

  add.method('setComment', function (c) {
    avocado.organization.current.setCommentForSlot(this, c);
    return this;
  }, {category: ['accessing annotation', 'comment']});

  add.method('category', function () {
    var cds = this.slotThatIAmCopiedDownFrom();
    if (cds) { return cds.category(); }
    
    var catParts = avocado.organization.current.categoryForSlot(this);
    return this.holder().category(catParts);
  }, {category: ['accessing annotation', 'category']});

  add.method('setCategory', function (c) {
    avocado.organization.current.setCategoryForSlot(this, c.parts());
    return this;
  }, {category: ['accessing annotation', 'category']});

  add.method('copyDownParentThatIAmFrom', function () {
    var name = this.name();
    var cdps = this.holder().copyDownParents();
    for (var i = 0, n = cdps.length; i < n; ++i) {
      var cdp = cdps[i];
      var parentMir = reflect(cdp.parent);
      if (parentMir.reflecteeHasOwnProperty(name)) {
        var slotsToOmit = cdp.slotsToOmit || [];
        if (typeof slotsToOmit === 'string') { slotsToOmit = slotsToOmit.split(' '); }
        if (! slotsToOmit.include(name) && this.contents().equals(parentMir.slotAt(name).contents())) { return cdp; }
      }
    }
  }, {category: ['copy-down parents']});

  add.method('slotThatIAmCopiedDownFrom', function () {
    var cdp = this.copyDownParentThatIAmFrom();
    if (cdp) { return reflect(cdp.parent).slotAt(this.name()); }
    return null;
  }, {category: ['copy-down parents']});

  add.method('wellKnownImplementors', function () {
    return avocado.objectGraphWalker.visitors.implementorsFinder.create(this.name()).createWalker().go();
  }, {category: ['searching']});

  add.method('wellKnownSenders', function () {
    return avocado.senders.finder.create(this.name()).go();
  }, {category: ['searching']});

});


thisModule.addSlots(avocado.slots, function(add) {

  add.creator('parent', Object.create(avocado.slots['abstract']));

});


thisModule.addSlots(avocado.slots.parent, function(add) {

  add.method('name', function () { return "__proto__"; }, {category: ['accessing']});

  add.method('readableName', function () { return "inherits from"; }, {category: ['printing']});

  add.method('sortOrder', function () { return ''; }, {category: ['sorting'], comment: 'Should come first.'});

  add.method('isParent', function () { return true; }, {category: ['testing']});

  add.method('contents', function () { return this._mirror.parent(); }, {category: ['accessing']});

  add.method('setContents', function (m) {
    this.markModuleAsChanged();
    return this._mirror.setParent(m);
  }, {category: ['accessing']});

  add.method('equals', function (s) {
    if (!s) { return false; }
    return s.isParent() && this.mirror().equals(s.mirror());
  }, {category: ['comparing']});

  add.method('hashCode', function () {
    return 'parent_' + this.mirror().hashCode();
  }, {category: ['comparing']});

  add.method('isSimpleMethod', function () { return false; }, {category: ['testing']});

  add.method('category', function () {
    return this.mirror().rootCategory();
  }, {category: ['accessing annotation', 'category']});

  add.method('getModuleAssignedToMeExplicitly', function () {
    var cs = this.mirror().theCreatorSlot();
    return cs ? cs.getModuleAssignedToMeExplicitly() : null;
  }, {category: ['accessing annotation', 'module']});

  add.method('initializationExpression', function () {
    return "";
  }, {category: ['accessing annotation', 'initialization expression']});

  add.method('beCreator', function () {
    this.markModuleAsChanged();
    this.contents().setCreatorSlot(this);
    return this;
  }, {category: ['creator slots']});

});


thisModule.addSlots(avocado.slots, function(add) {

  add.creator('functionBody', Object.create(avocado.slots['abstract']));

});


thisModule.addSlots(avocado.slots.functionBody, function(add) {

  add.method('name', function () { return "*body*"; }, {category: ['accessing']});

  add.method('contents', function () { return this._mirror; }, {category: ['accessing']});

  add.method('isSimpleMethod', function () { return true; }, {category: ['testing']});

  add.method('isFunctionBody', function () { return true; }, {category: ['testing']});

});


thisModule.addSlots(avocado.slots, function(add) {

  add.creator('hardWiredContents', Object.create(avocado.slots['abstract']));

});


thisModule.addSlots(avocado.slots.hardWiredContents, function(add) {

  add.method('initialize', function (m, n, c) {
    this._mirror = m;
    this._name = n;
    this._contents = c;
  }, {category: ['creating']});

  add.method('name', function () { return this._name; }, {category: ['accessing']});

  add.method('contents', function () { return this._contents; }, {category: ['accessing']});

  add.method('initializationExpression', function () {
    return "";
  }, {category: ['accessing annotation', 'initialization expression']});

  add.method('isHardWired', function () { return true; }, {category: ['testing']});

  add.method('equals', function (s) {
    if (this === s) { return true; }
    if (!s) { return false; }
    if (typeof(s.name) !== 'function' || typeof(s.isHardWired) !== 'function') { return false; }
    return s.isHardWired() && this.name() === s.name() && this.mirror().equals(s.mirror()) && this.contents().equals(s.contents());
  }, {category: ['comparing']});

  add.method('hashCode', function () {
    return this.name().hashCode() + this.mirror().hashCode();
  }, {category: ['comparing']});

  add.method('category', function () {
    return this.mirror().rootCategory();
  }, {category: ['accessing annotation', 'category']});

});


thisModule.addSlots(avocado.slots, function(add) {

  add.creator('domChildNode', Object.create(avocado.slots.hardWiredContents));

});


thisModule.addSlots(avocado.slots.domChildNode, function(add) {

  add.method('isDOMChildNode', function () { return true; }, {category: ['testing']});

});


});

avocado.transporter.module.onLoadCallbacks["reflection/process"] = function() {};
avocado.transporter.module.create('reflection/process', function(requires) {

requires('core/testFramework');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('process', {}, {category: ['avocado', 'reflection']});

  add.method('grabStack', function () {
    // Just here for convenience.
    var p = avocado.process.create().trimLeaves(1);
    avocado.ui.grab(p);
    return p;
  }, {category: ['avocado', 'reflection']});

});


thisModule.addSlots(avocado.process, function(add) {

  add.method('create', function () {
    return Object.newChildOf(this, arguments.callee.caller);
  }, {category: ['creating']});

  add.method('initialize', function (f) {
    this._leaf = this.contextFor(f);
  }, {category: ['creating']});

  add.creator('context', {}, {category: ['contexts']});

  add.creator('tests', Object.create(avocado.testCase), {category: ['tests']});

  add.method('leafContext', function () {
    return this._leaf;
  }, {category: ['accessing']});

  add.method('contextFor', function (f) {
    return this.context.create(f, this);
  }, {category: ['accessing']});

  add.method('inspect', function () {
    return "a process";
  }, {category: ['printing']});

  add.method('printTo', function (logger, max) {
    var c = this.leafContext();
    var i = 0;
    while (c && i++ < max) {
      c.printTo(logger);
      c = c.callerContext();
    }
  }, {category: ['printing']});

  add.method('trimLeaves', function (n) {
    for (var i = 0; i < n; ++i) {
      this._leaf = this._leaf.callerContext();
    }
    return this;
  }, {category: ['trimming']});

});


thisModule.addSlots(avocado.process.context, function(add) {

  add.method('create', function (f, p) {
    return Object.newChildOf(this, f, p);
  }, {category: ['creating']});

  add.method('initialize', function (f, p) {
    this._function = f;
    this._process = p;
    
    this._args = $A(this._function.arguments);
    var caller = this._function.caller;
    this._caller = caller ? this._process.contextFor(caller) : null;
  }, {category: ['creating']});

  add.method('rawFunction', function () {
    return this._function;
  }, {category: ['accessing']});

  add.method('functionMirror', function () {
    return this._functionMirror || (this._functionMirror = reflect(this._function));
  }, {category: ['accessing']});

  add.method('callerContext', function () {
    return this._caller;
  }, {category: ['accessing']});

  add.method('args', function () {
    return this._args;
  }, {category: ['accessing']});

  add.method('functionName', function () {
    return this.rawFunction().displayName || this.functionMirror().inspect();
  }, {category: ['accessing']});

  add.method('argNames', function () {
    var names = this._argNames;
    if (names) { return names; }
    var regex = /\(([^(]*)\)/;
    var functionString = this._function.toString();
    var match = regex.exec(functionString);
    if (! match) { throw new Error("Cannot find argument names of function: " + functionString); }
    var argsString = match[1].strip();
    if (argsString.length === 0) {
      names = []
    } else {
      names = argsString.split(',').map(function(s) { return s.strip(); });
    }
    this._argNames = names;
    return names;
  }, {category: ['accessing']});

  add.method('toString', function () {
    return this.functionName();
  }, {category: ['printing']});

  add.method('inspect', function () {
    return this.toString();
  }, {category: ['printing']});

  add.method('printTo', function (logger) {
    logger.log(this.inspect());
  }, {category: ['printing']});

  add.method('commandToGrabAllArgs', function () {
    return avocado.command.create("arguments", function(evt) { avocado.ui.grab(reflect(this.args()), evt); }, this);
  }, {category: ['user interface']});

  add.method('commandToGrabArg', function (i) {
    return avocado.command.create(this.argNames()[i], function(evt) { avocado.ui.grab(reflect(this.args()[i]), evt); }, this);
  }, {category: ['user interface']});

});


thisModule.addSlots(avocado.process.tests, function(add) {

  add.method('simpleNestingA', function (x) {
    return this.simpleNestingB(x + 4, 'neat');
  });

  add.method('simpleNestingB', function (y, z) {
    return this.simpleNestingC('a', 'b', 'c');
  });

  add.method('simpleNestingC', function () {
    return this.simpleNestingD(111);
  });

  add.method('simpleNestingD', function () {
    return avocado.process.create();
  });

  add.method('testCallStack', function () {
    var p = this.simpleNestingA(3);
    var c = p.leafContext();
    this.assertEqual("simpleNestingD", c.functionName());
    this.assertEqual([111], c.args());
    this.assertEqual([], c.argNames());
    c = c.callerContext();
    this.assertEqual("simpleNestingC", c.functionName());
    this.assertEqual(['a', 'b', 'c'], c.args());
    this.assertEqual([], c.argNames());
    c = c.callerContext();
    this.assertEqual("simpleNestingB", c.functionName());
    this.assertEqual([7, 'neat'], c.args());
    this.assertEqual(['y', 'z'], c.argNames());
    c = c.callerContext();
    this.assertEqual("simpleNestingA", c.functionName());
    this.assertEqual([3], c.args());
    this.assertEqual(['x'], c.argNames());
    c = c.callerContext();
    this.assertEqual("testCallStack", c.functionName());
    this.assertEqual([], c.args());
    this.assertEqual([], c.argNames());
  });

});


});

avocado.transporter.module.onLoadCallbacks["reflection/remote_reflection"] = function() {};
avocado.transporter.module.create('reflection/remote_reflection', function(requires) {

requires('reflection/mirror');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('remoteMirror', Object.create(avocado.mirror), {category: ['reflection', 'remote']});

});


thisModule.addSlots(avocado.remoteMirror, function(add) {

  add.method('initialize', function (server, remoteOIDOrPrimitive, type) {
    this._server = server;
    this._remoteOIDOrPrimitive = remoteOIDOrPrimitive;
    this._type = type;
    this._contentsByName = {};
    this._typesByName = {};
  }, {category: ['creating']});

  add.creator('tests', Object.create(avocado.testCase), {category: ['tests']});

  add.method('reflectee', function () {
    throw new Error('Cannot access reflectee of a remote object');
  }, {category: ['accessing']});

  add.method('storeStringNeeds', function () {
    return avocado.remoteMirror;
  }, {category: ['transporting']});

  add.method('remoteOIDOrPrimitive', function () {
    return this._remoteOIDOrPrimitive;
  }, {category: ['numbers']});

  add.method('primitiveReflectee', function () {
    if (this.hasOID()) { throw new Error("not a primitive"); }
    return this._remoteOIDOrPrimitive;
  }, {category: ['numbers']});

  add.method('remoteOID', function () {
    if (! this.hasOID()) { throw new Error("not an object"); }
    return this._remoteOIDOrPrimitive;
  }, {category: ['accessing']});

  add.method('hasOID', function () {
    return this.canHaveSlots();
  }, {category: ['testing']});

  add.method('server', function () {
    return this._server;
  }, {category: ['accessing']});

  add.method('updateContentsAndTypes', function (contentsByName, typesByName) {
    this._contentsByName = contentsByName;
    this._typesByName = typesByName;
  }, {category: ['updating']});

  add.method('equals', function (m) {
    if (!m) { return false; }
    if (typeof(m.server) !== 'function') { return false; }
    if (typeof(m.remoteOIDOrPrimitive) !== 'function') { return false; }
    if (typeof(m.reflecteeType) !== 'function') { return false; }
    return this.remoteOIDOrPrimitive() === m.remoteOIDOrPrimitive() && this.reflecteeType() === m.reflecteeType() && this.server() === m.server();
  }, {category: ['comparing']});

  add.method('hashCode', function () {
    return avocado.identityHashFor(this.remoteOIDOrPrimitive());
  }, {category: ['comparing']});

  add.method('isRootOfGlobalNamespace', function () {
    return false; // aaa for now;
  }, {category: ['naming']});

  add.method('reflecteeToString', function () {
    return ""; // aaa do a remote call?;
  }, {category: ['naming']});

  add.method('inspect', function ($super) {
    return [$super(), " (on ", this._server.inspect(), ")"].join("");
  }, {category: ['naming']});

  add.method('realSlotNameFor', function (n) {
    if (n.substring(0, 5) !== 'slot_') { throw new Error("Assertion failure: why doesn't it start with 'slot_'?"); }
    return n.substring(5);
  }, {category: ['accessing slot contents']});

  add.method('eachNormalSlotName', function (f) {
    reflect(this._contentsByName).eachNormalSlotName(function (key) {
      var n = this.realSlotNameFor(key);
      if (n !== '__annotation__' && n !== '__proto__') {
        f(n);
      }
    }.bind(this));
  }, {category: ['iterating']});

  add.method('contentsAt', function (n) {
    var key = 'slot_' + n;
    return this._server.mirrorForOIDAndType(this._contentsByName[key], this._typesByName[key]);
  }, {category: ['accessing slot contents']});

  add.method('setContentsAt', function (n, mir) {
    this._server.setSlotContents(this.remoteOID(), n, mir.remoteOIDOrPrimitive(), mir.reflecteeType());
  }, {category: ['accessing slot contents']});

  add.method('removeSlotAt', function (n) {
    this._server.removeSlot(this.remoteOID(), n);
  }, {category: ['accessing slot contents']});

  add.method('reflecteeObjectHasOwnProperty', function (n) {
    return this._contentsByName.hasOwnProperty('slot_' + n);
  }, {category: ['accessing reflectee']});

  add.method('reflecteeType', function () {
    return this._type;
  }, {category: ['accessing']});

  add.method('canAccessParent', function () {
    return this.hasOID(); // aaa for now, can't access Number.prototype, String.prototype, etc.;
  }, {category: ['testing']});

  add.method('isReflecteeNull', function () {
    return this._remoteOIDOrPrimitive === null;
  }, {category: ['testing']});

  add.method('isReflecteeArray', function () {
    return this.reflecteeType() === 'object' && this.reflecteeHasOwnProperty('length'); // aaa reasonable approximation for now;
  }, {category: ['testing']});

  add.method('isReflecteeSimpleMethod', function () {
    return false; // aaa for now;
  }, {category: ['testing']});

  add.method('isReflecteeProbablyAClass', function () {
    return false; // aaa for now;
  }, {category: ['testing']});

  add.method('reflecteeLength', function () {
    return this.contentsAt('length').primitiveReflectee();
  }, {category: ['arrays']});

  add.method('getExistingAnnotation', function () {
    return null; // aaa how do we do annotations?;
  }, {category: ['annotations']});

});


thisModule.addSlots(avocado.remoteMirror.tests, function(add) {

  add.method('testSimpleObject', function () {
    var s = avocado.mockRemoteObjectServer.create();
    s.addObject({x: 3, y: 4});
    s.rootOID(function(rootOID) {
      this.assertEqual(0, rootOID);
      var rootMir = s.mirrorForOIDAndType(rootOID, 'object');
      this.assertEqual(['x', 'y'], rootMir.normalSlotNames().toArray());
      // avocado.ui.grab(rootMir);
    }.bind(this));
  });

});


thisModule.addSlots(avocado, function(add) {

  add.creator('remoteObjectServer', {}, {category: ['reflection', 'remote']});

});


thisModule.addSlots(avocado.remoteObjectServer, function(add) {

  add.method('create', function () {
    var c = Object.create(this);
    c.initialize.apply(c, arguments);
    return c;
  }, {category: ['creating']});

  add.method('initialize', function () {
    this._cachedMirrors = avocado.set.copyRemoveAll();
  }, {category: ['creating']});

  add.method('mirrorForOIDAndType', function (oid, t) {
    var mir = Object.newChildOf(avocado.remoteMirror, this, oid, t);
    var existingMir = this._cachedMirrors.entryForKey(mir);
    if (existingMir) { return existingMir; }
    this._cachedMirrors.add(mir);
    this.updateMirror(mir);
    return mir;
  });

  add.method('updateMirror', function (mir) {
    this.getObjectContents(mir.remoteOIDOrPrimitive(), mir.reflecteeType(), function(contentsByName, typesByName) {
      mir.updateContentsAndTypes(contentsByName, typesByName);
    });
  }, {category: ['updating']});

});


thisModule.addSlots(avocado, function(add) {

  add.creator('mockRemoteObjectServer', Object.create(avocado.remoteObjectServer), {category: ['reflection', 'remote']});

});


thisModule.addSlots(avocado.mockRemoteObjectServer, function(add) {

  add.data('_nextOID', 0);

  add.method('initialize', function ($super) {
    $super();
    this._objectsByOID = [];
    this._oidsByObject = Object.newChildOf(avocado.dictionary, avocado.dictionary.identityComparator);
  }, {category: ['creating']});

  add.method('inspect', function () {
    return "mock server";
  }, {category: ['printing']});

  add.method('addObject', function (o) {
    var remoteOID = this._nextOID++;
    this._objectsByOID[remoteOID] = o;
    this._oidsByObject.put(o, remoteOID);
    return remoteOID;
  }, {category: ['mocking']});

  add.method('rootOID', function (callback) {
    // aaa not right, obviously
    callback(0);
  }, {category: ['remote protocol']});

  add.method('getObjectContents', function (oidOrPrimitive, type, callback) {
    var localObj = (type === 'function' || (type === 'object' && oidOrPrimitive !== null)) ? this.objectForOID(oidOrPrimitive) : oidOrPrimitive;
    var localMir = reflect(localObj);
    var contentsByName = {};
    var typesByName = {};
    localMir.slots().each(function(s) {
      var n = 'slot_' + s.name();
      var c = s.contents().reflectee();
      contentsByName[n] = this.oidOrPrimitiveForObject(c);
      typesByName[n] = typeof(c);
    }.bind(this));
    callback(contentsByName, typesByName);
  }, {category: ['remote protocol']});

  add.method('objectForOID', function (oid) {
    return this._objectsByOID[oid];
  }, {category: ['mocking']});

  add.method('isPrimitive', function (obj) {
    var t = typeof(obj);
    return ! (t === 'function' || (t === 'object' && obj !== null));
  }, {category: ['mocking']});

  add.method('oidOrPrimitiveForObject', function (obj) {
    if (this.isPrimitive(obj)) {
      return obj;
    } else {
      return this._oidsByObject.getOrIfAbsent(obj, function() { return this.addObject(obj); }.bind(this));
    }
  }, {category: ['mocking']});

  add.method('setSlotContents', function (remoteOID, n, contentsRemoteOID, contentsType, callback) {
    var v;
    if (contentsType === 'function' || (contentsType === 'object' && contentsRemoteOID !== null)) {
      v = this.objectForOID(contentsRemoteOID);
    } else {
      v = contentsRemoteOID;
    }
    reflect(this.objectForOID(remoteOID)).setContentsAt(n, reflect(v));
    if (callback) { callback(); }
  }, {category: ['remote protocol']});

  add.method('removeSlot', function (remoteOID, n, callback) {
    reflect(this.objectForOID(remoteOID)).removeSlotAt(n);
    if (callback) { callback(); }
  }, {category: ['remote protocol']});

});


});

avocado.transporter.module.onLoadCallbacks["reflection/vocabulary"] = function() {};
avocado.transporter.module.create('reflection/vocabulary', function(requires) {

requires('reflection/mirror');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('vocabulary', {}, {category: ['reflection']}, {comment: 'If you\'ve got a better name for this object, I\'m open to suggestions.\nThe idea is that this represents every message an object understands.'});

});


thisModule.addSlots(avocado.vocabulary, function(add) {

  add.method('create', function (mir) {
    return Object.newChildOf(this, mir);
  }, {category: ['creating']});

  add.method('initialize', function (mir) {
    this._mirror = mir;
  }, {category: ['creating']});

  add.method('mirror', function () { return this._mirror; }, {category: ['accessing']});

  add.method('equals', function (other) {
    if (!other) { return false; }
    if (this.mirror !== other.mirror) { return false; }
    return this.mirror().equals(other.mirror());
  }, {category: ['comparing']});

  add.method('hashCode', function () {
    return "vocabulary for " + this.mirror().hashCode();
  }, {category: ['comparing']});

  add.method('inspect', function () {
    return "vocabulary for " + this.mirror().inspect();
  }, {category: ['printing']});

  add.method('toString', function () {
    return this.inspect();
  }, {category: ['printing']});

});


});

avocado.transporter.module.onLoadCallbacks["reflection/category"] = function() {};
avocado.transporter.module.create('reflection/category', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('category', {}, {category: ['reflection']});

});


thisModule.addSlots(avocado.category, function(add) {

  add.creator('ofAParticularMirror', {}, {category: ['prototypes']});

});


thisModule.addSlots(avocado.category.ofAParticularMirror, function(add) {

  add.method('create', function (mir, parts) {
    return Object.newChildOf(this, mir, parts);
  }, {category: ['creating']});

  add.method('initialize', function (mir, parts) {
    this._mirror = mir;
    this._parts = parts;
    // aaa HACK why are we getting an undefined in the first place? And why only in JSQuiche, not the regular Avocado?
    for (var i = 0, n = parts.length; i < n; ++i) { if (parts[i] === undefined) { parts[i] = "undefined"; } }
  }, {category: ['creating']});

  add.method('mirror', function () { return this._mirror; }, {category: ['accessing']});

  add.method('holder', function () { return this._mirror; }, {category: ['accessing']});

  add.method('category', function () { return this; }, {category: ['accessing']});

  add.method('toString', function () { return this.fullName(); }, {category: ['printing']});

  add.method('immediateName', function () { return this.lastPart(); }, {category: ['printing']});

  add.method('fullName', function () { return this._parts.join(" "); }, {category: ['printing']});

  add.method('sortOrder', function () { return this.isRoot() ? '' : this.lastPart().toLowerCase(); }, {category: ['sorting']});

  add.method('part', function (i) {
    if (this.isRoot()) { return ""; }
    return this._parts[i];
  }, {category: ['accessing']});

  add.method('parts', function () { return this._parts; }, {category: ['accessing']});

  add.method('isRoot', function () { return this._parts.length === 0; }, {category: ['testing']});

  add.method('copy', function () {
    return avocado.category.ofAParticularMirror.create(this.mirror(), this.parts().map(function(p) { return p; }));
  }, {category: ['copying']});

  add.method('equals', function (c) {
    if (!c) { return false; }
    if (typeof(c.mirror) !== 'function') { return false; }
    if (typeof(c.parts) !== 'function') { return false; }
    if (! this.mirror().equals(c.mirror())) { return false; }
    if (this.parts().length !== c.parts().length) { return false; }
    return this.isEqualToOrSubcategoryOf(c);
  }, {category: ['comparing']});

  add.method('hashCode', function () {
    return this.mirror().hashCode() + this.parts().map(function(p) { return p.hashCode(); }).join();
  }, {category: ['comparing']});

  add.method('supercategory', function () {
    return this.otherCategoryOfSameMirror(this._parts.slice(0, this._parts.length - 1));
  }, {category: ['related categories']});

  add.method('subcategory', function (subcatName) {
    return this.otherCategoryOfSameMirror(this._parts.concat([subcatName]));
  }, {category: ['related categories']});

  add.method('supernode', function () {
    return this.supercategory();
  }, {category: ['related categories']});

  add.method('subnode', function (name) {
    return this.subcategory(name);
  }, {category: ['related categories']});

  add.method('ownerObject', function () {
    return this.isRoot() ? null : this.supercategory();
  }, {category: ['related categories']});

  add.method('ofMirror', function (mir) {
    if (mir.equals(this._mirror)) { return this; }
    return avocado.category.ofAParticularMirror.create(mir, this.parts());
  }, {category: ['related categories']});

  add.method('otherCategoryOfSameMirror', function (otherCatParts) {
    return avocado.category.ofAParticularMirror.create(this.mirror(), otherCatParts);
  }, {category: ['related categories']});

  add.method('concat', function (otherCat) {
    return this.otherCategoryOfSameMirror(this._parts.concat(otherCat.parts()));
  }, {category: ['related categories']});

  add.method('withoutFirstParts', function (n) {
    return this.otherCategoryOfSameMirror(this._parts.slice(n));
  }, {category: ['related categories']});

  add.method('lastPart', function () {
    return this.part(this._parts.length - 1);
  }, {category: ['accessing']});

  add.method('setLastPart', function (newName) {
    return this.rename(newName);
  }, {category: ['accessing']});

  add.method('addSubcategory', function () {
    var c = this.subcategory("");
    this.mirror().annotationForWriting().getCategoryCache(c.parts()); // this should make sure the category "exists"
    avocado.ui.currentWorld().morphFor(c).wasJustAdded();
    return c;
  }, {category: ['categories']});

  add.method('isImmediateSubcategoryOf', function (c) {
    if (this.parts().length !== c.parts().length + 1) { return false; }
    return this.isEqualToOrSubcategoryOf(c);
  }, {category: ['comparing']});

  add.method('isSubcategoryOf', function (c) {
    if (this.parts().length <= c.parts().length) { return false; }
    return this.isEqualToOrSubcategoryOf(c);
  }, {category: ['comparing']});

  add.method('isEqualToOrSubcategoryOf', function (c) {
    if (this.parts().length < c.parts().length) { return false; }
    for (var i = 0; i < c.parts().length; i += 1) {
      if (this.parts()[i] !== c.parts()[i]) { return false; }
    }
    return true;
  }, {category: ['comparing']});

  add.method('possiblyStaleEachSlot', function (f) {
    if (this.isRoot()) {
      this.mirror().eachFakeSlot(f);
    }
    this.mirror().possiblyStaleSlotsInCategory(this).each(f);
  }, {category: ['iterating']});

  add.method('possiblyStaleSlots', function () {
    return avocado.enumerator.create(this, 'possiblyStaleEachSlot');
  }, {category: ['accessing']});

  add.method('possiblyStaleNormalSlotsInMeAndSubcategories', function () {
    return this.mirror().possiblyStaleSlotsNestedSomewhereUnderCategory(this);
  }, {category: ['accessing']});

  add.method('rename', function (newName) {
    if (this.isRoot()) { throw "Cannot rename the root category"; }
    
    var oldCat = this.copy();
    var oldCatPrefixParts = oldCat.parts().map(function(p) {return p;});
    var slotCount = 0;
    this.possiblyStaleNormalSlotsInMeAndSubcategories().each(function(s) {
      slotCount += 1;
      var newCatParts = s.category().parts().map(function(p) {return p;});
      
      // Just for the sake of sanity, let's check to make sure this slot really is in this category.
      for (var i = 0; i < oldCatPrefixParts.length; ++i) {
        if (newCatParts[i] !== oldCatPrefixParts[i]) {
          throw new Error("Assertion failure: renaming a category, but trying to recategorize a slot that's not in that category. ('" + newCatParts[i] + "' !== '" + oldCatPrefixParts[i] + "')");
        }
      }

      newCatParts[oldCatPrefixParts.length - 1] = newName;
      var newCat = this.otherCategoryOfSameMirror(newCatParts);
      //console.log("Changing the category of " + s.name() + " from " + oldCat + " to " + newCat);
      s.setCategory(newCat);
    }.bind(this));

    this._parts = this._parts.clone();
    this._parts[this._parts.length - 1] = newName;

    this.mirror().annotationForWriting().getCategoryCache(  this.parts()); // this should make sure the new category "exists"
    this.mirror().annotationForWriting().getCategoryCache(oldCat.parts()).removeMe();
    this.mirror().justRenamedCategory(oldCat, this, slotCount === 0);
    return this;
  }, {category: ['renaming']});

  add.method('getModuleAssignedToMeImplicitly', function () {
    return this.mirror().getModuleAssignedToMeImplicitly();
  }, {category: ['modules']});

  add.method('modules', function () {
    var modules = [];
    var implicitModule = this.getModuleAssignedToMeImplicitly();
    this.possiblyStaleNormalSlotsInMeAndSubcategories().each(function(s) {
      if (! s.isFromACopyDownParent()) {
        var m = s.getModuleAssignedToMeExplicitly();
        if (!m) { m = implicitModule; }
        if (! modules.include(m)) { modules.push(m); }
      }
    });
    return modules.sort();
  }, {category: ['modules']});

  add.method('contentsSummaryString', function () {
    var modules = this.modules();
    var n = modules.length;
    if (n === 0) { return ""; }
    if (n >=  5) { return n + " modules"; }
    var s = avocado.stringBuffer.create(n === 1 ? "Module:  " : "Modules:  ");
    var sep = "";
    modules.map(function(m) { return m ? m.lastPartOfName() : '-'; }).sort().each(function(name) {
      s.append(sep).append(name);
      sep = ", ";
    });
    return s.toString();
  }, {category: ['user interface']});

  add.method('requiresContentsSummary', function () {
    if (window.isInCodeOrganizingMode) { return false; }
    return this.isRoot() || this.contentsSummaryString() !== this.supernode().contentsSummaryString();
  }, {category: ['user interface']});

  add.method('immediateContents', function () {
    return avocado.compositeCollection.create([
      this.mirror().immediateSubcategoriesOf(this),
      this.possiblyStaleSlots().sortBy(function(s) { return s.sortOrder(); })
    ]);
  }, {category: ['iterating']});

  add.method('canBeAddedToCategory', function (cat) {
    if (window.isInCodeOrganizingMode) {
      return this.possiblyStaleNormalSlotsInMeAndSubcategories().all(function(s) { return s.canBeAddedToCategory(cat); });
    } else {
      return true;
    }
  }, {category: ['testing']});

  add.method('removeSlots', function () {
    this.possiblyStaleNormalSlotsInMeAndSubcategories().each(function(slot) {
      slot.remove();
    });
  }, {category: ['removing']});

  add.method('copyToNewHolder', function () {
    return this.copyInto(reflect({}).rootCategory());
  }, {category: ['copying']});

  add.method('copyInto', function (target) {
    var targetSubcat = this.isRoot() ? target : target.subcategory(this.lastPart());
    return this.copyContentsInto(targetSubcat);
  }, {category: ['copying']});

  add.method('copyContentsInto', function (target) {
    var numPartsToLopOffTheBeginning = this.parts().length;

    this.possiblyStaleNormalSlotsInMeAndSubcategories().each(function(slot) {
      slot.copyTo(target.concat(slot.category().withoutFirstParts(numPartsToLopOffTheBeginning)));
    });
    return target;
  }, {category: ['copying']});

  add.method('commands', function () {
    var cmdList = avocado.command.list.create();
    var addCommands = [];
    if (this.mirror().canHaveSlots()) {
      if (! window.isInCodeOrganizingMode) {
        addCommands.push(avocado.command.create("function",  function(evt) { this.automaticallyChooseDefaultNameAndAddNewSlot(reflect(function() {})); }, this));
        addCommands.push(avocado.command.create("attribute", function(evt) { this.automaticallyChooseDefaultNameAndAddNewSlot(reflect(null         )); }, this));
      }
      addCommands.push(avocado.command.create("category", function(evt) { this.addSubcategory(evt); }, this));
      cmdList.addItem(["add...", addCommands]);
    }
    return cmdList;
  }, {category: ['user interface', 'commands']});

  add.method('dragAndDropCommands', function () {
    var cmdList = avocado.command.list.create(this);
    var thisCategory = this; // aaa - need to make the argSpecs use the context when calling the _acceptanceFunction
    cmdList.addItem(avocado.command.create("add slot or category", function(evt, slotOrCat) {
      var newSlotOrCat = this.equals(slotOrCat.category()) ? slotOrCat : slotOrCat.copyInto(this);
      avocado.ui.ensureVisible(newSlotOrCat, evt);
      return newSlotOrCat;
    }).setArgumentSpecs([avocado.command.argumentSpec.create('slotOrCat').onlyAccepts(function(o) {
      return o && typeof(o.canBeAddedToCategory) === 'function' && o.canBeAddedToCategory(thisCategory);
    })]));
    return cmdList;
  }, {category: ['user interface', 'drag and drop']});

  add.method('automaticallyChooseDefaultNameAndAddNewSlot', function (initialContentsMir) {
    return this.mirror().automaticallyChooseDefaultNameAndAddNewSlot(initialContentsMir, this);
  }, {category: ['user interface', 'slots']});

});


});

avocado.transporter.module.onLoadCallbacks["reflection/organization"] = function() {};
avocado.transporter.module.create('reflection/organization', function(requires) {

requires('reflection/category');
requires('core/collections/hash_table');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('abstractOrganization', {}, {category: ['reflection']});

});


thisModule.addSlots(avocado.abstractOrganization, function(add) {

  add.method('categoryForSlot', function (s) {
    return this.categoryOrNullForSlot(s) || [];
  }, {category: ['categories']});

  add.method('alphabeticallyCategorizeUncategorizedSlotsOf', function (mir) {
    var uncategorized = mir.rootCategory().subcategory("uncategorized");
    mir.normalSlots().each(function(s) {
      var c = mir.category(this.categoryForSlot(s));
      if (c.isRoot()) {
        this.setCategoryForSlot(s, uncategorized.subcategory((s.name()[0] || '_unnamed_').toUpperCase()).parts());
      }
    }.bind(this));
  }, {category: ['organizing']});

  add.method('commentForReflecteeOf', function (mir) {
    return this.commentOrNullForReflecteeOf(mir) || "";
  }, {category: ['comments']});

  add.method('commentForSlot', function (s) {
    return this.commentOrNullForSlot(s) || "";
  }, {category: ['comments']});

  add.method('findUnusedPoseName', function () {
    var i = 1;
    while (true) {
      var n = "pose " + i;
      if (! this.getPose(n)) { return n; }
      i += 1;
    }
  }, {category: ['poses']});

  add.method('promptForPoseName', function (callWhenDone) {
    avocado.ComboBoxMorph.prompt("Name this pose.", "Save pose", "Cancel", this.poses().keys().sort(), this.findUnusedPoseName(), callWhenDone);
  }, {category: ['poses']});

});


thisModule.addSlots(avocado, function(add) {

  add.creator('organization', Object.create(avocado.abstractOrganization), {category: ['reflection']});

});


thisModule.addSlots(avocado.organization, function(add) {

  add.data('current', null, {initializeTo: 'null'});

  add.method('setCurrent', function (org) {
    avocado.organization.current = org;
    org.update();
  }, {category: ['loading']});

  add.method('temporarilySetCurrent', function (org, f) {
    var previousOrg = avocado.organization.current;
    try {
      this.setCurrent(org);
      var result = f();
    } finally {
      avocado.organization.current = previousOrg;
    }
    return result;
  }, {category: ['loading']});

});


thisModule.addSlots(avocado, function(add) {

  add.creator('organizationUsingAnnotations', Object.create(avocado.abstractOrganization), {category: ['reflection']});

});


thisModule.addSlots(avocado.organizationUsingAnnotations, function(add) {

  add.method('postFileIn', function () {
    if (!avocado.organization.current) { avocado.organization.setCurrent(this); }
  }, {category: ['transporting']});

  add.method('update', function (callWhenDone) {
    // nothing to do here
    if (callWhenDone) { callWhenDone(); }
  }, {category: ['loading']});

  add.method('unlink', function () {
    // nothing to do here;
  }, {category: ['tests']});

  add.method('copyEmpty', function () {
    return this;
  }, {category: ['copying']});

  add.method('categoryOrNullForSlot', function (s) {
    if (! s.hasInheritedOrUninheritedAnnotation()) { return null; }
    return s.annotationForReading().categoryParts();
  }, {category: ['categories']});

  add.method('setCategoryForSlot', function (s, catParts) {
    s.holder().annotationForWriting().setCategoryPartsForSlotNamed(s.name(), catParts);
  }, {category: ['categories']});

  add.method('commentOrNullForReflecteeOf', function (mir) {
    var a = mir.annotationForReading();
    if (! a) { return null; }
    var c = a.getComment();
    if (c === undefined) { return null; }
    return c;
  }, {category: ['comments']});

  add.method('setCommentForReflecteeOf', function (mir, c) {
    mir.annotationForWriting().comment = c || "";
  }, {category: ['comments']});

  add.method('commentOrNullForSlot', function (s) {
    if (! s.hasInheritedOrUninheritedAnnotation()) { return null; }
    var a = s.annotationForReading();
    var c = a.getComment();
    if (c === undefined) { return null; }
    return c;
  }, {category: ['comments']});

  add.method('setCommentForSlot', function (s, c) {
    s.annotationForWriting().setComment(c);
  }, {category: ['comments']});

  add.data('_rememberedPosesByName', null, {category: ['poses'], initializeTo: 'null'});

  add.method('poses', function () {
    return this._rememberedPosesByName || (this._rememberedPosesByName = avocado.dictionary.copyRemoveAll());
  }, {category: ['poses']});

  add.method('getPose', function (poseName) {
    return this.poses().get(poseName);
  }, {category: ['poses']});

  add.method('rememberPose', function (pose) {
    this.poses().put(pose.name(), pose);
  }, {category: ['poses']});

});


thisModule.addSlots(avocado, function(add) {

  add.creator('organizationChain', Object.create(avocado.abstractOrganization), {category: ['reflection']});

});


thisModule.addSlots(avocado.organizationChain, function(add) {

  add.method('create', function (o1, o2) {
    return Object.newChildOf(this, o1, o2);
  });

  add.method('initialize', function (o1, o2) {
    this._org1 = o1;
    this._org2 = o2;
  });

  add.method('update', function (callWhenDone) {
    avocado.callbackWaiter.on(function(finalCallback) {
      this._org1.update(finalCallback());
      this._org2.update(finalCallback());
    }.bind(this), callWhenDone);
  }, {category: ['loading']});

  add.method('copyEmpty', function () {
    return avocado.organizationChain.create(this._org1.copyEmpty(), this._org2.copyEmpty());
  }, {category: ['copying']});

  add.method('unlink', function () {
    this._org1.unlink();
    this._org2.unlink();
    if (this === avocado.organization.current) { avocado.organization.current = this.copyEmpty(); }
  }, {category: ['tests']});

  add.method('categoryOrNullForSlot', function (s) {
    return this._org1.categoryOrNullForSlot(s) || this._org2.categoryOrNullForSlot(s);
  }, {category: ['categories']});

  add.method('setCategoryForSlot', function (s, catParts) {
    return this._org1.setCategoryForSlot(s, catParts);
  }, {category: ['categories']});

  add.method('commentOrNullForReflecteeOf', function (mir) {
    return this._org1.commentOrNullForReflecteeOf(mir) || this._org2.commentOrNullForReflecteeOf(mir);
  }, {category: ['comments']});

  add.method('setCommentForReflecteeOf', function (mir, c) {
    return this._org1.setCommentForReflecteeOf(mir, c);
  }, {category: ['comments']});

  add.method('commentOrNullForSlot', function (s) {
    return this._org1.commentOrNullForSlot(s) || this._org2.commentOrNullForSlot(s);
  }, {category: ['comments']});

  add.method('setCommentForSlot', function (s, c) {
    return this._org1.setCommentForSlot(s, c);
  }, {category: ['comments']});

  add.method('poses', function () {
    var poses = avocado.dictionary.copyRemoveAll();
    this._org2.poses().eachKeyAndValue(function(k, v) { poses.put(k, v); });
    this._org1.poses().eachKeyAndValue(function(k, v) { poses.put(k, v); });
    return poses;
  }, {category: ['poses']});

  add.method('getPose', function (poseName) {
    return this._org1.getPose(poseName) || this._org2.getPose(poseName);
  }, {category: ['poses']});

  add.method('rememberPose', function (pose) {
    this._org1.rememberPose(pose);
  }, {category: ['poses']});

});


});

avocado.transporter.module.onLoadCallbacks["reflection/reflection"] = function() {};
avocado.transporter.module.create('reflection/reflection', function(requires) {

requires('reflection/mirror');
requires('reflection/slot');
requires('reflection/organization');
requires('reflection/process');
requires('reflection/vocabulary');
requires('reflection/remote_reflection');

}, function(thisModule) {


});

avocado.transporter.module.onLoadCallbacks["transporter/transporter"] = function() {};
avocado.transporter.module.create('transporter/transporter', function(requires) {

requires('core/testFramework');
requires('core/notifier');
requires('reflection/reflection');
requires('transporter/writing');
requires('transporter/ordering');
requires('transporter/loading_and_saving');

}, function(thisModule) {


thisModule.addSlots(avocado.transporter, function(add) {

  add.creator('tests', Object.create(avocado.testCase), {category: ['tests']});

  add.creator('reasonsForNeedingCreatorPath', {}, {category: ['filing out']});

  add.method('addGlobalCommandsTo', function (cmdList, evt) {
    cmdList.addLine();

    cmdList.addItem(["show modules...", [
      ["changed modules", function(evt) {
        var changedOnes = avocado.transporter.module.changedOnes().toArray();
        
        // Include the Unowned Attributes if there are any.
        var unownedSlotFinder = avocado.objectGraphWalker.visitors.unownedSlotFinder.create();
        var unownedSlotsMorph = avocado.ui.worldFor(evt).morphFor(avocado.searchResultsPresenter.create(unownedSlotFinder.createWalker(), evt)).redo();
        var unownedSlotsSearcher = unownedSlotsMorph._model;
        if (unownedSlotsSearcher.results().size() > 0) {
          changedOnes.unshift(unownedSlotsSearcher);
        }
        
        if (changedOnes.size() > 0) {
          avocado.ui.showObjects(changedOnes, "changed modules", evt);
        } else {
          avocado.ui.showMessage("No changed modules to display", evt);
        }
      }],

      ["all modules", function(evt) {
        avocado.ui.showObjects(avocado.transporter.module.allModules(), "all modules", evt);
      }]
    ]]);

    var reposThatCanListFiles = avocado.transporter.availableRepositories.select(function(repo) { return repo.canListDirectoryContents; });
    if (reposThatCanListFiles.size() > 0) {
      var shouldEnableFileBrowserExperiment = false;
      if (shouldEnableFileBrowserExperiment) {
        cmdList.addItem(["browse files...", function(evt) {
          var world = avocado.ui.worldFor(evt);
          //reposThatCanListFiles.forEach(function(repo) { avocado.ui.grab(repo, evt); });
          avocado.ui.grab(new FileDirectory(new URL("http://localhost/~adam/avocado/javascripts/text/")));
          /* AAAAAAAAAAA
          var fileMorph = world.addMorphAt(world.morphFor(avocado.webdav.file.create(new URL("http://localhost/~adam/avocado/javascripts/reflection/slot.js"))), pt(100,100));
          */
        }]);
      } else {
        cmdList.addItem(["load JS file...", function(evt) {
          var cmdList = avocado.transporter.repositories.prompter.commandListForRepositories(function(repo) { return repo.menuItemsForLoadMenu(); });
          avocado.ui.showMenu(cmdList, evt.hand.world(), "From where?", evt);
        }]);
      }
    }
  }, {category: ['user interface', 'commands']});

  add.method('fileOutPlural', function (specs, evt, repo, filerOuterProto) {
    return avocado.ui.showErrorsThatOccurDuring(function(failBlock) {
      specs.each(function(spec) {
        spec.moduleVersion.fileOut(spec.filerOuter || filerOuterProto ? Object.newChildOf(filerOuterProto) : null, repo, function() {}, function(msg, errors) {
          if (errors) {
            errors.forEach(function(err) {
              var mir = err.mirrorWithoutCreatorPath;
              if (mir) {
                var module = spec.moduleVersion.module();
                var reason = err.reasonForNeedingCreatorPath || "of an unknown reason";
                err.objectsToShow = err.objectsToShow || [];
                err.objectsToShow.push(module + " needs " + mir.inspect() + " to have a creator path because " + reason);
              }
            });
          }
          failBlock(msg, errors);
        });
      });
    }.bind(this));
  }, {category: ['user interface', 'commands', 'filing out']});

  add.creator('idTracker', {}, {category: ['version IDs']});

});


thisModule.addSlots(avocado.transporter.tests, function(add) {

  add.creator('someObject', {});

  add.method('addSlot', function (m, holder, name, contents) {
    var s = reflect(holder).slotAt(name);
    s.setContents(reflect(contents));
    s.setModule(m);
    return s;
  });

  add.method('testCreatingAndDestroying', function () {
    modules['transporter/transporter'].modificationFlag(); // make sure it exists before running this test, since adding slots to someObject will end up creating it
    
    var w1 = avocado.objectGraphWalker.visitors.testingObjectGraphWalker.create().createWalker();
    w1.go();
    
    var m = avocado.transporter.module.named('blah');

    this.addSlot(m, this.someObject, 'qwerty', 3);
    
    m.uninstall();

    var w2 = avocado.objectGraphWalker.visitors.testingObjectGraphWalker.create().createWalker();
    w2.go();

    /* Useful for finding out which objects are left over, if the test below fails.
    var objs1 = w1._objectsReached.map(function(o) { return reflect(o).inspect(); }).sort();
    var objs2 = w2._objectsReached.map(function(o) { return reflect(o).inspect(); }).sort();
    for (var i = 0, n = Math.max(objs1.length, objs2.length); i < n; ++i) {
      if (objs1[i] !== objs2[i]) {
        debugger;
      }
    }

    var slots1 = w1.visitor()._slotsReached.sortBy(function(s) { return s.fullName(); });
    var slots2 = w2.visitor()._slotsReached.sortBy(function(s) { return s.fullName(); });
    for (var i = 0, n = Math.max(slots1.length, slots2.length); i < n; ++i) {
      if (! slots1[i].equals(slots2[i]) && ! slots1[i].holder().reflectee().hasOwnProperty('jsHeapSizeLimit')) { // blecch
        debugger;
      }
    }
    */
    
    this.assertEqual(w1.objectCount(), w2.objectCount(), "leftover objects after destroying a module");
    this.assertEqual(w1.visitor().slotCount(), w2.visitor().slotCount(), "leftover slots after destroying a module");
  });

  add.method('testModuleCache', function () {
    var m = avocado.transporter.module.named('test_blah');

    this.assertEqual([], m.slots().sort());

    var s1 = this.addSlot(m, this.someObject, 'qwerty', 3);
    this.assertEqual([s1], m.slots().sort());

    var s2 = this.addSlot(m, this.someObject, 'uiop', 4);
    this.assertEqual([s1, s2], m.slots().sort());

    var s3 = this.addSlot(m, this.someObject, 'zubObj', {}).beCreator();
    this.assertEqual([s1, s2, s3], m.slots().sort());

    var s31 = this.addSlot(m, this.someObject.zubObj, 'zzz', 5);
    this.assertEqual([s1, s2, s3, s31], m.slots().sort());
    
    // Try creating a slot but *not* explicitly assigning it a module; it should still be in the module, because its holder's creator slot is.
    this.someObject.zubObj.zzzzz = 6;
    var s32 = reflect(this.someObject.zubObj).slotAt('zzzzz');
    this.assertEqual(null, s32.getModuleAssignedToMeExplicitly());
    this.assertEqual(m,    s32.getModuleAssignedToMeExplicitlyOrImplicitly());
    this.assertEqual([s1, s2, s3, s31, s32], m.slots().sort());
    
    // Try creating a new sub-object but *not* explicitly assigning *any* of its slots to the module. Make sure the module cache is smart enough to find it.
    this.someObject.zubObj.zubObj2 = {};
    this.someObject.zubObj.zubObj2.zzzzzzz = 7;
    var s6 = reflect(this.someObject.zubObj).slotAt('zubObj2').beCreator();
    var s61 = reflect(this.someObject.zubObj.zubObj2).slotAt('zzzzzzz');
    this.assertEqual(null, s6.getModuleAssignedToMeExplicitly());
    this.assertEqual(m,    s6.getModuleAssignedToMeExplicitlyOrImplicitly());
    this.assertEqual(null, s61.getModuleAssignedToMeExplicitly());
    this.assertEqual(m,    s61.getModuleAssignedToMeExplicitlyOrImplicitly());
    this.assertEqual([s1, s2, s3, s6, s31, s32, s61], m.slots().sort());
    

    var n1 = new DOMParser().parseFromString('<abc def="ghi"><xyz></xyz></abc>', 'text/xml').documentElement;
    var n2 = n1.firstChild;
    var s4 = this.addSlot(m, this.someObject, 'node1', n1);
    var s5 = this.addSlot(m, this.someObject, 'node2', n2);
    this.assertEqual([s4, s5, s1, s2, s3, s6, s31, s32, s61], m.slots().sort());

    m.uninstall();
  });

  add.method('testChangeMarking', function () {
    var m1 = avocado.transporter.module.named('test_blah1');
    var m2 = avocado.transporter.module.named('test_blah2');

    this.assert(! m1.modificationFlag().hasJustThisOneChanged());
    this.assert(! m2.modificationFlag().hasJustThisOneChanged());

    var s1 = this.addSlot(m1, this.someObject, 'qwerty', 3);
    this.assert(  m1.modificationFlag().hasJustThisOneChanged());
    this.assert(! m2.modificationFlag().hasJustThisOneChanged());
    
    m1.markAsUnchanged();
    this.assert(! m1.modificationFlag().hasJustThisOneChanged());

    var s2 = this.addSlot(m2, this.someObject, 'uiop', 4);
    this.assert(! m1.modificationFlag().hasJustThisOneChanged());
    this.assert(  m2.modificationFlag().hasJustThisOneChanged());

    m1.uninstall();
    m2.uninstall();
  });

  add.method('testRenaming', function () {
    var m = avocado.transporter.module.named('test_blah');

    var s1 = this.addSlot(m, this.someObject, 'qwerty', {}).beCreator();
    var s2 = this.addSlot(m, this.someObject.qwerty, 'uiop', 4);

    this.assertEqual("test_blah", m.name());
    this.assert(s1.isIncludedInModule(m));
    this.assert(s2.isIncludedInModule(m));
    this.assertEqual(2, m.slots().size());
    m.rename("test_argleBargle");
    this.assertEqual("test_argleBargle", m.name());
    this.assert(s1.isIncludedInModule(m));
    this.assert(s2.isIncludedInModule(m));
    this.assertEqual(2, m.slots().size());
    this.assertEqual(m, avocado.transporter.module.existingOneNamed('test_argleBargle'));
    this.assert(! avocado.transporter.module.existingOneNamed('test_blah'));

    var m2 = avocado.transporter.module.named('test_blah');
    this.assertEqual(0, m2.slots().size());
    this.assertThrowsException(function() { m.rename("test_argleBargle"); });

    m.uninstall();
    m2.uninstall();
  });

  add.method('testTransportableInfo', function () {
    var m = avocado.transporter.module.named('test_blah');

    var s1 = this.addSlot(m, this.someObject, 'qwerty', {});
    s1.beCreator();

    var sp = reflect(this.someObject.qwerty).parentSlot();
    sp.setContents(reflect({}));
    sp.beCreator();

    this.assertEqual("{}",                sp.transportableInfo().contentsExpr);
    this.assertEqual("Object.create({})", s1.transportableInfo().contentsExpr);

    // aaa - lots more stuff I could test - this is actually an awesome place to test the transporter

    m.uninstall();
  });

  add.method('testOrderingForFilingOut', function () {
    var m = avocado.transporter.module.named('test_blah');

    var s1 = this.addSlot(m, this.someObject, 'qwerty', {});
    s1.beCreator();
    var s2 = this.addSlot(m, this.someObject.qwerty, 'uiop', 3);
    this.assertEqual([s1, s2], m.slotsInOrderForFilingOut());

    var sp = reflect(this.someObject.qwerty).parentSlot();
    sp.setContents(reflect({}));
    sp.beCreator();
    this.assertEqual(sp, sp.contents().theCreatorSlot());
    m.slotsInOrderForFilingOut();

    m.uninstall();
  });

  add.method('testFilingOutArrays', function () {
    var m = avocado.transporter.module.named('test_array_fileout');

    var s1 = this.addSlot(m, this.someObject, 'anArrayToFileOut', ['a', 2, 'three']).beCreator();
    var a = s1.contents();
    var indexables = [a.slotAt('0'), a.slotAt('1'), a.slotAt('2')];
    this.assertEqual([s1].concat(indexables), m.slotsInOrderForFilingOut());
    this.assertEqual([s1], m.slotsInMirror(reflect(this.someObject)).toArray());
    this.assertEqual(indexables, m.slotsInMirror(a).toArray());

    this.assertEqual(
"start module test_array_fileout\n" +
"  start object avocado.transporter.tests.someObject\n" +
"    slot anArrayToFileOut: []\n" +
"  end object avocado.transporter.tests.someObject\n" +
"  start object avocado.transporter.tests.someObject.anArrayToFileOut\n" +
"    slot 0: 'a'\n" +
"    slot 1: 2\n" +
"    slot 2: 'three'\n" +
"  end object avocado.transporter.tests.someObject.anArrayToFileOut\n",
    m.codeOfMockFileOut());

    m.uninstall();
  });

  add.method('testFilingOutReferencesToInternalsOfIntensionallySavedObjects', function () {
    // aaa - Not working yet. -- August 29, 2011
    
    
    var m1 = avocado.transporter.module.named('test_refs_to_intensional_internals_1');
    var m2 = avocado.transporter.module.named('test_refs_to_intensional_internals_2');

    this.addSlot(m1, this.someObject, 'objWithStoreString', {}).beCreator();
    this.addSlot(m1, this.someObject.objWithStoreString, 'initialize', function(x) { this._internalObj = {x: x}; reflect(this).slotAt('_internalObj').beCreator(); }).beCreator();
    this.addSlot(m1, this.someObject.objWithStoreString, 'storeString', function() { return 'Object.newChildOf(avocado.transporter.tests.someObject.objWithStoreString, ' + this._internalObj.x + ')'; }).beCreator();
    this.addSlot(m1, this.someObject.objWithStoreString, 'storeStringNeeds', function() { return avocado.transporter.tests.someObject.objWithStoreString; }).beCreator();
    
    this.addSlot(m2, this.someObject, 'childOfObjWithStoreString', Object.newChildOf(avocado.transporter.tests.someObject.objWithStoreString, 33)).beCreator();
    this.addSlot(m2, this.someObject, 'refToInternalObj', avocado.transporter.tests.someObject.childOfObjWithStoreString._internalObj);
    
    var code = m2.codeOfMockFileOut();
    this.assertEqual(
"start module test_refs_to_intensional_internals_2\n" +
"  start object avocado.transporter.tests.someObject\n" +
"    slot childOfObjWithStoreString: Object.newChildOf(avocado.transporter.tests.someObject.objWithStoreString, 33)\n" +
"    slot refToInternalObj: avocado.transporter.tests.someObject.childOfObjWithStoreString._internalObj\n" +
"  end object avocado.transporter.tests.someObject\n",
    code);

    m2.uninstall();
    m1.uninstall();
  });

  add.method('obsolete_testObjectsWithNoCreatorPath', function () {
    // aaa - This test is obsolete, but we should do something similar to test the trash-can warning, once we've implemented that. -- Adam, Mar. 2011
    var m = avocado.transporter.module.named('test_non_well_known_objects');

    var o = {};
    var oMir = reflect(o);
    var s1 = this.addSlot(m, o, 'x', 3);
    var s2 = this.addSlot(m, o, 'y', 'four');
    
    var fo = avocado.transporter.module.filerOuters.mock.create();
    m.codeToFileOut(fo);
    this.assertEqual(1, fo.errors().length);
    this.assertEqual(oMir, fo.errors()[0].mirrorWithoutCreatorPath);
    this.assertEqual(avocado.transporter.reasonsForNeedingCreatorPath.objectContainsSlotInTheModule.create(s1), fo.errors()[0].reasonForNeedingCreatorPath);
    
    m.uninstall();
  });

  add.method('obsolete_testObjectsThatHaveParentsWithNoCreatorPath', function () {
    // aaa - This test is obsolete too.
    
    var m = avocado.transporter.module.named('test_non_well_known_parents');

    var p = {};
    var o = Object.create(p);
    var pMir = reflect(p);
    var oMir = reflect(o);
    var s1 = this.addSlot(m, o, 'x', 3);
    var s2 = this.addSlot(m, this.someObject, 'pleh', o);
    s2.beCreator();
    
    var fo = avocado.transporter.module.filerOuters.mock.create();
    m.codeToFileOut(fo);
    this.assertEqual(1, fo.errors().length);
    this.assertEqual(pMir, fo.errors()[0].mirrorWithoutCreatorPath);
    // aaa - fix this and put it back in; it's the right idea, just gotta fix the details, don't have time right now
    // this.assertEqual(avocado.transporter.reasonsForNeedingCreatorPath.ancestorOfObjectCreatedInTheModule.create(oMir), fo.errors()[0].reasonForNeedingCreatorPath);
    
    m.uninstall();
  });

  add.method('testFilingOutToJSON', function () {
    var m = avocado.transporter.module.named('test_JSON_fileout');
    
    this.addSlot(m, this.someObject, 'x', 123);
    this.addSlot(m, this.someObject, 'a', ['a', 2, 'three', false]).beCreator();
    this.addSlot(m, this.someObject, 's', 'pleh');
    this.addSlot(m, this.someObject, 'b', true);
    this.addSlot(m, this.someObject, 'o', {n: 456}).beCreator();
    this.addSlot(m, this.someObject, 'r', avocado.transporter.tests);
    
    var fo = avocado.transporter.module.filerOuters.json.create();
    fo.fileOutSlots(reflect(this.someObject).normalSlots());
    this.assertEqual([], fo.errors());
    this.assertEqual('{\n  "x": 123,\n  "a": [\n    "a",\n    2,\n    "three",\n    false\n  ],\n  "s": "pleh",\n  "b": true,\n  "o": {\n    "n": 456\n  },\n  "r__creatorPath": [\n    "avocado",\n    "transporter",\n    "tests"\n  ]\n}', fo.fullText());

    m.uninstall();
  });

});


thisModule.addSlots(avocado.transporter.idTracker, function(add) {

  add.data('latestTemporaryIDNumber', 0, {initializeTo: '0'});

  add.data('objectsByTemporaryID', {}, {initializeTo: '{}'});

  add.method('createTemporaryIDFor', function (obj) {
    var tempID = "tempID_" + (++this.latestTemporaryIDNumber);
    this.objectsByTemporaryID[tempID] = obj;
    obj.setID(tempID);
    return tempID;
  });

  add.method('recordRealID', function (tempID, realID) {
    var obj = this.objectsByTemporaryID[tempID];
    obj.setID(realID);
    delete this.objectsByTemporaryID[tempID];
    return obj;
  });

});


thisModule.addSlots(avocado.transporter.module, function(add) {

  add.method('createNewOne', function (name, repo, parentModule) {
    if (!name)         { throw new Error("Cannot create a module with no name"); }
    if (modules[name]) { throw new Error("There is already a module named " + name); }
    var module = avocado.transporter.module.named(name);
    module.setRepository(repo);
    if (!parentModule && avocado.project.current()) { parentModule = avocado.project.current().module(); }
    if (parentModule) { parentModule.addRequirement(name); }
    return module;
  }, {category: ['creating']});

  add.method('name', function () { return this._name; }, {category: ['accessing']});

  add.method('lastPartOfName', function () { return this.name().split('/').last(); }, {category: ['accessing']});

  add.method('toString', function () { return this.name(); }, {category: ['printing']});

  add.method('inspect', function () { return this.name(); }, {category: ['printing']});

  add.data('isAvocadoModule', true, {category: ['testing']});

  add.method('doesTypeMatch', function (obj) { return obj && obj.isAvocadoModule; }, {category: ['testing']});

  add.creator('prompter', {}, {category: ['user interface']});

  add.method('uninstall', function () {
    this.slots().each(function(s) { s.remove(); });
    reflect(modules).slotAt(this._name).remove();
    reflect(avocado.transporter.module.cache).slotAt(this._name).remove();
  }, {category: ['removing']});

  add.method('rename', function (newName) {
    if (this.existingOneNamed(newName)) { throw new Error("There is already a module named " + newName); }
    var oldName = this._name;
    reflect(modules                         ).slotAt(oldName).rename(newName);
    reflect(avocado.transporter.module.cache).slotAt(oldName).rename(newName);
    this._name = newName;
    this.markAsChanged();
    // aaa - should fix up the modules that depend on this one;
  }, {category: ['accessing']});

  add.method('eachRequiredModule', function (f) {
    this.requiredModules().each(f);
  }, {category: ['requirements']});

  add.data('_modificationFlag', null, {category: ['keeping track of changes'], initializeTo: 'null'});

  add.method('modificationFlag', function () {
    if (this._modificationFlag) { return this._modificationFlag; }
    var subflags = avocado.enumerator.create(this, 'eachRequiredModule').map(function(m) { return m.modificationFlag(); });
    this._modificationFlag = avocado.modificationFlag.create(this, subflags);
    return this._modificationFlag;
  }, {category: ['keeping track of changes']});

  add.method('markAsChanged', function () {
    this.modificationFlag().markAsChanged();
  }, {category: ['keeping track of changes']});

  add.method('markAsUnchanged', function () {
    this.modificationFlag().markAsUnchanged();
  }, {category: ['keeping track of changes']});

  add.method('whenChangedNotify', function (observer) {
    this.modificationFlag().notifier().addObserver(observer);
  }, {category: ['keeping track of changes']});

  add.method('canBeFiledOut', function () {
    var r = this.repository();
    return r && r.canFileOutIndividualModules();
  }, {category: ['transporting']});

  add.method('currentVersion', function () {
    if (! this._currentVersion) { this.setCurrentVersion(this.version.create(this)); }
    return this._currentVersion;
  }, {category: ['versions']});

  add.method('createNewVersion', function () {
    this.setCurrentVersion(this.version.create(this, [this.currentVersion()]));
    avocado.transporter.idTracker.createTemporaryIDFor(this._currentVersion);
    return this._currentVersion;
  }, {category: ['versions']});

  add.method('requiredModules', function () {
    return this.requirements().map(function(mName) { return modules[mName]; }).compact();
  }, {category: ['requirements']});

  add.method('createNewOneRequiredByThisOne', function (name) {
    return avocado.transporter.module.createNewOne(name, this.repository(), this);
  }, {category: ['creating']});

  add.method('repository', function () {
    return this._repository;
  }, {category: ['accessing']});

  add.method('slots', function () {
    return avocado.enumerator.create(this, 'eachSlot');
  }, {category: ['accessing']});

  add.method('eachSlotInMirror', function (mir, f) {
    // We used to keep going and treat this as an error, but it got annoying and unusable;
    // we need to be able to just unhook an object from the well-known tree and assume that
    // it won't be saved anymore. So the plan now is to just offer a warning when putting the
    // mirror morph in the trash.
    if (! mir.isWellKnown('probableCreatorSlot')) { return; }
    
    if (mir.isReflecteeDOMNode()) {
      // Treat DOM nodes specially because they're a big mess. Don't follow the normal slots,
      // but do use these magic domChildNode slots. -- Adam, July 2011
      var cs = mir.theCreatorSlot();
      if (cs && cs.isIncludedInModule(this) && cs.contents().equals(mir)) {
        mir.eachDOMChildNode(f);
      }
    } else {
      mir.normalSlots().each(function(s) {
        if (s.isIncludedInModule(this)) {
          f(s);
        }
      }.bind(this));
    }
  }, {category: ['iterating']});

  add.method('slotsInMirror', function (mir) {
    return avocado.enumerator.create(this, 'eachSlotInMirror', mir);
  }, {category: ['accessing']});

  add.method('eachSlot', function (f) {
    var walker = avocado.transporter.module.slotFinder.create(this).createWalker();
    var rootSlots = this.slotCollection().explicitlyIncludedSlots();
    walker.goStartingAtRootSlots(rootSlots);
    walker.results().each(f);
  }, {category: ['iterating']});

  add.method('interactiveRename', function (evt) {
    avocado.ui.prompt("New name?", function(newName) {
      avocado.ui.showMessageIfErrorDuring(function () {
        this.rename(newName);
      }.bind(this), evt);
    }.bind(this), this.name(), evt);
  }, {category: ['user interface', 'commands']});

  add.method('showAllObjects', function (evt) {
    var objectsToShow = [this];
    var holderMirrors = avocado.set.copyRemoveAll();
    this.eachSlot(function(s) { holderMirrors.add(s.holder()); });
    holderMirrors.toArray().sort().each(function(mir) { objectsToShow.push(mir); });
    avocado.ui.showObjects(objectsToShow, "objects in module " + this.name(), evt);
  }, {category: ['user interface', 'commands']});

  add.method('commands', function () {
    var cmdList = avocado.command.list.create(this);
    cmdList.addItem({id: 'save', label: 'save as .js file', go: this.fileOutAndReportErrors, isApplicable: this.canBeFiledOut.bind(this)});
    // aaa - not working yet: cmdList.addItem({label: 'email me the source', go: this.emailTheSource, isApplicable: this.canBeFiledOut.bind(this)});

    cmdList.addItem({label: 'print to console', go: this.printToConsole});
    cmdList.addItem({label: 'forget I was changed', go: function(evt) { this.markAsUnchanged(); }, isApplicable: function() { return this.modificationFlag().hasJustThisOneChanged(); }.bind(this)});

    cmdList.addLine();

    cmdList.addItem({label: 'rename',            go: this.interactiveRename});
    cmdList.addItem({label: 'get module object', go: function(evt) { avocado.ui.grab(reflect(this), evt); }});

    cmdList.addLine();

    cmdList.addItem({label: 'all objects', go: this.showAllObjects});
    return cmdList;
  }, {category: ['user interface', 'commands']});

  add.method('buttonCommands', function () {
    return avocado.command.list.create(this, [
      avocado.command.create('Save as .js file', this.fileOutAndReportErrors).onlyApplicableIf(this.canBeFiledOut.bind(this))
    ]);
  }, {category: ['user interface', 'commands']});

  add.method('eachModule', function (f) {
    reflect(modules).normalSlots().each(function(s) { f(s.contents().reflectee()); });
  }, {category: ['iterating']});

  add.method('allModules', function () {
    return avocado.enumerator.create(this, 'eachModule');
  }, {category: ['iterating']});

  add.method('changedOnes', function () {
    return this.allModules().select(function(m) { return m.modificationFlag().hasJustThisOneChanged(); });
  }, {category: ['keeping track of changes']});

  add.creator('slotFinder', Object.create(avocado.objectGraphWalker.visitors.general), {category: ['finding all slots']});

});


thisModule.addSlots(avocado.transporter.module.prompter, function(add) {

  add.method('prompt', function (caption, context, evt, callback) {
    this.chooseOrCreateAModule(evt, context.likelyModules(), context, caption, function(m, evt) { callback(m); });
  });

  add.method('chooseOrCreateAModule', function (evt, likelyModules, target, menuCaption, callback) {
    var modulesCmdList = this.commandListForChoosingOrCreatingAModule(evt, likelyModules, target, callback);
    avocado.ui.showMenu(modulesCmdList, target, menuCaption, evt);
  });

  add.method('commandListForChoosingOrCreatingAModule', function (evt, likelyModules, target, callback) {
    var cmdList = avocado.command.list.create();
    cmdList.addItem(["new module...", function(evt) { this.createAModule(evt, target, callback); }.bind(this)]);
    cmdList.addLine();
    if (likelyModules.length > 0 && likelyModules.length < 8) {
      likelyModules.each(function(m) {
        if (m) { cmdList.addItem([m.name(), function(evt) { callback(m, evt); }]); }
      });
      cmdList.addLine();
    }
    cmdList.addItems(avocado.dictionary.menuItemsForPathTree(this.modulePathTree(), evt, callback));
    return cmdList;
  });

  add.method('modulePathTree', function () {
    return avocado.dictionary.createPathTree(avocado.transporter.module.allModules().map(function(m) { return { object: m, path: m.name().split('/') }; }));
  }, {category: ['module tree']});

  add.method('createAModule', function (evt, target, callback) {
    avocado.transporter.repositories.prompter.prompt('Which server should the new module live on?', target, evt, function(repo, evt) {
      avocado.ui.prompt("Module name?", function(name) {
        callback(avocado.transporter.module.createNewOne(name, repo), evt);
      }, null, evt);
    });
  });

});


thisModule.addSlots(avocado.transporter.module.slotFinder, function(add) {

  add.method('initialize', function ($super, module) {
    $super();
    this._module = module;
  });

  add.method('createWalker', function ($super) {
    return $super().setShouldWalkIndexables(true).useDOMChildNodePseudoSlots();
  });

  add.data('_resultsAreSlots', true);

  add.method('shouldContinueRecursingIntoObject', function (object, objectAnno, howDidWeGetHere) {
    var mir = reflect(object);
    if (mir.reflecteeStoreString()) { return false; }
    if (mir.isReflecteeSimpleMethod()) { return false; }

    var cs = mir.theCreatorSlot();
    if (!cs) { return false; }
    if (howDidWeGetHere.slotName !== cs.name() || howDidWeGetHere.slotHolder !== cs.holder().reflectee()) { return false; }

    return true;
  });

  add.method('shouldIgnoreSlot', function (holder, slotName, howDidWeGetHere) {
    var slotAnno = avocado.annotator.annotationOf(holder).slotAnnotation(slotName);
    var alreadyInModule = slotAnno.getModuleAssignedToMeExplicitly();
    if (alreadyInModule && alreadyInModule !== this._module) { return true; }
    
    var slot = reflect(holder).slotAt(slotName);
    if (slot.isFromACopyDownParent()) { return true; }
    
    return false;
  });

  add.method('shouldContinueRecursingIntoSlot', function (holder, slotName, howDidWeGetHere) {
    var slot = reflect(holder).slotAt(slotName);
    if (slot.initializationExpression()) { return false; }
    
    return true;
  });

  add.method('reachedSlot', function (holder, slotName, contents) {
    if (slotName !== '__proto__') {
      this._results.push(reflect(holder).slotAt(slotName));
    }
  });

  add.method('reachedDOMChildNode', function (parentNode, index, childNode) {
    this._results.push(avocado.slots.domChildNode.create(reflect(parentNode), "childnode" + index, reflect(childNode)));
  });

});


thisModule.addSlots(avocado.annotator.slotSpecifierPrototype, function(add) {

  add.method('asSlot', function () {
    return reflect(this.holder).slotAt(this.name);
  });

});


thisModule.addSlots(avocado.transporter.slotCollection, function(add) {

  add.method('explicitlyIncludedSlots', function () {
    return this._explicitlyIncluded.map(function(slotSpec) { return slotSpec.asSlot(); });
  }, {category: ['accessing']});

});


thisModule.addSlots(avocado.transporter.module.version, function(add) {

  add.method('create', function (module, id, parentVersions) {
    return Object.newChildOf(this, module, id, parentVersions);
  }, {category: ['creating']});

  add.method('module', function () { return this._module; }, {category: ['accessing']});

  add.method('versionID', function () { return this._id; }, {category: ['accessing']});

  add.method('setID', function (id) { this._id = id; }, {category: ['accessing']});

  add.method('parentVersions', function () { return this._parentVersions; }, {category: ['accessing']});

  add.method('requiredModuleVersions', function () {
    // aaa should probably make this refer to them directly or something
    return this.module().requiredModules().map(function(m) { return m.currentVersion(); });
  }, {category: ['accessing']});

  add.method('toString', function () { return this.module().toString() + (this._id ? " version " + this._id : ""); }, {category: ['printing']});

  add.method('fileOut', function (filerOuter, repo, successBlock, failBlock) {
    var codeToFileOut;
    filerOuter = filerOuter || Object.newChildOf(this.module().filerOuters.normal);
    try {
      codeToFileOut = this.module().codeToFileOut(filerOuter).toString();
      var errors = filerOuter.errors();
      if (errors.length > 0) {
        return failBlock(errors.length.toString() + " error" + (errors.length === 1 ? "" : "s") + " trying to file out " + this.module(), errors);
      }
    } catch (ex) {
      return failBlock(ex, [ex]);
    }
    avocado.transporter.fileOut(this, repo, codeToFileOut, successBlock, failBlock);
  }, {category: ['transporting']});

});


thisModule.addSlots(avocado.slots['abstract'], function(add) {

  add.method('transportableInfo', function () {
    var contents = this.contents();
    var info = {
      name: this.name(),
      creationMethod: "data",
      contentsExpr: undefined,
      rawAnnotation: this.annotationIfAny && this.annotationIfAny() && this.annotationIfAny().asRawDataObject(),
      contentsRawAnnotation: contents.annotationForReading() && contents.annotationForReading().asRawDataObject(),
      isCreator: false,
      isReferenceToWellKnownObjectThatIsCreatedElsewhere: false,
      isHardWired: this.isHardWired()
    };
    var array = null;
    var initializer = this.initializationExpression();
    if (initializer) {
      info.contentsExpr = initializer;
    } else {
      var storeString = contents.reflecteeStoreString();
      if (storeString) {
        info.contentsExpr = storeString;
      } else if (! contents.canHaveCreatorSlot()) {
        info.contentsExpr = contents.expressionEvaluatingToMe();
      } else {
        var chain = contents.creatorSlotChain('probableCreatorSlot');
        var cs = chain ? chain[0] : null;
        var remoteRef = contents.reflecteeRemoteReference();
        if (!chain && remoteRef) {
          info.remoteReference = remoteRef;
        } else {
          if (!chain) {
            // console.log("Marking " + this.name() + " as a possible creator slot.");
            this.beCreator(); // aaa - not sure this is a good idea, but maybe
            cs = contents.theCreatorSlot();
            if (!cs) {
              var error = new Error("Why is there no creator? Something is wrong.");
              error.objectsToShow = [contents];
              throw error;
            }
            
            /* Old code, remove it if the new automatically-make-it-a-possible-creator mechanism seems to be working. -- Adam, Mar. 2011
            var err = new Error("Cannot file out a reference to an object without a creator slot: " + contents.name());
            err.mirrorWithoutCreatorPath = contents;
            err.objectsToShow = [contents];
            err.reasonForNeedingCreatorPath = "it is referenced from " + this.holder().name() + "." + this.name();
            throw err;
            */
          }
          
          if (! cs.equals(this)) {
            avocado.transporter.reasonsForNeedingCreatorPath.recordIfExceptionDuring(function() {
              info.contentsExpr = contents.expressionForCreatorSlotChain(chain);
              info.isReferenceToWellKnownObjectThatIsCreatedElsewhere = chain.map(function(s) { return s.name(); }).reverse();
              if (this.isDOMChildNode()) { info.creationMethod = 'domChildNode'; } // hack to let us transport morphs
            }.bind(this), avocado.transporter.reasonsForNeedingCreatorPath.referencedBySlotInTheModule.create(this));
          } else {
            info.isCreator = true;
            
            var contentsParentSlot = contents.parentSlot();
            var contentsParent = contentsParentSlot.contents();
            if (contentsParentSlot.equals(contentsParent.theCreatorSlot())) {
              info.parentCreatorSlotChainExpression = contentsParent.creatorSlotChainExpression();
              info.parentSlotName = contentsParentSlot.name();
              info.parentHolderCreatorSlotChainExpression = contentsParentSlot.holder().creatorSlotChainExpression();
              info.parentRawAnnotation = contentsParent.annotationForReading().asRawDataObject();
            }
            
            if (contents.isReflecteeFunction()) {
              info.creationMethod = "method";
              info.contentsExpr = contents.reflecteeToString();
              //info.contentsExpr = contents.prettyPrint({indentationLevel: 2});
            } else {
              info.creationMethod = "creator";
              if (contents.isReflecteeArray()) {
                info.contentsExpr = "[]";
              } else if (contents.isReflecteeDOMNode()) {
                info.contentsExpr = contents.reflectee().storeStringWithoutChildren(); // let the children be recreated as "slots"
              } else {
                var contentsParent = contents.parent();
                if (contentsParent.equals(reflect(Object.prototype))) {
                  info.contentsExpr = "{}";
                } else {
                  avocado.transporter.reasonsForNeedingCreatorPath.recordIfExceptionDuring(function() {
                    var parentInfo = contents.parentSlot().transportableInfo();
                    info.contentsExpr = "Object.create(" + parentInfo.contentsExpr + ")";
                  }, avocado.transporter.reasonsForNeedingCreatorPath.ancestorOfObjectCreatedInTheModule.create(contents));
                }
              }
            }
          }
        }
      }
    }
    return info;
  }, {category: ['transporting']});

});


thisModule.addSlots(avocado.transporter.reasonsForNeedingCreatorPath, function(add) {

  add.method('recordIfExceptionDuring', function (f, reason) {
    try {
      return f();
    } catch (ex) {
      if (ex.mirrorWithoutCreatorPath) {
        if (ex.reasonForNeedingCreatorPath) {
          if (! ex.reasonForNeedingCreatorPath.include(reason)) {
            ex.reasonForNeedingCreatorPath += ", " + reason;
          }
        } else {
          ex.reasonForNeedingCreatorPath = reason;
        }
      }
      throw ex;
    }
  });

  add.creator('abstract', {});

});


thisModule.addSlots(avocado.transporter.reasonsForNeedingCreatorPath['abstract'], function(add) {

  add.method('create', function (param) {
    return Object.newChildOf(this, param);
  });

  add.method('initialize', function (param) {
    this._param = param;
  });

  add.method('equals', function (other) {
    // aaa hack, should really have a general equality tester that isn't part of hashTable.
    return this['__proto__'] === other['__proto__'] && avocado.hashTable.equalityComparator.keysAreEqual(this._param, other._param);
  });

});


thisModule.addSlots(avocado.transporter.reasonsForNeedingCreatorPath, function(add) {

  add.creator('ancestorOfObjectCreatedInTheModule', Object.create(avocado.transporter.reasonsForNeedingCreatorPath['abstract']));

});


thisModule.addSlots(avocado.transporter.reasonsForNeedingCreatorPath.ancestorOfObjectCreatedInTheModule, function(add) {

  add.method('toString', function () {
    return "it is an ancestor of " + this._param.inspect();
  });

});


thisModule.addSlots(avocado.transporter.reasonsForNeedingCreatorPath, function(add) {

  add.creator('objectContainsSlotInTheModule', Object.create(avocado.transporter.reasonsForNeedingCreatorPath['abstract']));

});


thisModule.addSlots(avocado.transporter.reasonsForNeedingCreatorPath.objectContainsSlotInTheModule, function(add) {

  add.method('toString', function () {
    return "the module contains slots in that object: " + this._param.name();
  });

});


thisModule.addSlots(avocado.transporter.reasonsForNeedingCreatorPath, function(add) {

  add.creator('referencedBySlotInTheModule', Object.create(avocado.transporter.reasonsForNeedingCreatorPath['abstract']));

});


thisModule.addSlots(avocado.transporter.reasonsForNeedingCreatorPath.referencedBySlotInTheModule, function(add) {

  add.method('toString', function () {
    return "it's referenced from " + this._param;
  });

});


});

avocado.transporter.module.onLoadCallbacks["core/batcher_upper"] = function() {};
avocado.transporter.module.create('core/batcher_upper', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('batcherUpper', {}, {category: ['core']});

});


thisModule.addSlots(avocado.batcherUpper, function(add) {

  add.method('create', function () {
    var b = Object.create(this);
    b.initialize.apply(b, arguments);
    return b;
  }, {category: ['creating']});

  add.method('initialize', function (context, finalFn, accumulatorFn, clearFn) {
    this._context = context;
    this._finalAction = finalFn;
    this._accumulateParameters = accumulatorFn;
    this._clearParams = clearFn;
    this.clear();
  }, {category: ['creating']});

  add.method('batchUp', function (params) {
    if (this._isRunning) {
      this._hasBeenCalled = true;
      if (this._accumulateParameters) { this._accumulateParameters(params); }
    }
  }, {category: ['batching up']});

  add.method('start', function () {
    this._isRunning = true;
    return this;
  }, {category: ['batching up']});

  add.method('stop', function () {
    this._isRunning = false;
    if (this._hasBeenCalled) {
      this._finalAction();
      this.clear();
    }
    return this;
  }, {category: ['batching up']});

  add.method('clear', function () {
    this._hasBeenCalled = false;
    if (this._clearParams) { this._clearParams(); }
  }, {category: ['batching up']});

  add.method('runDuring', function (f) {
    this.start();
    try {
      f();
    } finally {
      this.stop();
    }
  }, {category: ['batching up']});

  add.method('isRunning', function () {
    return this._isRunning;
  }, {category: ['testing']});

});


});

avocado.transporter.module.onLoadCallbacks["core/commands"] = function() {};
avocado.transporter.module.create('core/commands', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('command', {}, {category: ['ui']});

});


thisModule.addSlots(avocado.command, function(add) {

  add.creator('list', {});

  add.creator('argumentSpec', {});

  add.creator('tests', Object.create(avocado.testCase), {category: ['tests']});

  add.method('create', function () {
    var c = Object.create(this);
    c.initialize.apply(c, arguments);
    return c;
  }, {category: ['creating']});

  add.method('initialize', function (label, runFnOrSubcmds, optionalContext) {
    this.setLabel(label);
    if (typeof(runFnOrSubcmds) === 'function') {
      this.setFunction(runFnOrSubcmds);
    } else if (reflect(runFnOrSubcmds).isReflecteeArray()) {
      this.setSubcommands(runFnOrSubcmds);
    } else {
      throw new Error("Trying to make a command, but don't know what this is: " + runFnOrSubcmds);
    }
    if (typeof(optionalContext) !== undefined) { this.setContext(optionalContext); }
  }, {category: ['creating']});

  add.data('isCommand', true, {category: ['testing']});

  add.method('helpText', function () {
    return this._helpText;
  }, {category: ['accessing']});

  add.method('functionToRun', function () {
    return this._functionToRun;
  }, {category: ['accessing']});

  add.method('subcommands', function () {
    return this._subcommands;
  }, {category: ['accessing']});

  add.method('applicabilityFunction', function () {
    return this._applicabilityFunction;
  }, {category: ['accessing']});

  add.method('setLabel', function (label) {
    this.label = label;
    return this;
  }, {category: ['accessing']});

  add.method('labelString', function () {
    return typeof(this.label) === 'function' ? this.label(target) : this.label;
  }, {category: ['accessing']});

  add.method('setID', function (id) {
    this.id = id;
    return this;
  }, {category: ['accessing']});

  add.method('contextOrDefault', function () {
    if (! this.hasContext()) { return {}; }
    return this._context;
  }, {category: ['accessing']});

  add.method('hasContext', function () {
    return typeof(this._context) !== 'undefined';
  }, {category: ['accessing']});

  add.method('setContext', function (context) {
    this._context = context;
    return this;
  }, {category: ['accessing']});

  add.method('setHelpText', function (textOrFn) {
    this._helpText = textOrFn;
    return this;
  }, {category: ['accessing']});

  add.method('setFunction', function (f) {
    this._functionToRun = f;
    return this;
  }, {category: ['accessing']});

  add.method('setSubcommands', function (subcmds) {
    this._subcommands = subcmds;
    return this;
  }, {category: ['accessing']});

  add.method('toString', function () {
    return this.label;
  }, {category: ['printing']});

  add.method('wrapFunction', function (newFn) {
    var oldFunctionToRun = this._functionToRun;
    return this.setFunction(function() {
      return newFn.apply(this, [oldFunctionToRun].concat($A(arguments)));
    });
  }, {category: ['accessing']});

  add.method('onlyApplicableIf', function (f) {
    this._applicabilityFunction = f;
    return this;
  }, {category: ['accessing']});

  add.method('isApplicable', function () {
    return !this._applicabilityFunction || this._applicabilityFunction.call(this.contextOrDefault());
  }, {category: ['accessing']});

  add.method('argumentSpecs', function () {
    return this._argumentSpecs;
  }, {category: ['arguments']});

  add.method('setArgumentSpecs', function (specs) {
    this._argumentSpecs = specs;
    return this;
  }, {category: ['arguments']});

  add.method('canAcceptArguments', function (args) {
    if (!this._argumentSpecs) { return args.length === 0; }
    var n = this._argumentSpecs.length;
    if (n !== args.length) { return false; }
    for (var i = 0; i < n; ++i) {
      var spec = this._argumentSpecs[i];
      var arg = args[i];
      if (! spec.canAccept(arg)) { return false; }
    }
    return true;
  }, {category: ['arguments']});

  add.method('go', function () {
    var f = this.functionToRun();
    var rcvr = this.contextOrDefault();
    if (f) {
      return f.apply(rcvr, $A(arguments));
    } else {
      var subcmds = this.subcommands();
      if (!subcmds) { throw new Error("What kind of command is this, with no functionToRun and no subcommands?"); }
      var subcmdList = avocado.command.list.create(rcvr, subcmds);
      avocado.ui.showMenu(subcmdList);
    }
  }, {category: ['running']});

  add.method('wrapWithPromptersForArguments', function () {
    var argSpecs = this._argumentSpecs;
    if (! argSpecs || argSpecs.size() === 0) { return this; }
    
    var c = Object.create(this);
    
    if (typeof(this.label) === 'string' && ! this.label.endsWith("...")) { this.setLabel(this.label + "..."); }
    
    c.setArgumentSpecs([]);
    c._argumentSpecsThatWillBeFoundOrPromptedFor = argSpecs;
    
    var oldFunctionToRun = c.functionToRun();
    c.setFunction(function(evt) {
      var rcvr = c.contextOrDefault();
      var args = [evt];
      var promptForArg = function(i) {
        if (i >= argSpecs.length) { return oldFunctionToRun.apply(rcvr, args); }
        
        var argSpec = argSpecs[i];
        
        argSpec.findArgOrPrompt(rcvr, evt, function(arg) {
          args.push(arg);
          promptForArg(i + 1);
        }, function(err) {
          avocado.ui.showError(err, evt);
        });
      };
      promptForArg(0);
    });

    return c;
  }, {category: ['prompting for arguments']});

  add.creator('partial', {}, {category: ['partial commands']});

  add.method('createPartialCommand', function () {
    return avocado.command.partial.create().setCommand(this);
  }, {category: ['partial commands']});

});


thisModule.addSlots(avocado.command.list, function(add) {

  add.method('create', function (optionalDefaultContext, optionalCommands) {
    return Object.newChildOf(this, optionalDefaultContext, optionalCommands);
  }, {category: ['creating']});

  add.method('initialize', function (optionalDefaultContext, optionalCommands) {
    this._defaultContext = optionalDefaultContext;
    this._commands = [];
    if (optionalCommands) { this.addItems(optionalCommands); }
  }, {category: ['creating']});

  add.method('toString', function () {
    return "a command list";
  }, {category: ['printing']});

  add.method('inspect', function () {
    return this.toString();
  }, {category: ['printing']});

  add.method('size', function () {
    return this._commands.size();
  }, {category: ['accessing']});

  add.method('commands', function () {
    return this._commands;
  }, {category: ['iterating']});

  add.method('eachCommand', function (f) {
    this._commands.each(function(c) { if (c) { f(c); } });
  }, {category: ['iterating']});

  add.method('hasDefaultContext', function () {
    return typeof(this._defaultContext) !== 'undefined';
  });

  add.method('addItem', function (c) {
    // for compatibility with MenuMorph
    if (reflect(c).isReflecteeArray()) {
      c = avocado.command.create(c[0], c[1]);
    } else if (c && !c.isCommand) {
      // aaa - maybe just create the commands in the caller, don't do this translation thing
      var newC = avocado.command.create(c.label, c.go);
      if (c.hasOwnProperty("id")) { newC.setID(c.id); }
      if (c.hasOwnProperty("isApplicable")) { newC.onlyApplicableIf(c.isApplicable); }
      if (c.hasOwnProperty("pluralGo")) { newC.pluralGo = c.pluralGo; }
      if (c.hasOwnProperty("pluralLabel")) { newC.pluralLabel = c.pluralLabel; }
      c = newC;
    }

    this.ifNecessaryPassOnDefaultContextTo(c);
    
    this._commands.push(c);
  }, {category: ['adding']});

  add.method('ifNecessaryPassOnDefaultContextTo', function (c) {
    if (c && !c.hasContext() && this.hasDefaultContext()) {
      c.setContext(this._defaultContext);
    }
  }, {category: ['adding']});

  add.method('addItems', function (items) {
    items.forEach(function(item) { this.addItem(item); }.bind(this));
  }, {category: ['adding']});

  add.method('addAllCommands', function (cmdList) {
    this.addItems(cmdList.commands());
  }, {category: ['adding']});

  add.method('addLine', function (c) {
    if (this._commands.length === 0 || this._commands[this._commands.length - 1] === null) { return; }
    this._commands.push(null);
  }, {category: ['adding']});

  add.method('addSection', function (cs) {
    if (cs.size() > 0) {
      this.addLine();
      cs.each(this.addItem.bind(this));
    }
  }, {category: ['adding']});

  add.method('itemWith', function (attrName, attrValue) {
    return this.itemSuchThat(function(c) { return c[attrName] === attrValue; });
  }, {category: ['accessing']});

  add.method('itemSuchThat', function (criterion) {
    for (var i = 0, n = this._commands.length; i < n; ++i) {
      var c = this._commands[i];
      if (c && criterion(c)) { return c; }
    }
    return null;
  }, {category: ['accessing']});

  add.method('typeNameOfMorph', function (m) {
    if (typeof(m.typeName) === 'string') { return m.typeName; }
    if (typeof(m.typeName) === 'function') { return m.typeName(); }
    var type = m['__proto__'];
    if (window.reflect) { return reflect(type).name(); }
    return 'morph';
  }, {category: ['groups of objects']});

  add.method('descriptionOfGroup', function (commandBearers) {
    if (!commandBearers || commandBearers.length === 0) { return "nothing here"; }
    
    var byTypeName = avocado.dictionary.copyRemoveAll();
    commandBearers.each(function(m) {
      byTypeName.getOrIfAbsentPut(this.typeNameOfMorph(m), function() {return [];}).push(m);
    }.bind(this));

    var buf = avocado.stringBuffer.create();
    var sep = "";
    byTypeName.eachKeyAndValue(function(typeName, ms) {
      buf.append(sep).append(ms.length.toString()).append(" ").append(typeName).append(ms.length === 1 ? "" : "s");
      sep = ", ";
    });
    return buf.toString();
  }, {category: ['groups of objects']});

  add.method('addItemsFromGroup', function (commandBearers) {
    if (! commandBearers) { return; }

    var byCommandType = avocado.dictionary.copyRemoveAll();
    commandBearers.each(function(m) {
      var cmdList = m.commands();
      if (cmdList) {
        cmdList.eachCommand(function(c) {
          if (c.pluralLabel && c.isApplicable()) {
            byCommandType.getOrIfAbsentPut(c.pluralLabel, function() {return [];}).push({morph: m, command: c});
          }
        });
      }
    });

    byCommandType.keys().sort().each(function(pluralLabel) {
      var specs = byCommandType.get(pluralLabel);
      this.addItem({label: pluralLabel, go: function(evt) {
        var pluralGo = specs[0].command.pluralGo;
        if (pluralGo) {
          pluralGo(specs, evt);
        } else {
          // By default, just do each one in sequence.
          specs.each(function(spec) {
            spec.command.go(evt);
          });
        }
      }});
    }.bind(this));
  }, {category: ['adding']});

  add.method('wrapWithPromptersForArguments', function () {
    return avocado.command.list.create(this._defaultContext, this._commands.map(function(c) { return c ? c.wrapWithPromptersForArguments() : null; }));
  }, {category: ['prompting for arguments']});

});


thisModule.addSlots(avocado.command.argumentSpec, function(add) {

  add.method('create', function () {
    var c = Object.create(this);
    c.initialize.apply(c, arguments);
    return c;
  }, {category: ['creating']});

  add.method('initialize', function (name) {
    this._name = name;
  }, {category: ['creating']});

  add.method('name', function () {
    return this._name;
  }, {category: ['accessing']});

  add.method('type', function () {
    return this._type;
  }, {category: ['accessing']});

  add.method('onlyAccepts', function (f) {
    this._acceptanceFunction = f;
    return this;
  }, {category: ['filtering']});

  add.method('onlyAcceptsType', function (t) {
    this._type = t;
    this.onlyAccepts(function(o) { return typeof(t.doesTypeMatch) === 'function' ? t.doesTypeMatch(o) : Object.inheritsFrom(t, o); });
    return this;
  }, {category: ['filtering']});

  add.method('butDoesNotAccept', function (rejectionFunction) {
    var oldAcceptanceFunction = this._acceptanceFunction || function() { return true; };
    this.onlyAccepts(function(o) { return !rejectionFunction(o) && oldAcceptanceFunction(o); });
    return this;
  }, {category: ['filtering']});

  add.method('setPrompter', function (p) {
    this._prompter = p;
    return this;
  }, {category: ['prompting']});

  add.method('setArgFinder', function (f) {
    this._argFinder = f;
    return this;
  }, {category: ['prompting']});

  add.method('canAccept', function (arg) {
    if (! this._acceptanceFunction) { return true; }
    return this._acceptanceFunction(arg);
  }, {category: ['testing']});

  add.method('prompter', function () {
    var p = this._prompter;
    if (p) { return p; }
    var t = this._type;
    if (t) {
      if (typeof(t.prompter) === 'function') { return t.prompter(); }
      if (typeof(t.prompter) === 'object'  ) { return t.prompter;   }
    }
    return null;
  }, {category: ['prompting']});

  add.method('prompt', function (context, evt, callback, errback) {
    var p = this.prompter();
    if (p) {
      return p.prompt(this._name, context, evt, callback);
    } else {
      return errback(new Error('Cannot prompt for the "' + this._name + '" argument without a prompter'));
    }
  }, {category: ['prompting']});

  add.method('findArgOrPrompt', function (context, evt, callback, errback) {
    var arg = this.findArg(context, evt, callback);
    if (typeof(arg) !== 'undefined') {
      callback(arg);
    } else {
      this.prompt(context, evt, callback, errback);
    }
  }, {category: ['prompting']});

  add.method('findArg', function (context, evt) {
    if (this._argFinder) {
      return this._argFinder(context, evt);
    } else {
      return undefined;
    }
  }, {category: ['prompting']});

});


thisModule.addSlots(avocado.command.tests, function(add) {

  add.method('doughnutEatingCommand', function (answer) {
    return avocado.command.create('eat doughnuts', function (howMany, whatKind) {
      if (whatKind.indexOf('chocolate') < 0) {
        this.whatDoYouSay = "blecch";
      } else {
        this.whatDoYouSay = "om";
        for (var i = 0; i < howMany; ++i) { this.whatDoYouSay += " nom"; }
      }
    }, answer).setArgumentSpecs([
      avocado.command.argumentSpec.create("how many").onlyAccepts(function(n) { return typeof(n) === 'number' && n > 0; }),
      avocado.command.argumentSpec.create("what kind").onlyAcceptsType(avocado.types.string)
    ]);
  });

  add.method('testAcceptingArguments', function () {
    var answer = {};
    var c = this.doughnutEatingCommand(answer);
    
    this.assert( c.canAcceptArguments([3, "chocolate dip"]));
    this.assert(!c.canAcceptArguments([0, "chocolate dip"]));
    this.assert(!c.canAcceptArguments([12, 89]));
    this.assert(!c.canAcceptArguments(['not a number', "jelly"]));
    c.go(2, "double chocolate");
    this.assertEqual("om nom nom", answer.whatDoYouSay);
    c.go(3, "pink");
    this.assertEqual("blecch", answer.whatDoYouSay);
  });

  add.method('aaa_testPromptingForArguments', function () {
    // aaa - there are are some annoying complications because of that "evt" argument that we assume is there... blecch, simplify this, but later
    
    var answer = {};
    var c = this.doughnutEatingCommand(answer);
    c.argumentSpecs()[0].setPrompter({prompt: function(name, context, evt, callback) { callback(3); }});
    c.argumentSpecs()[1].setPrompter({prompt: function(name, context, evt, callback) { callback("chocolate glazed"); }});
    
    var c2 = c.wrapWithPromptersForArguments();
    c2.go();
    this.assertEqual("om nom nom nom", answer.whatDoYouSay);
  });

});


thisModule.addSlots(avocado.command.partial, function(add) {

  add.method('create', function () {
    return Object.newChildOf(this);
  }, {category: ['creating']});

  add.method('initialize', function () {
  }, {category: ['creating']});

  add.method('toString', function () {
    return this.command().toString();
  }, {category: ['printing']});

  add.method('command', function () {
    return this._command;
  }, {category: ['accessing']});

  add.method('setCommand', function (c) {
    this._command = c;
    this._argumentHolders = (this._command._argumentSpecsThatWillBeFoundOrPromptedFor || this._command.argumentSpecs() || []).map(function(s) {
      var h = avocado.valueHolder.containing(s.type() && s.type().defaultValue ? s.type().defaultValue() : undefined).setName(s.name()).setType(s.type());
      // aaa kind of a hack; this isn't quite what isReallyPartOfHolder was meant to be used for
      h.isReallyPartOfHolder = function () { var v = this.getValue(); return v !== null && typeof(v) !== 'undefined'; };
      return h;
    });
    return this;
  }, {category: ['accessing']});

  add.method('argumentHolders', function () {
    return this._argumentHolders;
  }, {category: ['arguments']});

  add.method('immediateContents', function () {
    return this.argumentHolders();
  }, {category: ['user interface']});

  add.method('commands', function () {
    var cmdList = avocado.command.list.create(this);
    cmdList.addItem(avocado.command.create('run', function(evt) {
      var args = this.argumentHolders().map(function(h) { return h.getValue(); });
      args.unshift(evt);
      return this._command.go.apply(this._command, args);
    }));
    return cmdList;
  }, {category: ['user interface', 'commands']});

});


thisModule.addSlots(String, function(add) {

  add.creator('prompter', {}, {category: ['prompting']});

});


thisModule.addSlots(String.prompter, function(add) {

  add.method('prompt', function (caption, context, evt, callback) {
    avocado.ui.currentWorld().prompt(caption, function(s) {
      if (s) {
        callback(s);
      }
    }, '');
  }, {category: ['prompting']});

});


});

avocado.transporter.module.onLoadCallbacks["core/exit"] = function() {};
avocado.transporter.module.create('core/exit', function(requires) {

requires('core/testFramework');

}, function(thisModule) {


thisModule.addSlots(window, function(add) {

  add.method('exitValueOf', function (f) {
    var exitToken = {};
    var exiter = function(v) {
      exitToken.value = v;
      throw exitToken;
    };
    try {
      return f(exiter);
    } catch (exc) {
      if (exc === exitToken) {
        return exc.value;
      } else {
        // must be some other exception
        throw exc;
      }
    }
  }, {category: ['avocado', 'control flow']});

});


thisModule.addSlots(exitValueOf, function(add) {

  add.data('displayName', 'exitValueOf');

  add.creator('tests', Object.create(avocado.testCase), {category: ['tests']});

  add.creator('prototype', {});

});


thisModule.addSlots(exitValueOf.tests, function(add) {

  add.method('testNotExiting', function () {
    this.assertEqual(7, exitValueOf(function(exit) { return 7; }));
  });

  add.method('testExiting', function () {
    this.assertEqual(6, exitValueOf(function(exit) { exit(6); return 7; }));
  });

  add.method('testExitingFromInsideAFunction', function () {
    this.assertEqual('good', exitValueOf(function(exit) {
      [1, 2, 3, 4, 5, 6, 7, 8, 9].each(function(n) { if (n === 4) { exit('good'); } });
      return 'no good';
    }));
  });

});


});

avocado.transporter.module.onLoadCallbacks["core/core"] = function() {};
avocado.transporter.module.create('core/core', function(requires) {

requires('core/collections/collections');
requires('core/accessors');
requires('core/batcher_upper');
requires('core/commands');
requires('core/exit');
requires('core/functions');
requires('core/deep_copy');
requires('core/notifier');
requires('core/string_buffer');
requires('core/string_extensions');
requires('core/array_extensions');
requires('core/value_holder');
requires('core/dependencies');
requires('core/little_profiler');
requires('core/math');
requires('core/sound');
requires('core/graphs');
requires('core/types');
requires('core/modification_flag');
requires('core/dom_stuff');
requires('core/http');
requires('core/tree_node');
requires('core/naming');

}, function(thisModule) {


});

avocado.transporter.module.onLoadCallbacks["avocado_lib"] = function() {};
avocado.transporter.module.create('avocado_lib', function(requires) {

requires('core/testFramework');
requires('core/core');
requires('transporter/transporter');
requires('reflection/reflection');

}, function(thisModule) {


});

avocado.transporter.doneLoadingAvocadoLib();
avocado.transporter.module.onLoadCallbacks["lk_ext/tags"] = function() {};
avocado.transporter.module.create('lk_ext/tags', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('tag', {}, {category: ['user interface']});

});


thisModule.addSlots(avocado.tag, function(add) {

  add.method('create', function () {
    var a = Object.create(this);
    a.initialize.apply(a, arguments);
    return a;
  }, {category: ['creating']});

  add.method('initialize', function (name, criterion) {
    this._name = name;
    this._criterion = criterion;
  }, {category: ['creating']});

  add.method('toString', function () {
    return this._name || "";
  }, {category: ['printing']});

  add.method('matches', function (o) {
    return this._criterion(o);
  }, {category: ['matching']});

  add.method('matchesMorph', function (m) {
    var model = m._model;
    if (typeof(model) === 'undefined') { return false; }
    return this.matches(model);
  }, {category: ['matching']});

  add.creator('cloud', {});

  add.method('Morph', function Morph() { Class.initializer.apply(this, arguments); }, {category: ['ui']});

});


thisModule.addSlots(avocado.tag.cloud, function(add) {

  add.method('create', function () {
    var a = Object.create(this);
    a.initialize.apply(a, arguments);
    return a;
  }, {category: ['creating']});

  add.method('initialize', function (name, tagTypes, allPossibleObjects) {
    this._name = name;
    this._allElements = tagTypes.map(function(tagType) { return avocado.tag.cloud.element.create(this, tagType); }.bind(this));
    this._allPossibleObjects = allPossibleObjects;
  }, {category: ['creating']});

  add.method('name', function () {
    return this._name;
  }, {category: ['accessing']});

  add.method('allElements', function () {
    return this._allElements;
  }, {category: ['accessing']});

  add.method('allTagTypes', function () {
    return this.allElements().map(function(e) { return e.tagType(); });
  }, {category: ['accessing']});

  add.method('toString', function () {
    return this._name || "";
  }, {category: ['printing']});

  add.method('immediateContents', function () {
    return this.allElements();
  });

  add.method('allPossibleObjects', function () {
    if (this._allPossibleObjects) { return this._allPossibleObjects; }
    var objs = [];
    // aaa - I don't think this object should know about morphs.
    WorldMorph.current().eachSubmorph(function(morph) {
      var model = morph._model;
      if (typeof(model) !== 'undefined') { objs.push(model); }
    });
    return objs;
  });

  add.creator('element', {});

  add.creator('defaultMorphStyle', {}, {category: ['user interface']});

  add.method('newMorph', function () {
    var m = avocado.treeNode.newMorphFor(this, this.defaultMorphStyle);
    m.typeName = 'tag cloud';
    return m;
  }, {category: ['user interface']});

  add.method('tagAllMorphsInWorld', function (w) {
    w = w || WorldMorph.current();
    this.allElements().forEach(function(e) {
      w.tagSubmorphsWithNewTag(e.tagType(), e.fill());
    });
  }, {category: ['user interface']});

});


thisModule.addSlots(avocado.tag.cloud.element, function(add) {

  add.method('create', function () {
    var a = Object.create(this);
    a.initialize.apply(a, arguments);
    return a;
  }, {category: ['creating']});

  add.method('initialize', function (cloud, tagType) {
    this._cloud = cloud;
    this._tagType = tagType;
    this._fill = Color.random();
  }, {category: ['creating']});

  add.method('cloud', function () {
    return this._cloud;
  }, {category: ['accessing']});

  add.method('fill', function () {
    return this._fill;
  }, {category: ['accessing']});

  add.method('tagType', function () {
    return this._tagType;
  }, {category: ['accessing']});

  add.method('toString', function () {
    return this.tagType().toString();
  }, {category: ['printing']});

  add.method('immediateContents', function () {
    return this.cloud().allPossibleObjects().select(function(o) { return this._tagType.matches(o); }.bind(this));
  });

  add.creator('defaultMorphStyle', {}, {category: ['user interface']});

  add.method('newMorph', function () {
    var m = avocado.treeNode.newMorphFor(this, {fill: this._fill});
    m.typeName = 'tag cloud element';
    return m;
  }, {category: ['user interface']});

});


thisModule.addSlots(avocado.tag.cloud.defaultMorphStyle, function(add) {

  add.data('fillBase', new Color(0.1, 0.5, 0.6));

});


thisModule.addSlots(avocado.tag.Morph, function(add) {

  add.data('displayName', 'Morph');

  add.data('superclass', Morph);

  add.data('type', 'avocado.tag.Morph');

  add.creator('prototype', Object.create(Morph.prototype));

});


thisModule.addSlots(avocado.tag.Morph.prototype, function(add) {

  add.data('constructor', avocado.tag.Morph);

  add.method('initialize', function ($super, tag, fill) {
    $super(new lively.scene.Ellipse(pt(0,0), 10));
    this._model = tag;
    this.setFill(fill);
    this.setFillOpacity(0.4);
  }, {category: ['creating']});

  add.data('shouldNotBePartOfRowOrColumn', true);

  add.data('suppressHandles', true);

});


thisModule.addSlots(Morph.prototype, function(add) {

  add.method('allLikeMe', function () {
    // aaa - Flesh this out, make it smart about finding related objects.
    if (typeof(this._model) === 'undefined') { return []; }
    if (typeof(this._model.matchesMorph) !== 'function') { return []; }
    return this.owner.owner.submorphs.select(function(morph) { return this._model.matchesMorph(morph); }.bind(this));
  }, {category: ['finding related objects']});

  add.method('taggingCommands', function () {
    var items = [];

    items.push(avocado.command.create("add tag", function(evt, targetMorph) {
      var tagMorph = avocado.placeholder.newPlaceholderMorphForMorph(targetMorph);
      this.aboutToReceiveDrop(tagMorph);
      this.addTagMorph(tagMorph);
      if (targetMorph.owner instanceof avocado.CarryingHandMorph) {
        targetMorph.owner.putBackInOriginalPosition(targetMorph, evt);
      }
    }).setArgumentSpecs([
      avocado.command.argumentSpec.create('target').onlyAcceptsType(avocado.morphWithAModel).useMorphicContextualArgFinder()
    ]));
    
    if (false) { // aaa - I think we need something like this but I'm not sure of the details yet.

      if (this.owner.isHighlighted()) {
        items.push(avocado.command.create('unhighlight related objects', function(evt) { this.allLikeMe().forEach(function(tm) { tm.beUnhighlighted(); }); }));
      } else {
        items.push(avocado.command.create('highlight related objects', function(evt) { this.allLikeMe().forEach(function(tm) { tm.beHighlighted(); }); }));
      }
    
      items.push(avocado.command.create('gather related objects', function(evt) {
        var container = this.owner.owner;
        var pose = avocado.poses.list.create("all tagged " + this._model, container.getExtent.bind(container), this.allLikeMe());
        evt.hand.world().promptForPoint(function(startingPos) {
          container.poseManager().assumePose(pose, startingPos);
        });
      }));
    
    }
    
    return items;
  }, {category: ['tagging']});

  add.method('tagColorsByType', function () {
    if (! this._tagColorsByType) {
      this._tagColorsByType = avocado.dictionary.copyRemoveAll(avocado.dictionary.identityComparator);
    }
    return this._tagColorsByType;
  }, {category: ['tagging']});

  add.method('getOrCreateColorForTagType', function (tagType, preferredColor) {
    return this.tagColorsByType().getOrIfAbsentPut(tagType, function() { return preferredColor || Color.random(); });
  }, {category: ['tagging']});

  add.method('tagSubmorphsWithNewTag', function (tagType, color) {
    this.getOrCreateColorForTagType(tagType, color);
    this.tagSubmorphsWithTag(tagType);
  }, {category: ['tagging']});

  add.method('tagSubmorphsWithTag', function (tagType) {
    var color = this.getOrCreateColorForTagType(tagType);
    this.eachSubmorph(function(m) {
      if (tagType.matchesMorph(m)) {
        m.addTagMorph(avocado.placeholder.newPlaceholderMorphForMorph(tagType));
      }
    });
  }, {category: ['tagging']});

  add.method('currentTags', function () {
    if (! this._tagHolderMorph) { return []; }
    return this.tagHolderMorph().submorphs;
  }, {category: ['tagging']});

  add.method('addTagMorph', function (tagMorph) {
    this.ensureTagHolderMorphIsVisible().layout().addCell(tagMorph);
    return this;
  }, {category: ['tagging']});

  add.method('ensureTagHolderMorphIsVisible', function () {
    // Children should feel free to override this if they want to specify exactly where to place tags.
    var m = this.tagHolderMorph();
    if (! m.owner) { this.addMorphAt(m, pt(20,0)); }
    return m;
  }, {category: ['tagging']});

  add.method('tagHolderMorph', function () {
    if (! this._tagHolderMorph) {
      this._tagHolderMorph = this.createTagHolderMorph();
    }
    return this._tagHolderMorph;
  }, {category: ['tagging']});

  add.method('createTagHolderMorph', function () {
    return avocado.table.newColumnMorph().applyStyle({fill: null}).ignoreEvents();
  }, {category: ['tagging']});

});


});

avocado.transporter.module.onLoadCallbacks["projects/projects"] = function() {};
avocado.transporter.module.create('projects/projects', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('project', {}, {category: ['projects']});

});


thisModule.addSlots(avocado.project, function(add) {

  add.method('current', function () {
    if (this._current) { return this._current; }
    if (! modules.thisProject) { return null; }
    this._current = this.create({ moduleName: "thisProject", name: "This project" });
    return this._current;
  }, {category: ['current one']});

  add.method('setCurrent', function (p) {
    this._current = p;
    
	  if (this.shouldOnlyShowDeploymentArea()) {
	    var dm = p.deploymentMorphIfAny();
	    if (dm) { avocado.ui.currentWorld().addMorph(dm); }
    }
    
    if (typeof(avocado.justSetCurrentProject) === 'function') {
      avocado.justSetCurrentProject(p);
    }
    
    return p;
  }, {category: ['current one']});

  add.method('shouldOnlyShowDeploymentArea', function () {
    return avocado.applicationList.applications().any(function(app) { return app.shouldOnlyShowDeploymentArea; });
  }, {category: ['current one']});

  add.method('create', function (info) {
    return Object.newChildOf(this, info);
  }, {category: ['creating']});

  add.method('initialize', function (info) {
    this._module = modules[info.moduleName];
    this.setName(info.name);
    this.setIsPrivate(info.isPrivate);
    if (info._id) {
      this.setID(info._id);
    } else {
      avocado.transporter.idTracker.createTemporaryIDFor(this);
    }
  }, {category: ['creating']});

  add.method('name', function () { return this._name; }, {category: ['accessing']});

  add.method('setName', function (n) { this._name = n; this.markAsChanged(); }, {category: ['accessing']});

  add.method('id', function () { return this._projectID; }, {category: ['accessing']});

  add.method('setID', function (id) { this._projectID = id; }, {category: ['accessing']});

  add.data('_modificationFlag', null, {category: ['accessing'], initializeTo: 'null'});

  add.method('modificationFlag', function () {
    return this._modificationFlag || (this._modificationFlag = avocado.modificationFlag.create(this, [this.module().modificationFlag()]));
  }, {category: ['accessing']});

  add.method('isPrivate', function () { return this._isPrivate; }, {category: ['accessing']});

  add.method('setIsPrivate', function (b) { this._isPrivate = b; this.markAsChanged(); }, {category: ['accessing']});

  add.method('isInTrashCan', function () { return this._isInTrashCan; }, {category: ['accessing']});

  add.method('putInTrashCan', function () { this._isInTrashCan = true; this.markAsChanged(); }, {category: ['accessing']});

  add.method('module', function () { return this._module; }, {category: ['accessing']});

  add.method('inspect', function () { return this.name(); }, {category: ['printing']});

  add.method('toString', function () { return this.name(); }, {category: ['printing']});

  add.method('markAsChanged', function () {
    this.modificationFlag().markAsChanged();
  }, {category: ['keeping track of changes']});

  add.method('markAsUnchanged', function () {
    this.modificationFlag().markAsUnchanged();
  }, {category: ['keeping track of changes']});

  add.method('whenChangedNotify', function (observer) {
    this.modificationFlag().notifier().addObserver(observer);
  }, {category: ['keeping track of changes']});

  add.method('deploymentMorph', function () {
    var module = this.currentWorldStateModule();
    var morph = module._deploymentMorph;
    if (! morph) {
      morph = module._deploymentMorph = new Morph(new lively.scene.Rectangle(pt(0,0).extent(pt(600,450))));
      morph.setFill(Color.white);
      morph.setBorderColor(Color.black);
      morph.switchEditModeOn();
      
      /* aaa - I do want some sort of instructions for the programmer, but I don't want this
       label to appear in the deployed project. -- Adam, June 2011
      var label = avocado.label.newMorphFor("Put things in this box to make them appear in the deployed project");
      label.fitText();
      morph.addMorphCentered(label);
      */
      
      var slot = reflect(module).slotAt('_deploymentMorph');
      slot.beCreator();
      slot.setModule(module);
    }
    return morph;
  }, {category: ['deploying']});

  add.method('deploymentMorphIfAny', function () {
    return modules.currentWorldState && modules.currentWorldState._deploymentMorph;
  }, {category: ['deploying']});

  add.method('addGlobalCommandsTo', function (cmdList, evt) {
    cmdList.addLine();
    
    cmdList.addItem(["project info", function(evt) {
      var currentProject = avocado.project.current();
      if (! currentProject) {
        avocado.transporter.module.named("thisProject");
        currentProject = avocado.project.current();
      }
      avocado.ui.grab(currentProject, evt);
    }]);
  }, {category: ['commands']});

  add.method('togglePrivacy', function (evt) {
    this.setIsPrivate(! this.isPrivate());
  }, {category: ['commands']});

  add.method('grabDeploymentMorph', function (evt) {
    this.deploymentMorph().grabMe(evt);
  }, {category: ['commands']});

  add.method('grabRootModule', function (evt) {
    avocado.ui.grab(this.module(), evt);
  }, {category: ['commands']});

  add.method('rename', function (evt) {
    avocado.ui.prompt("New name?", function(n) { if (n) { this.setName(n); }}.bind(this), this.name(), evt);
  }, {category: ['commands']});

  add.method('determineVersionsToSave', function () {
    var versionsToSave = {};
    var rootModule = this.module();
    var modulesNotToSave = {};
    var modulesLeftToLookAt = [this.module()];
    while (modulesLeftToLookAt.length > 0) {
      var m = modulesLeftToLookAt.pop();
      if (!modulesNotToSave[m.name()] && !versionsToSave[m.name()]) {
        // aaa - Could make this algorithm faster if each module knew who required him - just check
        // if m itself has changed, and if so then walk up the requirements chain making sure that
        // they're included.
        if (m === rootModule || m.modificationFlag().hasThisOneOrChildrenChanged()) { // always save the root, just makes things simpler
          versionsToSave[m.name()] = m.createNewVersion();
          m.requirements().each(function(requiredModuleName) { modulesLeftToLookAt.push(modules[requiredModuleName])});
        } else {
          modulesNotToSave[m.name()] = m;
        }
      }
    }
    return versionsToSave;
  }, {category: ['saving']});

  add.method('sortVersionsToSave', function (versionsToSave) {
    var moduleGraph = avocado.graphs.directed.create([this.module()], function(m) { return m.requiredModules(); });
    var sortedModules = moduleGraph.topologicalSort();
    var sortedVersionsToSave = [];
    sortedModules.each(function(m) {
      var v = versionsToSave[m.name()];
      if (v) { sortedVersionsToSave.push(v); }
    });
    return sortedVersionsToSave;
  }, {category: ['saving']});

  add.data('_shouldNotSaveCurrentWorld', false, {category: ['saving']});

  add.method('currentWorldStateModule', function () {
    return modules.currentWorldState || this.module().createNewOneRequiredByThisOne('currentWorldState');
  }, {category: ['saving']});

  add.method('resetCurrentWorldStateModule', function () {
    if (!modules.currentWorldState) { return; }
    if (!modules.currentWorldState.morphs) { return; }
    var morphs = modules.currentWorldState.morphs;
  	var morphsArrayMir = reflect(morphs);
    // Need to take the slots in the "morphs" array out of the module whenever we reset the
    // array to an empty one, so that the transporter doesn't gripe about the old array not
    // being well-known.
    morphs.forEach(function(m, i) { morphsArrayMir.slotAt(i).setModule(null); });
	  modules.currentWorldState.morphs = [];
  	reflect(modules.currentWorldState).slotAt('morphs').beCreator();
  }, {category: ['saving']});

  add.method('assignCurrentWorldStateToTheRightModule', function () {
  	var currentWorldStateModule = this.currentWorldStateModule();
  	
  	currentWorldStateModule.morphs = [];
  	reflect(currentWorldStateModule).slotAt('morphs').beCreator(); // .setInitializationExpression('[]'); // aaa I don't understand why this was here, it just seems broken
  	var morphsArrayMir = reflect(currentWorldStateModule.morphs);
  	
    var currentWorldSubmorphs = avocado.ui.currentWorld().submorphs;
    var currentWorldSubmorphsMir = reflect(currentWorldSubmorphs);
    currentWorldSubmorphs.forEach(function(m, i) {
      if (! m.shouldNotBeTransported() && ! m.shouldIgnorePoses()) {
    	  currentWorldStateModule.morphs.push(m);
    	  
        // If the morph is already owned by some creator slot other than the world's submorphs array,
        // don't steal it, just remember which module it's in, and make the currentWorldState module
        // depend on it.
        var mMir = reflect(m);
        var cs = mMir.theCreatorSlot();
        var csModule;
        if (cs && cs.contents().equals(mMir) && (csModule = cs.getModuleAssignedToMeExplicitlyOrImplicitly()) && !cs.holder().equals(currentWorldSubmorphsMir) && mMir.creatorSlotChain()) {
          if (csModule !== currentWorldStateModule) {
            currentWorldStateModule.addRequirement(csModule.name());
          }
        } else {
          morphsArrayMir.slotAt(currentWorldStateModule.morphs.length - 1).beCreator();
        }
  	  }
  	});
  	
  	currentWorldStateModule.postFileIn = function() {
  	  var w = avocado.ui.currentWorld();
  	  if (! avocado.project.shouldOnlyShowDeploymentArea()) {
    	  this.morphs.forEach(function(m) { w.addMorph(m); });
  	  }
  	  avocado.project.resetCurrentWorldStateModule();
  	};
  	reflect(currentWorldStateModule).slotAt('postFileIn').beCreator();
  	reflect(currentWorldStateModule).normalSlots().each(function(s) { s.setModule(currentWorldStateModule); });
  	
    // aaa - hack; really these slots should be annotated with an initializeTo: 'undefined' or something like that
    // AAAAAAAAAA - we're not actually walking anymore, now that we have the new module slotFinder, so I think I've gotta do the initializeTo thing now
  	// walker.namesToIgnore = walker.namesToIgnore.concat(['pvtCachedTransform', 'fullBounds', '_currentVersion', '_requirements', '_modificationFlag']);

    currentWorldStateModule.markAsChanged();
    
  });

  add.method('autoSave', function (evt) {
  	this.save(evt, true);
  });

  add.method('save', function (evt, isAutoSave) {
    if (!this._shouldNotSaveCurrentWorld) { this.assignCurrentWorldStateToTheRightModule(); }
    
    var versionsToSave = this.determineVersionsToSave();
    var sortedVersionsToSave = this.sortVersionsToSave(versionsToSave);
    
    // Check to make sure there aren't any *other* changes in the image that aren't part of this project.
    var allChangedModules = avocado.transporter.module.changedOnes();
    var changedModulesNotInThisProject = allChangedModules.select(function(m) { return !versionsToSave[m.name()] && m !== modules.init; }).toArray(); // AAAAAAAAAAAA
    if (changedModulesNotInThisProject.size() > 0) { // aaaaaaaaaaaaaaaaaaaaa
      avocado.ui.showObjects(changedModulesNotInThisProject, "changed modules not in this project", evt);
      avocado.messageNotifier.showError("WARNING: You have modified modules that are not part of your project; they will not be saved.", evt, Color.orange);
    }
    
    var mockRepo = avocado.project.moduleRepository.create(this, isAutoSave);
    mockRepo.setRoot(versionsToSave[this.module().name()]);
    var errors = avocado.transporter.fileOutPlural(sortedVersionsToSave.map(function(v) { return { moduleVersion: v }; }), evt, mockRepo, this.defaultModuleFilerOuter());
    if (errors.length === 0) {
      var server = this.defaultServer();
      var format = this.defaultFormat();
      server.save(mockRepo, format, true, function() {
        console.log("Successfully saved the project.");
    	  if (!this._shouldNotSaveCurrentWorld) { avocado.project.resetCurrentWorldStateModule(); }
        this.markAsUnchanged();
      }.bind(this), function(failureReason) {
        console.log("Error saving " + this + ": " + failureReason);
      });
    } else {
      console.log("Not saving because there were transporter errors.");
    }
  }, {category: ['saving']});

  add.creator('moduleRepository', {}, {category: ['saving']});

  add.creator('servers', {}, {category: ['saving']});

  add.creator('formats', {}, {category: ['saving']});

  add.method('defaultServer', function () {
    // aaa - this needs to be specified by the various kinds of servers
    // return this._defaultServer || avocado.project.servers.savingScript.create("http://" + window.location.host + "/project/save", "post");
    return this._defaultServer || avocado.project.servers.webdav.create(modules.bootstrap.repository(), "put");
  }, {category: ['saving']});

  add.method('defaultFormat', function () {
    // aaa - this needs to be specified by the various kinds of servers
    // return this._defaultFormat || this.formats.json;
    return this._defaultFormat || this.formats.runnable;
  }, {category: ['saving']});

  add.method('defaultModuleFilerOuter', function () {
    // aaa - this needs to be specified by the various kinds of servers
    // return avocado.transporter.module.filerOuters.justBody;
    return avocado.transporter.module.filerOuters.normal;
  }, {category: ['saving']});

  add.method('setDefaultServer', function (s) {
    this._defaultServer = s;
  }, {category: ['saving']});

  add.method('setDefaultFormat', function (f) {
    this._defaultFormat = f;
  }, {category: ['saving']});

  add.method('commands', function () {
    return avocado.command.list.create(this, [
      avocado.command.create('save', this.save),
      avocado.command.create('show deployment area', this.grabDeploymentMorph),
      avocado.command.create('rename', this.rename),
      avocado.command.create(this.isPrivate() ? 'be public' : 'be private', this.togglePrivacy),
      avocado.command.create('get root module', this.grabRootModule)
    ]);
  }, {category: ['user interface', 'commands']});

});


thisModule.addSlots(avocado.project.moduleRepository, function(add) {

  add.method('create', function (project, isAutoSave) {
    return Object.newChildOf(this, project, isAutoSave);
  }, {category: ['creating']});

  add.method('initialize', function (project, isAutoSave) {
    this._project = project;
    this._projectData = {
      _id: project.id(),
      name: project.name(),
      isPrivate: project.isPrivate(),
      isInTrashCan: project.isInTrashCan(),
      isAutoSave: isAutoSave,
      modules: []
    };
  }, {category: ['creating']});

  add.method('setRoot', function (rootModuleVersion) {
    this._projectData.root = rootModuleVersion.versionID();
  }, {category: ['saving']});

  add.method('fileOutModuleVersion', function (moduleVersion, codeToFileOut, successBlock, failBlock) {
    this._projectData.modules.push({
      module: moduleVersion.module().name(),
      version: moduleVersion.versionID(),
      parents: moduleVersion.parentVersions().map(function(pv) { return pv.versionID(); }),
      reqs: moduleVersion.requiredModuleVersions().map(function(v) { return v.versionID(); }),
      code: codeToFileOut
    });
  }, {category: ['saving']});

});


thisModule.addSlots(avocado.project.formats, function(add) {

  add.creator('json', {});

  add.creator('runnable', {});

});


thisModule.addSlots(avocado.project.formats.json, function(add) {

  add.method('fileContentsFromProjectData', function (projectData) {
    return Object.toJSON(projectData);
  });

  add.method('parseResponse', function (responseText) {
    return JSON.parse(responseText);
  });

  add.method('contentType', function () {
    return 'application/json';
  });

});


thisModule.addSlots(avocado.project.formats.runnable, function(add) {

  add.method('fileContentsFromProjectData', function (projectData) {
    var projectDataToSend = {};
    if (projectData._id) { projectDataToSend._id = projectData._id.toString(); }
    projectDataToSend.moduleName = "thisProject";
    projectDataToSend.name = projectData.name.toString();
    projectDataToSend.isPrivate = !! projectData.isPrivate;
    return "modules.bootstrap.repository().fileIn('thisProject', function() {\n  avocado.project.setCurrent(avocado.project.create(" + Object.toJSON(projectDataToSend) + "));\n});\n";
  });

  add.method('parseResponse', function (responseText) {
    // I don't think there should be anything in the responseText.
    return {};
  });

  add.method('contentType', function () {
    return 'text/plain';
  });

});


thisModule.addSlots(WorldMorph.prototype, function(add) {

  add.method('deployProjectFromFile', function (projectFileName, callback) {
    avocado.transporter.availableRepositories[0].fileIn(projectFileName.withoutSuffix(".js"), function() {
      this.deployProject(avocado.project.current(), callback);
    }.bind(this));
  }, {category: ['projects']});

  add.method('deployProject', function (p, callback) {
    var dm = p.deploymentMorph();
    this.addMorphAt(dm, pt(0,0));
    dm.grabsShouldFallThrough = true;
    var desiredExtent = dm.getExtent().scaleBy(dm.getScale());
    this.setExtent(desiredExtent);
    var canvas = this.canvas();
    canvas.setAttribute("width",  desiredExtent.x);
    canvas.setAttribute("height", desiredExtent.y);
    this.changed();
    if (callback) { callback(); }
  }, {category: ['projects']});

});


thisModule.addSlots(avocado.project.servers, function(add) {

  add.creator('generic', {});

  add.creator('savingScript', Object.create(avocado.project.servers.generic));

});


thisModule.addSlots(avocado.project.servers.savingScript, function(add) {

  add.method('create', function (url) {
    return Object.newChildOf(this, url);
  }, {category: ['creating']});

  add.method('initialize', function (url) {
    this._url = url;
  }, {category: ['creating']});

  add.method('save', function (moduleRepo, format, shouldSaveAsSingleFile, successBlock, failBlock) {
    // shouldSaveAsSingleFile is ignored because the server is smart enough to store the modules
    // separately and recombine them as needed; the parameter is just here for compatibility with
    // the webdav one. -- Adam, June 2011
    
    var body = format.fileContentsFromProjectData(moduleRepo._projectData);
    console.log("About to save the project to URL " + this._url + ", sending:\n" + body);
    
    var req = new XMLHttpRequest();
    req.open('post', this._url, true);
    req.onreadystatechange = function() {
      if (req.readyState === 4) {
        try {
          var status = req.status;
          var success = !status || (status >= 200 && status < 300);
          if (success) {
            this.onSuccessfulPost(format.parseResponse(req.responseText), successBlock, failBlock);
          } else {
            failBlock("Failed to file out project " + moduleRepo._project + " to repository " + moduleRepo + "; HTTP status code was " + status);
          }
        } catch (e) {
          failBlock("Failed to file out project " + moduleRepo._project + " to repository " + moduleRepo + "; exception was " + e);
        }
      }
    }.bind(this);
    req.send(body);
  }, {category: ['saving']});

  add.method('onSuccessfulPost', function (responseJSON, successBlock, failBlock) {
    if (responseJSON.error) {
      failBlock("Server responded with error: " + responseJSON.error);
    } else {
      var realIDsByTempID = responseJSON;
      for (var tempID in realIDsByTempID) {
        avocado.transporter.idTracker.recordRealID(tempID, realIDsByTempID[tempID]);
      }
      successBlock();
    }
  }, {category: ['saving']});

});


thisModule.addSlots(avocado.project.servers, function(add) {

  add.creator('webdav', Object.create(avocado.project.servers.generic));

});


thisModule.addSlots(avocado.project.servers.webdav, function(add) {

  add.method('create', function (repo) {
    return Object.newChildOf(this, repo);
  }, {category: ['creating']});

  add.method('initialize', function (repo) {
    this._repo = repo;
  }, {category: ['creating']});

  add.method('callbackThatAccumulatesErrorsIn', function (errors, callback) {
    return function(errorMessage) {
      errors.push(errorMessage);
      callback();
    };
  }, {category: ['saving']});

  add.method('save', function (moduleRepo, format, shouldSaveAsSingleFile, successBlock, failBlock) {
    var project = moduleRepo._project;
    var projectData = moduleRepo._projectData;
    var modulesData = projectData.modules;
    projectData.modules = projectData.modules.map(function(moduleData) { return moduleData.module; });
    if (shouldSaveAsSingleFile) {
      var fileContents = [];
      
      modulesData.forEach(function(moduleData) {
        fileContents.push(moduleData.code, "\n\n");
      });
      
      fileContents.push(format.fileContentsFromProjectData(projectData));
      this._repo.saveFile(project.name() + "_project.js", fileContents.join(""), successBlock, failBlock);
    } else {
      var errors = [];
      avocado.callbackWaiter.on(function(generateIntermediateCallback) {
        modulesData.forEach(function(moduleData) {
          var intermediateCallback = generateIntermediateCallback();
          avocado.transporter.fileOut(modules[moduleData.module].currentVersion(), this._repo, moduleData.code, intermediateCallback, this.callbackThatAccumulatesErrorsIn(errors, intermediateCallback));
        }.bind(this));

        var intermediateCallback = generateIntermediateCallback();
        var projectBody = format.fileContentsFromProjectData(projectData);
        this._repo.saveFile(project.name() + "_project.js", projectBody, intermediateCallback, this.callbackThatAccumulatesErrorsIn(errors, intermediateCallback));
      }.bind(this), function() {
        if (errors.length === 0) {
          successBlock();
        } else {
          failBlock(errors.join(", "));
        }
      }, "saving a project");
    }
  }, {category: ['saving']});

});


});

avocado.transporter.module.onLoadCallbacks["programming_environment/categorize_libraries"] = function() {};
avocado.transporter.module.create('programming_environment/categorize_libraries', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.method('categorizeGlobals', function () {
    // These lists come from a simple little HTML page that we wrote to get a list of the stuff
    // that comes built-in to the window object. Ideally we'd like to categorize *everything*.
    // For now, this at least gets a few hundred attributes out of our hair. -- Adam, August 2010

    var globalObjectCategories = [
      [['built-ins', 'SVG'], ['SVGAElement', 'SVGAltGlyphElement', 'SVGAngle', 'SVGAnimateColorElement', 'SVGAnimateElement', 'SVGAnimateTransformElement', 'SVGAnimatedAngle', 'SVGAnimatedBoolean', 'SVGAnimatedEnumeration', 'SVGAnimatedInteger', 'SVGAnimatedLength', 'SVGAnimatedLengthList', 'SVGAnimatedNumber', 'SVGAnimatedNumberList', 'SVGAnimatedPreserveAspectRatio', 'SVGAnimatedRect', 'SVGAnimatedString', 'SVGAnimatedTransformList', 'SVGCircleElement', 'SVGClipPathElement', 'SVGColor', 'SVGCursorElement', 'SVGDefsElement', 'SVGDescElement', 'SVGDocument', 'SVGElement', 'SVGElementInstance', 'SVGElementInstanceList', 'SVGEllipseElement', 'SVGException', 'SVGFontElement', 'SVGFontFaceElement', 'SVGFontFaceFormatElement', 'SVGFontFaceNameElement', 'SVGFontFaceSrcElement', 'SVGFontFaceUriElement', 'SVGForeignObjectElement', 'SVGGElement', 'SVGGlyphElement', 'SVGGradientElement', 'SVGImageElement', 'SVGLength', 'SVGLengthList', 'SVGLineElement', 'SVGLinearGradientElement', 'SVGMarkerElement', 'SVGMaskElement', 'SVGMatrix', 'SVGMetadataElement', 'SVGMissingGlyphElement', 'SVGNumber', 'SVGNumberList', 'SVGPaint', 'SVGPathElement', 'SVGPathSeg', 'SVGPathSegArcAbs', 'SVGPathSegArcRel', 'SVGPathSegClosePath', 'SVGPathSegCurvetoCubicAbs', 'SVGPathSegCurvetoCubicRel', 'SVGPathSegCurvetoCubicSmoothAbs', 'SVGPathSegCurvetoCubicSmoothRel', 'SVGPathSegCurvetoQuadraticAbs', 'SVGPathSegCurvetoQuadraticRel', 'SVGPathSegCurvetoQuadraticSmoothAbs', 'SVGPathSegCurvetoQuadraticSmoothRel', 'SVGPathSegLinetoAbs', 'SVGPathSegLinetoHorizontalAbs', 'SVGPathSegLinetoHorizontalRel', 'SVGPathSegLinetoRel', 'SVGPathSegLinetoVerticalAbs', 'SVGPathSegLinetoVerticalRel', 'SVGPathSegList', 'SVGPathSegMovetoAbs', 'SVGPathSegMovetoRel', 'SVGPatternElement', 'SVGPoint', 'SVGPointList', 'SVGPolygonElement', 'SVGPolylineElement', 'SVGPreserveAspectRatio', 'SVGRadialGradientElement', 'SVGRect', 'SVGRectElement', 'SVGRenderingIntent', 'SVGSVGElement', 'SVGScriptElement', 'SVGSetElement', 'SVGStopElement', 'SVGStringList', 'SVGStyleElement', 'SVGSwitchElement', 'SVGSymbolElement', 'SVGTRefElement', 'SVGTSpanElement', 'SVGTextContentElement', 'SVGTextElement', 'SVGTextPathElement', 'SVGTextPositioningElement', 'SVGTitleElement', 'SVGTransform', 'SVGTransformList', 'SVGUnitTypes', 'SVGUseElement', 'SVGViewElement', 'SVGZoomEvent']],
      [['built-ins', 'SVG', 'Chrome'], ['SVGComponentTransferFunctionElement', 'SVGFEBlendElement', 'SVGFEColorMatrixElement', 'SVGFEComponentTransferElement', 'SVGFECompositeElement', 'SVGFEConvolveMatrixElement', 'SVGFEDiffuseLightingElement', 'SVGFEDisplacementMapElement', 'SVGFEDistantLightElement', 'SVGFEFloodElement', 'SVGFEFuncAElement', 'SVGFEFuncBElement', 'SVGFEFuncGElement', 'SVGFEFuncRElement', 'SVGFEGaussianBlurElement', 'SVGFEImageElement', 'SVGFEMergeElement', 'SVGFEMergeNodeElement', 'SVGFEMorphologyElement', 'SVGFEOffsetElement', 'SVGFEPointLightElement', 'SVGFESpecularLightingElement', 'SVGFESpotLightElement', 'SVGFETileElement', 'SVGFETurbulenceElement', 'SVGFilterElement', 'SVGHKernElement', 'SVGVKernElement']],
      [['built-ins', 'DOM'], ['HTMLAllCollection', 'HTMLAnchorElement', 'HTMLAppletElement', 'HTMLAreaElement', 'HTMLAudioElement', 'HTMLBRElement', 'HTMLBaseElement', 'HTMLBaseFontElement', 'HTMLBlockquoteElement', 'HTMLBodyElement', 'HTMLButtonElement', 'HTMLCanvasElement', 'HTMLCollection', 'HTMLDListElement', 'HTMLDirectoryElement', 'HTMLDivElement', 'HTMLDocument', 'HTMLElement', 'HTMLEmbedElement', 'HTMLFieldSetElement', 'HTMLFontElement', 'HTMLFormElement', 'HTMLFrameElement', 'HTMLFrameSetElement', 'HTMLHRElement', 'HTMLHeadElement', 'HTMLHeadingElement', 'HTMLHtmlElement', 'HTMLIFrameElement', 'HTMLImageElement', 'HTMLInputElement', 'HTMLIsIndexElement', 'HTMLLIElement', 'HTMLLabelElement', 'HTMLLegendElement', 'HTMLLinkElement', 'HTMLMapElement', 'HTMLMarqueeElement', 'HTMLMediaElement', 'HTMLMenuElement', 'HTMLMetaElement', 'HTMLModElement', 'HTMLOListElement', 'HTMLObjectElement', 'HTMLOptGroupElement', 'HTMLOptionElement', 'HTMLParagraphElement', 'HTMLParamElement', 'HTMLPreElement', 'HTMLQuoteElement', 'HTMLScriptElement', 'HTMLSelectElement', 'HTMLStyleElement', 'HTMLTableCaptionElement', 'HTMLTableCellElement', 'HTMLTableColElement', 'HTMLTableElement', 'HTMLTableRowElement', 'HTMLTableSectionElement', 'HTMLTextAreaElement', 'HTMLTitleElement', 'HTMLUListElement', 'HTMLVideoElement']],
      [['built-ins', 'CSS'], ['CSSCharsetRule', 'CSSFontFaceRule', 'CSSImportRule', 'CSSMediaRule', 'CSSPageRule', 'CSSPrimitiveValue', 'CSSRule', 'CSSRuleList', 'CSSStyleDeclaration', 'CSSStyleRule', 'CSSStyleSheet', 'CSSValue', 'CSSValueList', 'CSSVariablesDeclaration', 'CSSVariablesRule']],
      [['built-ins', 'event handlers'], ['onabort', 'onbeforeunload', 'onblur', 'oncanplay', 'oncanplaythrough', 'onchange', 'onclick', 'oncontextmenu', 'ondblclick', 'ondrag', 'ondragend', 'ondragenter', 'ondragleave', 'ondragover', 'ondragstart', 'ondrop', 'ondurationchange', 'onemptied', 'onended', 'onerror', 'onfocus', 'onhashchange', 'oninput', 'oninvalid', 'onkeydown', 'onkeypress', 'onkeyup', 'onload', 'onloadeddata', 'onloadedmetadata', 'onloadstart', 'onmessage', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'onmousewheel', 'onoffline', 'ononline', 'onpagehide', 'onpageshow', 'onpause', 'onplay', 'onplaying', 'onpopstate', 'onprogress', 'onratechange', 'onreset', 'onresize', 'onscroll', 'onsearch', 'onseeked', 'onseeking', 'onselect', 'onstalled', 'onstorage', 'onsubmit', 'onsuspend', 'ontimeupdate', 'onunload', 'onvolumechange', 'onwaiting', 'onwebkitanimationend', 'onwebkitanimationiteration', 'onwebkitanimationstart', 'onwebkittransitionend']],
      [['built-ins', 'uncategorized'], ['Attr', 'Audio', 'BeforeLoadEvent', 'Blob', 'CDATASection', 'CanvasRenderingContext2D', 'CharacterData', 'ClientRect', 'ClientRectList', 'Clipboard', 'Comment', 'Counter', 'DOMException', 'DOMImplementation', 'DOMParser', 'Document', 'DocumentFragment', 'DocumentType', 'Element', 'Entity', 'EntityReference', 'EvalError', 'Event', 'EventException', 'EventSource', 'File', 'FileList', 'FormData', 'Image', 'ImageData', 'KeyboardEvent', 'MediaError', 'MediaList', 'MessageChannel', 'MessageEvent', 'MessagePort', 'MimeType', 'MimeTypeArray', 'MouseEvent', 'MutationEvent', 'NamedNodeMap', 'Node', 'NodeFilter', 'NodeList', 'Notation', 'Option', 'OverflowEvent', 'PageTransitionEvent', 'Plugin', 'PluginArray', 'ProcessingInstruction', 'ProgressEvent', 'RGBColor', 'Range', 'RangeError', 'RangeException', 'Rect', 'ReferenceError', 'SharedWorker', 'Storage', 'StorageEvent', 'StyleSheet', 'StyleSheetList', 'SyntaxError', 'Text', 'TextEvent', 'TextMetrics', 'TypeError', 'UIEvent', 'URIError', 'WebKitAnimationEvent', 'WebKitCSSKeyframeRule', 'WebKitCSSKeyframesRule', 'WebKitCSSMatrix', 'WebKitCSSTransformValue', 'WebKitPoint', 'WebKitTransitionEvent', 'WebSocket', 'WheelEvent', 'Worker', 'XMLDocument', 'XMLHttpRequest', 'XMLHttpRequestException', 'XMLHttpRequestUpload', 'XMLSerializer', 'XPathEvaluator', 'XPathException', 'XPathResult', 'XSLTProcessor', 'addEventListener', 'alert', 'applicationCache', 'atob', 'blur', 'btoa', 'captureEvents', 'clearInterval', 'clearTimeout', 'clientInformation', 'close', 'closed', 'confirm', 'console', 'crypto', 'defaultStatus', 'defaultstatus', 'devicePixelRatio', 'dispatchEvent', 'document', 'event', 'find', 'focus', 'frameElement', 'frames', 'getComputedStyle', 'getMatchedCSSRules', 'getSelection', 'history', 'innerHeight', 'innerWidth', 'length', 'localStorage', 'location', 'locationbar', 'menubar', 'moveBy', 'moveTo', 'name', 'navigator', 'offscreenBuffering', 'open', 'openDatabase', 'opener', 'outerHeight', 'outerWidth', 'pageXOffset', 'pageYOffset', 'parent', 'personalbar', 'postMessage', 'print', 'prompt', 'releaseEvents', 'removeEventListener', 'resizeBy', 'resizeTo', 'screen', 'screenLeft', 'screenTop', 'screenX', 'screenY', 'scroll', 'scrollBy', 'scrollTo', 'scrollX', 'scrollY', 'scrollbars', 'self', 'sessionStorage', 'setInterval', 'setTimeout', 'showModalDialog', 'status', 'statusbar', 'stop', 'styleMedia', 'toolbar', 'top', 'webkitConvertPointFromNodeToPage', 'webkitConvertPointFromPageToNode', 'window']],
      [['built-ins', 'uncategorized', 'Firefox'], ['_options', 'back', 'content', 'controllers', 'disableExternalCapture', 'dump', 'enableExternalCapture', 'forward', 'fullScreen', 'getInterface', 'globalStorage', 'home', 'mozAnimationStartTime', 'mozInnerScreenX', 'mozInnerScreenY', 'mozPaintCount', 'mozRequestAnimationFrame', 'moz_indexedDB', 'netscape', 'openDialog', 'pkcs11', 'routeEvent', 'scrollByLines', 'scrollByPages', 'scrollMaxX', 'scrollMaxY', 'setResizable', 'sizeToContent', 'updateCommands']],
      [['built-ins', 'uncategorized', 'Chrome'], ['BlobBuilder', 'CanvasGradient', 'CanvasPattern', 'DOMStringList', 'FileError', 'FileReader', 'HTMLMeterElement', 'HTMLProgressElement', 'SQLException', 'TimeRanges', 'TouchEvent', 'chrome', 'chromium', 'external', 'webkitNotifications', 'webkitPerformance']],
      [['libraries', 'Prototype'], ['$$', '$', '$A', '$F', '$H', '$R', '$break', '$continue', '$w', 'Abstract', 'Ajax', 'Class', 'Enumerable', 'Field', 'Form', 'Hash', 'Insertion', 'ObjectRange', 'PeriodicalExecuter', 'Position', 'Prototype', 'Selector', 'Template', 'Toggle', 'Try']],
      [['libraries', 'MooTools'], ['$family', 'MooTools', 'addEvent', 'addEvents', 'addListener', 'cloneEvents', 'eliminate', 'fireEvent', 'getCoordinates', 'getDocument', 'getHeight', 'getLeft', 'getPosition', 'getScroll', 'getScrollHeight', 'getScrollLeft', 'getScrollSize', 'getScrollTop', 'getScrollWidth', 'getSize', 'getTop', 'getWidth', 'getWindow', 'removeEvent', 'removeEvents', 'removeListener', 'retrieve', 'store', 'uid']],
      [['avocado', 'libraries', 'Moousture'], ['Moousture']],
      [['avocado', 'libraries', 'JSLint'], ['JSLINT']],
      [['avocado', 'libraries', 'JSParse'], ['jsParse']],
      [['avocado', 'libraries', 'ShareThis'], ['cookie', 'openWidget', 'rNumFor5x', 'Shareable', 'stButtons', 'stLight', 'stWidget', 'st_showing', 'switchTo5x', 'testLimitFor5x']],
      [['avocado', 'lively kernel'], ['$morph', 'anonymous_module_0', 'ClipboardHack', 'Config', 'ContextJS', 'Converter', 'CustomJSON', 'DisplayThemes', 'Functions', 'Global', 'GlobalLayers', 'LayerStack', 'LayerableObjectTrait', 'LivelyNS', 'Loader', 'ModelMigration', 'NetRequestReporterTrait', 'NodeFactory', 'NodeStyle', 'Properties', 'Strings', 'UserAgent', 'ViewTrait', 'XHTMLNS', 'XLinkNS', 'basicResize', 'classes', 'composeLayers', 'computerLayersFor', 'connect', 'cop', 'createLayer', 'currentLayers', 'dbgOn', 'disableLayer', 'disconnect', 'disconnectAll', 'enableLayer', 'ensurePartialLayer', 'equals', 'functions', 'gather', 'getCurrentContext', 'getLayerDefinitionForObject', 'getStack', 'halt', 'initialize', 'inspect', 'interactiveEval', 'layerClass', 'layerClassAndSubclasses', 'layerGetterMethod', 'layerMethod', 'layerObject', 'layerProperty', 'layerPropertyWithShadow', 'layerSetterMethod', 'lively', 'logError', 'logStack', 'makePropertyLayerAware', 'module', 'namespace', 'namespaceIdentifier', 'newDragnDropListPane', 'newListPane', 'newPrintPane', 'newRealListPane', 'newTextListPane', 'newTextPane', 'newXenoPane', 'openStackViewer', 'printError', 'printStack', 'pt', 'rect', 'require', 'resetLayerStack', 'signal', 'subNamespaces', 'updateAttributeConnection', 'using', 'withLayers', 'withoutLayers', 'constructor']]
    ];

    globalObjectCategories.forEach(function(catAndAttrs) {
      avocado.annotator.annotationOf(window).categorize(catAndAttrs[0], catAndAttrs[1]);
    });
    
    if (window.Enumerable) {
      avocado.annotator.annotationOf(Enumerable).categorize(['enumerating'], ['all', 'any', 'collect', 'detect', 'each', 'eachSlice', 'entries', 'every', 'filter', 'find', 'findAll', 'grep', 'include', 'inGroupsOf', 'inject', 'inspect', 'invoke', 'map', 'max', 'member', 'min', 'partition', 'pluck', 'reject', 'select', 'size', 'some', 'sortBy', 'toArray', 'zip']);
    }

  }, {category: ['categorizing']});

});


});

avocado.transporter.module.onLoadCallbacks["demo/person"] = function() {};
avocado.transporter.module.create('demo/person', function(requires) {

requires('core/deep_copy');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('person', Object.create({}));

  add.creator('humanName', Object.create({}));

});


thisModule.addSlots(avocado.person, function(add) {

  add.creator('example', Object.create(avocado.person));

  add.method('toString', function () { return this._name.toString(); });

});


thisModule.addSlots(avocado.person.example, function(add) {

  add.creator('_name', Object.create(avocado.humanName));

  add.data('_age', 45);

});


thisModule.addSlots(avocado.person.example._name, function(add) {

  add.data('_first', 'Bob');

  add.data('_middle', 'J.');

  add.data('_last', 'Smith');

});


thisModule.addSlots(avocado.humanName, function(add) {

  add.creator('example', Object.create(avocado.humanName));

  add.method('copy', function () {
    return Object.deepCopyRecursingIntoCreatorSlots(this);
  }, {category: ['copying']});

  add.method('toString', function () {
    var n = [];
    if (this._first ) { n.push(this._first ); }
    if (this._middle) { n.push(this._middle); }
    if (this._last  ) { n.push(this._last  ); }
    return n.join(" ");
  }, {category: ['printing']});

  add.method('set', function (first, middle, last) {
    this._first = first;
    this._middle = middle;
    this._last = last;
    return this;
  }, {category: ['accessing']});

});


thisModule.addSlots(avocado.humanName.example, function(add) {

  add.data('_first', 'Bullwinkle');

  add.data('_middle', 'J.');

  add.data('_last', 'Moose');

});


});

avocado.transporter.module.onLoadCallbacks["lk_ext/changes"] = function() {};
WorldMorph.addMethods({
  onMouseDown: function($super, evt) {
    // Added by Adam, Feb. 2008, because sometimes it's useful
    // to have no keyboard focus (so that, for example, I can
    // hit Cmd-t to open a new tab).
    //
    // NOTE: I once tried making this line say setKeyboardFocus(this),
    // and for some reason Style Editors broke. (They're probably
    // not the only thing that broke, but that was the thing I
    // noticed.) I have no idea why, but it's not important right
    // now, so I'm letting it go. -- Adam, Nov. 2010
    evt.hand.setKeyboardFocus(null);
    
    this.removeAllPartialCommandMorphs();

    if (this.shouldSlideIfClickedAtEdge) { this.slideIfClickedAtEdge(evt); }

    return $super(evt);
  },
  
  worldPointCorrespondingToScreenPoint: function (p) {
    return p;
  }
});

Object.extend(Morph, {
  suppressAllHandlesForever: function() {
    Object.extend(Morph.prototype, {checkForControlPointNear: function(evt) {return false;}});
  },
});

PasteUpMorph.addMethods({
    onMouseDown: function PasteUpMorph$onMouseDown($super, evt) {  //default behavior is to grab a submorph
      $super(evt);
      var m = this.morphToReceiveEvent(evt, null, true); // Modified to checkForDnD -- Adam, August 2008
      if (Config.usePieMenus) {
        if (m.handlesMouseDown(evt)) return false;
        m.showPieMenu(evt, m);
        return true;
      }
      if (m == null) {
        if (evt.isLeftMouseButtonDown()) { // Added the isLeftMouseButtonDown check, 'cause I like it better that way. -- Adam, Jan. 2009
          if (! UserAgent.isTouch) { // don't want SelectionMorphs on touch-screens -- Adam
            this.makeSelection(evt);
          }
          return true;
        } else {
          return false;
        }
      } else if (!evt.isForContextMenu() && !evt.isForMorphMenu()) { // Changed from a simple isCommandKey check. -- Adam, Jan. 2009
        if (m === this.world()) {
          if (! UserAgent.isTouch) { // don't want SelectionMorphs on touch-screens -- Adam
            this.makeSelection(evt);
          }
          return true;
        } else if (m.handlesMouseDown(evt)) {
          return false;
        }
      }
      evt.hand.grabMorph(m, evt);
      return true;
    },
});

Morph.addMethods({
  getOwner: function() { return this.owner; },

  getShape: function() { return this.shape; },
  
  eachSubmorph: function(f) {
    for (var i = 0, n = this.submorphs.length; i < n; ++i) {
      f(this.submorphs[i]);
    }
  },

  topmostOwnerBesidesTheWorldAndTheHand: function () {
    var m = this;
    while (m.owner && ! (m.owner instanceof WorldMorph) && ! (m.owner instanceof HandMorph)) {
      m = m.owner;
    }
    return m;
  },
  
  // for compatibility with 3D
  setTopLeftPosition:    function(p      ) { return this.setTopLeftPositionXY(p.x, p.y); },
  setTopLeftPositionXY:  function(x, y   ) { return this.setPositionXY(x, y); },
  setTopLeftPositionXYZ: function(x, y, z) { return this.setTopLeftPositionXY(x, y); },
  
  getOriginAAAHack: function() { return pt(0,0); }, // aaa for compatibility with 3D, but it's a bug, I need to just fix it
  
  rotateToFaceTheCamera: function() {}, // nothing necessary here, just for compatibility with 3D
  
  getHorizontalScale: function () { return this.scalePoint.x; },
  getVerticalScale:   function () { return this.scalePoint.y; },
  setHorizontalScale: function (s) { this.setScalePoint(pt(s, this.scalePoint.y)); return this; },
  setVerticalScale:   function (s) { this.setScalePoint(pt(this.scalePoint.x, s)); return this; },
});

Morph.addMethods({
  
  overallScaleTakingUsersPositionIntoAccount: function() {
    return this.overallScale();
  },
  
    aboutToReceiveDrop: function(m) {
      // children can override
      
      if (this._layout && this._layout.aboutToReceiveDrop) {
        this._layout.aboutToReceiveDrop(m);
      }
    },
    
    aboutToBeDroppedOn: function(receiver) {
      // children can override
      
      return true; // to indicate that the receiver morph should handle the drop
    },
    
  
    checkForDoubleClick: function(evt) {
      if (evt.isDoubleClick()) {
        return this.onDoubleClick(evt);
      } else {
        return false;
      }
    },

    onDoubleClick: function(evt) {
      if (this._eventHandler && this._eventHandler.onDoubleClick) {
        return this._eventHandler.onDoubleClick(this, evt);
      } else if (window.avocado && avocado.defaultDoubleClickHandler) {
        return avocado.defaultDoubleClickHandler(this, evt);
      } else if (UserAgent.isTouch) {
        return this.showContextMenu(evt);
      } else {
        return false;
      }
    },

    handlesDoubleClick: function(evt) {
      if (this._eventHandler && this._eventHandler.onDoubleClick) { return true; }
      if (window.avocado && avocado.defaultDoubleClickHandler) { return true; }
      if (UserAgent.isTouch) { return true; }
      return false;
    },

    // Copied and adapted from PasteUpMorph - it's convenient to be able to allow any morph to do selecting. -- Adam, June 2011
  	makeSelection: function(evt) {	//default behavior is to grab a submorph
  		if (this.currentSelection != null) this.currentSelection.removeOnlyIt();

      var p = this.localizePointFrom(evt.point(), this.world());
  		var m = new SelectionMorph(p.asRectangle(), this);
  		this.currentSelection = m;

  		this.addMorph(m);
  		var handle = new HandleMorph(pt(0,0), lively.scene.Rectangle, evt.hand, m, "bottomRight");
  		handle.setExtent(pt(0, 0));
      handle.focusHaloBorderWidth = 0; // added by Adam; the halo looks weird
  		handle.mode = 'reshape';
  		m.addMorph(handle);
  		evt.hand.setMouseFocus(handle);
  		evt.hand.setKeyboardFocus(handle);
  	},
  	
  	shouldAllowSelecting: function() {
  	  return this._shouldAllowSelecting;
  	},
});

Object.extend(Event.prototype, {
  isDoubleClick: function() {
    var previous = this.hand.lastMouseDownEvent;
    return previous && this.timeStamp && previous.timeStamp && this.timeStamp - previous.timeStamp < 400; // aaa magic number
  }
});

HandMorph.addMethods({
    dropMorphsOn: function(receiver) {
        if (receiver !== this.world()) this.unbundleCarriedSelection();
        if (this.logDnD) console.log("%s dropping %s on %s", this, this.topSubmorph(), receiver);
        this.carriedMorphsDo( function(m) {
            var shouldLetTheReceiverHandleIt = m.aboutToBeDroppedOn(receiver); // Added by Adam
            if (shouldLetTheReceiverHandleIt) {
              receiver.aboutToReceiveDrop(m); // Added by Adam
              m.dropMeOnMorph(receiver);
              this.showAsUngrabbed(m);
              receiver.justReceivedDrop(m, this); // Added by Adam
            }
        });
        this.removeAllMorphs(); // remove any shadows or halos
    },

    // Copied-and-pasted the bottom half of grabMorph. Needed for
    // stuff that should be able to be explicitly grabbed, but
    // not through the default "just click to pick it up" mechanism. -- Adam
    grabMorphWithoutAskingPermission: function(grabbedMorph, evt) {
        if (this.keyboardFocus && grabbedMorph !== this.keyboardFocus) {
            this.keyboardFocus.relinquishKeyboardFocus(this);
        }
        // console.log('grabbing %s', grabbedMorph);
        // Save info for cancelling grab or drop [also need indexInOwner?]
        // But for now we simply drop on world, so this isn't needed
        this.grabInfo = [grabbedMorph.owner, grabbedMorph.position()];
        if (this.logDnD) console.log('%s grabbing %s', this, grabbedMorph);
        this.addMorphAsGrabbed(grabbedMorph);
        // grabbedMorph.updateOwner();
        this.changed(); //for drop shadow
    },

    grabMorph: function(grabbedMorph, evt) {
        if (evt.isShiftDown() || (grabbedMorph.owner && grabbedMorph.owner.copySubmorphsOnGrab == true)) {
            if (!grabbedMorph.okToDuplicate()) return;
            grabbedMorph.copyToHand(this);
            return;
        }
        if (evt.isForMorphMenu()) {
            grabbedMorph.showMorphMenu(evt);
            return;
        }
        if (evt.isForContextMenu()) { // Changed from a simple isCommandKey check. -- Adam, Jan. 2009
            grabbedMorph.showContextMenu(evt);
            return;
        }
        // Give grabbed morph a chance to, eg, spawn a copy or other referent
        grabbedMorph = grabbedMorph.okToBeGrabbedBy(evt);
        if (!grabbedMorph) return;
        
        // A morph with a whooshOuttaHereTimer is supposed to whoosh away after a short while, unless the user touches it. -- Adam
        if (grabbedMorph.whooshOuttaHereTimer) { clearTimeout(grabbedMorph.whooshOuttaHereTimer); }

        // aaa - I think this is not what we want. openForDragAndDrop should mean
        // that the morph is open for arbitrary embedding, but even if it's not,
        // we may want to grab a morph for some other reason. Use suppressGrabbing
        // if you want to disable grabbing a morph altogether. I think. -- Adam, Apr. 2011
        // if (grabbedMorph.owner && !grabbedMorph.owner.openForDragAndDrop) return;

        if (this.keyboardFocus && grabbedMorph !== this.keyboardFocus) {
            this.keyboardFocus.relinquishKeyboardFocus(this);
        }
        // console.log('grabbing %s', grabbedMorph);
        // Save info for cancelling grab or drop [also need indexInOwner?]
        // But for now we simply drop on world, so this isn't needed
        this.grabInfo = [grabbedMorph.owner, grabbedMorph.position()];
        if (this.logDnD) console.log('%s grabbing %s', this, grabbedMorph);
        this.addMorphAsGrabbed(grabbedMorph);
        // grabbedMorph.updateOwner();
        this.changed(); //for drop shadow
    }
});

TextMorph.addMethods({
  getText: function()  {return this.textString;},
  setText: function(t) {if (this.textString !== t) {this.updateTextString(t); this.layoutChanged(); this.changed();}},

  // Just wondering whether I can set a TextMorph to be bold/italic and have it stay that way no matter what text I give it.
  setEmphasis: function(emph) {
    var txt = new lively.Text.Text(this.textString, this.textStyle);
    txt.emphasize(emph, 0, this.textString.length);
    this.textStyle = txt.style;
    this.composeAfterEdits();
    return this;
  },
  
  updateStyle: function($super) {
    $super();
    if (avocado.shouldHideTextSmallerThan) {
      var overallFontSize = this.getFontSize() * this.overallScale();

      var tooSmall = overallFontSize < avocado.shouldHideTextSmallerThan;
      if (tooSmall && !this._textColorToUseWhenNotHidden) {
        this._textColorToUseWhenNotHidden = this.getTextColor();
        this.setTextColor(null);
      } else if (!tooSmall && this._textColorToUseWhenNotHidden) {
        this.setTextColor(this._textColorToUseWhenNotHidden);
        delete this._textColorToUseWhenNotHidden;
      }
    }
  }
});
    
Class.newInitializer = function(name) {
  // this hack ensures that class instances have a name
  var c = eval(Class.initializerTemplate.replace(/CLASS/g, name) + ";" + name);
  
  // Put it in a category so that it doesn't clutter up the window object. -- Adam
  if (window.avocado && avocado.annotator && name.startsWith('anonymous_')) {
    avocado.annotator.annotationOf(window).setSlotAnnotation(name, {category: ['anonymous classes']});
  }

  return c;
};

Morph.addMethods({
	  pickMeUpLeavingPlaceholderIfNecessary: function(evt) {
	    this.becomeDirectSubmorphOfWorld(evt.hand.world());
  	  this.pickMeUp(evt);
	  },
	  
	  shouldBeEasilyGrabbable: function() {
	    if (avocado.shouldMorphsOnlyBeEasilyGrabbableIfTheyExplicitlySaySo) {
  	    if (this._model && typeof(this._model.shouldBeEasilyGrabbable) === 'function') {
  	      return this._model.shouldBeEasilyGrabbable();
  	    }
  	    return false;
	    } else {
	      return !this.isWorld;
	    }
    },

	  pullCloser: function(evt, callback, desiredScale) {
	    var world = evt.hand.world();
	    this.becomeDirectSubmorphOfWorld(world);
	    var space = this.getExtent().scaleBy(this.getScale());
	    var worldExtent = world.getExtent();
	    desiredScale = desiredScale || this.getScale() * Math.max(1, Math.min(worldExtent.x / space.x, worldExtent.y / space.y) * 0.5);
	    // console.log("this.getExtent(): " + this.getExtent() + ", this.getScale(): " + this.getScale() + ", world.getExtent(): " + world.getExtent() + ", world.getScale(): " + world.getScale());
  	  this.stayCenteredAndSmoothlyScaleTo(desiredScale, pt(0,0), function() {
    	  if (callback) { callback(); }
  	  }.bind(this));
    },
    
	  grabAndPullMe: function(evt, callback) {
	    this.pullCloser(evt, function() {
    	  this.grabMeWithoutZoomingAroundFirst(evt);
    	  if (callback) { callback(); }
  	  }.bind(this));
	  },

	  grabAndPullMeOrPutMeBack: function(evt, callback) {
      if (this._placeholderMorphIJustCameFrom) {
        this._placeholderMorphIJustCameFrom.layout().putOriginalMorphBack(callback);
      } else {
        this.grabAndPullMe(evt, callback);
      }
	  },
    
  	debugInspect: function() {
  	  var tos = this.toString();
  	  return "a " + this.constructor.type + (tos ? "(" + tos + ")" : "");
  	},

    useBackgroundImage: function(url) {
      if (!this._image) {
        var extent = this.getExtent();
    		this._image = new lively.scene.Image(url, extent.x, extent.y);
    		this._image.rawNode.setAttribute("preserveAspectRatio", "none");
    		this.addNonMorph(this._image.rawNode);
    		/*
    		How do I make it stay in the back?
    		this._image = new ImageMorph(pt(0,0).extent(extent), url);
    		this._image.ignoreEvents();
    		this._image.image.rawNode.setAttribute("preserveAspectRatio", "none");
    		this.addMorphBack(this._image);
    		*/
      } else {
        var extent = this.getExtent();
        this._image.setWidth (extent.x);
        this._image.setHeight(extent.y);
        //this._image.setExtent(extent);
      }
    },
});

avocado.morphWithAModel = {
  prompter: {
    prompt: function (caption, context, evt, callback) {
      evt.hand.world().showMessage("Must pick up a target object first.", Color.red); // aaa let the user just click on the target
    }
  },
  
  doesTypeMatch: function (obj) {
    return obj && typeof(obj._model) !== 'undefined' && obj instanceof Morph;
  }
};

Morph.addMethods({
  setHelpText: function(t) {
    this.getHelpText = function() { return t; };
    return this;
  }
});


Morph.addMethods({
  changeNotifier: function() {
    // aaa - A hack to allow someone to ask to be notified when a particular morph
    // changes. Useful for arrows - we can make sure to update the arrow the instant
    // its endpoint moves.
    return this._changeNotifier || (this._changeNotifier = avocado.notifier.on(this));
  }
});


Morph.addMethods({
  animatedAddMorphCentered: function(m, callWhenDone) {
    this.animatedAddMorphCenteredAt(m, this.getExtent().scaleBy(0.5), callWhenDone);
  },
  
  animatedAddMorphCenteredAt: function(m, centerPt, callWhenDone) {
    this.animatedAddMorphAt(m, centerPt.subPt(m.getExtent().scaleBy(0.5)), callWhenDone);
  },
  
  addMorphCentered: function(m) {
    this.addMorphCenteredAt(m, this.getExtent().scaleBy(0.5));
  },

  addMorphCenteredAt: function(m, centerPt) {
    this.addMorphAt(m, centerPt.subPt(m.getExtent().scaleBy(0.5)));
  },
});


Morph.addMethods({
  handIsOverMe: function (hand) {
    return this.shape.containsPoint(this.localize(hand.getPosition()));
  },
  
  submorphThatHandIsOver: function (hand) {
    for (var i = 0, n = this.submorphs.length; i < n; ++i) {
      var m = this.submorphs[i];
      if (m.handIsOverMe(hand)) { return m; }
    }
    return null;
  },
});


Morph.addMethods({
  setExtentIfChanged: function (newExtent) {
    if (! newExtent.eqPt(this.getExtent())) {
      this.setExtent(newExtent);
      //this.smoothlyResizeTo(newExtent); // aaa - doesn't quite work right yet
    }
  }
});

Morph.addMethods({
  replaceMorph: function(m, newSubmorph) {
    // Let the layout take care of it if it wants to.
    if (this._layout && this._layout.replaceMorph) { return this._layout.replaceMorph(m, newSubmorph); }
    
    // This method is kind of a combination of addMorphFrontOrBack and removeMorph. -- Adam
    
		var index = this.submorphs.indexOf(m);
		if (index < 0) {
			m.owner !== this && console.log("%s has owner %s that is not %s?", m, m.owner, this);
			return null;
		}

		if (newSubmorph.owner) {
			var tfm = newSubmorph.transformForNewOwner(this);
			newSubmorph.owner.removeMorph(newSubmorph); // KP: note not m.remove(), we don't want to stop stepping behavior
			newSubmorph.setTransform(tfm); 
			// FIXME transform is out of date
			// morph.setTransform(tfm); 
			// m.layoutChanged(); 
		} 
		
		var position = m.getPosition();
		m.replaceRawNode(newSubmorph.rawNode);
		var spliced = this.submorphs.spliceAndAdjustCreatorSlots(index, 1, newSubmorph); // aaa fileout hack -- Adam
		if (spliced instanceof Array) spliced = spliced[0];
		if (m !== spliced) {
			console.log("invariant violated removing %s, spliced %s", m, spliced);
		}
		
		// cleanup, move to ?
		// Gotta make sure to leave the replaced morph at the right scale, so that if we then add it back to the world it'll look right. -- Adam
		var mScale = m.overallScale(this.world());
		m.owner = null;
		m.setScale(mScale);
		m.setHasKeyboardFocus(false);
		this.layoutManager.removeMorph(this, m);

		newSubmorph.owner = this;
		newSubmorph.changed();
		newSubmorph.layoutChanged();
		
		this.layoutChanged();
		
		newSubmorph.setPosition(position);
  },
});


Object.extend(lively.scene.Rectangle, {
  createWithIrrelevantExtent: function () {
    // This is a small hack. Sometimes we just want a default shape and we don't really
    // care what it is because it's going to be changed immediately anyways.
    // But LK doesn't let us create a Morph without a shape.
    return new this(new Rectangle(0, 0, 10, 10));
  }
});


Object.extend(HandMorph.prototype, {
  shouldNotBePartOfRowOrColumn: true
});


Object.extend(HandleMorph.prototype, {
  shouldNotBePartOfRowOrColumn: true
});


ButtonMorph.addMethods({
  pushMe: function() {
    this.getModel().setValue(false);
  }
});


ImageMorph.addMethods({
  beLabel: function() {
    this.applyStyle(this.labelStyle);
    return this;
  },
  
  labelStyle: {
    fill: null,
    suppressGrabbing: true,
    shouldIgnoreEvents: true,
    openForDragAndDrop: false
  },
  
  keepAspectRatioAndResizeToAtMost: function(desiredExtent) {
    var originalImageSize = this.originalImageSize(this.getURL());
    var yIfWeUseTheDesiredX = desiredExtent.x * originalImageSize.y / originalImageSize.x;
    var xIfWeUseTheDesiredY = desiredExtent.y * originalImageSize.x / originalImageSize.y;
    if (yIfWeUseTheDesiredX > desiredExtent.y) {
      this.setExtent(pt(xIfWeUseTheDesiredY, desiredExtent.y));
    } else {
      this.setExtent(pt(desiredExtent.x, yIfWeUseTheDesiredX));
    }
    return this;
  }
});

SelectionMorph.addMethods({
  inspect: function () {
    return avocado.command.list.descriptionOfGroup(this.selectedMorphs);
  },

  commands: function () {
    var cmdList = avocado.command.list.create();
    cmdList.addItemsFromGroup(this.selectedMorphs);
    return cmdList;
  }
});

Object.extend(lively.scene.Rectangle.prototype, {
  area: function() { return this.bounds().area(); }
});

Object.extend(lively.paint.Gradient.prototype, {
  // Copied over from Color.
  
	darker: function(recursion) { 
		if (recursion == 0) 
			return this;
		var result = this.mixedWith(Color.black, 0.5);
		return recursion > 1  ? result.darker(recursion - 1) : result;
	},

	lighter: function(recursion) { 
		if (recursion == 0) 
			return this;
		var result = this.mixedWith(Color.white, 0.5);
		return recursion > 1 ? result.lighter(recursion - 1) : result;
	},

	mixedWith: function(color, proportion) {
		var result = this.copyRemoveAll();
		for (var i = 0; i < this.stops.length; ++i) {
			result.addStop(this.stops[i].offset(), this.stops[i].color().mixedWith(color, proportion));
		}
		return result;
	}
});

Object.extend(lively.paint.LinearGradient.prototype, {
    copyRemoveAll: function() {
        return new this.constructor([], this.vector);
    }
});

Object.extend(lively.paint.RadialGradient.prototype, {
    copyRemoveAll: function() {
        return new this.constructor([], this.focus());
    },
    
    focus: function() {
        return pt(this.getTrait('fx'), this.getTrait('fy'));
    }
});


Object.extend(FileDirectory.prototype, {
  newMorph: function () {
    return avocado.treeNode.newMorphFor(this);
  }
});
avocado.transporter.module.onLoadCallbacks["lk_ext/changes"] = 'done';

avocado.transporter.module.onLoadCallbacks["lk_ext/menus"] = function() {};
Event.addMethods({
  isForContextMenu:    function() { return (this.isLeftMouseButtonDown() && this.isCtrlDown())   || this.isRightMouseButtonDown() || this.isAltDown();  },
  isForMorphMenu:      function() { return (this.isLeftMouseButtonDown() && this.isCommandKey()) || this.isMiddleMouseButtonDown(); }
});

MenuMorph.addMethods({
  addSection: function(newItems) {
    if (newItems.size() > 0) {
      if (this.items.size() > 0) {this.addLine();}
      newItems.each(function(item) {this.addItem(item);}.bind(this));
    }
  }
});

PieMenuMorph.addMethods({
  addItem: function(item) {
    if (item) {
      this.items.push(item);
    } else {
      this.addLine();
    }
  },
  
  addLine: function() {
    // nothing to do here
  },
  
  openIn: function(parentMorph, loc, remainOnScreen, captionIfAny) { 
    // aaa - What's the right way to create a common interface between MenuMorph and PieMenuMorph?
    var evt = Event.createFake();
    evt.mousePoint = loc;
    this.open(evt);
  }
});
avocado.transporter.module.onLoadCallbacks["lk_ext/menus"] = 'done';

avocado.transporter.module.onLoadCallbacks["lk_ext/grabbing"] = function() {};
Morph.addMethods({
	
	  applicableCommandForDropping: function(morph) { 
	    var cmdList = this.dragAndDropCommands();
  	  if (cmdList) {
  	    var args = [morph];
  	    var applicableCmd = cmdList.itemSuchThat(function(c) { return c.canAcceptArguments(args); });
  	    return applicableCmd;
  	  }
  	  return null;
    },

  	acceptsDropping: function(morph) {
  	  // More general drag-and-drop mechanism, added by Adam.
  	  var c = this.applicableCommandForDropping(morph);
  	  if (c) { return true; }

  		return this.openForDragAndDrop && !(morph instanceof WindowMorph);
  	},

    particularlyWantsToBeDroppedOn: function (m) {
      // I'm not sure I like this mechanism, but I want it for things like MorphChoosers,
      // which should be able to be dropped on anything - the target thing shouldn't
      // need to know anything about it. -- Adam, Nov. 2011
      return false;
    },

    okToBeDroppedOn: function(m) {
      return m && (m.acceptsDropping(this) || this.particularlyWantsToBeDroppedOn(m));
    },
  
    okToReceiveDrop: function(m) {
      return m && m.okToBeDroppedOn(this);
    },
  
    justReceivedDrop: function(morph, hand) {
  	  var c = this.applicableCommandForDropping(morph);
  	  if (c) {
  	    c.go(Event.createFake(), morph); // aaa - can't we get a real event?
  	    if (morph.owner === this && ! this.openForDragAndDrop && hand.grabInfo) { // aaa - not sure this.openForDragAndDrop makes sense here
					var previousOwner    = hand.grabInfo[0];
					var previousPosition = hand.grabInfo[1];
					var world = previousOwner.world();
					if (world) {
  					morph.ensureIsInWorld(world, previousPosition, true, true, false, function() {
  						previousOwner.addMorph(morph);
  					});
					}
	      }
  	  } else if (this.openForDragAndDrop) {
  	    // fine
	    } else {
        throw new Error("for drag-and-drop, children should implement either dragAndDropCommands or justReceivedDrop");
      }
      
      if (this._layout && this._layout.justReceivedDrop) {
        this._layout.justReceivedDrop(morph, hand);
      }
    },

    morphToGrabOrReceive: function(evt, droppingMorph, checkForDnD) {
        // If checkForDnD is false, return the morph to receive this mouse event (or null)
        // If checkForDnD is true, return the morph to grab from a mouse down event (or null)
        // If droppingMorph is not null, then check that this is a willing recipient (else null)

        //if (droppingMorph) {console.log(this.inspect() + ">>morphToGrabOrReceive starting");}

        if (this.owner) { // added by Adam; otherwise we have problems with world-scaling; the world should contain everything.
          if (!this.fullContainsWorldPoint(evt.mousePoint)) return null; // not contained anywhere
        }
        
        // First check all the submorphs, front first
        for (var i = this.submorphs.length - 1; i >= 0; i--) {
            var hit = this.submorphs[i].morphToGrabOrReceive(evt, droppingMorph, checkForDnD);
            if (hit != null) {
              //if (droppingMorph) {console.log(this.inspect() + ">>morphToGrabOrReceive hit: " + hit.inspect());}
                return hit;  // hit a submorph
            }
        }

        // Check if it's really in this morph (not just fullBounds)
        if (!this.containsWorldPoint(evt.mousePoint)) return null;

        // If no DnD check, then we have a hit (unless no handler in which case a miss)
        if (!checkForDnD) {
          if (this.mouseHandler && (!this.grabsShouldFallThrough || !evt.isForGrabbing() || this.shouldAllowSelecting())) { // Modified to check grabsShouldFallThrough and isForGrabbing. -- Adam, March 2010;  and shouldAllowSelecting() -- Adam, June 2011
            //if (droppingMorph) {console.log(this.inspect() + ">>morphToGrabOrReceive has a mouseHandler");}
            return this;
          } else {
            return null;
          }
        }

        // On drops, check that this is a willing recipient
        if (droppingMorph != null) {
          if (this.okToReceiveDrop(droppingMorph)) {
            //if (droppingMorph) {console.log(this.inspect() + ">>morphToGrabOrReceive accepts the droppingMorph");}
            return this;
          } else {
            return null;
          }
        } else {
            // On grabs, can't pick up the world or morphs that handle mousedown
            // DI:  I think the world is adequately checked for now elsewhere
            // else return (!evt.isCommandKey() && this === this.world()) ? null : this;
            return this.okToBeGrabbedBy(evt) ? this : null; // Modified to check okToBeGrabbedBy(evt) -- Adam, August 2008;  
        }

    },

  grabMe: function(evt, callWhenDone) {
    this.scaleAndGrabMe(1 / avocado.ui.worldFor(evt).getScale(), true, evt, callWhenDone);
  },

  scaleAndGrabMe: function(desiredScale, shouldAnticipateAtStart, evt, callWhenDone) {
    evt = evt || Event.createFake(); // just for convenience; I call this method from evaluators pretty often

    var shouldDoCoolAnimations = true;

    // don't use evt because it'll bring up the menu if evt.isForContextMenu(), etc.
    var eventForFinalGrab = Event.createFake(evt.hand);

    if (shouldDoCoolAnimations) {
      var world = avocado.ui.worldFor(evt);
      
      var desiredPos = function() {return evt.hand.position().subPt(this.getExtent().scaleBy((desiredScale || this.overallScale(world)) * 0.5));}.bind(this);
      desiredPos.desiredScale = desiredScale;  // aaa - Not sure at all that this is a good idea. But it might be.
      this.ensureIsInWorld(world, desiredPos, true, shouldAnticipateAtStart, false, function() {
        this.grabMeWithoutZoomingAroundFirst(eventForFinalGrab);
        if (callWhenDone) { callWhenDone(this); }
      }.bind(this));
    } else {
      this.grabMeWithoutZoomingAroundFirst(eventForFinalGrab); 
      if (callWhenDone) { callWhenDone(this); }
    }
  },

  grabMeWithoutZoomingAroundFirst: function(evt) {
    // Had to do this to make the morph be right under the hand, and to get the drop shadows right.
    this.addCenteredAt(evt.hand.position(), evt.hand.world());
    this.refreshContentOfMeAndSubmorphs(); // aaa - not sure this is a good idea, but maybe; it makes sure that a mirror will be updated as soon as it's visible, for one thing.
    evt.hand.grabMorph(this, evt);
  },

  addCenteredAt: function(centerPos, newOwner) {
    var desiredPos = centerPos.subPt(this.getExtent().scaleBy(this.getScale() * 0.5));
    newOwner.addMorphAt(this, desiredPos);
  },

  growFromNothing: function(evt, callWhenDone) {
    var desiredScale = 1;
    this.setScale(desiredScale * 0.01);
    this.grabMeWithoutZoomingAroundFirst(evt);
    this.stayCenteredAndSmoothlyScaleTo(desiredScale, pt(0,0), function() {
      if (this.owner === evt.hand) { // might have been dropped while growing
        evt.hand.showAsGrabbed(this); // to make the drop shadow look right
      }
      if (callWhenDone) { callWhenDone(); }
    }.bind(this));
  },

  growFromNothingAt: function(p, callWhenDone) {
    var desiredScale = 1;
    this.setScale(desiredScale * 0.01);
    this.setPosition(p);
    this.stayCenteredAndSmoothlyScaleTo(desiredScale, p, callWhenDone);
  }

});


WorldMorph.addMethods({

  acceptsDropping: function (m) {
    return true;
  },

  justReceivedDrop: function (m) {
    if (this.okToReceiveDrop(m)) {
      m.wasJustDroppedOnWorld(this);
    }
  }

});


Event.addMethods({
  isForGrabbing: function() {
    return this.type !== 'MouseMove' && this.type !== 'TouchMove' && !this.isForMorphMenu() && !this.isForContextMenu();
  }
});

avocado.transporter.module.onLoadCallbacks["lk_ext/grabbing"] = 'done';

avocado.transporter.module.onLoadCallbacks["lk_ext/transporting_morphs"] = function() {};
avocado.transporter.module.create('lk_ext/transporting_morphs', function(requires) {

requires('core/dom_stuff');

}, function(thisModule) {


thisModule.addSlots(modules['lk_ext/transporting_morphs'], function(add) {

  add.method('postFileIn', function () {
    var annotator = avocado.annotator;
    var g = lively.paint.LinearGradient;
    annotator.annotationOf(g.NorthSouth).setCreatorSlot('NorthSouth', g);
    annotator.annotationOf(g.SouthNorth).setCreatorSlot('SouthNorth', g);
    annotator.annotationOf(g.EastWest  ).setCreatorSlot('EastWest',   g);
    annotator.annotationOf(g.WestEast  ).setCreatorSlot('WestEast',   g);
    annotator.annotationOf(g.SouthWest ).setCreatorSlot('SouthWest',  g);
    annotator.annotationOf(g.SouthEast ).setCreatorSlot('SouthEast',  g);
  });

});


thisModule.addSlots(Morph.prototype, function(add) {

  add.method('postFileIn', function () {
    /* I think this should be unnecessary now that we're saving the nodes right.
    if (this.shape) {
      this.initializePersistentState(this.shape);
    }

    if (this.owner) {
      this.owner.addMorphAt(this, this.getPosition());
    }
    */

    // aaa - hack for TTT demo; this is the wrong place for this.
    if (this.worldMenuContributors) {
      var w = this.world();
      this.worldMenuContributors().each(function(c) {
        w.applicationList().addApplication(c);
      }.bind(this));
    }
  }, {category: ['transporting']});

  add.method('shouldNotBeTransported', function () {
    // Children can override.
    return false;
  }, {category: ['transporting']});

  add.method('basicMorphPropertiesStoreString', function () {
    // useful for creating storeStrings
    return ["{ owner: " + reflect(this.owner).creatorSlotChainExpression() + ", position: ", this.getPosition().storeString(), " }"].join("");
  }, {category: ['transporting']});

  add.method('setBasicMorphProperties', function (info) {
    // useful for creating storeStrings
    this.owner = info.owner;
    this.setPosition(info.position);
    return this;
  }, {category: ['transporting']});

});


thisModule.addSlots(lively.scene.Node.prototype, function(add) {

  add.method('postFileIn', function () {
    // aaa - hack, not sure why the fill node isn't getting filed in right
    if (this._fill) {
      this.setFill(this._fill);
    }
  }, {category: ['transporting']});

});


thisModule.addSlots(Color.prototype, function(add) {

  add.method('storeString', function () {
    return ['new Color(', this.r, ', ', this.g, ', ', this.b, ')'].join('');
  }, {category: ['transporting']});

});


thisModule.addSlots(TextEmphasis.prototype, function(add) {

  add.method('storeString', function () {
		var props = reflect(this).normalSlots().toArray().map(function(s) { return s.name() + ": " + Object.inspect(s.contents().reflectee()); });
    return ['new TextEmphasis({', props.join(", "), '})'].join('');
  }, {category: ['transporting']});

});


thisModule.addSlots(Text.prototype, function(add) {

  add.method('storeString', function () {
    return ['document.createTextNode(', this.textContent.inspect(), ')'].join('');
  }, {category: ['transporting']});

});


thisModule.addSlots(lively.paint.LinearGradient.prototype, function(add) {

  add.method('storeString', function () {
    return ["new lively.paint.LinearGradient([",
            this.stops.map(function(s) {return s.storeString();}).join(", "),
            "], ",
            reflect(this.vector).creatorSlotChainExpression(),
            ")"
            ].join("");
  }, {category: ['transporting']});

});


thisModule.addSlots(lively.paint.RadialGradient.prototype, function(add) {

  add.method('storeString', function () {
    return ["new lively.paint.RadialGradient([",
            this.stops.map(function(s) {return s.storeString();}).join(", "),
            "])"
            ].join("");
  }, {category: ['transporting']});

});


thisModule.addSlots(lively.paint.Stop.prototype, function(add) {

  add.method('storeString', function () {
    return ['new lively.paint.Stop(', this.offset(), ', ', this.color().storeString(), ')'].join('');
  }, {category: ['transporting']});

});


thisModule.addSlots(lively.scene.Similitude.prototype, function(add) {

  add.method('storeString', function () {
    return ['new lively.scene.Similitude({a: ', this.a, ', b: ', this.b, ', c: ', this.c, ', d: ', this.d, ', e: ', this.e, ', f: ', this.f, '})'].join('');
  }, {category: ['transporting']});

});


thisModule.addSlots(lively.Text.Font.prototype, function(add) {

  add.method('storeString', function () {
    return ['new lively.Text.Font(', this.family.inspect(), ', ', this.size, ', ', this.style.inspect(), ')'].join('');
  }, {category: ['transporting']});

});


});

avocado.transporter.module.onLoadCallbacks["lk_ext/text_morph_variations"] = function() {};
avocado.transporter.module.create('lk_ext/text_morph_variations', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.method('TextMorphRequiringExplicitAcceptance', function TextMorphRequiringExplicitAcceptance() { Class.initializer.apply(this, arguments); }, {category: ['ui']});

  add.method('TwoModeTextMorph', function TwoModeTextMorph() { Class.initializer.apply(this, arguments); }, {category: ['ui']});

});


thisModule.addSlots(avocado.TextMorphRequiringExplicitAcceptance, function(add) {

  add.data('displayName', 'TextMorphRequiringExplicitAcceptance');

  add.data('superclass', TextMorph);

  add.data('type', 'avocado.TextMorphRequiringExplicitAcceptance');

  add.creator('prototype', Object.create(TextMorph.prototype));

});


thisModule.addSlots(avocado.TextMorphRequiringExplicitAcceptance.prototype, function(add) {

  add.data('constructor', avocado.TextMorphRequiringExplicitAcceptance);

  add.method('initialize', function ($super, accessors) {
    $super();
    this.dontNotifyUntilTheActualModelChanges = true;
    this.connectModel({model: this, getText: "getSavedText", setText: "setSavedText"});
    this.acceptInput = true;
    this.setFill(this.backgroundColorWhenWritable || null),
    this.changed();
    this.setSavedText(this.textString); // aaa - what is this for?
    this.justAcceptedOrCancelled();
    if (accessors) { this._accessors = accessors; }
    this.refreshText();
  });

  add.data('defaultBounds', new Rectangle(5, 10, 140, 20));

  add.data('openForDragAndDrop', false);

  add.data('suppressGrabbing', true);

  add.data('wrap', 'Shrink');

  add.method('getSavedText', function () {
    if (this._accessors) {
      return this._accessors.get();
    } else {
      return this.savedTextString;
    }
  });

  add.method('setSavedText', function (t) {
    if (this._accessors) {
      this._accessors.set(t);

      if (this._savedTextMightNotBeIdenticalToWhatWasTyped) {
        this.cancelChanges(); // to make sure the editor doesn't stay red
      }
    } else {
      this.savedTextString = t;
      if (this._notifier) {this._notifier.notifyAllObservers();} // aaa is this even used?
    }
  });

  add.method('setTextString', function ($super, replacement, delayComposition, justMoreTyping) {
    var x = $super(replacement, delayComposition, justMoreTyping);
    this.updateLayoutIfNecessary();
    return x;
  });

  add.method('rememberThatSavedTextMightNotBeIdenticalToWhatWasTyped', function () {
    this._savedTextMightNotBeIdenticalToWhatWasTyped = true;
    return this;
  });

  add.method('updateLayoutIfNecessary', function () {
    this.adjustForNewBounds(); // makes the focus halo look right   // aaa should probably be outside the conditional, or even in the Core code
    this.minimumExtentMayHaveChanged();
  });

  add.method('checkForAcceptOrCancel', function (evt) {
    if (this.hasChangedFromSavedText() && evt.getKeyCode() == Event.KEY_ESC) {
      this.cancelChanges();
      evt.stop();
      return true;
    }

    if (this.hasChangedFromSavedText() && evt.getKeyCode() == Event.KEY_RETURN && (this.returnKeyShouldAccept() || evt.isMetaDown() || evt.isAltDown() || evt.isCtrlDown())) {
      this.acceptChanges();
      evt.stop();
      return true;
    }
    
    return false;
  });

  add.method('onKeyDown', function ($super, evt) {
    if (this.checkForAcceptOrCancel(evt)) { return true; }
    return $super(evt);
  });

  add.method('onKeyPress', function ($super, evt) {
    if (this.checkForAcceptOrCancel(evt)) { return true; }
    return $super(evt);
  });

  add.method('beWritableAndSelectAll', function (evt) {
    this.beWritable();
    this.requestKeyboardFocus(evt ? evt.hand : WorldMorph.current().firstHand());
    this.doSelectAll();
  });

  add.method('wasJustAdded', function (evt) {
    this.prepareForUserInput(evt);
  });

  add.method('prepareForUserInput', function (evt) {
    this.beWritableAndSelectAll(evt);
  });

  add.method('beWritable', function () {
    // nothing to do here, but children can override;
  });

  add.method('hasChangedFromSavedText', function () {
    return this._hasChangedFromSavedText;
  });

  add.data('normalStyle', TextMorph.prototype.style);

  add.creator('modifiedStyle', {});

  add.method('changed', function ($super) {
    // Avoid infinite recursion when setting the border stuff.
    if (this._isChangingRightNow) {return;}
    this._isChangingRightNow = true;

    var currentText = this.getText();
    var savedText = this.getSavedText();
    var hasChanged = this._hasChangedFromSavedText = (currentText !== savedText);
    this.applyStyle(hasChanged ? this.modifiedStyle : this.normalStyle);
    
    this.adjustScale(); // aaa - this doesn't really belong here, just trying it as an experiment
    
    this.minimumExtentMayHaveChanged();
    delete this._isChangingRightNow;
    $super();
  });

  add.method('refreshText', function () {
    if (this.hasChangedFromSavedText()) {
      // Don't wanna lose the stuff that we've typed.
      this.changed();
    } else {
      var newText = this.getSavedText();
      if (newText !== this.getText()) {
        //this.setWrapStyle(lively.Text.WrapStyle.Shrink); /// aaa experimenting with word-wrapping
        
        this.setText(newText);
        this.changed();
        
        // aaa experiment with word-wrapping
        /*
        var extent = this.getExtent();
        if (extent.x > 600) {
          this.setExtent(extent.withX(600));
          this.setWrapStyle(lively.Text.WrapStyle.Normal);
        } 
        */
      }
    }
  });

  add.method('justAcceptedOrCancelled', function () {
    this.changed();
    this.updateLayoutIfNecessary();
  });

  add.method('acceptChanges', function () {
    var newText = this.getText();
    if (newText !== this.getSavedText()) {
      this.setSavedText(newText);
      
      if (avocado.ui.currentWorld().firstHand().keyboardFocus === this) { // setSavedText might have changed it, in which case we don't want to muck with it
        this.passOnInputFocus();
      }
    }
    this.justAcceptedOrCancelled();
  });

  add.method('cancelChanges', function () {
    this.setText(this.getSavedText());
    this.justAcceptedOrCancelled();
  });

  add.method('handlesMouseDown', function (evt) { return true; });

  add.method('returnKeyShouldAccept', function () { return false; });

  add.method('morphMenu', function (evt) {
    return this.editingCommands().createMenu(this);
  });

  add.method('editingCommands', function () {
    var cmdList = avocado.command.list.create(this);
    if (this.hasChangedFromSavedText()) {
      cmdList.addItem(["accept    [alt+enter]", this.acceptChanges]);
      cmdList.addItem(["cancel    [escape]"   , this.cancelChanges]);
    }
    return cmdList;
  });

});


thisModule.addSlots(avocado.TextMorphRequiringExplicitAcceptance.prototype.modifiedStyle, function(add) {

  add.data('borderWidth', 2);

  add.data('borderColor', new Color(0.8, 0, 0));

});


thisModule.addSlots(TextMorph.prototype.style, function(add) {

  add.data('borderColor', new Color(0.6, 0.6, 0.6));

});


thisModule.addSlots(avocado.TwoModeTextMorph, function(add) {

  add.data('displayName', 'TwoModeTextMorph');

  add.data('superclass', avocado.TextMorphRequiringExplicitAcceptance);

  add.data('type', 'avocado.TwoModeTextMorph');

  add.creator('prototype', Object.create(avocado.TextMorphRequiringExplicitAcceptance.prototype));

});


thisModule.addSlots(avocado.TwoModeTextMorph.prototype, function(add) {

  add.data('constructor', avocado.TwoModeTextMorph);

  add.method('hasChangedFromSavedText', function () {
    return this.isInWritableMode;
  });

  add.method('beUnwritable', function () {
    this.acceptInput = false;
    this.setFill(this.backgroundColorWhenUnwritable || null);
    this.setNullSelectionAt(0);
    var w = this.world();
    if (w) {this.relinquishKeyboardFocus(w.firstHand());}
    this.changed();
    this.mouseHandler = this.oldMouseHandler;
    delete this.oldMouseHandler;
    this.isInWritableMode = false;
    return this;
  });

  add.method('beWritable', function () {
    this.acceptInput = true;
    this.setFill(this.backgroundColorWhenWritable || null);
    this.changed();
    this.oldMouseHandler = this.mouseHandler;
    this.enableEvents();
    this.isInWritableMode = true;
    return this;
  });

  add.method('switchEditModeOn', function () { this.beWritable(); });

  add.method('switchEditModeOff', function () { this.beUnwritable(); });

  add.creator('normalStyle', Object.create(TextMorph.prototype.style));

  add.method('justAcceptedOrCancelled', function () {
    this.beUnwritable();
    this.updateLayoutIfNecessary();
  });

  add.method('onMouseDown', function ($super, evt) {
    if (! this.isInWritableMode) {
      return this.checkForDoubleClick(evt);
    }
    return $super(evt);
  });

  add.method('canBecomeWritable', function () { return ! this.isReadOnly; });

  add.method('returnKeyShouldAccept', function () { return true; });

  add.method('onDoubleClick', function (evt) {
    if (this.canBecomeWritable()) {
      this.beWritable();
      this.onMouseDown(evt);
      return true;
    }
    return false;
  });

  add.data('nameOfEditCommand', 'edit');

  add.method('setNameOfEditCommand', function (n) {
    this.nameOfEditCommand = n;
    return this;
  });

  add.method('editingCommands', function ($super) {
    var cmdList = $super();
    if (!this.isInWritableMode && this.canBecomeWritable()) {
      cmdList.addItem(avocado.command.create(this.nameOfEditCommand, function(evt) {this.beWritableAndSelectAll(evt);}, this));
    }
    return cmdList;
  });

});


thisModule.addSlots(avocado.TwoModeTextMorph.prototype.normalStyle, function(add) {

  add.data('borderWidth', 0);

});


});

avocado.transporter.module.onLoadCallbacks["lk_ext/shortcuts"] = function() {};
avocado.transporter.module.create('lk_ext/shortcuts', function(requires) {

}, function(thisModule) {


thisModule.addSlots(TextMorph, function(add) {

  add.method('createInputBox', function (initialText, extent) {
    var tm = new this(pt(5, 10).extent(extent || pt(50, 20)), initialText || "");
    tm.closeDnD();
    tm.suppressHandles = true;
    return tm;
  }, {category: ['shortcuts']});

});


thisModule.addSlots(ButtonMorph, function(add) {

  add.creator('simpleModelPlug', {}, {category: ['shortcuts']});

  add.method('createButton', function (contents, f, padding, labelPos) {
    var contentsMorph = (typeof contents === 'string' || typeof contents === 'function') ? avocado.label.newMorphFor(contents) : contents;
    var p = (padding !== null && padding !== undefined) ? padding : 5;
    if (Config.fatFingers) { p = Math.max(p, 10); }
    var b = new ButtonMorph(pt(0,0).extent(contentsMorph.bounds().extent().addXY(p * 2, p * 2)));
    b.run = f;
    reflect(b).slotAt('run').beCreator();
    b.addMorphAt(contentsMorph, labelPos || pt(p, p));

    var plugSpec = {
      model: Object.newChildOf(ButtonMorph.simpleModelPlug, b),
      getValue: "getValue",
      setValue: "setValue"
    };
    reflect(plugSpec).slotAt('model').beCreator();

    b.connectModel(plugSpec);
    return b;
  }, {category: ['shortcuts']});

});


thisModule.addSlots(ButtonMorph.simpleModelPlug, function(add) {

  add.method('initialize', function (m) { this.morph = m; });

  add.data('Value', null);

  add.method('getValue', function () { return this.Value; });

  add.method('setValue', function (v) { this.Value = v; if (!v) { this.morph.run(Event.createFake()); } });

});


thisModule.addSlots(DisplayThemes.lively.button, function(add) {

  add.data('fill', new lively.paint.LinearGradient([new lively.paint.Stop(0, new Color(0.9019607843137255, 0.9019607843137255, 0.9019607843137255)), new lively.paint.Stop(1, new Color(0.4, 0.4, 0.4))], lively.paint.LinearGradient.NorthSouth));

  add.data('openForDragAndDrop', false);

});


thisModule.addSlots(Event, function(add) {

  add.method('createFake', function (hand) {
    hand = hand || WorldMorph.current().firstHand();
    return {
      hand: hand,
      isShiftDown: Functions.False,
      isForContextMenu: Functions.False,
      isForMorphMenu: Functions.False,
      isForGrabbing: function() {
        return this.type !== 'MouseMove' && !this.isForMorphMenu() && !this.isForContextMenu();
      },
      point: function() { return this.mousePoint || this.hand.getPosition(); }
    };
  }, {category: ['shortcuts']});

});


thisModule.addSlots(ButtonMorph.prototype, function(add) {

  add.method('simulatePress', function (evt) {
    this.onMouseDown(evt);
    this.onMouseUp(evt);
  }, {category: ['shortcuts']});

});


thisModule.addSlots(Morph.prototype, function(add) {

  add.method('wrappedInScrollPaneIfNecessaryToFitWithin', function (maxExtent) {
    if (this.getExtent().y <= maxExtent.y) { return this; }
    return ScrollPane.containing(this, maxExtent);
  }, {category: ['scrolling']});

});


thisModule.addSlots(ScrollPane, function(add) {

  add.method('containing', function (morph, extent) {
    var sp = new this(morph, extent.extentAsRectangle());
    sp.closeDnD();
    sp.clipMorph.closeDnD();
    sp.adjustForNewBounds();
    return sp;
  }, {category: ['shortcuts']});

});


});

avocado.transporter.module.onLoadCallbacks["lk_ext/check_box"] = function() {};
avocado.transporter.module.create('lk_ext/check_box', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.method('CheckBoxMorph', function CheckBoxMorph() { Class.initializer.apply(this, arguments); }, {category: ['ui']});

});


thisModule.addSlots(avocado.CheckBoxMorph, function(add) {

  add.data('displayName', 'CheckBoxMorph');

  add.data('superclass', ButtonMorph);

  add.data('type', 'avocado.CheckBoxMorph');

  add.method('createWithImage', function (imageURL, size) {
    var image = new ImageMorph(size.extentAsRectangle(), imageURL);
    image.setFill(null);
    var button = new this(size, image);
    button.setFill(null);
    return button;
  }, {category: ['creating']});

  add.creator('prototype', Object.create(ButtonMorph.prototype));

});


thisModule.addSlots(avocado.CheckBoxMorph.prototype, function(add) {

  add.data('constructor', avocado.CheckBoxMorph);

  add.method('initialize', function ($super, booleanHolder, extent, m) {
    this._model = booleanHolder || avocado.booleanHolder.containing(false);
    if (!extent) {extent = pt(15,15);}
    this.checkedMorph = m || this.createXShapedMorph(extent);
    this.checkedMorph.handlesMouseDown = function() { return true; };
    this.checkedMorph.relayMouseEvents(this, {onMouseDown: "onMouseDown", onMouseMove: "onMouseMove", onMouseUp: "onMouseUp"});
    $super(pt(0,0).extent(extent));
    this.setFill(Color.white);
    this.setFillOpacity(0.2);
    this.connectModel({model: this._model, getValue: "isChecked", setValue: "setChecked"});

    this.refreshContentOfMeAndSubmorphs();
    return this;
  }, {category: ['creating']});

  add.method('createXShapedMorph', function (extent) {
    return avocado.label.newMorphFor("X", extent);
  }, {category: ['creating']});

  add.data('toggle', true, {category: ['toggling']});

  add.method('getValue', function () {return this.getModel().getValue( );}, {category: ['accessing']});

  add.method('setValue', function (b) {return this.getModel().setValue(b);}, {category: ['accessing']});

  add.method('isChecked', function () {return this.getModel().getValue( );}, {category: ['accessing']});

  add.method('setChecked', function (b) {return this.getModel().setValue(b);}, {category: ['accessing']});

  add.method('notifier', function () {
    return this._model.notifier();
  }, {category: ['observing']});

  add.method('changeAppearanceFor', function (v) {
    if (v) {
      if (this.checkedMorph.owner !== this) {
        this.addMorphCentered(this.checkedMorph);
      }
    } else {
      if (this.checkedMorph.owner === this) {
        this.removeMorph(this.checkedMorph);
      }
    }
  }, {category: ['updating']});

  add.method('refreshContent', function () {
    this.changeAppearanceFor(this.isChecked());
  }, {category: ['updating']});

});


});

avocado.transporter.module.onLoadCallbacks["lk_ext/expander"] = function() {};
avocado.transporter.module.create('lk_ext/expander', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.method('ExpanderMorph', function ExpanderMorph() { Class.initializer.apply(this, arguments); }, {category: ['ui']});

});


thisModule.addSlots(avocado.ExpanderMorph, function(add) {

  add.data('displayName', 'ExpanderMorph');

  add.data('superclass', ButtonMorph);

  add.data('type', 'avocado.ExpanderMorph');

  add.creator('prototype', Object.create(ButtonMorph.prototype));

});


thisModule.addSlots(avocado.ExpanderMorph.prototype, function(add) {

  add.data('constructor', avocado.ExpanderMorph);

  add.method('initialize', function ($super, expandee) {
    var s = this.defaultSideLength();
    $super(pt(0, 0).extent(pt(s, s))); // aaa - should fix ButtonMorph so that its initial shape doesn't have to be a rectangle
    var model = avocado.booleanHolder.containing(false);
    this.connectModel({model: model, getValue: "isChecked", setValue: "setChecked"});
    this._expandee = expandee;
    model.addObserver(function() {if (this._expandee && this._expandee.world()) { this._expandee.refreshContentOfMeAndSubmorphs(); }}.bind(this));
    return this;
  });

  add.data('toggle', true, {category: ['toggling']});

  add.data('styleClass', ['button', 'expander'], {category: ['style'], initializeTo: '[\'button\', \'expander\']'});

  add.data('focusHaloBorderWidth', 0, {category: ['style'], comment: 'I don\'t like the halo'});

  add.method('defaultSideLength', function () { return 12 * (Config.fatFingers ? 2 : 1); });

  add.method('getHelpText', function () { return (this.isExpanded() ? 'Collapse' : 'Expand') + ' me'; });

  add.method('verticesForValue', function (value) {
    var s = this.defaultSideLength();
    return value ? [pt(0,0), pt(s,0), pt(s/2, s), pt(0,0)] : [pt(0,0), pt(s, s/2), pt(0,s), pt(0,0)];
  });

  add.method('changeAppearanceFor', function ($super, value) {
    if (this.shape.setVertices) {
      this.shape.setVertices(this.verticesForValue(value));
    } else {
      var oldStyle = this.makeStyleSpec();
      this.setShape(new lively.scene.Polygon(this.verticesForValue(false)));
      this.applyStyle(oldStyle); // workaround for ButtonMorphs having to start off being a rectangle
    }
    // $super(value); // Messes things up, I think. -- Adam;
  });

  add.method('isExpanded', function () {return !!this.getModel().getValue();});

  add.method('setExpanded', function (b) {if (this.isExpanded() !== !!b) {this.setValue(!!b); this.updateView("all");}});

  add.method('constructUIStateMemento', function () {
    return this.isExpanded();
  });

  add.method('assumeUIState', function (uiState, callWhenDone, evt) {
    this.setExpanded(uiState);
    if (callWhenDone) { callWhenDone(); }
  });

});


thisModule.addSlots(DisplayThemes.lively, function(add) {

  add.creator('expander', {}, {category: ['expanders']});

});


thisModule.addSlots(DisplayThemes.lively.expander, function(add) {

  add.data('fill', new lively.paint.LinearGradient([new lively.paint.Stop(0, new Color(0.75, 0.75, 0.95)), new lively.paint.Stop(1, new Color(0.5, 0.5, 0.9))]), {initializeTo: 'new lively.paint.LinearGradient([new lively.paint.Stop(0, new Color(0.75, 0.75, 0.95)), new lively.paint.Stop(1, new Color(0.5, 0.5, 0.9))])'});

});


});

avocado.transporter.module.onLoadCallbacks["lk_ext/edit_mode"] = function() {};
avocado.transporter.module.create('lk_ext/edit_mode', function(requires) {

}, function(thisModule) {


thisModule.addSlots(Morph.prototype, function(add) {

  add.method('isInEditMode', function () {
    return this._isInEditMode;
  }, {category: ['edit mode']});

  add.method('switchEditModeOn', function () {
    if (this.isInEditMode()) { return; }
    this._isInEditMode = true;
    this.suppressHandles = false;
    this.openDnD();
    this.startUsingEditModeLayoutManager();
    this.eachSubmorph(function(m) { m.switchEditModeOn(); });
    return this;
  }, {category: ['edit mode']});

  add.method('switchEditModeOff', function () {
    if (! this.isInEditMode()) { return; }
    delete this._isInEditMode;
    this.suppressHandles = true;
    this.closeDnD();
    this.stopUsingEditModeLayoutManager();
    this.eachSubmorph(function(m) { m.switchEditModeOff(); });
    return this;
  }, {category: ['edit mode']});

  add.creator('editModeLayoutManagerTraits', {}, {category: ['edit mode']});

  add.method('startUsingEditModeLayoutManager', function () {
    this.layoutManager = Object.extend(Object.create(this.layoutManager), this.editModeLayoutManagerTraits);
    reflect(this).slotAt('layoutManager').beCreator();
  }, {category: ['edit mode']});

  add.method('stopUsingEditModeLayoutManager', function () {
    this.layoutManager = this.layoutManager['__proto__'];
  }, {category: ['edit mode']});

});


thisModule.addSlots(Morph.prototype.editModeLayoutManagerTraits, function(add) {

  add.method('beforeAddMorph', function (supermorph, submorph, isFront) {
    submorph.setPosition(submorph.getPosition().roundTo(10));
  });

});


});

avocado.transporter.module.onLoadCallbacks["lk_ext/world_navigation"] = function() {};
avocado.transporter.module.create('lk_ext/world_navigation', function(requires) {

}, function(thisModule) {


thisModule.addSlots(WorldMorph.prototype, function(add) {

  add.method('onMouseWheel', function (evt) {
	  if (evt.isCtrlDown() || evt.isMetaDown() || evt.isAltDown()) {
      var factor = Math.pow(1.2, (evt.rawEvent.wheelDeltaY / -600));
      this.zoomBy(factor, evt.point());
      // this.staySameSizeAndSmoothlyScaleTo(this.getScale() * factor, evt.point(), 200, this.refreshContentIfOnScreenOfMeAndSubmorphs.bind(this));
      return true;
    }
  }, {category: ['navigation']});

  add.creator('navigationAccessor', {}, {category: ['navigation']}, {comment: 'Needed because we can\'t yet translate the world, we have to translate all the morphs in it.'});

  add.method('slideIfClickedAtEdge', function (evt) {
    var b = this.fullBounds;
    var p = evt.point();
    var amountToSlide = 50;
    var v;
    if (           p.x <= 50) { v = pt(-amountToSlide, 0); }
    if (           p.y <= 50) { v = pt(0, -amountToSlide); }
    if (b.maxX() - p.x <= 50) { v = pt( amountToSlide, 0); }
    if (b.maxY() - p.y <= 50) { v = pt(0,  amountToSlide); }
    
    if (v) { this.slideBy(v.scaleBy(1 / this.getScale())); }
  }, {category: ['navigation']});

  add.method('slideBy', function (p) {
    var delta = p;
    //this.origin = this.origin.addPt(p);
    //this.shape.translateBy(delta.negated());
    // Blecch. I would have preferred to leave the morphs at the same world-coordinates and just
    // make the top-left corner be (-X,-Y) instead of (0,0). But that was turning out to be complicated.
    // So for now, just move all the morphs by (X,Y).
    this.eachSubmorph(function(m) {
      if (m.shouldStickToScreen) {
      } else {
        // The animated version is a bit weird for now, I think. -- Adam
        // m.startWhooshingInAStraightLineTo(m.position().addPt(delta), false, false, true);
        
        if (! (m.shouldNotMoveWhenSlidingTheWorld)) { // aaa I have no idea why this is necessary, but try taking it out and then zooming in while an arrow is visible
          m.moveBy(delta);
        }
      }
    });
    
    this.hands.forEach(function(m) {
      // The animated version is a bit weird for now, I think. -- Adam
      // m.startWhooshingInAStraightLineTo(m.position().addPt(delta), false, false, true);
      m.moveBy(delta);
    });
  }, {category: ['navigation']});

  add.method('smoothlySlideBy', function (p, functionToCallWhenDone) {
    var worldNavigator = Object.newChildOf(WorldMorph.prototype.navigationAccessor, this);
    var a = avocado.animation.newMovement(worldNavigator, avocado.animation.straightPath, p, p.r() / (400 * this.getScale()), false, false, true);
    worldNavigator.startZoomAnimation(a, functionToCallWhenDone);
  }, {category: ['navigation']});

  add.method('zoomBy', function (factor, pointerPosition) {
    this.zoomTo(this.getScale() * factor, pointerPosition);
  }, {category: ['navigation']});

  add.method('zoomTo', function (scale, pointerPosition) {
    var worldNavigator = Object.newChildOf(WorldMorph.prototype.navigationAccessor, this);
    
    worldNavigator.staySameSizeAndScaleTo(scale, pointerPosition);
  }, {category: ['navigation']});

  add.method('stickyMorphs', function (f) {
    return this.submorphs.select(function(m) { return m.shouldStickToScreen; });
  });

  add.method('startZoomAnimation', function (animation, functionToCallWhenDone) {
    if (this._zoomAnimation) { this._zoomAnimation.stopAnimating(); }
    this._zoomAnimation = animation;
    this.startAnimating(this._zoomAnimation, function() {
      delete this._zoomAnimation;
      if (functionToCallWhenDone) { functionToCallWhenDone(); }
    }.bind(this));
  }, {category: ['scaling']});

  add.method('staySameSizeAndSmoothlyScaleTo', function (desiredScale, currentPointerPosFn, mainDuration, functionToCallWhenDone) {
    var worldNavigator = Object.newChildOf(WorldMorph.prototype.navigationAccessor, this);
    this.startZoomAnimation(avocado.animation.newSpeedStepper(worldNavigator, desiredScale, {
      getValue: function(m   ) { return worldNavigator.getScale();                                       },
      setValue: function(m, v) {        worldNavigator.staySameSizeAndScaleTo(v, currentPointerPosFn()); }
    }, mainDuration), functionToCallWhenDone);
  }, {category: ['scaling']});

  add.method('staySameSizeAndSmoothlySlideAndScaleTo', function (desiredCenterPosition, desiredScale, targetMorph, functionToCallWhenDone) {
    var worldNavigator = Object.newChildOf(WorldMorph.prototype.navigationAccessor, this);
    
    var extent = worldNavigator.getExtent();
    var currentScale = worldNavigator.getScale();
    var currentCenterPosition = worldNavigator.getPosition().addPt(extent.scaleBy(currentScale * 0.5));
    var totalDistance = currentCenterPosition.subPt(desiredCenterPosition).r();
    
    var cruisingScale = currentScale / ((0.001 * totalDistance * currentScale) + 1);
    // Trying to improve on the above way, but so far I don't like this better.
    // var cruisingScale = 800 / totalDistance;
    
    
    var needToLand = true;
    var needToCruise = true;
    var needToTakeOff = true;
    if (totalDistance * currentScale < 0.0001) {
      needToCruise = false;
    }
    if (Math.abs(1 - (currentScale / cruisingScale)) < 0.1) {
      cruisingScale = currentScale;
      needToTakeOff = false;
    }
    if (Math.abs(1 - (desiredScale / cruisingScale)) < 0.1) {
      cruisingScale = desiredScale;
      needToLand = false;
    }
    if (desiredScale > cruisingScale && cruisingScale > currentScale) {
      cruisingScale = currentScale; // no sense doing a zoom-out + slide + zoom-in; just slide and zoom-in
      needToTakeOff = false;
    } else if (desiredScale < cruisingScale) {
      cruisingScale = desiredScale; // no sense doing a zoom-out + slide + zoom-in; just zoom-out and slide
      needToLand = false;
    }
    
    
    //console.log("desiredCenterPosition is " + desiredCenterPosition + ", currentCenterPosition is " + currentCenterPosition + ", totalDistance is " + totalDistance + ", currentScale is " + currentScale + ", using cruisingScale " + cruisingScale + ", desiredScale is " + desiredScale);
    
    var land = function() {
      if (needToLand) {
        //console.log("desiredScale: " + desiredScale);
        this.staySameSizeAndSmoothlyScaleTo(desiredScale, function() { return worldNavigator.getExtent().scaleBy(0.5); }, 1000, functionToCallWhenDone);
      } else {
        // done!
      }
    }.bind(this);
    
    var cruise = function() {
      if (needToCruise) {
        var targetMorphCenterPos = targetMorph.owner.worldPoint(targetMorph.getPosition().addPt(targetMorph.getExtent().scaleBy(targetMorph.getScale() * 0.5)));
        var cruisingEndPosition = targetMorphCenterPos.subPt(this.getExtent().scaleBy(0.5));

        //console.log("cruisingEndPosition: " + cruisingEndPosition);
        this.smoothlySlideBy(cruisingEndPosition.negated(), needToLand ? land : null);
      } else {
        land();
      }
    }.bind(this);
    
    var takeOff = function() {
      if (needToTakeOff) {
        this.staySameSizeAndSmoothlyScaleTo(cruisingScale, function() { return worldNavigator.getExtent().scaleBy(0.5); }, 1000, cruise);
      } else {
        cruise();
      }
    }.bind(this);
    
    takeOff();
  }, {category: ['navigation']});

  add.method('fixFonts', function () {
    // OK, this is kinda ridiculous, but removing and re-adding the rawNode seems to fix that
    // font-scaling problem where the text would look very strange. Of course, this means
    // that the fonts are constantly adjusting themselves as you zoom in and out, which
    // is a bit distracting, but... well, it's better than the fonts *not* adjusting.
    var worldNode = this.rawNode;
    var parentNode = worldNode.parentNode;
    parentNode.removeChild(worldNode);
    parentNode.appendChild(worldNode);
  }, {category: ['refreshing']});

  add.method('scheduleRefresh', function () {
    // Need to refresh, but don't want to do it too often - it's unnecessary and noticeably slows things down.
    // So unschedule the previously-scheduled refresh, since we're about to schedule a new one.
    var world = this;
    if (typeof(world._scheduledZoomRefresh) !== 'undefined') { clearTimeout(world._scheduledZoomRefresh); }
    world._scheduledZoomRefresh = setTimeout(function() {
      world._scheduledZoomRefresh = undefined;
      world.refreshContentIfOnScreenOfMeAndSubmorphs();
      world.fixFonts();
    }, 50);
  }, {category: ['refreshing']});

});


thisModule.addSlots(WorldMorph.prototype.navigationAccessor, function(add) {

  add.method('initialize', function (w) {
    this._world = w;
    this._position = pt(0,0);
  });

  add.method('getPosition', function () {
    return this._position;
  });

  add.method('setPositionAndDoMotionBlurIfNecessary', function (newPos) {
    var delta = newPos.subPt(this.getPosition());
    this._world.slideBy(delta);
    this._position = newPos;
  });

  add.method('getScale', function () {
    return this._world.getScale();
  });

  add.method('setScale', function (s) {
    return this._world.setScale(s);
  });

  add.method('getExtent', function () {
    return this._world.getExtent();
  });

  add.method('setExtent', function (r) {
    return this._world.setExtent(r);
  });

  add.method('staySameSizeAndScaleTo', function (s, currentPointerPos) {
    var world = this._world;
    var oldScale = this.getScale();
    var scalingFactor = s / oldScale;
    var desiredSize = this.getExtent().scaleBy(oldScale);
    this.setScale(s);
    this.setExtent(desiredSize.scaleBy(1 / s));
    var delta = (currentPointerPos || pt(0,0)).translationNeededToStayInSameScreenPositionWhenScalingTheWorldBy(scalingFactor);
    world.slideBy(delta);
    world.hands.each(function(m) { m.setScale(1 / s); });
    world.stickyMorphs().each(function(m) { m.setScale(1 / s); m.moveBy(m.origin.translationNeededToStayInSameScreenPositionWhenScalingTheWorldBy(scalingFactor)); });
    world.eachSubmorph(function(m) {
      if (m) { m.justScaledWorld(s); }
    });
    world.scheduleRefresh();
  });

  add.method('isOnScreen', function () {
    return true;
  });

  add.method('hands', function () {
    return this._world.hands;
  });

  add.method('startAnimating', function (animator, functionToCallWhenDone) {
    animator.stopAnimating();
    animator.whenDoneCall(functionToCallWhenDone);
    animator.startAnimating(this);
    return animator;
  });

  add.method('startZoomAnimation', function (animation, functionToCallWhenDone) {
    if (this._world._zoomAnimation) { this._world._zoomAnimation.stopAnimating(); }
    this._world._zoomAnimation = animation;
    this.startAnimating(this._world._zoomAnimation, function() {
      delete this._world._zoomAnimation;
      if (functionToCallWhenDone) { functionToCallWhenDone(); }
    }.bind(this));
  });

});


thisModule.addSlots(Point.prototype, function(add) {

  add.method('translationNeededToStayInSameScreenPositionWhenScalingTheWorldBy', function (scalingFactor) {
    var desiredNewPosition = this.scaleBy(1 / scalingFactor);
    var delta = desiredNewPosition.subPt(this);
    return delta;
  }, {category: ['scaling']});

});


thisModule.addSlots(Morph.prototype, function(add) {

  add.method('navigateToMe', function (evt, functionToCallWhenDone) {
    var world = this.world();
    var myBounds = this.bounds();
    var myWidth = myBounds.width;
    var myHeight = myBounds.height;
    var worldSize = world.getExtent();
    var scalingFactor = Math.min(worldSize.x / myWidth, worldSize.y / myHeight).scaleBy(1 / this.owner.overallScale(world));
    var desiredCenterPosition = this.owner.worldPoint(myBounds.center()).scaleBy(world.getScale());
    
    world.staySameSizeAndSmoothlySlideAndScaleTo(desiredCenterPosition, scalingFactor * world.getScale(), this, functionToCallWhenDone);
  }, {category: ['navigating']});

  add.method('navigateToMeImmediately', function (evt, functionToCallWhenDone) {
    var world = this.world();
    var myBounds = this.bounds();
    var myWidth = myBounds.width;
    var myHeight = myBounds.height;
    var worldSize = world.getExtent();
    var scalingFactor = Math.min(worldSize.x / myWidth, worldSize.y / myHeight);
    var desiredPosition = this.owner.worldPoint(myBounds.topLeft());
    
    world.slideBy(desiredPosition.negated());
    world.zoomBy(scalingFactor, pt(0,0));
    
    if (functionToCallWhenDone) { functionToCallWhenDone(); }
  }, {category: ['navigating']});

  add.method('justScaledWorld', function (worldScale) {
    if (this._layout && typeof(this._layout.justScaledWorld) === 'function') {
      this._layout.justScaledWorld(worldScale);
    }
  }, {category: ['scaling']});

});


});

avocado.transporter.module.onLoadCallbacks["lk_ext/carrying_hand"] = function() {};
avocado.transporter.module.create('lk_ext/carrying_hand', function(requires) {

requires('core/collections/hash_table');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.method('CarryingHandMorph', function CarryingHandMorph() { Class.initializer.apply(this, arguments); }, {category: ['ui']});

});


thisModule.addSlots(avocado.CarryingHandMorph, function(add) {

  add.data('displayName', 'CarryingHandMorph');

  add.data('superclass', Morph);

  add.data('type', 'avocado.CarryingHandMorph');

  add.method('forWorld', function (w) {
    if (w._carryingHand) { return w._carryingHand; }
    w._carryingHand = new this(w);
    return w._carryingHand;
  });

  add.creator('prototype', Object.create(Morph.prototype));

});


thisModule.addSlots(avocado.CarryingHandMorph.prototype, function(add) {

  add.data('constructor', avocado.CarryingHandMorph);

  add.method('initialize', function ($super, w) {
    // $super(new lively.scene.Ellipse(pt(0,0), 70));
    $super(new lively.scene.Rectangle(pt(0,0).extent(pt(140,140))));
    this._world = w;
    this.applyStyle(this.defaultStyle);
    this._originalPositions = Object.newChildOf(avocado.dictionary, avocado.dictionary.identityComparator);
  }, {category: ['creating']});

  add.creator('defaultStyle', {}, {category: ['styles']});

  add.data('shouldStickToScreen', true, {category: ['showing']});

  add.method('ensureVisible', function (callWhenDone) {
    if (this.owner) {
      if (callWhenDone) { callWhenDone(); }
    } else {
      this.setFillOpacity(0);
      this.setScale(1 / this._world.getScale());
      console.log("carrying hand origin: " + this.origin + ", this._world.getScale(): " + this._world.getScale());
      this._world.addMorphAt(this, pt(0,0));
      this.smoothlyFadeTo(0.1);
      if (callWhenDone) { callWhenDone(); }
    }
  }, {category: ['showing']});

  add.method('hideIfEmpty', function (callWhenDone) {
    if (this.submorphs.length > 0) {
      if (callWhenDone) { callWhenDone(); }
    } else {
      this.smoothlyFadeTo(0, function() { this.remove(); }.bind(this));
      if (callWhenDone) { callWhenDone(); }
    }
  }, {category: ['showing']});

  add.method('carriedMorph', function () {
    return this.submorphs[0];
  }, {category: ['accessing']});

  add.method('applicableCommandForDroppingOn', function (targetMorph) {
    var carriedMorph = this.carriedMorph();
    if (!carriedMorph) { return null; }
    return targetMorph.applicableCommandForDropping(carriedMorph);
  }, {category: ['accessing']});

  add.method('rememberOriginalPositionOf', function (m) {
    this._originalPositions.put(m, { owner: m.owner, position: m.getPosition(), scale: m.getScale() });
  }, {category: ['original positions']});

  add.method('putBackInOriginalPosition', function (m, evt, callWhenDone) {
    var originalInfo = this._originalPositions.removeKey(m);
    var originalWorldPos = originalInfo.owner.worldPoint(originalInfo.position);
    originalWorldPos.desiredScale = originalInfo.owner.overallScale(this._world) * originalInfo.scale;
    m.ensureIsInWorld(this._world, originalWorldPos, true, false, false, function() {
      originalInfo.owner.addMorphAt(m, originalInfo.position);
	    this.hideIfEmpty();
      if (callWhenDone) { callWhenDone(); }
    }.bind(this));
  }, {category: ['original positions']});

  add.method('pickUp', function (m, evt, callWhenDone) {
    this.ensureVisible(function() {
      this.rememberOriginalPositionOf(m);
      var currentExternalSize = m.getExtent().scaleBy(m.getScale());
      var desiredInternalSize = pt(80,80);
      var desiredExternalSize = desiredInternalSize.scaleBy(this.getScale());
      var scales = pt(desiredExternalSize.x / currentExternalSize.x, desiredExternalSize.y / currentExternalSize.y);
      var desiredScale = Math.min(scales.x, scales.y);
      var finalExternalSize = currentExternalSize.scaleBy(desiredScale);
      var finalInternalSize = finalExternalSize.scaleBy(1 / this.getScale());
      var desiredInternalPos = this.getExtent().scaleBy(0.5).subPt(finalInternalSize.scaleBy(0.5));
      var desiredExternalPos = this.getPosition().addPt(desiredInternalPos.scaleBy(this.getScale()));
      /*
      console.log("Picking up " + m + ", currentExternalSize: " + currentExternalSize + ", desiredExternalSize: " + desiredExternalSize + ", scales: " + scales
                  + ", desiredScale: " + desiredScale + ", finalInternalSize: " + finalInternalSize + ", desiredInternalPos: " + desiredInternalPos
                  + ", desiredExternalPos: " + desiredExternalPos);
      */
      desiredExternalPos.desiredScale = desiredScale;
      m.ensureIsInWorld(this._world, desiredExternalPos, true, false, false, function() {
        this.addMorphAt(m, desiredInternalPos);
        if (callWhenDone) { callWhenDone(); }
      }.bind(this));
    }.bind(this));
  }, {category: ['picking up and dropping']});

  add.method('dropOn', function (targetMorph, evt, callWhenDone) {
    var carriedMorph = this.carriedMorph();
    if (!carriedMorph) { throw new Error("No morph to drop"); }
    var c = targetMorph.applicableCommandForDropping(carriedMorph);
    if (!c) { throw new Error("Cannot drop " + carriedMorph + " on " + targetMorph); }
    
    var desiredPos = evt.point().subPt(carriedMorph.getExtent().scaleBy(0.5));
    desiredPos.desiredScale = 1;
    carriedMorph.ensureIsInWorld(this._world, desiredPos, true, false, false, function() {
	    c.go(evt, carriedMorph);
	    this.hideIfEmpty();
      if (callWhenDone) { callWhenDone(); }
    }.bind(this));
  }, {category: ['picking up and dropping']});

});


thisModule.addSlots(avocado.CarryingHandMorph.prototype.defaultStyle, function(add) {

  add.data('grabsShouldFallThrough', true);

  add.data('openForDragAndDrop', false);

  add.data('suppressGrabbing', true);

  add.data('suppressHandles', true);

  add.data('fill', new Color(0, 0, 0));

});


});

avocado.transporter.module.onLoadCallbacks["lk_ext/morph_chooser"] = function() {};
avocado.transporter.module.create('lk_ext/morph_chooser', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.method('MorphChooser', function MorphChooser() { Class.initializer.apply(this, arguments); }, {category: ['ui']});

});


thisModule.addSlots(avocado.MorphChooser, function(add) {

  add.data('displayName', 'MorphChooser');

  add.data('superclass', Morph);

  add.data('type', 'avocado.MorphChooser');

  add.creator('prototype', Object.create(Morph.prototype));

});


thisModule.addSlots(avocado.MorphChooser.prototype, function(add) {

  add.data('constructor', avocado.MorphChooser);

  add.method('initialize', function ($super, targetType, callOnSuccess) {
    $super(new lively.scene.Ellipse(pt(0, 0), 5));
    this._targetType = targetType;
    this._callOnSuccess = callOnSuccess;
  }, {category: ['creating']});

  add.creator('style', {}, {category: ['styles']});

  add.method('particularlyWantsToBeDroppedOn', function (m) {
    return this._targetType.doesTypeMatch(m);
  }, {category: ['drag and drop']});

  add.method('aboutToBeDroppedOn', function ($super, m) {
    if (this.particularlyWantsToBeDroppedOn(m)) {
      this.remove();
      this._callOnSuccess(m);
      return false;
    } else {
      return $super(m);
    }
  }, {category: ['drag and drop']});

});


thisModule.addSlots(avocado.MorphChooser.prototype.style, function(add) {

  add.data('suppressHandles', true);

});


});

avocado.transporter.module.onLoadCallbacks["db/abstract"] = function() {};
avocado.transporter.module.create('db/abstract', function(requires) {

requires('core/collections/hash_table');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('remoteObjectReference', {}, {category: ['remote references']});

  add.creator('db', {}, {category: ['databases']});

});


thisModule.addSlots(avocado.remoteObjectReference, function(add) {

  add.creator('table', {});

  add.method('create', function (obj, realm, id) {
    return Object.newChildOf(this, obj, realm, id);
  }, {category: ['creating']});

  add.method('initialize', function (obj, realm, id) {
    this._object = obj;
    this._realm = realm;
    this._id = id;
  }, {category: ['creating']});

  add.method('object', function () { return this._object; }, {category: ['accessing']});

  add.method('realm', function () { return this._realm; }, {category: ['accessing']});

  add.method('id', function () { return this._id; }, {category: ['accessing']});

  add.method('setObject', function (o) {
    if (this._object) { throw new Error("This ref already has an object. Don't change it."); }
    this._object = o;
    avocado.remoteObjectReference.table.rememberRefForObject(o, this);
  }, {category: ['accessing']});

  add.method('setDBInfo', function (realm, id, rev) {
    if (this._realm) { throw new Error("This ref already has a DB and ID. Don't change it."); }
    this._realm = realm;
    this._id = id;
    this._rev = rev;
    realm.rememberRemoteRefForID(id, this);
  }, {category: ['accessing']});

  add.method('fetchObjectIfNotYetPresent', function (callback) {
    var obj = this.object();
    if (obj) {
      if (callback) { callback(obj); }
    } else {
      this.realm().getDocument(this.id(), callback);
    }
    return this;
  }, {category: ['objects']});

  add.method('forgetMe', function () {
    if (this._realm ) { this._realm.forgetRemoteRefForID(this._id); }
    if (this._object) { this.table.forgetRefForObject(this._object); }
  });

  add.method('expressionToRecreateRefAndFetchObject', function () {
    return ["(", this._realm.storeString(), ").remoteRefForID(", this.id().inspect(), ").fetchObjectIfNotYetPresent()"].join("");
  }, {category: ['transporting']});

});


thisModule.addSlots(avocado.remoteObjectReference.table, function(add) {

  add.data('realms', {}, {initializeTo: '{}'});

  add.method('addRealm', function (name, realm) {
    if (this.realms[name]) {
      throw new Error("Already have a realm named " + name);
      // or we could assign it a different name
    }
    
    this.realms[name] = realm;
  });

  add.method('rememberRefForObject', function (obj, ref) {
    avocado.annotator.annotationOf(obj).setRemoteRef(ref);
  });

  add.method('forgetRefForObject', function (obj) {
    avocado.annotator.annotationOf(obj).setRemoteRef(null);
  });

  add.method('existingRefForObject', function (obj) {
    return avocado.annotator.annotationOf(obj).getRemoteRef();
  });

  add.method('refForObject', function (obj) {
    var anno = avocado.annotator.annotationOf(obj);
    var ref = anno.getRemoteRef();
    if (! ref) {
      ref = avocado.remoteObjectReference.create(obj);
      anno.setRemoteRef(ref);
    }
    return ref;
  });

  add.method('findRealmReferredToAs', function (realmID, callback) {
    var colon = realmID.indexOf(":");
    var realmType = colon >= 0 ? realmID.substring(0, colon) : 'named';
    var restOfID  = colon >= 0 ? realmID.substring(colon + 1) : realmID;
    if (realmType === "named") {
      var realm = this.realms[restOfID];
      if (realm) {
        callback(realm);
        return;
      } else {
        throw new Error("No realm named " + restOfID);
      }
    } else if (realmType === "couch") {
      avocado.couch.db.findDBAtURL(restOfID, callback, function(err) { throw err; });
      return;
    }
    throw new Error("What kind of realm is this? " + realmID);
  });

  add.method('findObjectReferredToAs', function (refLiteral, callback) {
    var refLiteralObj = typeof(refLiteral) === 'string' ? JSON.parse(refLiteral) : refLiteral;
    this.findRealmReferredToAs(refLiteralObj.realm, function(realm) {
      realm.findObjectByID(refLiteralObj.id, callback);
    });
  });

});


thisModule.addSlots(avocado.annotator.objectAnnotationPrototype, function(add) {

  add.method('getRemoteRef', function () {
    return this.remoteRef;
  }, {category: ['remote references']});

  add.method('setRemoteRef', function (ref) {
    this.remoteRef = ref;
  }, {category: ['remote references']});

});


});

avocado.transporter.module.onLoadCallbacks["db/couch"] = function() {};
avocado.transporter.module.create('db/couch', function(requires) {

requires('core/testFramework');
requires('transporter/transporter');
requires('db/abstract');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('couch', {}, {category: ['databases']});

});


thisModule.addSlots(avocado.couch, function(add) {

  add.creator('dbServer', {});

  add.creator('db', Object.create(avocado.db));

});


thisModule.addSlots(avocado.couch.dbServer, function(add) {

  add.method('atURL', function (baseURL, proxyURL) {
    return this.serversByURL[baseURL] || (this.serversByURL[baseURL] = Object.newChildOf(this, baseURL, proxyURL));
  }, {category: ['creating']});

  add.data('serversByURL', {}, {category: ['caching'], initializeTo: '{}'});

  add.method('initialize', function (baseURL, proxyURL) {
    this._baseURL = baseURL;
    this._proxyURL = proxyURL;
    this._dbsByName = {};
  }, {category: ['creating']});

  add.method('baseURL', function () { return this._baseURL; }, {category: ['accessing']});

  add.method('dbNamed', function (name) {
    return this._dbsByName[name] || (this._dbsByName[name] = Object.newChildOf(avocado.couch.db, this, name));
  }, {category: ['databases']});

  add.method('storeString', function () {
    return ["avocado.couch.dbServer.atURL(", this._baseURL.inspect(), ", ", this._proxyURL.inspect(), ")"].join("");
  }, {category: ['transporting']});

  add.method('doRequest', function (httpMethod, url, paramsStringOrObject, body, callback, errback) {
    // See http://wiki.apache.org/couchdb/Complete_HTTP_API_Reference for a list of possible requests.
    
    if (typeof(callback) !== 'function' || typeof(errback) !== 'function') { throw new Error("Need to pass in a callback and errback to doRequest."); }
    
    var fullURL = this._baseURL + url;
    var paramsString = avocado.http.paramsStringFrom(paramsStringOrObject);
    var req = new XMLHttpRequest();
    var urlForTheImmediateRequest;
    if (this._proxyURL) {
      urlForTheImmediateRequest = this._proxyURL;
      if (httpMethod === 'GET') {
        urlForTheImmediateRequest = urlForTheImmediateRequest + "?url=" + (fullURL + encodeURIComponent(paramsString ? (fullURL.include("?") ? "&" : "?") + paramsString : ""));
      } else {
        body = "url=" + fullURL + (paramsString ? "&" + paramsString : "") + "\n" + body;
      }
    } else {
      urlForTheImmediateRequest = fullURL;
    }
    //console.log("About to doRequest: " + httpMethod + " " + urlForTheImmediateRequest + "\n" + body);
    req.open(httpMethod, urlForTheImmediateRequest, true);
    req.setRequestHeader("Content-Type", "application/json");
    req.onreadystatechange = function() {
      if (req.readyState === 4) {
        //console.log("Received response from CouchDB: " + req.responseText);
        try {
          obj = JSON.parse(req.responseText);
          callback(obj);
        } catch (e) {
          errback(e);
        }
      }
    };
    req.send(body);
  }, {category: ['requests']});

});


thisModule.addSlots(avocado.couch.db, function(add) {

  add.method('proxyURL', function () {
    // aaa - This is still a bit too hard-coded. Should be configurable from within Avocado, I think. -- Adam
    var baseURL = avocado.transporter.avocadoBaseURL;
    if (baseURL === undefined) { baseURL = document.documentURI; }
    baseURL = baseURL.substring(0, baseURL.lastIndexOf("/")) + '/';
    return baseURL + "cgi/proxy.cgi";
  });

  add.method('findDBAtURL', function (url, callback, errback) {
    var i = url.lastIndexOf("/");
    if (i < 0 || i === url.length - 1) { errback(new Error("A CouchDB URL should be of the form http://server:5984/db")); return; }
    var server = avocado.couch.dbServer.atURL(url.substr(0, i), this.proxyURL());
    var db = server.dbNamed(url.substr(i + 1));
    db.ensureExists(callback, errback);
  }, {category: ['creating']});

  add.creator('prompter', {}, {category: ['user interface']});

  add.method('initialize', function (server, name) {
    this._server = server;
    this._name = name;
    this._refsByID = {};
    this._designsByName = {};
  }, {category: ['creating']});

  add.creator('tests', Object.create(avocado.testCase), {category: ['tests']});

  add.method('name', function () { return this._name; }, {category: ['accessing']});

  add.method('toString', function () { return this.name(); }, {category: ['printing']});

  add.method('baseURL', function () { return this._server.baseURL() + "/" + this.name(); }, {category: ['accessing']});

  add.method('labelString', function () { return this._name; }, {category: ['user interface']});

  add.method('textualReference', function () { return 'couch:' + this.baseURL(); }, {category: ['accessing']});

  add.method('storeString', function () {
    return ["(", this._server.storeString(), ").dbNamed(", this._name.inspect(), ")"].join("");
  }, {category: ['transporting']});

  add.method('doRequest', function (httpMethod, url, paramsStringOrObject, body, callback, errback) {
    this._server.doRequest(httpMethod, "/" + this.name() + url, paramsStringOrObject, body, callback, errback);
  }, {category: ['requests']});

  add.method('ensureExists', function (callback, errback) {
    if (this._isKnownToExist) { callback(this); return; }
    
    this.doRequest("PUT", "", "", "", function (responseObj) {
      if (responseObj.ok || responseObj.error === 'file_exists') {
        this._isKnownToExist = true;
        callback(this);
      } else {
        errback(responseObj);
      }
    }.bind(this), errback);
  }, {category: ['creating']});

  add.method('ensureDoesNotExist', function (callback, errback) {
    this.doRequest("DELETE", "", "", "", function (responseObj) {
      delete this._isKnownToExist;
      this._refsByID = {};
      callback(this);
    }.bind(this), errback);
  }, {category: ['creating']});

  add.method('error', function (responseObj) {
    throw new Error(responseObj.error + ": " + responseObj.reason);
  }, {category: ['handling errors']});

  add.method('remoteRefForID', function (id) {
    var ref = this.existingRemoteRefForID(id);
    if (ref) { return ref; }
    ref = avocado.remoteObjectReference.create(undefined, this, id);
    this.rememberRemoteRefForID(id, ref);
    return ref;
  }, {category: ['documents']});

  add.method('rememberRemoteRefForID', function (id, ref) {
    this._refsByID[id] = ref;
  }, {category: ['documents']});

  add.method('forgetRemoteRefForID', function (id) {
    delete this._refsByID[id];
    
  }, {category: ['documents']});

  add.method('existingRemoteRefForID', function (id, throwErrorIfNotFound) {
    var ref = this._refsByID[id];
    if (throwErrorIfNotFound && !ref) { throw new Error("Don't know anything about a document with ID " + id); }
    return ref;
  }, {category: ['documents']});

  add.method('addDocument', function (obj, callback, errback) {
    var ref = avocado.remoteObjectReference.table.refForObject(obj);

    var alreadyInDB = ref.realm();
    if (alreadyInDB) {
      if (alreadyInDB === this) {
        this.putDocumentAt(ref.id(), obj, callback, errback);
      } else {
        errback(new Error("That object is already in a different DB: " + alreadyInDB));
      }
    } else {
      var json = this.convertRealObjectToJSON(obj);
      this.doRequest("POST", "", "", json, function(responseObj) {
        if (responseObj.ok) {
          ref.setDBInfo(this, responseObj.id, responseObj.rev);
          responseObj.ref = ref;
          callback(responseObj);
        } else {
          errback(responseObj);
        }
      }.bind(this), errback);
    }
  }, {category: ['documents']});

  add.method('putDocumentAt', function (id, obj, callback, errback) {
    var ref = avocado.remoteObjectReference.table.refForObject(obj);
    
    var alreadyInDB = ref.realm();
    if (alreadyInDB && alreadyInDB !== this) {
      errback(new Error("That object is already in a different DB: " + alreadyInDB));
    } else if (alreadyInDB && ref.id() !== id) {
      errback(new Error("That object is already in this DB under a different ID: " + ref.id()));
    } else {
      var extraSlots = ref._rev ? { _rev: ref._rev } : {};
      var json = this.convertRealObjectToJSON(obj, extraSlots);
      this.doRequest("PUT", "/" + id, "", json, function(responseObj) {
        if (responseObj.ok) {
          ref._rev = responseObj.rev;
          responseObj.ref = ref;
          callback(responseObj);
        } else {
          errback(responseObj);
        }
      }.bind(this), errback);
    }
  }, {category: ['documents']});

  add.method('deleteDocumentAt', function (id, callback, errback) {
    var ref = this.existingRemoteRefForID(id);
    if (! ref) { callback(); return; } // aaa - this is probably not the right thing to do, but right now I just want to say "delete the object if it's there, otherwise don't worry about it"
    var rev = ref._rev;
    this.doRequest("DELETE", "/" + id, "rev=" + rev, null, function(responseObj) {
      callback(responseObj);
    }.bind(this), errback);
  }, {category: ['documents']});

  add.method('getDocument', function (id, callback, errback) {
    this.doRequest("GET", "/" + id, "", null, function(responseObj) {
      var idAgain = responseObj._id;
      if (id !== idAgain) {
        var errorObj;
        if (typeof(responseObj.error) !== 'undefined') {
          errorObj = responseObj;
        } else {
          errorObj = { error: "The document that came back from the DB has a different ID from the one we asked for.", reason: "unknown" };
        }
        
        errback(errorObj);
      } else {
        var ref = this.updateRealObjectFromDumbDataObject(responseObj);
        if (callback) { callback(ref.object(), ref.id(), ref); }
      }
    }.bind(this));
  }, {category: ['documents']});

  add.method('convertRealObjectToJSON', function (obj, hardwiredSlots) {
    if (typeof(obj) === 'string') { return obj; } // allow raw JSON
    
    var mir = reflect(obj);
    var slots = mir.slots().toArray();
    slots.push(mir.parentSlot());
    if (hardwiredSlots) {
      reflect(hardwiredSlots).normalSlots().each(function(hardwiredSlot) {
        slots.push(Object.newChildOf(avocado.slots.hardWiredContents, mir, hardwiredSlot.name(), hardwiredSlot.contents()));
      });
    }
    
    var fo = avocado.transporter.module.filerOuters.json.create(this);
    fo.fileOutSlots(slots);
    if (fo.errors().size() > 0) { throw new Error("Errors converting " + obj + " to JSON: " + fo.errors().map(function(e) { return e.toString(); }).join(", ")); }
    return fo.fullText() || "{}";
  }, {category: ['documents', 'converting']});

  add.method('updateRealObjectFromDumbDataObject', function (dumbDataObj) {
    var id = dumbDataObj._id;
    delete dumbDataObj._id;
    var ref = this.remoteRefForID(id);
    ref._rev = dumbDataObj._rev;
    delete dumbDataObj._rev;
    
    var obj = ref.object() || dumbDataObj;
    if (obj === dumbDataObj) {
      ref.setObject(obj);
    }
    
    var underscoreReplacementLength = 'underscoreReplacement'.length;
    var names = reflect(dumbDataObj).normalSlotNames();
    names.each(function(name) {
      var contents = dumbDataObj[name];
      var realName = name;
      var realContents = contents;
      
      if (realName.substr(0, underscoreReplacementLength) === 'underscoreReplacement') {
        realName = realName.substr(underscoreReplacementLength);
      }
      
      if (realName.endsWith('__creatorPath')) {
        realName = realName.substr(0, realName.length - '__creatorPath'.length);
        var chainNames = contents;
        var o = window;
        for (var i = 0; i < chainNames.length; ++i) {
          var slotName = chainNames[i];
          o = o[slotName];
          if (o === undefined || o === null) { throw new Error("Invalid creator path: " + chainNames.join(", ")); }
        }
        realContents = o;
      }

      if (realName.endsWith('__id')) {
        realName = realName.substr(0, realName.length - '__id'.length);
        realContents = this.remoteRefForID(contents).object();
      }
      
      var nameChanged = name !== realName;
      if (nameChanged) { delete dumbDataObj[name]; }
      
      if (obj !== dumbDataObj || nameChanged || contents !== realContents) {
        obj[realName] = realContents;
      }
    }.bind(this));
    
    return ref;
  }, {category: ['documents', 'converting']});

  add.method('findObjectByID', function (id, callback) {
    this.remoteRefForID(id).fetchObjectIfNotYetPresent(callback);
  }, {category: ['objects']});

  add.creator('relationships', {}, {category: ['relationships']});

  add.creator('container', {}, {category: ['relationships']});

  add.creator('design', {}, {category: ['designs']});

  add.creator('view', {}, {category: ['designs']});

  add.creator('query', {}, {category: ['designs']});

  add.method('designWithName', function (n) {
    return this._designsByName[n] || (this._designsByName[n] = Object.newChildOf(this.design, this, n));
  }, {category: ['designs']});

  add.method('containerTypesOrganizer', function () {
    return Object.newChildOf(this.containerTypesOrganizerProto, this);
  }, {category: ['containers']});

  add.creator('containerTypesOrganizerProto', {}, {category: ['containers']});

  add.method('commands', function () {
    var cmdList = avocado.command.list.create(this);
    cmdList.addItem(avocado.command.create('container types', function(evt) {
      avocado.ui.grab(this.containerTypesOrganizer(), evt);
    }));
    return cmdList;
  }, {category: ['user interface', 'commands']});

  add.method('dragAndDropCommands', function () {
    var cmdList = avocado.command.list.create(this);
    cmdList.addItem(avocado.command.create("add object", function(evt, mir) {
      this.addDocument(mir.reflectee(), function(responseObj) {
        var ref = responseObj.ref;
        // anything to do here?
      }, function(err) {
        throw err; // aaa or display it in a better way
      });
    }).setArgumentSpecs([avocado.command.argumentSpec.create('mir').onlyAccepts(function(o) {
      return o && typeof(o.reflectee) === 'function' && o.reflectee();
    })]));
    return cmdList;
  }, {category: ['user interface', 'drag and drop']});

});


thisModule.addSlots(avocado.couch.db.prompter, function(add) {

  add.method('prompt', function (caption, context, evt, callback) {
    avocado.ui.prompt('CouchDB URL?', function(url) {
      avocado.couch.db.findDBAtURL(url, callback, avocado.ui.showError);
    }, 'http://localhost:5984/dbname', evt);
  }, {category: ['prompting']});

});


thisModule.addSlots(avocado.couch.db.tests, function(add) {

  add.creator('argle', {});

  add.creator('bargle', {});

  add.method('asynchronouslyTestBasicStuff', function (callback, errback) {
    var server = avocado.couch.dbServer.atURL('http://localhost:5984', avocado.couch.db.proxyURL());
    server.doRequest("GET", "/", "", null, function (responseObj) {
      this.assertEqual(responseObj.couchdb, 'Welcome');
      var db1 = server.dbNamed('avocado_tests_1');
      var db2 = server.dbNamed('avocado_tests_2');
      db1.ensureExists(function () {
        db2.ensureExists(function () {
          var argle1 = Object.newChildOf(this.argle, 1, 2, 3);
          db1.addDocument(argle1, function(responseObj) {
            var ref = responseObj.ref;
            var id = ref.id();
            ref.forgetMe();
            db1.getDocument(id, function(obj, idAgain) {
              this.assertEqual(id, idAgain);
              this.assertEqual("123", obj.toString());
              var argle2 = Object.newChildOf(this.argle, 'one', 'two', 'three'); // aaa - change one of these to say argle1, try inter-db references
              db2.addDocument(argle2, function(responseObj) {
                var ref2 = responseObj.ref;
                var id2 = ref2.id();
                ref2.forgetMe();
                db2.getDocument(id2, function(obj2, id2Again) {
                  this.assertEqual("onetwothree", obj2.toString());
                  avocado.remoteObjectReference.table.findObjectReferredToAs('{"realm": ' + db2.textualReference().inspect(true) + ', "id": ' + id2.inspect(true) + '}', function(obj2Again) {
                    this.assertEqual("onetwothree", obj2Again.toString());
                    callback();
                  }.bind(this), errback);
                }.bind(this), errback);
              }.bind(this), errback);
            }.bind(this), errback);
          }.bind(this), errback);
        }.bind(this), errback);
      }.bind(this), errback);
    }.bind(this), errback);
  });

  add.method('asynchronouslyTestQuerying', function (callback, errback) {
    var server = avocado.couch.dbServer.atURL('http://localhost:5984', avocado.couch.db.proxyURL());
    var db = server.dbNamed('avocado_querying_tests');
    db.ensureDoesNotExist(function () {
      db.ensureExists(function () {
        var design = db.designWithName("queryTest");
        var argleBargles = avocado.couch.db.relationships.oneToMany.create(avocado.couch.db.tests.argle, avocado.couch.db.tests.bargle, '_argle');
        design.addViewForRelationship(argleBargles);
        design.rawDoc().views.bFive = { map: "function(doc) { if (doc.b === 5) { emit(doc._id, doc); }}" };
        design.remove(function(responseObj) {
          design.put(function(responseObj) {
            var argle1 = Object.newChildOf(this.argle, 1, 2, 3);
            var argle2 = Object.newChildOf(this.argle, 3, 5, 7);
            var argle3 = Object.newChildOf(this.argle, 4, 5, 6);
            db.addDocument(argle1, function(responseObj) {
              db.addDocument(argle2, function(responseObj) {
                db.addDocument(argle3, function(responseObj) {

                  argle3.c = 'six';
                  // I think addDocument should do a putDocumentAt if the object is already in the DB.
                  db.addDocument(argle3, function(responseObj) {
                    
                    design.viewNamed('bFive').queryForAllResults().getResults(function(responseObj) {
                      var results = responseObj.refs;
                      this.assertEqual(2, results.size());
                      this.assertEqual("357",   results[0].object().toString());
                      this.assertEqual("45six", results[1].object().toString());

                      // Let's try out the oneToMany relationship object.
                      var bargle11 = Object.newChildOf(this.bargle, argle1, "one", 1);
                      var bargle12 = Object.newChildOf(this.bargle, argle1, "two", 2);
                      var bargle21 = Object.newChildOf(this.bargle, argle2, "one", 1);
                      var bargle22 = Object.newChildOf(this.bargle, argle2, "two", 2);
                      var argle1Bargles = argleBargles.queryFor(argle1, design);
                      var argle2Bargles = argleBargles.queryFor(argle2, design);
                      db.addDocument(bargle11, function(responseObj) {
                        db.addDocument(bargle12, function(responseObj) {
                          db.addDocument(bargle21, function(responseObj) {
                            db.addDocument(bargle22, function(responseObj) {
                              argle1Bargles.getResults(function(responseObj) {
                                var argle1BarglesResults = responseObj.refs;
                                this.assertEqual(3, argle1BarglesResults.length);
                                this.assertEqual(argle1,   argle1BarglesResults[0].object());
                                this.assertEqual(bargle11, argle1BarglesResults[1].object());
                                this.assertEqual(bargle12, argle1BarglesResults[2].object());
                                argle2Bargles.getResults(function(responseObj) {
                                  var argle2BarglesResults = responseObj.refs;
                                  this.assertEqual(3, argle2BarglesResults.length);
                                  this.assertEqual(argle2,   argle2BarglesResults[0].object());
                                  this.assertEqual(bargle21, argle2BarglesResults[1].object());
                                  this.assertEqual(bargle22, argle2BarglesResults[2].object());
                                  callback();
                                }.bind(this), errback);
                              }.bind(this), errback);
                            }.bind(this), errback);
                          }.bind(this), errback);
                        }.bind(this), errback);
                      }.bind(this), errback);
                    }.bind(this), errback);
                  }.bind(this)), errback;

                }.bind(this), errback);
              }.bind(this), errback);
            }.bind(this), errback);
          }.bind(this), errback);
        }.bind(this), errback);
      }.bind(this), errback);
    }.bind(this), errback);
  });

});


thisModule.addSlots(avocado.couch.db.tests.argle, function(add) {

  add.method('initialize', function (a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
  });

  add.method('toString', function () {
    return "" + this.a + this.b + this.c;
  });

});


thisModule.addSlots(avocado.couch.db.tests.bargle, function(add) {

  add.method('initialize', function (argle, s, t) {
    this.s = s;
    this.t = t;
    this.setArgle(argle);
  });

  add.method('toString', function () {
    return "" + this.argle() + this.s + this.t;
  });

  add.method('argle', function () {
    return this._argle;
  });

  add.method('setArgle', function (argle) {
    if (! reflect(argle).reflecteeRemoteReference()) { throw new Error("Must set argle to an object that is stored in a DB."); }
    this._argle = argle;
  });

});


thisModule.addSlots(avocado.couch.db.relationships, function(add) {

  add.creator('oneToMany', {});

});


thisModule.addSlots(avocado.couch.db.relationships.oneToMany, function(add) {

  add.method('create', function () {
    var c = Object.create(this);
    c.initialize.apply(c, arguments);
    return c;
  }, {category: ['creating']});

  add.method('createFromViewDocument', function (viewDoc, viewName) {
    var containerTypeMir = avocado.mirror.forObjectNamed(viewDoc.containerCreatorSlotChain);
    var   elementTypeMir = avocado.mirror.forObjectNamed(viewDoc.elementCreatorSlotChain);
    var prefix = this.viewNamePrefix(containerTypeMir, elementTypeMir);
    if (viewName.substr(0, prefix.length) !== prefix) {
      throw new Error("View name " + viewName.inspect() + " does not match the view's element type " + reflect(viewDoc.elementCreatorSlotChain).expressionEvaluatingToMe());
    }
    var attrName = viewName.substr(prefix.length);
    return this.create(containerTypeMir.reflectee(), elementTypeMir.reflectee(), attrName);
  }, {category: ['creating']});

  add.method('initialize', function (containerType, elementType, nameOfAttributePointingToContainer) {
    this._containerTypeMir = reflect(containerType);
    this._elementTypeMir   = reflect(elementType);
    this._nameOfAttributePointingToContainer = nameOfAttributePointingToContainer;
  }, {category: ['creating']});

  add.method('viewName', function () {
    return this.viewNamePrefix(this._containerTypeMir, this._elementTypeMir) + this._nameOfAttributePointingToContainer;
  }, {category: ['views']});

  add.method('viewNamePrefix', function (containerTypeMir, elementTypeMir) {
    var contPart = containerTypeMir.creatorSlotChain().reverse().map(function(s) { return s.name(); }).join("__");
    var elemPart =   elementTypeMir.creatorSlotChain().reverse().map(function(s) { return s.name(); }).join("__");
    return contPart + "__" + elemPart + "___";
  }, {category: ['views']});

  add.method('containerTypeMir', function () { return this._containerTypeMir; }, {category: ['accessing']});

  add.method('elementTypeMir', function () { return this._elementTypeMir; }, {category: ['accessing']});

  add.method('nameOfAttributePointingToContainer', function () { return this._nameOfAttributePointingToContainer; }, {category: ['accessing']});

  add.method('copyForAttribute', function (nameOfAttributePointingToContainer) {
    var c = Object.shallowCopy(this);
    c._nameOfAttributePointingToContainer = nameOfAttributePointingToContainer;
    return c;
  }, {category: ['copying']});

  add.method('toString', function () {
    return this._nameOfAttributePointingToContainer;
  }, {category: ['printing']});

  add.method('stringForMapFunction', function () {
    var s = [];
    s.push("function(doc) { var p = doc.underscoreReplacement__proto____creatorPath; if (!p) { return; }");
    
    var containerCreatorSlotChain = this._containerTypeMir.creatorSlotChain();
    s.push(" if (p.length === ", containerCreatorSlotChain.length);
    for (var i = 0, n = containerCreatorSlotChain.length; i < n; ++i) {
      s.push(" && p[", i, "] === ", containerCreatorSlotChain[n - 1 - i].name().inspect());
    }
    s.push(") { emit([doc._id, 0], doc); }");
    
    var elementCreatorSlotChain = this._elementTypeMir.creatorSlotChain();
    s.push(" if (p.length === ", elementCreatorSlotChain.length);
    for (var i = 0, n = elementCreatorSlotChain.length; i < n; ++i) {
      s.push(" && p[", i, "] === ", elementCreatorSlotChain[n - 1 - i].name().inspect());
    }
    var attrName = this._nameOfAttributePointingToContainer;
    if (attrName[0] === '_') { attrName = 'underscoreReplacement' + attrName; }
    s.push(" && doc.", attrName, "__id !== undefined");
    s.push(") { emit([doc.", attrName, "__id, 1], doc); }");
    
    s.push(" }");
    return s.join("");
  }, {category: ['views']});

  add.method('viewInDesign', function (design) {
    return design.viewNamed(this.viewName());
  }, {category: ['views']});

  add.method('attachMetaInfoToViewDocument', function (viewDoc) {
    viewDoc.containerCreatorSlotChain = this._containerTypeMir.creatorSlotChain().map(function(s) { return s.name(); }).reverse();
    viewDoc.  elementCreatorSlotChain = this._elementTypeMir  .creatorSlotChain().map(function(s) { return s.name(); }).reverse();
  }, {category: ['views']});

  add.method('containerFor', function (containerObj, design) {
    var containerRef = avocado.remoteObjectReference.table.refForObject(containerObj);
    return avocado.couch.db.container.create(this, containerRef, design);
  }, {category: ['querying']});

  add.method('queryFor', function (containerObj, design) {
    var ref = avocado.remoteObjectReference.table.existingRefForObject(containerObj);
    if (!ref) { throw new Error("Can't create a oneToMany query for " + containerObj + " because we don't know its ID."); }
    return this.queryForID(ref.id(), design);
  }, {category: ['querying']});

  add.method('queryForID', function (containerID, design) {
    return this.viewInDesign(design).newQuery({startkey: '[' + containerID.inspect(true) + ',0]', endkey: '[' + containerID.inspect(true) + ',{}]'});
  }, {category: ['querying']});

  add.method('storeString', function () {
    return ["avocado.couch.db.relationships.oneToMany.create(", this._containerTypeMir.creatorSlotChainExpression(), ", ", this._elementTypeMir.creatorSlotChainExpression(), ", ", this._nameOfAttributePointingToContainer.inspect(), ")"].join("");
  }, {category: ['transporting']});

});


thisModule.addSlots(avocado.couch.db.container, function(add) {

  add.method('create', function () {
    var c = Object.create(this);
    c.initialize.apply(c, arguments);
    return c;
  }, {category: ['creating']});

  add.method('initialize', function (relationship, containerRef, design, optionalName) {
    this._relationship = relationship;
    this._containerRef = containerRef;
    this._design = design;
    this._name = optionalName;
    this._contents = [];
  }, {category: ['creating']});

  add.method('containerObj', function () {
    return this._containerRef.object();
  }, {category: ['creating']});

  add.method('copyRemoveAll', function () {
    var newContainerObj = Object.create(this.containerObj().__proto__);
    return this._relationship.containerFor(newContainerObj, this._design);
  }, {category: ['copying']});

  add.method('setAttributeName', function (n) {
    this._relationship = this._relationship.copyForAttribute(n);
    this._contents = [];
  }, {category: ['accessing']});

  add.method('setContainerName', function (n) {
    this._name = n;
  }, {category: ['accessing']});

  add.method('contents', function () {
    return this._contents;
  }, {category: ['accessing']});

  add.method('relationship', function () {
    return this._relationship;
  }, {category: ['accessing']});

  add.method('db', function () {
    return this._design.db();
  }, {category: ['accessing']});

  add.method('doesTypeMatch', function (obj) { return obj && obj.__proto__ === avocado.couch.db.container; }, {category: ['testing']});

  add.method('updateContents', function (callback) {
    var ref = this._containerRef;
    if (!ref.id()) { return this; }
    var query = this._relationship.queryForID(ref.id(), this._design);
    query.getResults(function(responseObj) {
      if (responseObj.refs) {
        var containerRef = responseObj.refs.shift();
        this._contents = responseObj.refs.map(function(ref) { return reflect(ref.object()); }); // aaa - enhance this, want to be able to hold more than mirrors
      } else {
        if (responseObj.error) {
          console.error("Error: " + responseObj.error + ", reason: " + responseObj.reason);
        } else {
          throw new Error("What is going on?");
        }
      }
      if (callback) { callback(this._contents); }
    }.bind(this), function(err) { throw err; });
    return this;
  }, {category: ['updating']});

  add.method('toString', function () {
    if (this._name) { return this._name; }
    var elementTypeName = this._relationship.elementTypeMir().name().withoutSuffix(".prototype");
    return elementTypeName + "s whose " + this._relationship.nameOfAttributePointingToContainer() + " is " + reflect(this.containerObj()).inspect();
  }, {category: ['printing']});

  add.method('immediateContents', function () {
    return this._contents;
  }, {category: ['accessing']});

  add.method('commands', function () {
    var cmdList = avocado.command.list.create(this);

    cmdList.addItem(avocado.command.create('change attribute', function(evt, attributeName) {
      this.setAttributeName(attributeName);
      avocado.ui.justChanged(this, null, evt);
      this.updateContents(function() { avocado.ui.justChanged(this, evt); }.bind(this));
    }.bind(this)).setArgumentSpecs([
      avocado.command.argumentSpec.create('attributeName').onlyAcceptsType(String)
    ]));

    cmdList.addItem(avocado.command.create('rename', function(evt, containerName) {
      this.setContainerName(containerName);
      avocado.ui.justChanged(this, null, evt);
    }.bind(this)).setArgumentSpecs([
      avocado.command.argumentSpec.create('containerName').onlyAcceptsType(String)
    ]));

    cmdList.addItem(avocado.command.create('get container object', function(evt) {
      avocado.ui.grab(reflect(this.containerObj()), evt);
    }));

    return cmdList;
  }, {category: ['commands']});

  add.method('dragAndDropCommands', function () {
    var cmdList = avocado.command.list.create(this);
    
    cmdList.addItem(avocado.command.create("add mirror", function(evt, mir) {
      this.addObject(mir.reflectee(), function(responseObj) {
        var ref = responseObj.ref;
        avocado.ui.justChangedContent(this, evt);
        console.log("Successfully added " + mir.name() + " to " + this);
      }.bind(this), function(err) {
        throw err; // aaa or display it in a better way
      });
    }).setArgumentSpecs([avocado.command.argumentSpec.create('mir').onlyAccepts(function(mir) {
      if (!mir) { return false; }
      if (typeof(mir.reflectee) !== 'function') { return false; }
      var obj = mir.reflectee();
      return Object.inheritsFrom(this._relationship.elementTypeMir().reflectee(), obj);
    }.bind(this))]));
    
    return cmdList;
  }, {category: ['commands']});

  add.method('addObject', function (elementObj, callback, errback) {
    this.db().addDocument(this.containerObj(), function(responseObj) { // aaa - figure out a better way to make sure the container obj is in the DB
      this._containerRef = responseObj.ref;
      elementObj[this._relationship.nameOfAttributePointingToContainer()] = this.containerObj();
      this.db().addDocument(elementObj, function() {
        this.updateContents(callback);
      }.bind(this), errback);
    }.bind(this), errback);
  }, {category: ['adding']});

  add.method('storeString', function () {
    return ["avocado.couch.db.container.create(", this._relationship.storeString(), ", ", this._containerRef.expressionToRecreateRefAndFetchObject(), ", ", this._design.storeString(), (this._name ? ", " + Object.inspect(this._name) : ""), ")"].join("");
  }, {category: ['transporting']});

});


thisModule.addSlots(avocado.couch.db.design, function(add) {

  add.method('initialize', function (db, n) {
    this._db = db;
    this._name = n;
    var id = "_design/" + n;
    this._ref = db.existingRemoteRefForID(id);
    this._rawDoc = this._ref ? this._ref.object() : { _id : id, views : {} };
    this._viewsByName = {};
  }, {category: ['creating']});

  add.method('rawDoc', function () { return this._rawDoc; }, {category: ['accessing']});

  add.method('name', function () { return this._name; }, {category: ['accessing']});

  add.method('db', function () { return this._db; }, {category: ['accessing']});

  add.method('id', function () { return this.rawDoc()._id; }, {category: ['accessing']});

  add.method('remove', function (callback, errback) {
    this._db.deleteDocumentAt(this.id(), callback, errback);
  }, {category: ['adding and removing']});

  add.method('get', function (callback, errback) {
    return this._db.getDocument(this.id(), function(obj, id, ref) {
      this._rawDoc = obj;
      this._ref = ref;
      if (callback) { callback(obj); }
    }.bind(this), function(errorObj) {
      if (errback) {
        errback(errorObj);
      } else {
        if (callback) { callback(this._rawDoc); } // just use the local new one if there's no existing one
      }
    }.bind(this));
  }, {category: ['views']});

  add.method('put', function (callback, errback) {
    this._db.putDocumentAt(this.id(), this._rawDoc, function(responseObj) {
      this._ref = responseObj.ref;
      this._rawDoc = responseObj.ref.object();
      if (callback) { callback(responseObj); }
    }, errback);
  }, {category: ['adding and removing']});

  add.method('doRequest', function (httpMethod, url, paramsStringOrObject, body, callback, errback) {
    this._db.doRequest(httpMethod, "/" + this.id() + url, paramsStringOrObject, body, callback, errback);
  }, {category: ['requests']});

  add.method('viewNamed', function (viewName) {
    return this._viewsByName[viewName] || (this._viewsByName[viewName] = Object.newChildOf(avocado.couch.db.view, this, viewName));
  }, {category: ['views']});

  add.method('addViewForRelationship', function (r) {
    var viewDoc = { map: r.stringForMapFunction() };
    r.attachMetaInfoToViewDocument(viewDoc);
    this.rawDoc().views[r.viewName()] = viewDoc;
  }, {category: ['views']});

  add.method('storeString', function () {
    return ["(", this._db.storeString(), ").designWithName(", this._name.inspect(), ")"].join("");
  }, {category: ['transporting']});

});


thisModule.addSlots(avocado.couch.db.view, function(add) {

  add.method('initialize', function (design, n) {
    this._design = design;
    this._name = n;
  }, {category: ['creating']});

  add.method('design', function () { return this._design; }, {category: ['accessing']});

  add.method('name', function () { return this._name; }, {category: ['accessing']});

  add.method('newQuery', function (options) {
    return Object.newChildOf(avocado.couch.db.query, this, options);
  }, {category: ['queries']});

  add.method('queryForAllResults', function () {
    return this.newQuery();
  }, {category: ['queries']});

  add.method('storeString', function () {
    return ["(", this._design.storeString(), ").viewNamed(", this._name.inspect(), ")"].join("");
  }, {category: ['transporting']});

});


thisModule.addSlots(avocado.couch.db.query, function(add) {

  add.method('initialize', function (view, options) {
    this._view = view;
    this._options = options;
  }, {category: ['creating']});

  add.method('view', function () { return this._view; }, {category: ['accessing']});

  add.method('options', function () { return this._options; }, {category: ['accessing']});

  add.method('getResults', function (callback, errback) {
    // aaa - implement other kinds of queries, not just "get all results"
    var db = this.view().design().db();
    var viewName = this.view().name();
    this.view().design().doRequest("GET", "/_view/" + viewName, this.options(), null, function(responseObj) {
      if (responseObj.rows) {
        responseObj.refs = responseObj.rows.map(function(row) { return db.updateRealObjectFromDumbDataObject(row.value); });
      } else {
        errback(responseObj);
      }
      callback(responseObj);
    }.bind(this), errback);
  }, {category: ['views']});

});


thisModule.addSlots(avocado.couch.db.containerTypesOrganizerProto, function(add) {

  add.method('initialize', function (db) {
    this._db = db;
    this.setContainerPrototypes([]);
    this.updateContainerTypes();
  }, {category: ['creating']});

  add.method('toString', function () { return "Container types for " + this._db; });

  add.method('setContainerPrototypes', function (types) {
    types = types.toArray();
    this._containerPrototypes = types;
    types.forEach(function(containerProto) {
      containerProto.updateContents();
    });
  });

  add.method('design', function () {
    return this._db.designWithName("avocado_containers");
  }, {category: ['accessing']});

  add.method('updateContainerTypes', function (callback) {
    var design = this.design();
    design.get(function(designDoc) {
      var viewsDoc = designDoc.views;
      this.setContainerPrototypes(reflect(viewsDoc).normalSlotNames().map(function(viewName) {
        var viewDoc = viewsDoc[viewName];
        var relationship = avocado.couch.db.relationships.oneToMany.createFromViewDocument(viewDoc, viewName);
        return relationship.containerFor({}, design);
      }));
      if (callback) { callback(); }
    }.bind(this), function(err) {
      var relationship = avocado.couch.db.relationships.oneToMany.create(Object.prototype, Object.prototype, "holder");
      design.addViewForRelationship(relationship);
      design.put(function(responseObj) {
        this.setContainerPrototypes([relationship.containerFor({}, design)]);
        if (callback) { callback(); }
      }.bind(this), function(err) { throw err; });
    }.bind(this));
  }, {category: ['updating']});

  add.method('immediateContents', function () {
    return this._containerPrototypes;
  }, {category: ['accessing']});

  add.method('dragAndDropCommands', function () {
    var cmdList = avocado.command.list.create(this);
    cmdList.addItem(avocado.command.create("add container type", function(evt, container) {
      var design = this.design();
      design.get(function() {
        design.addViewForRelationship(container.relationship());
        design.put(function(responseObj) {
          this.updateContainerTypes(function() {
            avocado.ui.justChangedContent(this, evt);
          }.bind(this));
        }.bind(this), function(err) {
          console.error("Error setting the DB design: " + err.error + ", reason: " + err.reason);
        });
      }.bind(this), function(err) {
        console.error("Error getting the DB design: " + err.error + ", reason: " + err.reason);
      }.bind(this));
    }).setArgumentSpecs([avocado.command.argumentSpec.create('container').onlyAcceptsType(avocado.couch.db.container)]));
    return cmdList;
  }, {category: ['commands']});

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/string_buffer_morph"] = function() {};
avocado.transporter.module.create('general_ui/string_buffer_morph', function(requires) {

requires('core/string_buffer');

}, function(thisModule) {


thisModule.addSlots(avocado.stringBuffer, function(add) {

  add.method('newMorph', function () {
    this.startNotifyingUIWheneverChanged();
    return avocado.types.longString.createInputMorph(avocado.accessors.forMethods(this, 'toString'));
  }, {category: ['user interface']});

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/scripting"] = function() {};
avocado.transporter.module.create('general_ui/scripting', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('morphScripter', {}, {category: ['ui', 'scripting']});

});


thisModule.addSlots(avocado.morphScripter, function(add) {

  add.method('create', function (morph) {
    return Object.newChildOf(this, morph);
  }, {category: ['creating']});

  add.method('initialize', function (morph) {
    this._morph = morph;
  }, {category: ['creating']});

  add.method('forwardBy', function (n) {
  	var heading = this._morph.getRotation() - (Math.PI / 2);
    this._morph.translateBy(Point.polar(n, heading));
  }, {category: ['moving']});

  add.method('turnBy', function (degrees) {
    this._morph.rotateBy(degrees.toRadians());
  }, {category: ['moving']});

});


});

avocado.transporter.module.onLoadCallbacks["core/webdav"] = function() {};
avocado.transporter.module.create('core/webdav', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('webdav', {}, {category: ['WebDAV']});

});


thisModule.addSlots(avocado.webdav, function(add) {

  add.creator('file', {});

});


thisModule.addSlots(avocado.webdav.file, function(add) {

  add.method('create', function (url) {
    return Object.newChildOf(this, url);
  }, {category: ['creating']});

  add.method('initialize', function (url) {
    this._url = url;
  }, {category: ['creating']});

  add.method('fileName', function () {
    return this._url.filename();
  }, {category: ['accessing']});

  add.method('contentText', function (callback) {
    if (typeof(this._cachedContents) === 'undefined' && !this._contentsReq) {
      var thisFile = this;
      var req = Object.newChildOf(avocado.http.request, this.urlString());
      this._contentsReq = req;
      req.send(function(responseText) {
        thisFile._cachedContents = responseText;
        delete thisFile._contentsReq;
        avocado.ui.justChanged(thisFile);
        if (callback) { callback(responseText); }
      }, function(err) {
        console.log("Error getting contents of " + thisFile.urlString() + " - " + err);
      });
    }
    return this._cachedContents || "";
  }, {category: ['accessing']});

  add.method('setContentText', function (t, callback) {
    this._cachedContents = t || "";
    if (!this._contentsSetterReq) {
      var thisFile = this;
      var req = Object.newChildOf(avocado.http.request, this.urlString()).setHTTPMethod("PUT").setPostBody(this._cachedContents);
      this._contentsSetterReq = req;
      req.send(function() {
        delete thisFile._contentsSetterReq;
        if (callback) { callback(); }
      }, function(err) {
        console.log("Error setting contents of " + thisFile.urlString() + " - " + err);
      });
    }
    avocado.ui.justChanged(thisFile);
  }, {category: ['accessing']});

  add.method('urlString', function () {
    return this._url.toString();
  }, {category: ['accessing']});

  add.method('toString', function () {
    return this.fullName();
  }, {category: ['printing']});

  add.method('fullName', function () {
    return this.urlString();
  }, {category: ['printing']});

  add.method('hashCode', function () {
    return this.urlString();
  }, {category: ['comparing']});

  add.method('equals', function (other) {
    return typeof(other.urlString) === 'function' && this.urlString() === other.urlString();
  }, {category: ['comparing']});

  add.data('isImmutableForMorphIdentity', true, {category: ['comparing']});

  add.method('sortOrder', function () { return this.urlString().toUpperCase(); }, {category: ['sorting']});

});


thisModule.addSlots(avocado.transporter.repositories.httpWithWebDAV, function(add) {

  add.method('immediateContents', function () {
    return [this._rootDir || (this._rootDir = new FileDirectory(new URL(this._url)))];
  });

});


thisModule.addSlots(FileDirectory.prototype, function(add) {

  add.method('urlString', function () {
    return this.url.toString();
  }, {category: ['accessing']});

  add.method('toString', function () {
    return this.immediateName();
  }, {category: ['printing']});

  add.method('immediateName', function () {
    return this.url.filename();
  }, {category: ['printing']});

  add.method('hashCode', function () {
    return this.urlString();
  }, {category: ['comparing']});

  add.method('equals', function (other) {
    return typeof(other.urlString) === 'function' && this.urlString() === other.urlString();
  }, {category: ['comparing']});

  add.data('isImmutableForMorphIdentity', true, {category: ['comparing']});

  add.method('sortOrder', function () { return this.urlString().toUpperCase(); }, {category: ['sorting']});

  add.method('immediateContents', function () {
    if (! this._immediateContents) {
      var subdirs = this.subdirectories().selectThenMap(function(subDirURL) { return ! subDirURL.filename().startsWith("."); }, function(subDirURL) { return new FileDirectory(subDirURL); });
      var files = this.files().selectThenMap(function(fileURL) { return ! fileURL.filename().startsWith("."); }, function(fileURL) { return avocado.webdav.file.create(fileURL); });
      this._immediateContents = subdirs.concat(files);
    }
    return this._immediateContents;
  }, {category: ['user interface']});

  add.method('commands', function () {
    var cmdList = avocado.command.list.create();
    return cmdList;
  }, {category: ['user interface']});

  add.method('dragAndDropCommands', function () {
    var cmdList = avocado.command.list.create();
    return cmdList;
  }, {category: ['user interface']});

});


});

avocado.transporter.module.onLoadCallbacks["programming_environment/webdav"] = function() {};
avocado.transporter.module.create('programming_environment/webdav', function(requires) {

requires('core/webdav');

}, function(thisModule) {


thisModule.addSlots(avocado.transporter.repositories.httpWithWebDAV, function(add) {

  add.method('newMorph', function () {
    return avocado.treeNode.newMorphFor(this);
  }, {category: ['user interface']});

});


thisModule.addSlots(avocado.webdav.file, function(add) {

  add.method('newMorph', function () {
    var m = avocado.table.newColumnMorph().applyStyle(this.defaultMorphStyle);
    var titleLabel = avocado.infrequentlyEditedText.newMorphFor(avocado.accessors.forMethods(this, 'fileName'));
    var contentsMorph = avocado.types.longString.createInputMorph(avocado.accessors.forMethods(this, 'contentText'));
    m.layout().setCells([titleLabel, contentsMorph]);
    //m.startPeriodicallyUpdating();
    return m;
  }, {category: ['user interface']});

  add.creator('defaultMorphStyle', {}, {category: ['user interface']});

});


thisModule.addSlots(avocado.webdav.file.defaultMorphStyle, function(add) {

  add.data('borderRadius', 10);

  add.data('fillBase', new Color(0.9, 0.5, 0.5));

});


});

avocado.transporter.module.onLoadCallbacks["narcissus/jsparse"] = function() {};
// Gotten from   http://mxr.mozilla.org/mozilla/source/js/narcissus/
// aaa - This is actually jsdefs and jsparse smushed together. Could separate them,
// just make sure jsdefs gets loaded first. -- Adam



/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is the Narcissus JavaScript engine.
 *
 * The Initial Developer of the Original Code is
 * Brendan Eich <brendan@mozilla.org>.
 * Portions created by the Initial Developer are Copyright (C) 2004
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

/*
 * Narcissus - JS implemented in JS.
 *
 * Well-known constants and lookup tables.  Many consts are generated from the
 * tokens table via eval to minimize redundancy, so consumers must be compiled
 * separately to take advantage of the simple switch-case constant propagation
 * done by SpiderMonkey.
 */
 
// Enclose this whole thing in a function, to avoid polluting the global namespace. -- Adam
(function() {

const GLOBAL = window;
const nodeTypes = {};


var tokens = [
    // End of source.
    "END",

    // Operators and punctuators.  Some pair-wise order matters, e.g. (+, -)
    // and (UNARY_PLUS, UNARY_MINUS).
    "\n", ";",
    ",",
    "=",
    "?", ":", "CONDITIONAL",
    "||",
    "&&",
    "|",
    "^",
    "&",
    "==", "!=", "===", "!==",
    "<", "<=", ">=", ">",
    "<<", ">>", ">>>",
    "+", "-",
    "*", "/", "%",
    "!", "~", "UNARY_PLUS", "UNARY_MINUS",
    "++", "--",
    ".",
    "[", "]",
    "{", "}",
    "(", ")",

    // Nonterminal tree node type codes.
    "SCRIPT", "BLOCK", "LABEL", "FOR_IN", "CALL", "NEW_WITH_ARGS", "INDEX",
    "ARRAY_INIT", "OBJECT_INIT", "PROPERTY_INIT", "GETTER", "SETTER",
    "GROUP", "LIST",

    // Terminals.
    "IDENTIFIER", "NUMBER", "STRING", "REGEXP",

    // Keywords.
    "break",
    "case", "catch", "const", "continue",
    "debugger", "default", "delete", "do",
    "else", "enum",
    "false", "finally", "for", "function",
    "if", "in", "instanceof",
    "new", "null",
    "return",
    "switch",
    "this", "throw", "true", "try", "typeof",
    "var", "void",
    "while", "with",
];

// Operator and punctuator mapping from token to tree node type name.
// NB: superstring tokens (e.g., ++) must come before their substring token
// counterparts (+ in the example), so that the opRegExp regular expression
// synthesized from this list makes the longest possible match.
var opTypeNames = {
    '\n':   "NEWLINE",
    ';':    "SEMICOLON",
    ',':    "COMMA",
    '?':    "HOOK",
    ':':    "COLON",
    '||':   "OR",
    '&&':   "AND",
    '|':    "BITWISE_OR",
    '^':    "BITWISE_XOR",
    '&':    "BITWISE_AND",
    '===':  "STRICT_EQ",
    '==':   "EQ",
    '=':    "ASSIGN",
    '!==':  "STRICT_NE",
    '!=':   "NE",
    '<<':   "LSH",
    '<=':   "LE",
    '<':    "LT",
    '>>>':  "URSH",
    '>>':   "RSH",
    '>=':   "GE",
    '>':    "GT",
    '++':   "INCREMENT",
    '--':   "DECREMENT",
    '+':    "PLUS",
    '-':    "MINUS",
    '*':    "MUL",
    '/':    "DIV",
    '%':    "MOD",
    '!':    "NOT",
    '~':    "BITWISE_NOT",
    '.':    "DOT",
    '[':    "LEFT_BRACKET",
    ']':    "RIGHT_BRACKET",
    '{':    "LEFT_CURLY",
    '}':    "RIGHT_CURLY",
    '(':    "LEFT_PAREN",
    ')':    "RIGHT_PAREN"
};

// Hash of keyword identifier to tokens index.  NB: we must null __proto__ to
// avoid toString, etc. namespace pollution.
var keywords = {__proto__: null};

// Define const END, etc., based on the token names.  Also map name to index.

// Let's also put them in a nodeTypes object. -- Adam
for (var i = 0, j = tokens.length; i < j; i++) {
    var consts = "const ";
    var t = tokens[i];
    var name;
    if (/^[a-z]/.test(t)) {
        name = t.toUpperCase();
        keywords[t] = i;
    } else {
        name = (/^\W/.test(t) ? opTypeNames[t] : t);
    }
    consts += name + " = nodeTypes." + name + " = "+ i;
    tokens[t] = i;
    eval(consts + ";");
}

// Map assignment operators to their indexes in the tokens array.
var assignOps = ['|', '^', '&', '<<', '>>', '>>>', '+', '-', '*', '/', '%'];

for (i = 0, j = assignOps.length; i < j; i++) {
    t = assignOps[i];
    assignOps[t] = tokens[t];
}












/* vim: set sw=4 ts=8 et tw=78: */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is the Narcissus JavaScript engine.
 *
 * The Initial Developer of the Original Code is
 * Brendan Eich <brendan@mozilla.org>.
 * Portions created by the Initial Developer are Copyright (C) 2004
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

/*
 * Narcissus - JS implemented in JS.
 *
 * Lexical scanner and parser.
 */

// Build a regexp that recognizes operators and punctuators (except newline).
var opRegExpSrc = "^";
for (i in opTypeNames) {
    if (i == '\n')
        continue;
    if (opRegExpSrc != "^")
        opRegExpSrc += "|^";
    opRegExpSrc += i.replace(/[?|^&(){}\[\]+\-*\/\.]/g, "\\$&");
}
var opRegExp = new RegExp(opRegExpSrc);

// A regexp to match floating point literals (but not integer literals).
var fpRegExp = /^\d+\.\d*(?:[eE][-+]?\d+)?|^\d+(?:\.\d*)?[eE][-+]?\d+|^\.\d+(?:[eE][-+]?\d+)?/;

// A regexp to match regexp literals.
var reRegExp = /^\/((?:\\.|\[(?:\\.|[^\]])*\]|[^\/])+)\/([gimy]*)/;

function Tokenizer(s, f, l) {
    this.cursor = 0;
    this.source = String(s);
    this.tokens = [];
    this.tokenIndex = 0;
    this.lookahead = 0;
    this.scanNewlines = false;
    this.scanOperand = true;
    this.filename = f || "";
    this.lineno = l || 1;
}

Tokenizer.prototype = {
    get input() {
        return this.source.substring(this.cursor);
    },

    get done() {
        return this.peek() == END;
    },

    get token() {
        return this.tokens[this.tokenIndex];
    },

    match: function (tt) {
        return this.get() == tt || this.unget();
    },

    mustMatch: function (tt) {
        if (!this.match(tt))
            throw this.newSyntaxError("Missing " + tokens[tt].toLowerCase());
        return this.token;
    },

    peek: function () {
        var tt, next;
        if (this.lookahead) {
            next = this.tokens[(this.tokenIndex + this.lookahead) & 3];
            if (this.scanNewlines && next.lineno != this.lineno)
                tt = NEWLINE;
            else
                tt = next.type;
        } else {
            tt = this.get();
            this.unget();
        }
        return tt;
    },

    peekOnSameLine: function () {
        this.scanNewlines = true;
        var tt = this.peek();
        this.scanNewlines = false;
        return tt;
    },

    get: function () {
        var token;
        while (this.lookahead) {
            --this.lookahead;
            this.tokenIndex = (this.tokenIndex + 1) & 3;
            token = this.tokens[this.tokenIndex];
            if (token.type != NEWLINE || this.scanNewlines)
                return token.type;
        }

        for (;;) {
            var input = this.input;
            var match = (this.scanNewlines ? /^[ \t]+/ : /^\s+/)(input);
            if (match) {
                var spaces = match[0];
                this.cursor += spaces.length;
                var newlines = spaces.match(/\n/g);
                if (newlines)
                    this.lineno += newlines.length;
                input = this.input;
            }

            if (!(match = /^\/(?:\*(?:.|\n)*?\*\/|\/.*)/(input)))
                break;
            var comment = match[0];
            this.cursor += comment.length;
            newlines = comment.match(/\n/g);
            if (newlines)
                this.lineno += newlines.length
        }

        this.tokenIndex = (this.tokenIndex + 1) & 3;
        token = this.tokens[this.tokenIndex];
        if (!token)
            this.tokens[this.tokenIndex] = token = {};

        if (!input)
            return token.type = END;

        if ((match = fpRegExp(input))) {
            token.type = NUMBER;
            token.value = parseFloat(match[0]);
        } else if ((match = /^0[xX][\da-fA-F]+|^0[0-7]*|^\d+/(input))) {
            token.type = NUMBER;
            token.value = parseInt(match[0]);
        } else if ((match = /^[$_\w]+/(input))) {       // FIXME no ES3 unicode
            var id = match[0];
            token.type = keywords[id] || IDENTIFIER;
            token.value = id;
        } else if ((match = /^"(?:\\.|[^"])*"|^'(?:\\.|[^'])*'/(input))) { //"){
            token.type = STRING;
            token.value = eval(match[0]);
        } else if (this.scanOperand && (match = reRegExp(input))) {
            token.type = REGEXP;
            token.value = new RegExp(match[1], match[2]);
        } else if ((match = opRegExp(input))) {
            var op = match[0];
            if (assignOps[op] && input[op.length] == '=') {
                token.type = ASSIGN;
                token.assignOp = nodeTypes[opTypeNames[op]];
                match[0] += '=';
            } else {
                token.type = nodeTypes[opTypeNames[op]];
                if (this.scanOperand &&
                    (token.type == PLUS || token.type == MINUS)) {
                    token.type += UNARY_PLUS - PLUS;
                }
                token.assignOp = null;
            }
            token.value = op;
        } else if (this.scanNewlines && (match = /^\n/(input))) {
            token.type = NEWLINE;
        } else {
            throw this.newSyntaxError("Illegal token");
        }

        token.start = this.cursor;
        this.cursor += match[0].length;
        token.end = this.cursor;
        token.lineno = this.lineno;
        return token.type;
    },

    unget: function () {
        if (++this.lookahead == 4) throw "PANIC: too much lookahead!";
        this.tokenIndex = (this.tokenIndex - 1) & 3;
    },

    newSyntaxError: function (m) {
        var e = new SyntaxError(m, this.filename, this.lineno);
        e.source = this.source;
        e.cursor = this.cursor;
        return e;
    }
};

function CompilerContext(inFunction) {
    this.inFunction = inFunction;
    this.stmtStack = [];
    this.funDecls = [];
    this.varDecls = [];
}

var CCp = CompilerContext.prototype;
CCp.bracketLevel = CCp.curlyLevel = CCp.parenLevel = CCp.hookLevel = 0;
CCp.ecmaStrictMode = CCp.inForLoopInit = false;

function Script(t, x) {
    var n = Statements(t, x);
    n.type = SCRIPT;
    n.funDecls = x.funDecls;
    n.varDecls = x.varDecls;
    return n;
}

// Node extends Array, which we extend slightly with a top-of-stack method.
// aaa I'm confused, changed this to be a function rather than a getter,
// since that's what the code seems to expect. -- Adam
Array.prototype.top = function () {
    return this.length && this[this.length-1];
};

function Node(t, type) {
    var token = t.token;
    if (token) {
        this.type = type || token.type;
        this.value = token.value;
        this.lineno = token.lineno;
        this.start = token.start;
        this.end = token.end;
    } else {
        this.type = type;
        this.lineno = t.lineno;
    }
    this.tokenizer = t;

    for (var i = 2; i < arguments.length; i++)
        this.push(arguments[i]);
}

var Np = Node.prototype = new Array;
Np.constructor = Node;
Np.toSource = Object.prototype.toSource;

// Always use push to add operands to an expression, to update start and end.
Np.push = function (kid) {
    if (kid.start < this.start)
        this.start = kid.start;
    if (this.end < kid.end)
        this.end = kid.end;
    return Array.prototype.push.call(this, kid);
}

Node.indentLevel = 0;

function tokenstr(tt) {
    var t = tokens[tt];
    return /^\W/.test(t) ? opTypeNames[t] : t.toUpperCase();
}

Np.toString = function () {
    var a = [];
    for (var i in this) {
        if (this.hasOwnProperty(i) && i != 'type' && i != 'target')
            a.push({id: i, value: this[i]});
    }
    a.sort(function (a,b) { return (a.id < b.id) ? -1 : 1; });
    const INDENTATION = "    ";
    var n = ++Node.indentLevel;
    var s = "{\n" + INDENTATION.repeat(n) + "type: " + tokenstr(this.type);
    for (i = 0; i < a.length; i++)
        s += ",\n" + INDENTATION.repeat(n) + a[i].id + ": " + a[i].value;
    n = --Node.indentLevel;
    s += "\n" + INDENTATION.repeat(n) + "}";
    return s;
}

Np.getSource = function () {
    return this.tokenizer.source.slice(this.start, this.end);
};

Np.__defineGetter__('filename',
                    function () { return this.tokenizer.filename; });

String.prototype.__defineGetter__(
    'repeat',
    function (n) {
        var s = "", t = this + s;
        while (--n >= 0)
            s += t;
        return s;
    } //, aaa I wonder what this stuff does
    //false, false, true
);

// Statement stack and nested statement handler.
function nest(t, x, node, func, end) {
    x.stmtStack.push(node);
    var n = func(t, x);
    x.stmtStack.pop();
    end && t.mustMatch(end);
    return n;
}

function Statements(t, x) {
    var n = new Node(t, BLOCK);
    x.stmtStack.push(n);
    while (!t.done && t.peek() != RIGHT_CURLY)
        n.push(Statement(t, x));
    x.stmtStack.pop();
    return n;
}

function Block(t, x) {
    t.mustMatch(LEFT_CURLY);
    var n = Statements(t, x);
    t.mustMatch(RIGHT_CURLY);
    return n;
}

const functionForms = {DECLARED_FORM: 0, EXPRESSED_FORM: 1, STATEMENT_FORM: 2};

function Statement(t, x) {
    var i, label, n, n2, ss, tt = t.get();

    // Cases for statements ending in a right curly return early, avoiding the
    // common semicolon insertion magic after this switch.
    switch (tt) {
      case FUNCTION:
        return FunctionDefinition(t, x, true,
                                  (x.stmtStack.length > 1)
                                  ? functionForms.STATEMENT_FORM
                                  : functionForms.DECLARED_FORM);

      case LEFT_CURLY:
        n = Statements(t, x);
        t.mustMatch(RIGHT_CURLY);
        return n;

      case IF:
        n = new Node(t);
        n.condition = ParenExpression(t, x);
        x.stmtStack.push(n);
        n.thenPart = Statement(t, x);
        n.elsePart = t.match(ELSE) ? Statement(t, x) : null;
        x.stmtStack.pop();
        return n;

      case SWITCH:
        n = new Node(t);
        t.mustMatch(LEFT_PAREN);
        n.discriminant = Expression(t, x);
        t.mustMatch(RIGHT_PAREN);
        n.cases = [];
        n.defaultIndex = -1;
        x.stmtStack.push(n);
        t.mustMatch(LEFT_CURLY);
        while ((tt = t.get()) != RIGHT_CURLY) {
            switch (tt) {
              case DEFAULT:
                if (n.defaultIndex >= 0)
                    throw t.newSyntaxError("More than one switch default");
                // FALL THROUGH
              case CASE:
                n2 = new Node(t);
                if (tt == DEFAULT)
                    n.defaultIndex = n.cases.length;
                else
                    n2.caseLabel = Expression(t, x, COLON);
                break;
              default:
                throw t.newSyntaxError("Invalid switch case");
            }
            t.mustMatch(COLON);
            n2.statements = new Node(t, BLOCK);
            while ((tt=t.peek()) != CASE && tt != DEFAULT && tt != RIGHT_CURLY)
                n2.statements.push(Statement(t, x));
            n.cases.push(n2);
        }
        x.stmtStack.pop();
        return n;

      case FOR:
        n = new Node(t);
        n.isLoop = true;
        t.mustMatch(LEFT_PAREN);
        if ((tt = t.peek()) != SEMICOLON) {
            x.inForLoopInit = true;
            if (tt == VAR || tt == CONST) {
                t.get();
                n2 = Variables(t, x);
            } else {
                n2 = Expression(t, x);
            }
            x.inForLoopInit = false;
        }
        if (n2 && t.match(IN)) {
            n.type = FOR_IN;
            if (n2.type == VAR) {
                if (n2.length != 1) {
                    throw new SyntaxError("Invalid for..in left-hand side",
                                          t.filename, n2.lineno);
                }

                // NB: n2[0].type == IDENTIFIER and n2[0].value == n2[0].name.
                n.iterator = n2[0];
                n.varDecl = n2;
            } else {
                n.iterator = n2;
                n.varDecl = null;
            }
            n.object = Expression(t, x);
        } else {
            n.setup = n2 || null;
            t.mustMatch(SEMICOLON);
            n.condition = (t.peek() == SEMICOLON) ? null : Expression(t, x);
            t.mustMatch(SEMICOLON);
            n.update = (t.peek() == RIGHT_PAREN) ? null : Expression(t, x);
        }
        t.mustMatch(RIGHT_PAREN);
        n.body = nest(t, x, n, Statement);
        return n;

      case WHILE:
        n = new Node(t);
        n.isLoop = true;
        n.condition = ParenExpression(t, x);
        n.body = nest(t, x, n, Statement);
        return n;

      case DO:
        n = new Node(t);
        n.isLoop = true;
        n.body = nest(t, x, n, Statement, WHILE);
        n.condition = ParenExpression(t, x);
        if (!x.ecmaStrictMode) {
            // <script language="JavaScript"> (without version hints) may need
            // automatic semicolon insertion without a newline after do-while.
            // See http://bugzilla.mozilla.org/show_bug.cgi?id=238945.
            t.match(SEMICOLON);
            return n;
        }
        break;

      case BREAK:
      case CONTINUE:
        n = new Node(t);
        if (t.peekOnSameLine() == IDENTIFIER) {
            t.get();
            n.label = t.token.value;
        }
        ss = x.stmtStack;
        i = ss.length;
        label = n.label;
        if (label) {
            do {
                if (--i < 0)
                    throw t.newSyntaxError("Label not found");
            } while (ss[i].label != label);
        } else {
            do {
                if (--i < 0) {
                    throw t.newSyntaxError("Invalid " + ((tt == BREAK)
                                                         ? "break"
                                                         : "continue"));
                }
            } while (!ss[i].isLoop && (tt != BREAK || ss[i].type != SWITCH));
        }
        n.target = ss[i];
        break;

      case TRY:
        n = new Node(t);
        n.tryBlock = Block(t, x);
        n.catchClauses = [];
        while (t.match(CATCH)) {
            n2 = new Node(t);
            t.mustMatch(LEFT_PAREN);
            n2.varName = t.mustMatch(IDENTIFIER).value;
            if (t.match(IF)) {
                if (x.ecmaStrictMode)
                    throw t.newSyntaxError("Illegal catch guard");
                if (n.catchClauses.length && !n.catchClauses.top().guard)
                    throw t.newSyntaxError("Guarded catch after unguarded");
                n2.guard = Expression(t, x);
            } else {
                n2.guard = null;
            }
            t.mustMatch(RIGHT_PAREN);
            n2.block = Block(t, x);
            n.catchClauses.push(n2);
        }
        if (t.match(FINALLY))
            n.finallyBlock = Block(t, x);
        if (!n.catchClauses.length && !n.finallyBlock)
            throw t.newSyntaxError("Invalid try statement");
        return n;

      case CATCH:
      case FINALLY:
        throw t.newSyntaxError(tokens[tt] + " without preceding try");

      case THROW:
        n = new Node(t);
        n.exception = Expression(t, x);
        break;

      case RETURN:
        if (!x.inFunction)
            throw t.newSyntaxError("Invalid return");
        n = new Node(t);
        tt = t.peekOnSameLine();
        if (tt != END && tt != NEWLINE && tt != SEMICOLON && tt != RIGHT_CURLY)
            n.value = Expression(t, x);
        break;

      case WITH:
        n = new Node(t);
        n.object = ParenExpression(t, x);
        n.body = nest(t, x, n, Statement);
        return n;

      case VAR:
      case CONST:
        n = Variables(t, x);
        break;

      case DEBUGGER:
        n = new Node(t);
        break;

      case NEWLINE:
      case SEMICOLON:
        n = new Node(t, SEMICOLON);
        n.expression = null;
        return n;

      default:
        if (tt == IDENTIFIER) {
            t.scanOperand = false;
            tt = t.peek();
            t.scanOperand = true;
            if (tt == COLON) {
                label = t.token.value;
                ss = x.stmtStack;
                for (i = ss.length-1; i >= 0; --i) {
                    if (ss[i].label == label)
                        throw t.newSyntaxError("Duplicate label");
                }
                t.get();
                n = new Node(t, LABEL);
                n.label = label;
                n.statement = nest(t, x, n, Statement);
                return n;
            }
        }

        n = new Node(t, SEMICOLON);
        t.unget();
        n.expression = Expression(t, x);
        n.end = n.expression.end;
        break;
    }

    if (t.lineno == t.token.lineno) {
        tt = t.peekOnSameLine();
        if (tt != END && tt != NEWLINE && tt != SEMICOLON && tt != RIGHT_CURLY)
            throw t.newSyntaxError("Missing ; before statement");
    }
    t.match(SEMICOLON);
    return n;
}

function FunctionDefinition(t, x, requireName, functionForm) {
    var f = new Node(t);
    if (f.type != FUNCTION)
        f.type = (f.value == "get") ? GETTER : SETTER;
    if (t.match(IDENTIFIER))
        f.name = t.token.value;
    else if (requireName)
        throw t.newSyntaxError("Missing function identifier");

    t.mustMatch(LEFT_PAREN);
    f.params = [];
    var tt;
    while ((tt = t.get()) != RIGHT_PAREN) {
        if (tt != IDENTIFIER)
            throw t.newSyntaxError("Missing formal parameter");
        f.params.push(t.token.value);
        if (t.peek() != RIGHT_PAREN)
            t.mustMatch(COMMA);
    }

    t.mustMatch(LEFT_CURLY);
    var x2 = new CompilerContext(true);
    f.body = Script(t, x2);
    t.mustMatch(RIGHT_CURLY);
    f.end = t.token.end;

    f.functionForm = functionForm;
    if (functionForm == functionForms.DECLARED_FORM)
        x.funDecls.push(f);
    return f;
}

function Variables(t, x) {
    var n = new Node(t);
    do {
        t.mustMatch(IDENTIFIER);
        var n2 = new Node(t);
        n2.name = n2.value;
        if (t.match(ASSIGN)) {
            if (t.token.assignOp)
                throw t.newSyntaxError("Invalid variable initialization");
            n2.initializer = Expression(t, x, COMMA);
        }
        n2.readOnly = (n.type == CONST);
        n.push(n2);
        x.varDecls.push(n2);
    } while (t.match(COMMA));
    return n;
}

function ParenExpression(t, x) {
    t.mustMatch(LEFT_PAREN);
    var n = Expression(t, x);
    t.mustMatch(RIGHT_PAREN);
    return n;
}

var opPrecedence = {
    SEMICOLON: 0,
    COMMA: 1,
    ASSIGN: 2, HOOK: 2, COLON: 2,
    // The above all have to have the same precedence, see bug 330975.
    OR: 4,
    AND: 5,
    BITWISE_OR: 6,
    BITWISE_XOR: 7,
    BITWISE_AND: 8,
    EQ: 9, NE: 9, STRICT_EQ: 9, STRICT_NE: 9,
    LT: 10, LE: 10, GE: 10, GT: 10, IN: 10, INSTANCEOF: 10,
    LSH: 11, RSH: 11, URSH: 11,
    PLUS: 12, MINUS: 12,
    MUL: 13, DIV: 13, MOD: 13,
    DELETE: 14, VOID: 14, TYPEOF: 14, // PRE_INCREMENT: 14, PRE_DECREMENT: 14,
    NOT: 14, BITWISE_NOT: 14, UNARY_PLUS: 14, UNARY_MINUS: 14,
    INCREMENT: 15, DECREMENT: 15,     // postfix
    NEW: 16,
    DOT: 17
};

// Map operator type code to precedence.
for (i in opPrecedence)
    opPrecedence[nodeTypes[i]] = opPrecedence[i];

var opArity = {
    COMMA: -2,
    ASSIGN: 2,
    HOOK: 3,
    OR: 2,
    AND: 2,
    BITWISE_OR: 2,
    BITWISE_XOR: 2,
    BITWISE_AND: 2,
    EQ: 2, NE: 2, STRICT_EQ: 2, STRICT_NE: 2,
    LT: 2, LE: 2, GE: 2, GT: 2, IN: 2, INSTANCEOF: 2,
    LSH: 2, RSH: 2, URSH: 2,
    PLUS: 2, MINUS: 2,
    MUL: 2, DIV: 2, MOD: 2,
    DELETE: 1, VOID: 1, TYPEOF: 1,  // PRE_INCREMENT: 1, PRE_DECREMENT: 1,
    NOT: 1, BITWISE_NOT: 1, UNARY_PLUS: 1, UNARY_MINUS: 1,
    INCREMENT: 1, DECREMENT: 1,     // postfix
    NEW: 1, NEW_WITH_ARGS: 2, DOT: 2, INDEX: 2, CALL: 2,
    ARRAY_INIT: 1, OBJECT_INIT: 1, GROUP: 1
};

// Map operator type code to arity.
for (i in opArity)
    opArity[nodeTypes[i]] = opArity[i];

function Expression(t, x, stop) {
    var n, id, tt, operators = [], operands = [];
    var bl = x.bracketLevel, cl = x.curlyLevel, pl = x.parenLevel,
        hl = x.hookLevel;

    function reduce() {
        var n = operators.pop();
        var op = n.type;
        var arity = opArity[op];
        if (arity == -2) {
            // Flatten left-associative trees.
            var left = operands.length >= 2 && operands[operands.length-2];
            if (left.type == op) {
                var right = operands.pop();
                left.push(right);
                return left;
            }
            arity = 2;
        }

        // Always use push to add operands to n, to update start and end.
        var a = operands.splice(operands.length - arity);
        for (var i = 0; i < arity; i++)
            n.push(a[i]);

        // Include closing bracket or postfix operator in [start,end).
        if (n.end < t.token.end)
            n.end = t.token.end;

        operands.push(n);
        return n;
    }

loop:
    while ((tt = t.get()) != END) {
        if (tt == stop &&
            x.bracketLevel == bl && x.curlyLevel == cl && x.parenLevel == pl &&
            x.hookLevel == hl) {
            // Stop only if tt matches the optional stop parameter, and that
            // token is not quoted by some kind of bracket.
            break;
        }
        switch (tt) {
          case SEMICOLON:
            // NB: cannot be empty, Statement handled that.
            break loop;

          case ASSIGN:
          case HOOK:
          case COLON:
            if (t.scanOperand)
                break loop;
            // Use >, not >=, for right-associative ASSIGN and HOOK/COLON.
            while (opPrecedence[operators.top().type] > opPrecedence[tt] ||
                   (tt == COLON && operators.top().type == ASSIGN)) {
                reduce();
            }
            if (tt == COLON) {
                n = operators.top();
                if (n.type != HOOK)
                    throw t.newSyntaxError("Invalid label");
                --x.hookLevel;
            } else {
                operators.push(new Node(t));
                if (tt == ASSIGN)
                    operands.top().assignOp = t.token.assignOp;
                else
                    ++x.hookLevel;      // tt == HOOK
            }
            t.scanOperand = true;
            break;

          case IN:
            // An in operator should not be parsed if we're parsing the head of
            // a for (...) loop, unless it is in the then part of a conditional
            // expression, or parenthesized somehow.
            if (x.inForLoopInit && !x.hookLevel &&
                !x.bracketLevel && !x.curlyLevel && !x.parenLevel) {
                break loop;
            }
            // FALL THROUGH
          case COMMA:
            // Treat comma as left-associative so reduce can fold left-heavy
            // COMMA trees into a single array.
            // FALL THROUGH
          case OR:
          case AND:
          case BITWISE_OR:
          case BITWISE_XOR:
          case BITWISE_AND:
          case EQ: case NE: case STRICT_EQ: case STRICT_NE:
          case LT: case LE: case GE: case GT:
          case INSTANCEOF:
          case LSH: case RSH: case URSH:
          case PLUS: case MINUS:
          case MUL: case DIV: case MOD:
          case DOT:
            if (t.scanOperand)
                break loop;
            while (opPrecedence[operators.top().type] >= opPrecedence[tt])
                reduce();
            if (tt == DOT) {
                t.mustMatch(IDENTIFIER);
                operands.push(new Node(t, DOT, operands.pop(), new Node(t)));
            } else {
                operators.push(new Node(t));
                t.scanOperand = true;
            }
            break;

          case DELETE: case VOID: case TYPEOF:
          case NOT: case BITWISE_NOT: case UNARY_PLUS: case UNARY_MINUS:
          case NEW:
            if (!t.scanOperand)
                break loop;
            operators.push(new Node(t));
            break;

          case INCREMENT: case DECREMENT:
            if (t.scanOperand) {
                operators.push(new Node(t));  // prefix increment or decrement
            } else {
                // Don't cross a line boundary for postfix {in,de}crement.
                if (t.tokens[(t.tokenIndex + t.lookahead - 1) & 3].lineno !=
                    t.lineno) {
                    break loop;
                }

                // Use >, not >=, so postfix has higher precedence than prefix.
                while (opPrecedence[operators.top().type] > opPrecedence[tt])
                    reduce();
                n = new Node(t, tt, operands.pop());
                n.postfix = true;
                operands.push(n);
            }
            break;

          case FUNCTION:
            if (!t.scanOperand)
                break loop;
            operands.push(FunctionDefinition(t, x, false, functionForms.EXPRESSED_FORM));
            t.scanOperand = false;
            break;

          case NULL: case THIS: case TRUE: case FALSE:
          case IDENTIFIER: case NUMBER: case STRING: case REGEXP:
            if (!t.scanOperand)
                break loop;
            operands.push(new Node(t));
            t.scanOperand = false;
            break;

          case LEFT_BRACKET:
            if (t.scanOperand) {
                // Array initialiser.  Parse using recursive descent, as the
                // sub-grammar here is not an operator grammar.
                n = new Node(t, ARRAY_INIT);
                while ((tt = t.peek()) != RIGHT_BRACKET) {
                    if (tt == COMMA) {
                        t.get();
                        n.push(null);
                        continue;
                    }
                    n.push(Expression(t, x, COMMA));
                    if (!t.match(COMMA))
                        break;
                }
                t.mustMatch(RIGHT_BRACKET);
                operands.push(n);
                t.scanOperand = false;
            } else {
                // Property indexing operator.
                operators.push(new Node(t, INDEX));
                t.scanOperand = true;
                ++x.bracketLevel;
            }
            break;

          case RIGHT_BRACKET:
            if (t.scanOperand || x.bracketLevel == bl)
                break loop;
            while (reduce().type != INDEX)
                continue;
            --x.bracketLevel;
            break;

          case LEFT_CURLY:
            if (!t.scanOperand)
                break loop;
            // Object initialiser.  As for array initialisers (see above),
            // parse using recursive descent.
            ++x.curlyLevel;
            n = new Node(t, OBJECT_INIT);
          object_init:
            if (!t.match(RIGHT_CURLY)) {
                do {
                    tt = t.get();
                    if ((t.token.value == "get" || t.token.value == "set") &&
                        t.peek() == IDENTIFIER) {
                        if (x.ecmaStrictMode)
                            throw t.newSyntaxError("Illegal property accessor");
                        n.push(FunctionDefinition(t, x, true, functionForms.EXPRESSED_FORM));
                    } else {
                        switch (tt) {
                          case IDENTIFIER:
                          case NUMBER:
                          case STRING:
                            id = new Node(t);
                            break;
                          case RIGHT_CURLY:
                            if (x.ecmaStrictMode)
                                throw t.newSyntaxError("Illegal trailing ,");
                            break object_init;
                          default:
                            throw t.newSyntaxError("Invalid property name");
                        }
                        t.mustMatch(COLON);
                        n.push(new Node(t, PROPERTY_INIT, id,
                                        Expression(t, x, COMMA)));
                    }
                } while (t.match(COMMA));
                t.mustMatch(RIGHT_CURLY);
            }
            operands.push(n);
            t.scanOperand = false;
            --x.curlyLevel;
            break;

          case RIGHT_CURLY:
            if (!t.scanOperand && x.curlyLevel != cl)
                throw "PANIC: right curly botch";
            break loop;

          case LEFT_PAREN:
            if (t.scanOperand) {
                operators.push(new Node(t, GROUP));
            } else {
                while (opPrecedence[operators.top().type] > opPrecedence[NEW])
                    reduce();

                // Handle () now, to regularize the n-ary case for n > 0.
                // We must set scanOperand in case there are arguments and
                // the first one is a regexp or unary+/-.
                n = operators.top();
                t.scanOperand = true;
                if (t.match(RIGHT_PAREN)) {
                    if (n.type == NEW) {
                        --operators.length;
                        n.push(operands.pop());
                    } else {
                        n = new Node(t, CALL, operands.pop(),
                                     new Node(t, LIST));
                    }
                    operands.push(n);
                    t.scanOperand = false;
                    break;
                }
                if (n.type == NEW)
                    n.type = NEW_WITH_ARGS;
                else
                    operators.push(new Node(t, CALL));
            }
            ++x.parenLevel;
            break;

          case RIGHT_PAREN:
            if (t.scanOperand || x.parenLevel == pl)
                break loop;
            while ((tt = reduce().type) != GROUP && tt != CALL &&
                   tt != NEW_WITH_ARGS) {
                continue;
            }
            if (tt != GROUP) {
                n = operands.top();
                if (n[1].type != COMMA)
                    n[1] = new Node(t, LIST, n[1]);
                else
                    n[1].type = LIST;
            }
            --x.parenLevel;
            break;

          // Automatic semicolon insertion means we may scan across a newline
          // and into the beginning of another statement.  If so, break out of
          // the while loop and let the t.scanOperand logic handle errors.
          default:
            break loop;
        }
    }

    if (x.hookLevel != hl)
        throw t.newSyntaxError("Missing : after ?");
    if (x.parenLevel != pl)
        throw t.newSyntaxError("Missing ) in parenthetical");
    if (x.bracketLevel != bl)
        throw t.newSyntaxError("Missing ] in index expression");
    if (t.scanOperand)
        throw t.newSyntaxError("Missing operand");

    // Resume default mode, scanning for operands, not operators.
    t.scanOperand = true;
    t.unget();
    while (operators.length)
        reduce();
    return operands.pop();
}

function parse(s, f, l) {
    var t = new Tokenizer(s, f, l);
    var x = new CompilerContext(false);
    var n = Script(t, x);
    if (!t.done)
        throw t.newSyntaxError("Syntax error");
    return n;
}

// Here's the stuff that needs to be visible to the outside. -- Adam
window.jsParse = {
  parse: parse,
  tokens: tokens,
  functionForms: functionForms,
  nodeTypes: nodeTypes
};
avocado.annotator.annotationOf(window).setSlotAnnotation('jsParse', {initializeTo: ['null']}); // so it doesn't show up as an unowned slot

})();
avocado.transporter.module.onLoadCallbacks["narcissus/jsparse"] = 'done';

avocado.transporter.module.onLoadCallbacks["programming_environment/pretty_printer"] = function() {};
avocado.transporter.module.create('programming_environment/pretty_printer', function(requires) {

requires('narcissus/jsparse');
requires('core/testFramework');
requires('reflection/mirror');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('prettyPrinter', {}, {category: ['manipulating code'], comment: 'Not usable yet. Just an experiment I was trying. -- Adam'});

});


thisModule.addSlots(avocado.prettyPrinter, function(add) {

  add.method('create', function (node, options) {
    return Object.newChildOf(this, node, options);
  }, {category: ['creating']});

  add.method('initialize', function (node, options) {
    this._rootNode = node;
    this._buffer = avocado.stringBuffer.create();
    this._indentationLevel = options.indentationLevel || 0;
    this._spacesPerIndent = 2;
    this.prettyPrint(node);
  }, {category: ['creating']});

  add.creator('tests', Object.create(avocado.testCase), {category: ['tests']});

  add.method('result', function () {
    return this._buffer.toString();
  }, {category: ['accessing']});

  add.method('prettyPrint', function (node) {
    var i;
    // console.log("prettyPrint encountered node type: " + tokens[node.type]);
    
    var nodeTypes = jsParse.nodeTypes; // aaa get them out of the global namespace
    
    switch(node.type) {
    case nodeTypes.SCRIPT:
      for (i = 0; i < node.length; ++i) {
        if (i > 0) { this.newLine(); }
        this.prettyPrint(node[i]);
      }
      break;
    case nodeTypes.BLOCK:
      this._buffer.append("{");
      if (node.length === 0) {
      } else if (node.length === 1) {
        this._buffer.append(" ");
        this.prettyPrint(node[0]);
        this._buffer.append(" ");
      } else {
        this.indent();
        this.newLine();
        for (i = 0; i < node.length; ++i) {
          this.prettyPrint(node[i]);
          if (i === node.length - 1) { this.unindent(); }
          this.newLine();
        }
      }
      this._buffer.append("}");
      break;
    case nodeTypes.VAR:
      this._buffer.append("var ");
      for (i = 0; i < node.length; ++i) {
        if (i > 0) { this._buffer.append(", "); }
        this.prettyPrint(node[i]);
      }
      this._buffer.append(";");
      break;
    case nodeTypes.SEMICOLON:
      this.prettyPrint(node.expression);
      this._buffer.append(";");
      break;
    case nodeTypes.IDENTIFIER:
      this._buffer.append(node.value);
      if (node.initializer) {
        this._buffer.append(" = ");
        this.prettyPrint(node.initializer);
      }
      break;
    case nodeTypes.THIS:
    case nodeTypes.NULL:
    //case nodeTypes.UNDEFINED:
    case nodeTypes.TRUE:
    case nodeTypes.FALSE:
    case nodeTypes.NUMBER:
    case nodeTypes.REGEXP:
      this._buffer.append(node.value);
      break;
    case nodeTypes.STRING:
      var rightKindOfQuote = node.tokenizer.source[node.start];
      this._buffer.append(rightKindOfQuote).append(node.value).append(rightKindOfQuote);
      break;
    case nodeTypes.OBJECT_INIT:
      this._buffer.append("{");
      for (i = 0; i < node.length; ++i) {
        if (i > 0) { this._buffer.append(", "); }
        this.prettyPrint(node[i]);
      }
      this._buffer.append("}");
      break;
    case nodeTypes.PROPERTY_INIT:
      this.prettyPrint(node[0]);
      this._buffer.append(": ");
      this.prettyPrint(node[1]);
      break;
    case nodeTypes.ARRAY_INIT:
      this._buffer.append("[");
      for (i = 0; i < node.length; ++i) {
        if (i > 0) { this._buffer.append(", "); }
        this.prettyPrint(node[i]);
      }
      this._buffer.append("]");
      break;
    case nodeTypes.ASSIGN:
      this.prettyPrint(node[0]);
      this._buffer.append(" = ");
      this.prettyPrint(node[1]);
      break;
    case nodeTypes.GROUP:
      if (node.value !== '(') { throw new Error("Unknown type of group: not open-paren"); }
      this._buffer.append("(");
      if (node.length !== 1) { throw new Error("Unknown type of group: not just one member"); }
      this.prettyPrint(node[0]);
      this._buffer.append(")");
      break;
    case nodeTypes.CALL:
      this.prettyPrint(node[0]);
      this._buffer.append("(");
      this.prettyPrint(node[1]);
      this._buffer.append(")");
      break;
    case nodeTypes.DELETE:
      this._buffer.append("delete ");
      this.prettyPrint(node[0]);
      break;
    case nodeTypes.BREAK:
      this._buffer.append("break;");
      break;
    case nodeTypes.NEW:
      this._buffer.append("new ");
      this.prettyPrint(node[0]);
      break;
    case nodeTypes.NEW_WITH_ARGS:
      this._buffer.append("new ");
      this.prettyPrint(node[0]);
      this._buffer.append("(");
      this.prettyPrint(node[1]);
      this._buffer.append(")");
      break;
    case nodeTypes.DOT:
      this.prettyPrint(node[0]);
      this._buffer.append(".");
      this.prettyPrint(node[1]);
      break;
    case nodeTypes.LIST:
      for (i = 0; i < node.length; ++i) {
        if (i > 0) { this._buffer.append(", "); }
        this.prettyPrint(node[i]);
      }
      break;
    case nodeTypes.INDEX:
      this.prettyPrint(node[0]);
      this._buffer.append("[");
      this.prettyPrint(node[1]);
      this._buffer.append("]");
      break;
    case nodeTypes.FUNCTION:
      if (node.functionForm === jsParse.functionForms.EXPRESSED_FORM || node.functionForm === jsParse.functionForms.DECLARED_FORM) {
        this._buffer.append("function ");
        if (node.name) { this._buffer.append(node.name); }
        this._buffer.append("(");
        for (i = 0; i < node.params.length; ++i) {
          if (i > 0) { this._buffer.append(", "); }
          this._buffer.append(node.params[i]);
        }
        this._buffer.append(") {");
        switch (node.body.length) {
        case 0:
          this.prettyPrint(node.body);
          break;
        case 1:
          this._buffer.append(" ");
          this.prettyPrint(node.body);
          this._buffer.append(" ");
          break;
        default:
          this.indentDuring(function() {
            this.newLine();
            this.prettyPrint(node.body);
          }.bind(this));
          this.newLine();
        }
        this._buffer.append("}");
        break;
      }
      avocado.ui.grab(reflect(node));
      throw new Error("prettyPrinter encountered unknown FUNCTION type: " + node.functionForm);
    case nodeTypes.IF:
      this._buffer.append("if (");
      this.prettyPrint(node.condition);
      this._buffer.append(") ");
      this.prettyPrint(node.thenPart);
      if (node.elsePart) {
        this._buffer.append(" else ");
        this.prettyPrint(node.elsePart);
      }
      break;
    case nodeTypes.FOR:
      this._buffer.append("for (");
      this.prettyPrint(node.setup);
      // hack - sometimes the setup is an expression, sometimes it's a var statement; is there a clean way to do this? -- Adam
      if (node.setup.type !== nodeTypes.VAR) { this._buffer.append(";"); }
      this._buffer.append(" ");
      this.prettyPrint(node.condition);
      this._buffer.append("; ");
      this.prettyPrint(node.update);
      this._buffer.append(") ");
      this.prettyPrint(node.body);
      break;
    case nodeTypes.WHILE:
      this._buffer.append("while (");
      this.prettyPrint(node.condition);
      this._buffer.append(") ");
      this.prettyPrint(node.body);
      break;
    case nodeTypes.DO:
      this._buffer.append("do ");
      this.prettyPrint(node.body);
      this._buffer.append(" while (");
      this.prettyPrint(node.condition);
      this._buffer.append(");");
      break;
    case nodeTypes.FOR_IN:
      this._buffer.append("for (");
      if (node.varDecl) { this._buffer.append("var "); }
      this.prettyPrint(node.iterator);
      this._buffer.append(" in ");
      this.prettyPrint(node.object);
      this._buffer.append(") ");
      this.prettyPrint(node.body);
      break;
    case nodeTypes.TRY:
      this._buffer.append("try ");
      this.prettyPrint(node.tryBlock);
      node.catchClauses.each(function(catchClause) {
        this._buffer.append(" catch (").append(catchClause.varName).append(") ");
        this.prettyPrint(catchClause.block);
      }.bind(this));
      if (node.finallyBlock) {
        this._buffer.append(" finally ");
        this.prettyPrint(node.finallyBlock);
      }
      break;
    case nodeTypes.WITH:
      this._buffer.append("with (");
      this.prettyPrint(node.object);
      this._buffer.append(") ");
      this.prettyPrint(node.body);
      break;
    case nodeTypes.SWITCH:
      this._buffer.append("switch (");
      this.prettyPrint(node.discriminant);
      this._buffer.append(") {");
      this.newLine();
      for (i = 0; i < node.cases.length; ++i) {
        var c = node.cases[i];
        if (i === node.defaultIndex) {
          this._buffer.append("default");
        } else {
          this._buffer.append("case ");
          this.prettyPrint(c.caseLabel);
        }
        this._buffer.append(":");
        this.indent();
        c.statements.each(function(s) {
          this.newLine();
          this.prettyPrint(s);
        }.bind(this));
        this.unindent();
        this.newLine();
      }
      this._buffer.append("}");
      break;
    case nodeTypes.RETURN:
      if (typeof(node.value) === 'object') {
        this._buffer.append("return ");
        this.prettyPrint(node.value);
        this._buffer.append(";");
      } else {
        this._buffer.append("return;");
      }
      break;
    case nodeTypes.THROW:
      this._buffer.append("throw ");
      this.prettyPrint(node.exception);
      this._buffer.append(";");
      break;
    case nodeTypes.TYPEOF:
      this._buffer.append("typeof");
      // I sometimes write typeof(3), sometimes typeof 3.
      if (node[0].type !== nodeTypes.GROUP) { this._buffer.append(" "); }
      this.prettyPrint(node[0]);
      break;
    case nodeTypes.NOT:
      this._buffer.append("!");
      this.prettyPrint(node[0]);
      break;
    case nodeTypes.UNARY_MINUS:
      this._buffer.append("-");
      this.prettyPrint(node[0]);
      break;
    case nodeTypes.INCREMENT:
    case nodeTypes.DECREMENT:
      if (node.postfix) {
        this.prettyPrint(node[0]);
        this._buffer.append(node.value);
      } else {
        this._buffer.append(node.value);
        this.prettyPrint(node[0]);
      }
      break;
    case nodeTypes.OR:
    case nodeTypes.AND:
    case nodeTypes.BITWISE_OR:
    case nodeTypes.BITWISE_XOR:
    case nodeTypes.BITWISE_AND:
    case nodeTypes.EQ: case nodeTypes.NE: case nodeTypes.STRICT_EQ: case nodeTypes.STRICT_NE:
    case nodeTypes.LT: case nodeTypes.LE: case nodeTypes.GE: case nodeTypes.GT:
    case nodeTypes.INSTANCEOF:
    case nodeTypes.LSH: case nodeTypes.RSH: case nodeTypes.URSH:
    case nodeTypes.PLUS: case nodeTypes.MINUS:
    case nodeTypes.MUL: case nodeTypes.DIV: case nodeTypes.MOD:
      this.prettyPrint(node[0]);
      this._buffer.append(" ").append(node.value).append(" ");
      this.prettyPrint(node[1]);
      break;
    case nodeTypes.HOOK:
      this.prettyPrint(node[0]);
      this._buffer.append(" ? ");
      this.prettyPrint(node[1]);
      this._buffer.append(" : ");
      this.prettyPrint(node[2]);
      break;
    default:
      avocado.ui.grab(reflect(node));
      var errorMsg = "prettyPrinter encountered unknown node type: " + jsParse.tokens[node.type];
      console.log(errorMsg);
      throw new Error(errorMsg);
    }
  }, {category: ['formatting']});

  add.method('newLine', function () {
    this._buffer.append("\n");
    for (var i = 0; i < this._indentationLevel; ++i) { this._buffer.append(" "); }
  }, {category: ['formatting']});

  add.method('indentDuring', function (f) {
    this.indent();
    try {
      return f();
    } finally {
      this.unindent();
    }
  }, {category: ['formatting']});

  add.method('indent', function (f) {
    this._indentationLevel += this._spacesPerIndent;
  }, {category: ['formatting']});

  add.method('unindent', function (f) {
    this._indentationLevel -= this._spacesPerIndent;
  }, {category: ['formatting']});

});


thisModule.addSlots(avocado.prettyPrinter.tests, function(add) {

  add.method('functionToFormat1', function () {
    var nothing = function () {};
    var f = function (a) { return a + 4; };
    callAFunction(f, 42);
    var obj = {a: 4, b: 5};
    obj.a;
    f.callAMethod(3, obj);
  });

  add.method('functionToFormat2', function () {
    f = this;
    var arr = obj.a < 3 ? [1, 2, 'three'] : null;
    if (true) {
      lalala();
      return;
    }
    if (false) { bleh(); } else { blah(); }
  });

  add.method('functionToFormat3', function () {
    for (var i = 0; i < n; i++) {
      throw new Error("blah blah");
      ++i;
      --i;
      i--;
    }
    for (i = -2; i < n; i++) { something(); }
    new f['three'];
    delete f.pleh;
    f.match(/abc/g);
    return 'lalala';
  });

  add.method('functionToFormat4', function () {
    function localFunc() { argle(); }
    if (typeof(3) === typeof 4) { return 'good'; }
    with (window) { eval('"something"'); }
    try {
      one();
      two();
    } catch (ex) {
      nothing();
      doStuff();
    } finally {
      yeah();
      for (n in o) { alsoGreat(); }
      for (var n in o) { great(); }
    }
  });

  add.method('functionToFormat5', function () {
    while (true) { doSomething(); }
    do {
      one();
      two();
    } while (x < 4);
    switch (x) {
    case 3:
      blah();
      break;
    default:
      noodle();
    }
  });

  add.method('checkFunction', function (f) {
    // Gotta start with indentationLevel 2 because that's how we write all the
    // code in the source files here. -- Adam
    this.assertEqual(f.toString(), reflect(f).prettyPrint({indentationLevel: 2}));
  });

  add.method('test1', function () {
    this.checkFunction(this.functionToFormat1);
  });

  add.method('test2', function () {
    this.checkFunction(this.functionToFormat2);
  });

  add.method('test3', function () {
    this.checkFunction(this.functionToFormat3);
  });

  add.method('test4', function () {
    this.checkFunction(this.functionToFormat4);
  });

  add.method('test5', function () {
    this.checkFunction(this.functionToFormat5);
  });

});


thisModule.addSlots(avocado.mirror, function(add) {

  add.method('prettyPrint', function (options) {
    var expr = this.expressionEvaluatingToMe(true);
    var stmt = avocado.stringBuffer.create('var ___contents___ = (').append(expr).append(');').toString();
    // need the assignment and the semicolon so that the parser doesn't gripe about not having a function name
    var rootNode = jsParse.parse(stmt);
    var contentsNode = rootNode[0][0].initializer[0]; // bypass the nodes for the __contents__ statement
    return avocado.prettyPrinter.create(contentsNode, options).result();
  }, {category: ['pretty printing']});

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/types"] = function() {};
avocado.transporter.module.create('general_ui/types', function(requires) {

requires('core/types');

}, function(thisModule) {


thisModule.addSlots(avocado.types, function(add) {

  add.creator('morph', {}, {category: ['morphs']});

});


thisModule.addSlots(avocado.types.morph, function(add) {

  add.method('onModelOfType', function (modelType) {
    return Object.newChildOf(this, modelType);
  }, {category: ['creating']});

  add.method('initialize', function (modelType) {
    this._modelType = modelType;
  }, {category: ['creating']});

  add.method('doesTypeMatch', function (o) {
    if (!o) { return false; }
    if (typeof(o._model) === 'undefined') { return false; }
    return this._modelType.doesTypeMatch(o._model);
  }, {category: ['testing']});

});


thisModule.addSlots(avocado.types.general, function(add) {

  add.method('canCreateInputMorph', function () {
    return typeof(this.createInputMorph) === 'function';
  }, {category: ['input']});

});


thisModule.addSlots(avocado.types.number, function(add) {

  add.method('createInputMorph', function (slot) {
    return avocado.frequentlyEditedText.newMorphFor(slot);
  }, {category: ['input']});

});


thisModule.addSlots(avocado.types.shortString, function(add) {

  add.method('createInputMorph', function (slot) {
    return avocado.frequentlyEditedText.newMorphFor(slot);
  }, {category: ['input']});

});


});

avocado.transporter.module.onLoadCallbacks["lk_ext/types"] = function() {};
avocado.transporter.module.create('lk_ext/types', function(requires) {

requires('general_ui/types');

}, function(thisModule) {


thisModule.addSlots(avocado.types.bool, function(add) {

  add.method('createInputMorph', function (slot) {
    return new avocado.CheckBoxMorph(slot);
  }, {category: ['input']});

});


thisModule.addSlots(avocado.types.longString, function(add) {

  add.method('createInputMorph', function (slot) {
    if (! avocado.ui.enableHTMLTextMorphExperiment) {
      var tm = avocado.frequentlyEditedText.newMorphFor(slot);
      tm.setScale(0.3);
      tm.setFill(null);
      tm.applyStyle({horizontalLayoutMode: avocado.LayoutModes.SpaceFill, verticalLayoutMode: avocado.LayoutModes.SpaceFill});
      return ScrollPane.containing(tm, avocado.treeNode.defaultExtent());
    } else {
      var htmlMorph = new XenoMorph(new Rectangle(0, 0, 300, 205)).setScale(0.5).setFill(null).ignoreAllExceptDefaultEvents();

      htmlMorph.setLayout({
        minimumExtent: function() {
          // aaa how do I find out how much space the HTML actually takes up?
          var e = this.getExtent();
          this._cachedMinimumExtent = e;
          return e.scaleBy(this.getScale());
        }.bind(htmlMorph),

        rejigger: function(availableSpace) {
          var r = this.rejiggerJustMyLayout(availableSpace);
          this.adjustForNewBounds();
          return r;
        }.bind(htmlMorph),
      });

      var body = document.createElement("body");
      body.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
      var div = document.createElement("div");

      var textArea = document.createElement("textarea");
      textArea.style.width  = "100%";
      textArea.rows = 15;
      div.appendChild(textArea);
      
      htmlMorph.refreshContent = function () {
        while (textArea.hasChildNodes()) { textArea.removeChild(textArea.lastChild); }
        textArea.appendChild(document.createTextNode(slot.get()));
      };

      body.appendChild(div);
      htmlMorph.foRawNode.appendChild(body);
      return htmlMorph;
    }
  }, {category: ['input']});

});


thisModule.addSlots(avocado.types.enumeration.prompterProto, function(add) {

  add.method('prompt', function (caption, context, evt, callback) {
    avocado.ComboBoxMorph.prompt("Which?", "Choose", "Cancel", this._possibilities, this._possibilities.first(), callback);
  });

});


});

avocado.transporter.module.onLoadCallbacks["core/line_graph"] = function() {};
avocado.transporter.module.create('core/line_graph', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('lineGraph', {}, {category: ['graphing']});

});


thisModule.addSlots(avocado.lineGraph, function(add) {

  add.method('create', function (valuesOfLines) {
    return Object.newChildOf(this, valuesOfLines);
  }, {category: ['creating']});

  add.method('initialize', function (valuesOfLines) {
    this._lines = valuesOfLines ? valuesOfLines.map(function(values) { return avocado.lineGraph.line.create(this, values); }.bind(this)) : [];
  }, {category: ['creating']});

  add.method('lines', function () {
    return this._lines;
  }, {category: ['accessing']});

  add.creator('line', {}, {category: ['prototypes']});

});


thisModule.addSlots(avocado.lineGraph.line, function(add) {

  add.method('create', function (graph, values) {
    return Object.newChildOf(this, graph, values);
  }, {category: ['creating']});

  add.method('initialize', function (graph, values) {
    this._graph = graph;
    this._values = values;
  }, {category: ['creating']});

  add.method('values', function () {
    return this._values;
  }, {category: ['accessing']});

  add.method('min', function () {
    return this._min;
  }, {category: ['accessing']});

  add.method('max', function () {
    return this._max;
  }, {category: ['accessing']});

  add.method('numberOfValues', function () {
    return this._numberOfValues || this._values.size();
  }, {category: ['accessing']});

  add.method('addValue', function (v) {
    this._values.push(v);
    avocado.ui.justChanged(this._graph);
  }, {category: ['accessing']});

  add.method('determineMinAndMax', function () {
    var min, max;
    var i = 0;
    this.values().forEach(function(v) {
      if (typeof(min) === 'undefined' || v < min) { min = v; }
      if (typeof(max) === 'undefined' || v > max) { max = v; }
      ++i;
    });
    if (typeof(min) === 'undefined') { min = 0; }
    if (typeof(max) === 'undefined' || min === max) { max = min + 100; }
    this._min = min;
    this._max = max;
    this._numberOfValues = i;
  }, {category: ['scale']});

});


});

avocado.transporter.module.onLoadCallbacks["lk_ext/line_graph"] = function() {};
avocado.transporter.module.create('lk_ext/line_graph', function(requires) {

requires('core/line_graph');

}, function(thisModule) {


thisModule.addSlots(avocado.lineGraph, function(add) {

  add.method('newMorph', function () {
    return new this.Morph(this);
  }, {category: ['user interface']});

  add.method('Morph', function Morph() { Class.initializer.apply(this, arguments); }, {category: ['user interface']});

});


thisModule.addSlots(avocado.lineGraph.Morph, function(add) {

  add.data('displayName', 'Morph');

  add.data('superclass', Morph);

  add.data('type', 'avocado.lineGraph.Morph');

  add.creator('prototype', Object.create(Morph.prototype));

});


thisModule.addSlots(avocado.lineGraph.Morph.prototype, function(add) {

  add.data('constructor', avocado.lineGraph.Morph);

  add.method('initialize', function ($super, g) {
    $super(new lively.scene.Rectangle(new Rectangle(0, 0, 400, 200)));
    this.setModel(g);
    this.refreshContentOfMeAndSubmorphs();
  }, {category: ['creating']});

  add.method('createLineMorph', function (line) {
    line.determineMinAndMax();
    var range = line.max() - line.min();
    var morphExtent = this.getExtent();
    var padding = 5;
    var i = 0;
    var m = new Morph(new lively.scene.Polyline(line.values().map(function(v) {
      ++i;
      return pt(padding + ((morphExtent.x - padding - padding) * i / line.numberOfValues()), morphExtent.y - (padding + (v - line.min()) * (morphExtent.y - padding - padding) / range));
    })));
    m.applyStyle(this.lineStyle);
    return m;
  }, {category: ['updating']});

  add.method('refreshContent', function () {
    if (this._lineMorphs) { this._lineMorphs.forEach(function(m) { m.remove(); }); }
    this._lineMorphs = this._model.lines().map(function(line) { return this.createLineMorph(line); }.bind(this));
    this._lineMorphs.forEach(function(m) { this.addMorph(m); }.bind(this));
  }, {category: ['updating']});

  add.creator('style', {}, {category: ['styles']});

  add.creator('lineStyle', {}, {category: ['styles']});

});


thisModule.addSlots(avocado.lineGraph.Morph.prototype.style, function(add) {

  add.data('fill', new Color(1, 1, 1));

});


thisModule.addSlots(avocado.lineGraph.Morph.prototype.lineStyle, function(add) {

  add.data('borderColor', new Color(0, 0, 0));

  add.data('borderWidth', 1);

  add.data('fill', null);

  add.data('suppressGrabbing', true);

  add.data('openForDragAndDrop', false);

  add.data('shouldIgnoreEvents', true);

});


});

avocado.transporter.module.onLoadCallbacks["lk_ext/html"] = function() {};
avocado.transporter.module.create('lk_ext/html', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('html', {}, {category: ['user interface']});

});


thisModule.addSlots(avocado.html, function(add) {

  add.creator('layout', {});

  add.method('create', function () {
    var h = Object.create(this);
    h.initialize.apply(h, arguments);
    return h;
  }, {category: ['creating']});

  add.method('initialize', function (contents) {
    this._contents = contents;
  }, {category: ['creating']});

  add.method('setInitialBounds', function (b) {
    this._initialBounds = b;
    return this;
  }, {category: ['user interface']});

  add.method('setMaxExtent', function (e) {
    this._maxExtent = e;
    return this;
  }, {category: ['user interface']});

  add.method('newMorph', function () {
    return this.newMorphWithBounds(this._initialBounds || new Rectangle(0, 0, 200, 50), this._maxExtent, this, this._contents);
  }, {category: ['user interface']});

  add.method('newMorphWithBounds', function (initialBounds, maxExtent, model, contents) {
    var htmlMorph = avocado.ui.newMorph(avocado.ui.shapeFactory.newRectangle(initialBounds));
    htmlMorph.setFill(null);
    htmlMorph.setLayout(Object.newChildOf(avocado.html.layout, htmlMorph, initialBounds));
    htmlMorph.mouseHandler = MouseHandlerForDoingTheDefaultThing.prototype; // needed to make normal HTML events work, like clicking on links
    htmlMorph.setLayoutModes({horizontalLayoutMode: avocado.LayoutModes.Rigid, verticalLayoutMode: avocado.LayoutModes.ShrinkWrap});

    if (model) { htmlMorph.setModel(model); }
    if (contents) { htmlMorph.layout().bodyNode().appendChild(contents); }
    
    if (maxExtent) {
      return ScrollPane.containing(htmlMorph, maxExtent);
    } else {
      return htmlMorph;
    }
  }, {category: ['user interface']});

});


thisModule.addSlots(avocado.html.layout, function(add) {

  add.method('initialize', function (morph, initialBounds) {
    this._morph = morph;
    this._initialBounds = initialBounds;
    
    var bounds = this._initialBounds;
    morph.foRawNode = NodeFactory.createNS(Namespace.SVG, "foreignObject", {x: bounds.x, y: bounds.y, width: bounds.width, height: bounds.height});
    morph.addNonMorph(morph.foRawNode);
    morph.adjustForNewBounds();
    
    this._bodyNode = document.createElement("body");
    this._bodyNode.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
    morph.foRawNode.appendChild(this._bodyNode);
  }, {category: ['initializing']});

  add.method('adjustForNewBounds', function (morph) {
    var foreignObjectNode = morph.foRawNode;
    var bounds = morph.shape.bounds();
    foreignObjectNode.setAttributeNS(null, "x",      bounds.x     );
    foreignObjectNode.setAttributeNS(null, "y",      bounds.y     );
    foreignObjectNode.setAttributeNS(null, "width",  bounds.width );
    foreignObjectNode.setAttributeNS(null, "height", bounds.height);
		foreignObjectNode.x      = bounds.x;
		foreignObjectNode.y      = bounds.y;
		foreignObjectNode.width  = bounds.width;
		foreignObjectNode.height = bounds.height;
  }, {category: ['layout']});

  add.method('bodyNode', function () {
    return this._bodyNode;
  }, {category: ['accessing']});

  add.method('foreignObjectNode', function () {
    return this._morph.foRawNode;
  }, {category: ['accessing']});

  add.method('minimumExtent', function () {
    var e = this._morph.getExtent();
    var h = this._morph.horizontalLayoutMode;
    var v = this._morph.  verticalLayoutMode;
    //aaa blecch why is this causing so much trouble?
    //if (h === avocado.LayoutModes.ShrinkWrap || h === avocado.LayoutModes.SpaceFill) { e = e.withX(this.bodyNode().offsetWidth ); }
    if (v === avocado.LayoutModes.ShrinkWrap || v === avocado.LayoutModes.SpaceFill) { e = e.withY(this.bodyNode().offsetHeight); }
    if (e.y === 0) {
      e = e.withY(23);
      // The problem seems to be happening when the node isn't actually part of the document yet. I think.
      // So for now, let's just default it to the height of one line of text.
      // Maybe the right solution is to temporarily add it to the document (but maybe hidden), just so we can determine the height? I dunno.
      /*
      var n = this.foreignObjectNode();
      while (n && n !== document.body) { n = n.parentNode; }
      if (!n) { debugger; }
      */
    }
    this._morph._cachedMinimumExtent = e;
    return e.scaleBy(this._morph.getScale());
  }, {category: ['layout']});

  add.method('rejigger', function (htmlMorph, availableSpace) {
    var r = htmlMorph.rejiggerJustMyLayout(availableSpace);
    htmlMorph.adjustForNewBounds();
    return r;
  }, {category: ['layout']});

  add.method('justSetLayoutModes', function (morph) {
    if (morph.horizontalLayoutMode === avocado.LayoutModes.Rigid && morph.verticalLayoutMode === avocado.LayoutModes.ShrinkWrap) {
      // aaa - maybe nothing is necessary here?
    } else {
      //console.log("aaa finish implementing justSetLayoutModes for HTML morphs");
    }
  }, {category: ['layout']});

  add.method('refreshContent', function (morph) {
    if (typeof(morph._model.setContentsOfHTMLMorph) === 'function') {
      morph._model.setContentsOfHTMLMorph(morph);
    }
  }, {category: ['content']});

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/animation_math"] = function() {};
avocado.transporter.module.create('general_ui/animation_math', function(requires) {

requires('core/math');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('animation', {}, {category: ['animation']}, {comment: 'Taking a crack at some of those cartoon animation techniques that Self\'s UI1 uses.\nhttp://selflanguage.org/documentation/published/animation.html'});

});


thisModule.addSlots(Point.prototype, function(add) {

  add.method('planeThatAlsoPassesThrough', function (otherPt) {
    return avocado.geometry.planes.twoD;
  });

  add.method('doNotGoPast', function (targetValue, originalValue) {
    var originalDifference = targetValue.minus(originalValue);
    var      newDifference = targetValue.minus(this);
    if (newDifference.sign() !== originalDifference.sign()) {return targetValue;}
    var xIsDifferent = newDifference.x.sign() !== originalDifference.x.sign();
    var yIsDifferent = newDifference.y.sign() !== originalDifference.y.sign();
    if (xIsDifferent && yIsDifferent) { return targetValue; }
    if (xIsDifferent) { return this.withX(targetValue.x); }
    if (yIsDifferent) { return this.withY(targetValue.y); }
    return this;
  });

  add.method('circleThatAlsoPassesThrough', function (otherPt) {
    if (otherPt.is3D) { return this.withZ(0).circleThatAlsoPassesThrough(otherPt); }
    
    var plane = this.planeThatAlsoPassesThrough(otherPt);
    var vector = otherPt.subPt(this);
    var normal = vector.perpendicularVector().scaleToLength(vector.r() * 4); // can fiddle with the length until it looks good
    var center = this.midPt(otherPt).addPt(normal);
    return Object.newChildOf(avocado.geometry.circle, center, this.subPt(center).r(), plane);
  }, {category: ['geometry']});

});


thisModule.addSlots(Number.prototype, function(add) {

  add.method('doNotGoPast', function (targetValue, originalValue) {
    var originalDifference = targetValue - originalValue;
    if (originalDifference === 0) { return targetValue; }
    var      newDifference = targetValue - this;
    if (newDifference.sign() !== originalDifference.sign()) {return targetValue;}
    return this;
  });

});


thisModule.addSlots(avocado.animation, function(add) {

  add.data('timePerStep', 40);

  add.creator('abstract', {});

});


thisModule.addSlots(avocado.animation['abstract'], function(add) {

  add.method('create', function () {
    var a = Object.create(this);
    a.initialize.apply(a, arguments);
    return a;
  }, {category: ['creating']});

  add.method('initialize', function (name) {
    this._name = name;
    this._preferredTimePerStep = avocado.animation.timePerStep;
  });

  add.method('whenDoneCall', function (f) { this._functionToCallWhenDone = f; return this; });

  add.method('done', function () {
    this.stopAnimating();
    var f = this._functionToCallWhenDone;
    if (f) { f(); }
  });

  add.method('scheduleNextStep', function (morph, currentTime, timeElapsedForThisStep) {
    this._mostRecentStepTimestamp = currentTime;
    // aaa - could adjust _preferredTimePerStep based on timeElapsedForThisStep, make the system adapt dynamically
    this._timeout = setTimeout(function() { this.doNextStep(morph); }.bind(this), this._preferredTimePerStep);
  });

  add.method('doNextStep', function (morph) {
    var previousTime = this._mostRecentStepTimestamp;
    var currentTime = new Date().getTime();
    var timeElapsedForThisStep = currentTime - previousTime;
    this.doOneStep(morph, timeElapsedForThisStep);
    if (! this.isStopped()) { this.scheduleNextStep(morph, currentTime); }
  });

  add.method('startAnimating', function (morph) {
    this.scheduleNextStep(morph, new Date().getTime());
  });

  add.method('stopAnimating', function () {
    if (this._timeout) {
      clearTimeout(this._timeout);
      delete this._timeout;
    }
  });

  add.method('isStopped', function () {
    return ! this._timeout;
  });

});


thisModule.addSlots(avocado.animation, function(add) {

  add.creator('simultaneous', Object.create(avocado.animation['abstract']));

});


thisModule.addSlots(avocado.animation.simultaneous, function(add) {

  add.method('initialize', function ($super, name, simultaneousProcesses) {
    $super(name);
    this._simultaneousProcesses = simultaneousProcesses || [];
  });

  add.method('simultaneousProcesses', function () { return this._simultaneousProcesses; });

  add.method('totalDuration', function () {
    return this._simultaneousProcesses.max(function(each) { return each.totalDuration(); });
  });

  add.method('doOneStep', function (morph, timeElapsedForThisStep) {
    var anyAreNotDoneYet = false;
    for (var i = 0, n = this._simultaneousProcesses.length; i < n; ++i) {
      if (this._simultaneousProcesses[i].doOneStep(morph, timeElapsedForThisStep)) {
        anyAreNotDoneYet = true;
      }
    }
    if (! anyAreNotDoneYet) { this.done(); }
    return anyAreNotDoneYet;
  });

});


thisModule.addSlots(avocado.animation, function(add) {

  add.creator('sequential', Object.create(avocado.animation['abstract']));

});


thisModule.addSlots(avocado.animation.sequential, function(add) {

  add.method('initialize', function ($super, name, timeSegments) {
    $super(name);
    this._timeSegments = timeSegments || [];
    this._currentSegmentIndex = 0;
  });

  add.method('timeSegments', function () {
    return this._timeSegments;
  });

  add.method('currentSegment', function () {
    return this._timeSegments[this._currentSegmentIndex];
  });

  add.method('totalDuration', function () {
    return this._timeSegments.inject(0, function(sum, each) { return sum + each.totalDuration(); });
  });

  add.method('doOneStep', function (morph, timeElapsedForThisStep) {
    while (true) {
      var s = this.currentSegment();
      if (!s) { this.done(); return false; }
      var isNotDoneYet = s.doOneStep(morph, timeElapsedForThisStep);
      if (isNotDoneYet) { return true; } else { this._currentSegmentIndex += 1; }
    }
  });

});


thisModule.addSlots(avocado.animation, function(add) {

  add.creator('timeSegment', Object.create(avocado.animation['abstract']));

});


thisModule.addSlots(avocado.animation.timeSegment, function(add) {

  add.method('initialize', function ($super, name, duration, movement) {
    $super(name);
    this._totalDuration = duration;
    this._timeLeft = duration;
    this._movement = movement;
  });

  add.method('totalDuration', function () {
    return this._totalDuration;
  });

  add.method('doOneStep', function (morph, timeElapsedForThisStep) {
    if (this._timeLeft <= 0) { this.done(); return false; }
    this._movement.doOneStep(morph, timeElapsedForThisStep);
    this._timeLeft -= timeElapsedForThisStep;
    return true;
  });

});


thisModule.addSlots(avocado.animation, function(add) {

  add.creator('instantaneous', Object.create(avocado.animation['abstract']));

});


thisModule.addSlots(avocado.animation.instantaneous, function(add) {

  add.method('initialize', function ($super, name, functionToRun) {
    $super(name);
    this._functionToRun = functionToRun;
  });

  add.method('totalDuration', function () {
    return 0;
  });

  add.method('doOneStep', function (morph, timeElapsedForThisStep) {
    // console.log("About to run instantaneous action " + this._name);
    this._functionToRun(morph, timeElapsedForThisStep);
    this.done();
    return false;
  });

});


thisModule.addSlots(avocado.animation, function(add) {

  add.creator('stepper', {});

});


thisModule.addSlots(avocado.animation.stepper, function(add) {

  add.method('create', function () {
    var a = Object.create(this);
    a.initialize.apply(a, arguments);
    return a;
  }, {category: ['creating']});

  add.method('initialize', function () {});

  add.method('doOneStep', function (morph, timeElapsedForThisStep) {
    throw new Error("Children must implement doOneStep");
  });

});


thisModule.addSlots(avocado.animation, function(add) {

  add.creator('nothingDoer', Object.create(avocado.animation.stepper));

});


thisModule.addSlots(avocado.animation.nothingDoer, function(add) {

  add.method('doOneStep', function (morph, timeElapsedForThisStep) {
    return false;
  });

});


thisModule.addSlots(avocado.animation, function(add) {

  add.creator('accelerator', Object.create(avocado.animation.stepper));

});


thisModule.addSlots(avocado.animation.accelerator, function(add) {

  add.method('initialize', function (acceleration, speedHolder) {
    this._acceleration = acceleration;
    this._speedHolder = speedHolder;
  });

  add.method('doOneStep', function (morph, timeElapsedForThisStep) {
    var speedChangeThisStep = this._acceleration * timeElapsedForThisStep;
    this._speedHolder.speed += speedChangeThisStep;
  });

});


thisModule.addSlots(avocado.animation, function(add) {

  add.creator('pathMover', Object.create(avocado.animation.stepper));

});


thisModule.addSlots(avocado.animation.pathMover, function(add) {

  add.method('initialize', function (path, speedHolder) {
    this._path = path;
    this._speedHolder = speedHolder;
    this._progress = 0;
  });

  add.method('doOneStep', function (morph, timeElapsedForThisStep) {
    var curPos = morph.getPosition();
    var newDstPos = this._path.destination();
    if (this._oldDestination && ! this._oldDestination.eqPt(newDstPos)) {
      this._path = avocado.animation.straightPath.create(avocado.animation.straightPath.backtrackToFictionalStartingPoint(curPos, this._progress, newDstPos), this._path._destinationFnOrPt);
    }

    var speed = this._speedHolder.speed;
    var progressThisStep = speed * timeElapsedForThisStep;
    var newPos = this._path.move(progressThisStep, curPos);
    this._oldDestination = newDstPos;
    morph.setPositionAndDoMotionBlurIfNecessary(newPos, timeElapsedForThisStep);
    this._progress += progressThisStep;
  });

});


thisModule.addSlots(avocado.animation, function(add) {

  add.creator('speedStepper', Object.create(avocado.animation.stepper));

});


thisModule.addSlots(avocado.animation.speedStepper, function(add) {

  add.method('initialize', function (from, to, speedHolder, valueAccessor) {
    this._endingValue = to;
    this._totalDifference = to.minus(from);
    this._speedHolder = speedHolder;
    this._valueAccessor = valueAccessor;
  });

  add.method('doOneStep', function (morph, timeElapsedForThisStep) {
    var speed = this._speedHolder.speed;
    var progressThisStep = Math.max(0, speed * timeElapsedForThisStep);
    var currentValue = this._valueAccessor.getValue(morph);
    if (currentValue.equals(this._endingValue)) {return;}
    var amountToChange = this._totalDifference.scaleBy(progressThisStep);
    var newValue = currentValue.plus(amountToChange);
    newValue = newValue.doNotGoPast(this._endingValue, currentValue);
    this._valueAccessor.setValue(morph, newValue);
  });

});


thisModule.addSlots(avocado.animation, function(add) {

  add.creator('wiggler', Object.create(avocado.animation.stepper));

});


thisModule.addSlots(avocado.animation.wiggler, function(add) {

  add.method('initialize', function (centerFnOrPt, wiggleSize) {
    this._isMovingTowardExtreme1 = false;
    this._centerFnOrPt = centerFnOrPt;
  });

  add.method('calculatePoints', function (morph) {
    var wiggleSize = morph.getScale() * morph.getExtent().x / 50;
    this._distanceToMovePerStep = wiggleSize * 1.5;
    
    this._centerPt = (typeof this._centerFnOrPt === 'function') ? this._centerFnOrPt() : this._centerFnOrPt;
    this._extreme1 = this._centerPt.addXY(-wiggleSize, 0);
    this._extreme2 = this._centerPt.addXY( wiggleSize, 0);
  });

  add.method('doOneStep', function (morph, timeElapsedForThisStep) {
    if (!this._centerPt) { this.calculatePoints(morph); }
    var curPos = morph.getPosition();
    var dstPos = this._isMovingTowardExtreme1 ? this._extreme1 : this._extreme2;
    if (curPos.subPt(dstPos).rSquared() < 0.01) {
      this._isMovingTowardExtreme1 = ! this._isMovingTowardExtreme1;
      dstPos = this._isMovingTowardExtreme1 ? this._extreme1 : this._extreme2;
    }
    morph.setPosition(curPos.addPt(dstPos.subPt(curPos).scaleToLength(this._distanceToMovePerStep)));
  });

});


thisModule.addSlots(avocado.animation, function(add) {

  add.creator('path', {});

});


thisModule.addSlots(avocado.animation.path, function(add) {

  add.method('create', function () {
    var a = Object.create(this);
    a.initialize.apply(a, arguments);
    return a;
  }, {category: ['creating']});

  add.method('destination', function () { var p = this._destinationFnOrPt; return typeof(p) === 'function' ? p() : p; });

});


thisModule.addSlots(avocado.animation, function(add) {

  add.creator('straightPath', Object.create(avocado.animation.path));

});


thisModule.addSlots(avocado.animation.straightPath, function(add) {

  add.method('initialize', function (from, to) {
    this._destinationFnOrPt = to;
    var dstPos = this.destination();
    
    this._totalDistance = dstPos.subPt(from).r();
  });

  add.method('move', function (progressThisStep, curPos) {
    var dstPos = this.destination();
    var vector = dstPos.subPt(curPos);
    var difference = vector.r();
    if (difference < 0.1) {return curPos;}

    var distanceToMove = Math.min(difference, progressThisStep * this._totalDistance);
    var vectorToMove = vector.normalized().scaleBy(distanceToMove);
    // console.log("progressThisStep: " + progressThisStep + ", distanceToMove: " + distanceToMove + ", vectorToMove: " + vectorToMove + ", curPos: " + curPos);
    return curPos.addPt(vectorToMove);
  });

  add.method('backtrackToFictionalStartingPoint', function (curPos, progress, dstPos) {
    var vector = dstPos.subPt(curPos);
    var overallVector = vector.scaleBy(1 / (1 - progress));
    return dstPos.subPt(overallVector);
  });

});


thisModule.addSlots(avocado.animation, function(add) {

  add.creator('arcPath', Object.create(avocado.animation.path));

  add.method('newWiggler', function (morph, centerFnOrPt, duration) {
    var centerPt = (typeof centerFnOrPt === 'function') ? centerFnOrPt() : centerFnOrPt || morph.getPosition();

    var wigglerizer = this.sequential.create("wiggler");
    wigglerizer.timeSegments().push(this.timeSegment  .create("wiggling",   duration || 200, this.wiggler.create(centerFnOrPt || morph.getPosition())));
    wigglerizer.timeSegments().push(this.instantaneous.create("reset loc",  function(morph) {
      morph.setPosition((typeof centerFnOrPt === 'function') ? centerFnOrPt() : centerFnOrPt || centerPt);
    }));

    return wigglerizer;
  });

  add.method('newMovement', function (morph, kindOfPath, destinationFnOrPt, speed, shouldAnticipateAtStart, shouldWiggleAtEnd, shouldDecelerateAtEnd) {
    
    
    // I should really try replacing a bunch of this ad-hoc code with something more solid, like:
    // http://learningthreejs.com/blog/2011/08/17/tweenjs-for-smooth-animation/
    
    
    
    var currentPt = morph.getPosition();
    var destinationPt = (typeof destinationFnOrPt === 'function') ? destinationFnOrPt() : destinationFnOrPt;
    var vector = destinationPt.subPt(currentPt);
    var distance = vector.r();

    if (distance >= 0.1) {
      var wholeThing = this.sequential.create("whole movement");

      var arcStartPt = currentPt;

      if (shouldAnticipateAtStart && morph.isOnScreen()) { // if it's off-screen, there's no point and it's annoying
        var a = this.anticipator(currentPt, vector, 120, 120);
        wholeThing.timeSegments().push(a);
        arcStartPt = a.path.destination();
      }

      var topSpeed = speed * (shouldDecelerateAtEnd ? 3/4 : 1); // OK, it's not exactly a speed, but it's sorta similar; fix this, maybe.
      var mainMovingDuration = distance / topSpeed;
      var accelOrDecelDuration = mainMovingDuration * (shouldDecelerateAtEnd ? 5/12 : 8/9);
      var speederizer = this.speederizer(accelOrDecelDuration, mainMovingDuration, shouldDecelerateAtEnd);

      var path = kindOfPath.create(arcStartPt, destinationFnOrPt);
      var moverizer = this.moverizer(path, speederizer);

      wholeThing.timeSegments().push(moverizer);

      if (shouldWiggleAtEnd) {
        wholeThing.timeSegments().push(this.newWiggler(morph, destinationFnOrPt));
      }

      return wholeThing;

    } else {
      return this.instantaneous.create("set final loc", function(morph, timeElapsedForThisStep) {morph.setPositionAndDoMotionBlurIfNecessary(destinationPt, timeElapsedForThisStep);});
    }

  });

  add.method('anticipator', function (currentPt, actualTravelVector, anticipationDuration, waitingDuration) {
    var a = this.sequential.create("anticipator");
    a.path = this.straightPath.create(currentPt, currentPt.addPt(actualTravelVector.scaleBy(-0.05)));
    var speedHolder = {speed: 1.0 / anticipationDuration};
    var pathMover = this.pathMover.create(a.path, speedHolder);

    a.timeSegments().push(this.timeSegment.create("anticipating",    anticipationDuration, pathMover));
    a.timeSegments().push(this.timeSegment.create("waiting to move",      waitingDuration, this.nothingDoer.create()));
    return a;
  });

  add.method('speederizer', function (accelOrDecelDuration, mainMovingDuration, shouldDecelerateAtEnd) {
    // accelerating or decelerating is like travelling at half speed; use that as a shortcut in the math
    var halfSpeedDuration = shouldDecelerateAtEnd ? accelOrDecelDuration + accelOrDecelDuration : accelOrDecelDuration;
    var fullSpeedDuration = mainMovingDuration - halfSpeedDuration;
    var imaginaryTotalDurationIfWeWereGoingFullSpeedTheWholeTime = fullSpeedDuration + (0.5 * halfSpeedDuration);
    var    fullSpeed = 1.0 / imaginaryTotalDurationIfWeWereGoingFullSpeedTheWholeTime;
    var acceleration = fullSpeed / accelOrDecelDuration;

    var speedHolder = {speed: 0};

    var s = this.sequential.create("speederizer");
    s.speedHolder = function() {return speedHolder;};
    s.timeSegments().push(this.timeSegment.create("accelerating",    accelOrDecelDuration, this.accelerator.create(acceleration, speedHolder)));
    s.timeSegments().push(this.timeSegment.create("cruising along",     fullSpeedDuration, this.nothingDoer.create()));
    if (shouldDecelerateAtEnd) {
      s.timeSegments().push(this.timeSegment.create("decelerating",  accelOrDecelDuration, this.accelerator.create(-acceleration, speedHolder)));
    }
    return s;
  });

  add.method('moverizer', function (path, speederizer) {
    var m = this.sequential.create("mover steps");
    m.path = path;
    var pathMover = this.pathMover.create(m.path, speederizer.speedHolder());
    m.timeSegments().push(this.timeSegment  .create( "main arc",      speederizer.totalDuration(), pathMover));
    m.timeSegments().push(this.instantaneous.create( "set final loc", function(morph, timeElapsedForThisStep) {morph.setPositionAndDoMotionBlurIfNecessary(path.destination(), timeElapsedForThisStep);}));
    return this.simultaneous.create("moverizer", [speederizer, m]);
  });

  add.method('newSpeedStepper', function (morph, endingValue, valueAccessor, mainDuration) {
    // Don't bother if the morph is off-screen - it just feels like nothing's happening.
    if (! morph.isOnScreen()) {
      return this.instantaneous.create("set final value", function(m) {valueAccessor.setValue(m, endingValue);});
    }

    var startingValue = valueAccessor.getValue(morph);

    var accelOrDecelDuration = mainDuration * 0.4;
    var s = this.speederizer(accelOrDecelDuration, mainDuration, true);
    var speedStepper = this.speedStepper.create(startingValue, endingValue, s.speedHolder(), valueAccessor);
    var r = this.sequential.create("speed steps");
    r.timeSegments().push(this.timeSegment  .create("changing",        mainDuration, speedStepper));
    r.timeSegments().push(this.instantaneous.create("set final value", function(m) {valueAccessor.setValue(m, endingValue);}));
    return this.simultaneous.create("speed stepper", [s, r]);
  });

});


thisModule.addSlots(avocado.animation.arcPath, function(add) {

  add.method('initialize', function (from, to) {
    this._destinationFnOrPt = to;
    var dstPos = this.destination();
    
    this._circleThatPassesThroughBothPoints = from.circleThatAlsoPassesThrough(dstPos);

    this._destinationAngle = this._circleThatPassesThroughBothPoints.angleAtPoint(dstPos);
    this._sourceAngle      = this._circleThatPassesThroughBothPoints.angleAtPoint(from  );
    this._totalAngle       = this._destinationAngle - this._sourceAngle;
  });

  add.method('move', function (progressThisStep, curPos) {
    var to = this.destination();
    var vector = to.subPt(curPos);
    if (vector.r() < 0.1) {return curPos;}

    var angleToMove = progressThisStep * this._totalAngle;
    var curAngle = this._circleThatPassesThroughBothPoints.angleAtPoint(curPos);
    var angleDifference = this._destinationAngle - curAngle;
    if (angleDifference < 0.001) {return curPos;}
    var newAngle = curAngle + angleToMove;
    var newAngleDifference = this._destinationAngle - newAngle;
    if (newAngleDifference.sign() !== angleDifference.sign()) {newAngle = this._destinationAngle;} // don't go past it
    var newPos = this._circleThatPassesThroughBothPoints.pointAtAngle(newAngle);
    // console.log("progressThisStep: " + progressThisStep + ", angleToMove: " + angleToMove + ", curAngle: " + curAngle + ", newAngle: " + newAngle + ", newPos: " + newPos + ", curPos: " + curPos);
    return newPos;
  });

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/basic_morph_mixins"] = function() {};
avocado.transporter.module.create('general_ui/basic_morph_mixins', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('morphMixins', {}, {category: ['user interface']});

});


thisModule.addSlots(avocado.morphMixins, function(add) {

  add.method('installAll', function () {
    reflect(Morph.prototype).setCopyDownParents([{parent: this.Morph}, {parent: this.MorphOrWorld}]);
    reflect(WorldMorph.prototype).setCopyDownParents([{parent: this.WorldMorph}]);
    reflect(TextMorph.prototype).setCopyDownParents([{parent: this.TextMorph}]);
  }, {category: ['installing']});

  add.creator('MorphOrWorld', {});

  add.creator('Morph', {});

  add.creator('WorldMorph', {});

  add.creator('TextMorph', {});

});


thisModule.addSlots(avocado.morphMixins.Morph, function(add) {

  add.data('isMorph', true, {category: ['testing']});

});


thisModule.addSlots(avocado.morphMixins.WorldMorph, function(add) {

  add.data('isWorld', true, {category: ['testing']});

});


});

avocado.transporter.module.onLoadCallbacks["core/directions"] = function() {};
avocado.transporter.module.create('core/directions', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('directions', {}, {category: ['collections', 'tables']});

});


thisModule.addSlots(avocado.directions, function(add) {

  add.creator('abstractDirection', {});

  add.creator('vertical', Object.create(avocado.directions.abstractDirection));

  add.creator('horizontal', Object.create(avocado.directions.abstractDirection));

});


thisModule.addSlots(avocado.directions.vertical, function(add) {

  add.data('sideways', avocado.directions.horizontal);

  add.method('toString', function () { return 'vertical'; });

  add.method('coord', function (p) {return p.y;});

  add.method('setCoord', function (p, y) {p.y = y;});

  add.method('point', function (f, s) {return pt(s, f);});

  add.method('copyAndSetCoord', function (p, y) { return pt(p.x, y); });

});


thisModule.addSlots(avocado.directions.horizontal, function(add) {

  add.data('sideways', avocado.directions.vertical);

  add.method('toString', function () { return 'horizontal'; });

  add.method('coord', function (p) {return p.x;});

  add.method('setCoord', function (p, x) {p.x = x;});

  add.method('point', function (f, s) {return pt(f, s);});

  add.method('copyAndSetCoord', function (p, x) { return pt(x, p.y); });

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/poses"] = function() {};
avocado.transporter.module.create('general_ui/poses', function(requires) {

requires('general_ui/basic_morph_mixins');
requires('core/directions');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('poses', {}, {category: ['ui', 'poses']});

});


thisModule.addSlots(avocado.morphMixins.Morph, function(add) {

  add.method('poseManager', function () {
    if (! this._poseManager) {
      this._poseManager = Object.newChildOf(avocado.poses.manager, this);
      reflect(this).slotAt('_poseManager').setInitializationExpression('null');
    }
    return this._poseManager;
  }, {category: ['poses']});

  add.method('posers', function () {
    return this.allPotentialPosers().reject(function(m) { return m.shouldIgnorePoses(); }).toArray();
  }, {category: ['poses']});

  add.method('allPotentialPosers', function () {
    return this.submorphEnumerator();
  });

  add.method('shouldIgnorePoses', function () {
    if (this._layout && typeof(this._layout.shouldIgnorePoses) === 'function') {
      return this._layout.shouldIgnorePoses();
    } else {
      return false;
    }
  }, {category: ['poses']});

  add.method('constructUIStateMemento', function () {
    // override constructUIStateMemento and assumeUIState, or uiStateParts, in children if you want them to be recalled in a particular state
    
    if (this.partsOfUIState) {
      var parts = typeof(this.partsOfUIState) === 'function' ? this.partsOfUIState() : this.partsOfUIState;
      var uiState = {};
      reflect(parts).normalSlots().each(function(slot) {
        var partName = slot.name();
        var part = slot.contents().reflectee();
        if (part) {
          if (!(part.isMorph) && part.collection && part.keyOf && part.getPartWithKey) {
            uiState[partName] = part.collection.map(function(elem) {
              return { key: part.keyOf(elem), uiState: elem.constructUIStateMemento() };
            });
          } else {
            uiState[partName] = part.constructUIStateMemento();
          }
        }
      });
      return uiState;
    }
    
    if (this._layout && typeof(this._layout.constructUIStateMemento) === 'function') {
      return this._layout.constructUIStateMemento(this);
    }
    
    return null;
  }, {category: ['poses']});

  add.method('assumeUIState', function (uiState, callWhenDone, evt) {
    // override constructUIStateMemento and assumeUIState, or uiStateParts, in children if you want them to be recalled in a particular state

    if (this.partsOfUIState) {
      if (!uiState) { return; }
      evt = evt || Event.createFake();
      var parts = typeof(this.partsOfUIState) === 'function' ? this.partsOfUIState() : this.partsOfUIState;
      
      avocado.callbackWaiter.on(function(generateIntermediateCallback) {
        reflect(parts).normalSlots().each(function(slot) {
          var partName = slot.name();
          var part = slot.contents().reflectee();
          if (part) {
            var uiStateForThisPart = uiState[partName];
            if (typeof(uiStateForThisPart) !== 'undefined') {
              if (!(part.isMorph) && part.collection && part.keyOf && part.getPartWithKey) {
                uiStateForThisPart.each(function(elemKeyAndUIState) {
                  part.getPartWithKey(this, elemKeyAndUIState.key).assumeUIState(elemKeyAndUIState.uiState, generateIntermediateCallback());
                }.bind(this));
              } else {
                part.assumeUIState(uiStateForThisPart, generateIntermediateCallback(), evt);
              }
            }
          }
        }.bind(this));
      }, callWhenDone, "assuming UI state");
    } else if (this._layout && typeof(this._layout.assumeUIState) === 'function') {
      this._layout.assumeUIState(this, uiState, callWhenDone, evt);
    }
  }, {category: ['poses']});

  add.method('transferUIStateTo', function (otherMorph, evt) {
    otherMorph.assumeUIState(this.constructUIStateMemento());
  }, {category: ['poses']});

});


thisModule.addSlots(avocado.poses, function(add) {

  add.creator('abstract', {});

});


thisModule.addSlots(avocado.poses['abstract'], function(add) {

  add.method('create', function () {
    var c = Object.create(this);
    c.initialize.apply(c, arguments);
    return c;
  }, {category: ['creating']});

  add.method('initialize', function (name) {
    this._name = name;
  }, {category: ['creating']});

  add.method('name', function () {
    return this._name;
  }, {category: ['accessing']});

  add.method('setName', function (n) {
    this._name = n;
    return this;
  }, {category: ['accessing']});

  add.method('toString', function () {
    return this.name();
  }, {category: ['printing']});

  add.method('inspect', function () {
    return this.toString();
  }, {category: ['printing']});

  add.method('copy', function () {
    return Object.deepCopyRecursingIntoCreatorSlots(this);
  }, {category: ['printing']});

  add.method('beInDebugMode', function () {
    this._debugMode = true;
    return this;
  }, {category: ['debugging']});

  add.method('doNotAnticipateAtStart', function () {
    this._shouldNotAnticipateAtStart = true;
    return this;
  }, {category: ['animating']});

  add.method('doNotWiggleAtEnd', function () {
    this._shouldNotWiggleAtEnd = true;
    return this;
  }, {category: ['animating']});

  add.method('putInPosition', function (container, element, origin, callback) {
    if (this._shouldBeUnobtrusive) {
      var poserOrPlaceholder = element.poser;
      if (element.poser.getOwner() !== container && element.poser.world()) { // aaa what's going on here?
        poserOrPlaceholder = container.placeholderForMorph(element.poser);
      }
      var positionFromOrigin = origin.moveDownAndRightBy(element.position.x, element.position.y);
      poserOrPlaceholder.setTopLeftPosition(positionFromOrigin);
      container.addMorph(poserOrPlaceholder);
      if (callback) { callback(); }
    } else {
      if (! element.poser.world()) {
        // aaa - Not sure at all that this is a good idea. But it might be.
        element.poser.setScale(1 / container.world().getScale());
      }
      
      if (element.scale) { element.position.desiredScale = element.scale; } // aaa hack
      element.poser.ensureIsInWorld(container, element.position, true, !this._shouldNotAnticipateAtStart, !this._shouldNotWiggleAtEnd, callback);
    }
  }, {category: ['posing']});

  add.method('recreateInContainer', function (container, startingPos, callback) {
    var originalScale = container.getScale();
    var originalSpace = container.getExtent().scaleBy(originalScale);
    //var originalSpace = container.bounds().extent(); // aaa if I use this line instead of the previous line I get that annoying grows-slightly-each-time problem
    
    this._bounds = (startingPos || pt(0, 0)).extent(pt(0, 0));
    
    var elements = [];
    this.eachElement(function(e) {
      elements.push(e);
      
      e.poser.isPartOfCurrentPose = true;
      // do bad things happen if I make the uiState thing happen before moving the poser?
      if (e.uiState) { e.poser.assumeUIState(e.uiState); }
      
      // Keep track of how much space the pose is taking up, so that the pose can answer getExtent(). -- Adam, June 2011
      var poserPosition = e.position || e.poser.getPosition();
      var poserExtent   = e.extent   || e.poser.getExtent(); // aaa: haven't implemented this one yet, setting e.extent won't actually do anything
      var poserScale    = e.scale    || e.poser.getScale();
      var poserBounds   = poserPosition.extent(poserExtent.scaleBy(poserScale));
      this._bounds      = this._bounds.union(poserBounds);
      if (this._debugMode) { console.log("Adding poser with bounds: " + poserBounds + " and scale " + poserScale); }
    }.bind(this), startingPos);
    
    if (this._shouldScaleToFitWithinCurrentSpace) {
      // aaa - Shoot, this isn't going to work right if this pose is doing the animation (i.e. if _shouldBeUnobtrusive is false), because
      // the container won't know how much space its submorphs will take up until the animation is done.
      
      var currentScale = container.getScale();
      var currentBounds = this._bounds;
      var currentExternalExtent = currentBounds.extent();
      if (currentExternalExtent.isZero()) { currentExternalExtent = container.getExtent(); }
      var hs = originalSpace.x / currentExternalExtent.x;
      var vs = originalSpace.y / currentExternalExtent.y;
      
      var newExtent, newScale;
      if (hs < vs) {
        newScale = hs;
        newExtent = currentExternalExtent.withY(currentExternalExtent.x * (originalSpace.y / originalSpace.x));
      } else {
        newScale = vs;
        newExtent = currentExternalExtent.withX(currentExternalExtent.y * (originalSpace.x / originalSpace.y));
      }
      
      container.setScale(newScale);
      container.setExtent(newExtent); // needed because calling .bounds() returns a rectangle that encompasses the stickouts, but they're still stickouts

      if (this._debugMode) {
        console.log("Scaling " + container + " to fit within originalSpace: " + originalSpace + ", currentExternalExtent: " + currentExternalExtent + ", newExtent: " + newExtent + ", this._bounds.extent(): " + this._bounds.extent() + ", hs: " + hs + ", vs: " + vs + ", originalScale: " + originalScale + ", currentScale: " + currentScale);
      }
    }
    
    if (this._shouldSetExtentToEncompassWholePose) {
      container.setExtent(this._bounds.extent());
      container.minimumExtentMayHaveChanged();
    }
    
    var origin = container.getOriginAAAHack(); // necessary because in 3D-land the origin is in the centre, but I don't understand why it's not working in LK-land
    if (this._extraZHack) { origin = origin.withZ((origin.z || 0) + this._extraZHack); }
    
    avocado.callbackWaiter.on(function(createCallbackForThisOne) {
      elements.forEach(function(e) {
        var callbackForThisOne = createCallbackForThisOne();
        setTimeout(function() { // not sure this is necessary or worthwhile, but let's try it to see if it makes some animations feel smoother
          this.putInPosition(container, e, origin, callbackForThisOne);
        }.bind(this), 0);
      }.bind(this));
    }.bind(this), callback, "putting the posers in position");
  }, {category: ['posing']});

  add.method('whenDoneScaleToFitWithinCurrentSpace', function () {
    this._shouldScaleToFitWithinCurrentSpace = true;
    return this;
  }, {category: ['scaling']});

  add.method('whenDoneSetExtentToEncompassWholePose', function () {
    this._shouldSetExtentToEncompassWholePose = true;
    return this;
  }, {category: ['scaling']});

  add.method('beUnobtrusive', function () {
    this._shouldBeUnobtrusive = true;
    return this;
  });

  add.method('setDesiredPoserScale', function (s) {
    this._desiredPoserScale = s;
    return this;
  }, {category: ['accessing']});

  add.method('setPadding', function (padding) {
    this._padding = padding;
    return this;
  }, {category: ['accessing']});

  add.method('aaa_addExtraZHack', function (extraZ) {
    if (avocado.ui.is3D) { this._extraZHack = extraZ; } // aaa HACK, what's the right way to make the contents pop out?
    return this;
  });

  add.method('constructUIStateMemento', function () {
    // for compatibility with morphs - want to be able to make a pose of poses
    return null;
  }, {category: ['acting like a morph']});

  add.method('getExtent', function () {
    // for compatibility with morphs - want to be able to make a pose of poses
    return this._bounds.extent();
  }, {category: ['acting like a morph']});

  add.method('getScale', function () {
    return 1;
  }, {category: ['acting like a morph']});

  add.method('ensureIsInWorld', function (w, desiredLoc, shouldMoveToDesiredLocEvenIfAlreadyInWorld, shouldAnticipateAtStart, shouldWiggleAtEnd, functionToCallWhenDone) {
    w.poseManager().assumePose(this, desiredLoc, functionToCallWhenDone);
  }, {category: ['acting like a morph']});

});


thisModule.addSlots(avocado.poses, function(add) {

  add.creator('tree', Object.create(avocado.poses['abstract']));

});


thisModule.addSlots(avocado.poses.tree, function(add) {

  add.method('initialize', function ($super, name, foci, parentFunction, childrenFunction) {
    $super(name);
    this._foci = foci;
    this.parentOf = parentFunction;
    this.childrenOf = childrenFunction;
  });

  add.data('_indentation', 20);

  add.data('_padding', pt(5, 5), {initializeTo: 'pt(5, 5)'});

  add.method('setPosers', function (posers) {
    this._foci = posers;
    return this;
  }, {category: ['accessing']});

  add.method('ancestorsOf', function (focus) { 
    var ancestors = [];
    var ancestor = focus;
    do {
      ancestors.push(ancestor);
      ancestor = this.parentOf(ancestor);
    } while (ancestor);
    ancestors.reverse();
    return ancestors;
  });

  add.method('eachElement', function (f, startingPos) {
    var worldScale  = avocado.ui.currentWorld().getScale();
    var indentation = this._indentation / worldScale;
    var padding     = this._padding.scaleBy(1 / worldScale);
    if (!startingPos) { startingPos = padding; }
    var pos = startingPos;
    
    this._foci.forEach(function(focus) {
      this.ancestorsOf(focus).each(function(poser) {
        var poserScale = this._desiredPoserScale || poser.getScale();
        var e = {poser: poser, position: pos};
        if (this._desiredPoserScale) { e.scale = this._desiredPoserScale; }
        f(e);
        var poserSpace = poser.getExtent().scaleBy(poserScale);
        pos = pos.addXY(indentation, poserSpace.y + padding.y);
      }.bind(this));

      var newY = this.eachChildElement(focus, pos, f);
      pos = startingPos.withY(newY);
    }.bind(this));
  });

  add.method('eachChildElement', function (parentPoser, pos, f) {
    var worldScale = avocado.ui.currentWorld().getScale();
    var indentation = this._indentation / worldScale;
    var padding     = this._padding.scaleBy(1 / worldScale);
    this.childrenOf(parentPoser).each(function(child) {
      var childScale = this._desiredPoserScale || child.getScale();
      var e = {poser: child, position: pos};
      if (this._desiredPoserScale) { e.scale = this._desiredPoserScale; }
      f(e);
      var childSpace = child.getExtent().scaleBy(childScale);
      var newY = this.eachChildElement(child, pos.addXY(indentation, childSpace.y + padding.y), f);
      pos = pos.withY(newY);
    }.bind(this));
    return pos.y;
  });

});


thisModule.addSlots(avocado.poses, function(add) {

  add.creator('list', Object.create(avocado.poses['abstract']));

});


thisModule.addSlots(avocado.poses.list, function(add) {

  add.method('initialize', function ($super, name, maxExtentPtOrFn, posers) {
    $super(name);
    this._maxExtentPtOrFn = maxExtentPtOrFn;
    this._posers = posers || [];
  });

  add.method('setPosers', function (posers) {
    this._posers = posers;
    return this;
  }, {category: ['accessing']});

  add.method('setPoserModels', function (poserModels) {
    var world = avocado.ui.currentWorld();
    return this.setPosers(poserModels.map(function(m) { return world.morphFor(m); }));
  }, {category: ['accessing']});

  add.method('maxExtent', function () {
    if (typeof(this._maxExtentPtOrFn) === 'function') { return this._maxExtentPtOrFn(); }
    return this._maxExtentPtOrFn;
  });

  add.method('setMaxExtent', function (maxExtentPtOrFn) {
    this._maxExtentPtOrFn = maxExtentPtOrFn;
    return this;
  }, {category: ['accessing']});

  add.data('_direction', avocado.directions.vertical);

  add.method('setDirection', function (d) {
    this._direction = d;
    return this;
  }, {category: ['accessing']});

  add.method('eachElement', function (f, startingPos) {
    var sortedPosersToMove = this._posers.sort(function(m1, m2) {
      var n1 = m1.inspect();
      var n2 = m2.inspect();
      return n1 < n2 ? -1 : n1 === n2 ? 0 : 1;
    });

    startingPos = startingPos || pt(0,0);
    var padding = this._padding || pt(20,20);
    var pos = startingPos.addPt(padding);
    var biggestSideways = 0;
    var maxExtent = this.maxExtent();
    var maxForwards;
    var forwards = this._direction;
    var sideways = this._direction.sideways;
    if (maxExtent && !this._shouldBeSquarish) { maxForwards = forwards.coord(maxExtent) - forwards.coord(padding); }
    for (var i = 0, n = sortedPosersToMove.length; i < n; ++i) {
      var poser = sortedPosersToMove[i];
      var uiState = this.destinationUIStateFor(poser);
      if (uiState) { poser.assumeUIState(uiState); }
      var poserScale = this._desiredPoserScale || poser.getScale();
      
      var e = {poser: poser, position: pos, uiState: uiState};
      if (this._desiredPoserScale) { e.scale = this._desiredPoserScale; }
      f(e);
      
      var poserSpace = poser.getExtent().scaleBy(poserScale);
      pos = forwards.copyAndSetCoord(pos, forwards.coord(pos) + forwards.coord(poserSpace) + forwards.coord(padding));
      biggestSideways = Math.max(biggestSideways, sideways.coord(poserSpace));
      
      if (this._shouldBeSquarish && !maxForwards) {
        // If it seems like the current coord is far down enough to make the whole
        // thing come out squarish (assuming that all columns will be about as
        // wide as this one), then set this as the maxForwards.
        var desiredAspectRatio = forwards.coord(maxExtent) == 0 ? 1 : sideways.coord(maxExtent) / forwards.coord(maxExtent);
        
        var estimatedNumberOfLines = Math.ceil(n / (i + 1));
        var estimatedTotalExtentSideways = estimatedNumberOfLines * (biggestSideways + sideways.coord(padding));
        // aaa - not sure why it keeps coming out too tall; quick hack for now: compensate by multiplying by 1.2
        if (forwards.coord(pos) * desiredAspectRatio * 1.2 >= estimatedTotalExtentSideways) { maxForwards = forwards.coord(pos); }
      }
      
      if (maxForwards && forwards.coord(pos) >= maxForwards) {
        pos = forwards.point(forwards.coord(startingPos) + forwards.coord(padding), sideways.coord(pos) + biggestSideways + sideways.coord(padding));
      }
    }
  });

  add.method('beCollapsing', function () {
    this._shouldBeCollapsing = true;
    return this;
  });

  add.method('beSquarish', function () {
    this._shouldBeSquarish = true;
    return this;
  });

  add.method('destinationUIStateFor', function (poser) {
    if (this._shouldBeCollapsing) {
      var uiState = poser.constructUIStateMemento();
      if (uiState) { uiState.isExpanded = false; }
      return uiState;
    } else {
      // just use whatever state it's in now
      return null;
    }
  });

});


thisModule.addSlots(avocado.poses, function(add) {

  add.creator('row', Object.create(avocado.poses['abstract']));

});


thisModule.addSlots(avocado.poses.row, function(add) {

  add.method('initialize', function ($super, name, posers) {
    $super(name);
    this._posers = posers;
  });

  add.method('eachElement', function (f, startingPos) {
    var sortedPosersToMove = this._posers.sort(function(m1, m2) {
      var n1 = m1.inspect();
      var n2 = m2.inspect();
      return n1 < n2 ? -1 : n1 === n2 ? 0 : 1;
    });

    var padding = pt(0,0);
    var pos = startingPos || pt(0,0);
    
    for (var i = 0, n = sortedPosersToMove.length; i < n; ++i) {
      var poser = sortedPosersToMove[i];
      f({poser: poser, position: pos});
      var poserSpace = poser.getExtent().scaleBy(poser.getScale());
      pos = pos.withX(pos.x + poserSpace.x + padding.x);
    }
  });

});


thisModule.addSlots(avocado.poses, function(add) {

  add.creator('snapshot', Object.create(avocado.poses['abstract']));

  add.creator('manager', {});

  add.creator('layout', {});

  add.method('addGlobalCommandsTo', function (menu) {
    avocado.ui.currentWorld().poseManager().addGlobalCommandsTo(menu);
  }, {category: ['menu']});

  add.method('makeMorphsBecomeDirectSubmorphOfWorld', function (world, morphs) {
    var owners = [];
    morphs.forEach(function(m) { var o = m.getOwner(); if (!owners.include(o)) { owners.push(o); }});
    
    var layoutBatcherUppers = [];
    owners.forEach(function(o) {
      layoutBatcherUppers.push(o.layoutRejiggeringBatcherUpper());
      if (o._layout && o._layout.submorphReplacementBatcherUpper) { layoutBatcherUppers.push(o._layout.submorphReplacementBatcherUpper()); }
    });
    
    try {
      layoutBatcherUppers.forEach(function(bu) { bu.start(); });

      morphs.forEach(function(m) {
        // necessary so that the pose can know the correct final extent of the morphToShow when calculating positions
        m.becomeDirectSubmorphOfWorld(world);

        // aaa - hack to make the really-small-text disappear as desired
        var p = m._placeholderMorphIJustCameFrom;
        if (p) { p.refreshContentOfMeAndSubmorphs(); }
      });
    } finally {
      layoutBatcherUppers.forEach(function(bu) { bu.stop(); });
    }
  });

});


thisModule.addSlots(avocado.poses.snapshot, function(add) {

  add.method('initialize', function ($super, name, posers) {
    $super(name);
    this._elements = [];
    posers.each(function(m) {
      if (! m.shouldIgnorePoses()) {
        this.addElement({poser: m, position: m.getPosition(), uiState: m.constructUIStateMemento()});
      }
    }.bind(this));
  });

  add.method('addElement', function (elem) {
    this._elements.push(elem);
  });

  add.method('eachElement', function (f, startingPos) {
    this._elements.each(f);
  });

  add.method('addParamsForServerMessageTo', function (params, org) {
    for (var i = 0, n = this._elements.length; i < n; ++i) {
      var elem = this._elements[i];
      // aaa - handle other kinds of posers, not just mirrors
      params["poser"   + i] = elem.poser.isMirrorMorph ? "mirror(" + org.nameOfReflecteeOf(elem.poser.mirror()) + ")" : "unknown";
      params["pos"     + i] = elem.position.toString();
      params["uiState" + i] = Object.toJSON(elem.uiState);
    }
  });

});


thisModule.addSlots(avocado.poses.manager, function(add) {

  add.method('initialize', function (container) {
    this._container = container;
  }, {category: ['creating']});

  add.method('container', function () {
    return this._container;
  }, {category: ['accessing']});

  add.method('explicitlyRememberedPoses', function () {
    return avocado.organization.current.poses();
  }, {category: ['explicitly remembering']});

  add.method('undoPoseStack', function () {
    return this._undoPoseStack || (this._undoPoseStack = []);
  }, {category: ['undo']});

  add.method('undoPoseStackIndex', function () {
    if (this._undoPoseStackIndex === undefined) { this._undoPoseStackIndex = this.undoPoseStack().size(); }
    return this._undoPoseStackIndex;
  }, {category: ['undo']});

  add.method('addToUndoPoseStack', function (pose) {
    var i = this.undoPoseStackIndex();
    var stack = this.undoPoseStack();
    stack.splice(i, stack.size() - i, pose);
    this._undoPoseStackIndex += 1;
  }, {category: ['undo']});

  add.method('canGoBackToPreviousPose', function () {
    return this.undoPoseStackIndex() > 0;
  });

  add.method('canGoForwardToNextPose', function () {
    return this.undoPoseStackIndex() < this.undoPoseStack().size() - 1;
  });

  add.method('goBackToPreviousPose', function (callWhenDone) {
    if (! this.canGoBackToPreviousPose()) { throw "there is nothing to go back to"; }

    if (this.undoPoseStackIndex() === this.undoPoseStack().size()) {
      this.addToUndoPoseStack(this.createSnapshotOfCurrentPose(avocado.organization.current.findUnusedPoseName())); // so that we can go forward to it
      this._undoPoseStackIndex -= 1; // reset the index
    }

    var pose = this.undoPoseStack()[this._undoPoseStackIndex -= 1];
    pose.recreateInContainer(this.container(), undefined, callWhenDone);
  });

  add.method('goForwardToNextPose', function (callWhenDone) {
    if (! this.canGoForwardToNextPose()) { throw "there is nothing to go forward to"; }
    var pose = this.undoPoseStack()[this._undoPoseStackIndex += 1];
    pose.recreateInContainer(this.container(), undefined, callWhenDone);
  });

  add.method('assumePose', function (pose, startingPos, callWhenDone) {
    this.addToUndoPoseStack(this.createSnapshotOfCurrentPose(avocado.organization.current.findUnusedPoseName()));
    pose.recreateInContainer(this.container(), startingPos, callWhenDone);
  }, {category: ['poses']});

  add.method('createSnapshotOfCurrentPose', function (poseName) {
    return avocado.poses.snapshot.create(poseName, this.container().posers());
  }, {category: ['taking snapshots']});

  add.method('rememberThisPose', function () {
    avocado.organization.current.promptForPoseName(function(n) {
      avocado.organization.current.rememberPose(this.createSnapshotOfCurrentPose(n));
    }.bind(this));
  }, {category: ['taking snapshots']});

  add.method('cleaningUpPose', function (posers, name) {
    return avocado.poses.list.create(name || "clean up", function() { return this.container().getExtent(); }.bind(this), posers || this.container().posers()).beCollapsing();
  }, {category: ['cleaning up']});

  add.method('rowPose', function (posers, name) {
    return avocado.poses.row.create(name || "row", posers || this.container().posers());
  }, {category: ['cleaning up']});

  add.method('listPoseOfMorphsFor', function (objects, name) {
    return avocado.poses.list.create(name).setMaxExtent(function() { return this.container().getExtent(); }.bind(this)).setPoserModels(objects);
  }, {category: ['cleaning up']});

  add.method('poseChooser', function () {
    var c = avocado.command.list.create(this);
    this.explicitlyRememberedPoses().eachValue(function(pose) {
      c.addItem([pose.name(), function(evt) { this.assumePose(pose); }]);
    }.bind(this));
    return c;
  }, {category: ['menus']});

  add.method('addGlobalCommandsTo', function (cmdList) {
    cmdList.addLine();
    
    cmdList.addItem(["clean up", function(evt) {
      this.assumePose(this.cleaningUpPose());
    }.bind(this)]);

    var poseCommands = [];
    
    poseCommands.push(["remember this pose", function(evt) {
      this.rememberThisPose();
    }.bind(this)]);

    if (this.explicitlyRememberedPoses().size() > 0) {
      poseCommands.push(["assume a pose...", function(evt) {
        avocado.ui.showMenu(this.poseChooser(), this.container(), null, evt);
      }.bind(this)]);
    }

    if (this.canGoBackToPreviousPose()) {
      poseCommands.push(["back to previous pose", function(evt) {
        this.goBackToPreviousPose();
      }.bind(this)]);
    }

    if (this.canGoForwardToNextPose()) {
      poseCommands.push(["forward to next pose", function(evt) {
        this.goForwardToNextPose();
      }.bind(this)]);
    }
    
    cmdList.addItem(["poses...", poseCommands]);
  }, {category: ['menus']});

});


thisModule.addSlots(avocado.poses.layout, function(add) {

  add.method('initialize', function (pose) {
    this._pose = pose;
  }, {category: ['creating']});

  add.method('pose', function () {
    return this._pose;
  }, {category: ['accessing']});

  add.method('isAffectedBy', function (operation, morph) {
    return ! morph.shouldIgnorePoses();
  }, {category: ['layout']});

  add.method('dismissMorphs', function (morphsToDismiss, callWhenDone) {
    avocado.callbackWaiter.on(function(createCallbackForDismissingThisOne) {
      morphsToDismiss.forEach(function(morphToDismiss) {
        var callbackForDismissingThisOne = createCallbackForDismissingThisOne();
        setTimeout(function() { morphToDismiss.putBackOrDismiss(callbackForDismissingThisOne); }, 0);
      });
    }, callWhenDone, "dismissing the old morphs");
  }, {category: ['setting morphs']});

  add.method('setTitleContent', function (containerMorph, titleContent) {
    if (titleContent) {
      var titleLabel = containerMorph.findTitleLabel();
      if (titleLabel) {
        titleLabel._model.setContent(titleContent);
        titleLabel.refreshContent();
      }
    }
  }, {category: ['setting morphs']});

  add.method('addMorphs', function (containerMorph, morphsToShow, callWhenDone) {
    var world = containerMorph.world() || avocado.ui.currentWorld();
    avocado.poses.makeMorphsBecomeDirectSubmorphOfWorld(world, morphsToShow);
    var pose = this.pose().copy().setPosers(morphsToShow);
    pose.recreateInContainer(containerMorph, pt(0, 0), function() {
      world.fixFonts();
      if (callWhenDone) { callWhenDone(); }
    });
  }, {category: ['setting morphs']});

  add.method('showMorphs', function (containerMorph, morphsToShow, titleContent, callWhenOldMorphsHaveBeenDismissed, callWhenNewMorphsAreInPlace) {
    var morphsToDismiss = containerMorph.submorphEnumerator().toArray().select(function(m) { return ! morphsToShow.include(m); });
    this.dismissMorphs(morphsToDismiss, function() {
      if (callWhenOldMorphsHaveBeenDismissed) { callWhenOldMorphsHaveBeenDismissed(); }
      this.addMorphs(containerMorph, morphsToShow, callWhenNewMorphsAreInPlace);
      this.setTitleContent(containerMorph, titleContent); // no need to wait until the new morphs are in place
    }.bind(this));
  }, {category: ['setting morphs']});

});


});

avocado.transporter.module.onLoadCallbacks["lk_ext/poses"] = function() {};
avocado.transporter.module.create('lk_ext/poses', function(requires) {

requires('general_ui/poses');

}, function(thisModule) {


thisModule.addSlots(MenuMorph.prototype, function(add) {

  add.method('shouldIgnorePoses', function () {
    return ! this.stayUp;
  }, {category: ['poses']});

});


thisModule.addSlots(WorldMorph.prototype, function(add) {

  add.method('promptForPoint', function (callback) {
    var markerMorph = new Morph(new lively.scene.Ellipse(pt(0,0), 3));
    markerMorph.wasJustDroppedOnWorld = function(w) {
      var p = this.getPosition();
      this.remove();
      callback(p);
    };
    markerMorph.grabMeWithoutZoomingAroundFirst(Event.createFake());
  }, {category: ['poses']});

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/models"] = function() {};
avocado.transporter.module.create('general_ui/models', function(requires) {

requires('general_ui/basic_morph_mixins');

}, function(thisModule) {


thisModule.addSlots(avocado.morphMixins.Morph, function(add) {

  add.method('setModel', function (m) {
    this._model = m;
    return this;
  }, {category: ['models']});

  add.method('inspect', function () {
		try {
      if (this._model && typeof(this._model.inspect) === 'function') { return this._model.inspect(); } // added by Adam
			return this.toString();
		} catch (err) {
			return "#<inspect error: " + err + ">";
		}
  }, {category: ['printing']});

  add.method('toString', function () {
    var t = this.findTitleLabel();
    if (t && t.getText) { return t.getText(); }
    if (this._model) { return this._model.toString(); }
    if (this.typeName) { return "a " + this.typeName; }
    if (this._layout && this._layout.morphDescription) { return this._layout.morphDescription(this); }
    return ""; // the default behaviour is annoying - makes morph mirrors very wide;
  }, {category: ['printing']});

  add.method('enclosingObjectHavingANameInScheme', function (namingScheme) {
	  var m = this.getOwner();
	  while (m) {
	    if (m._model && m._model.namingScheme) {
	      if (m._model.namingScheme === namingScheme) { return m._model; }
	    }
	    m = m.getOwner();
	  }
	  return null;
  }, {category: ['printing']});

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/applications"] = function() {};
avocado.transporter.module.create('general_ui/applications', function(requires) {

requires('general_ui/basic_morph_mixins');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('applicationList', {}, {category: ['user interface']});

});


thisModule.addSlots(avocado.applicationList, function(add) {

  add.method('worldName', function () {
    var appNames = [];
    this.applications().each(function(app) {
      if (typeof(app.worldName) === 'function') {
        var n = app.worldName();
        if (n) {appNames.push(n);}
      }
    });
    return appNames.join(", ");
  }, {category: ['printing']});

  add.data('_applications', null, {category: ['accessing'], initializeTo: 'null'});

  add.method('applications', function () {
    if (! this._applications) {
      this.setApplications(this._applications || []);
    }
    return this._applications;
  }, {category: ['accessing']});

  add.method('setApplications', function (apps) {
    this._applications = apps;
    return this;
  }, {category: ['accessing']});

  add.method('addApplication', function (app) {
    var apps = this.applications();
    if (! apps.include(app)) {
      apps.push(app);
    }
  }, {category: ['adding']});

  add.method('commands', function () {
    var cmdList = avocado.command.list.create();
    this.applications().each(function(app) { app.addGlobalCommandsTo(cmdList); });
    if (cmdList.size() === 0) { return null; }
    return cmdList;
  }, {category: ['commands']});

  add.creator('adapter', {});

});


thisModule.addSlots(avocado.applicationList.adapter, function(add) {

  add.method('initialize', function (obj) {
    this._objectWhoseCommandsShouldBeGlobal = obj;
  }, {category: ['creating']});

  add.method('addGlobalCommandsTo', function (cmdList) {
    cmdList.addAllCommands(this._objectWhoseCommandsShouldBeGlobal.commands());
  }, {category: ['creating']});

});


thisModule.addSlots(avocado.morphMixins.WorldMorph, function(add) {

  add.method('applicationList', function () {
    return avocado.applicationList;
  }, {category: ['applications']});

  add.method('inspect', function () {
    return this.applicationList().worldName();
  }, {category: ['printing']});

  add.method('commands', function () {
    return this.applicationList().commands();
  }, {category: ['commands']});

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/one_morph_per_object"] = function() {};
avocado.transporter.module.create('general_ui/one_morph_per_object', function(requires) {

requires('general_ui/basic_morph_mixins');

}, function(thisModule) {


thisModule.addSlots(avocado.morphMixins.WorldMorph, function(add) {

  add.data('_morphsByObject', null, {category: ['one morph per object'], initializeTo: 'null'});

  add.method('morphsByObject', function () {
    return this._morphsByObject || (this._morphsByObject = avocado.dictionary.copyRemoveAll(avocado.morphIdentityComparator));
  }, {category: ['one morph per object']});

  add.method('existingMorphFor', function (obj) {
    return this.morphsByObject().get(obj);
  }, {category: ['one morph per object']});

  add.method('forgetAboutExistingMorphFor', function (obj, expectedOne) {
    var existingOne = this.morphsByObject().get(obj);
    if (existingOne === expectedOne) { this.morphsByObject().removeKey(obj); }
  }, {category: ['one morph per object']});

  add.method('morphFor', function (obj) {
    return this.morphsByObject().getOrIfAbsentPut(obj, function() {
      return this.newMorphFor(obj);
    }.bind(this));
  }, {category: ['one morph per object']});

  add.method('newMorphFor', function (obj) {
    var isNullOrUndefined = obj === null || typeof(obj) === 'undefined';
    if (!isNullOrUndefined && typeof(obj.newMorph) === 'function') {
      return obj.newMorph();
    } else {
      var str = isNullOrUndefined ? "" + obj : obj.toString();
      return avocado.messageNotifier.create(str, Color.yellow.lighter()).newMorph().setModel(obj);
    }
  }, {category: ['one morph per object']});

  add.method('rememberMorphFor', function (obj, morph) {
    this.morphsByObject().put(obj, morph);
    return morph;
  }, {category: ['one morph per object']});

});


thisModule.addSlots(avocado, function(add) {

  add.creator('morphIdentityComparator', {}, {category: ['user interface', 'one morph per object']});

});


thisModule.addSlots(avocado.morphIdentityComparator, function(add) {

  add.method('keysAreEqual', function (k1, k2) {
    var c = (k1 !== null && typeof(k1) !== 'undefined' && k1.isImmutableForMorphIdentity) ? avocado.hashTable.equalityComparator : avocado.hashTable.identityComparator;
    return c.keysAreEqual(k1, k2);
  }, {category: ['hashing']});

  add.method('hashCodeForKey', function (k) {
    var c = (k !== null && typeof(k) !== 'undefined' && k.isImmutableForMorphIdentity) ? avocado.hashTable.equalityComparator : avocado.hashTable.identityComparator;
    return c.hashCodeForKey(k);
  }, {category: ['hashing']});

});


thisModule.addSlots(avocado.morphMixins.Morph, function(add) {

  add.method('actualMorphToShow', function (context) {
    // If this morph is already elsewhere in the world, don't yank it from there, just show a placeholder.
    if (typeof(this._model) !== 'undefined' && (!this.ownerChainIncludes(context)) && this.world()) {
      return context.placeholderForMorph(this);
    }
    
    return this;
  });

  add.method('placeholdersByMorph', function () {
    return this._placeholdersByMorph || (this._placeholdersByMorph = avocado.dictionary.copyRemoveAll(avocado.dictionary.identityComparator));
  }, {category: ['one morph per object']});

  add.method('placeholderForMorph', function (morph) {
    return this.placeholdersByMorph().getOrIfAbsentPut(morph, function() {
      return avocado.placeholder.newPlaceholderMorphForMorph(morph);
    });
  }, {category: ['one morph per object']});

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/layout"] = function() {};
avocado.transporter.module.create('general_ui/layout', function(requires) {

requires('general_ui/basic_morph_mixins');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('LayoutModes', {}, {category: ['avocado', 'user interface']});

});


thisModule.addSlots(avocado.morphMixins.Morph, function(add) {

  add.method('minimumExtent', function () {
    if (this._layout && this._layout.minimumExtent) {
      return this._layout.minimumExtent(this);
    } else {
      // aaa - meh, don't bother caching yet, I'm scared that I haven't done this right
      var e = this.getExtent();
      this._cachedMinimumExtent = e;
      return e.scaleBy(this.getScale());
    }
  }, {category: ['layout']});

  add.method('rejiggerTheLayoutOfMySubmorphs', function () {
    this.eachSubmorph(function(m) {
      m.rejiggerTheLayout(m.getExtent().scaleBy(m.getScale()));
    });
  }, {category: ['layout']});

  add.method('rejiggerJustMyLayout', function (availableSpace) {
    // can be overridden by morphs that want to do special layout stuff, like TableMorph
    
    var availableSpaceToUse = availableSpace.scaleBy(1 / this.getScale());
    
    var oldExtent = this.getExtent();
    var newExtent = oldExtent;

    // Avoid infinite recursion... blecch.
    if (! this._isChangingRightNow) {
      this._isChangingRightNow = true;

      if (this.horizontalLayoutMode === avocado.LayoutModes.SpaceFill) { newExtent = newExtent.withX(availableSpaceToUse.x); }
      if (this.  verticalLayoutMode === avocado.LayoutModes.SpaceFill) { newExtent = newExtent.withY(availableSpaceToUse.y); }
      
      // aaa - not sure this is right, but I want it for HTML morphs
      var minExtent = this._cachedMinimumExtent;
      if (minExtent && this.horizontalLayoutMode === avocado.LayoutModes.ShrinkWrap) { newExtent = newExtent.withX(minExtent.x); }
      if (minExtent && this.  verticalLayoutMode === avocado.LayoutModes.ShrinkWrap) { newExtent = newExtent.withY(minExtent.y); }
      
      if (! oldExtent.eqPt(newExtent)) { this.setExtent(newExtent); }

      delete this._isChangingRightNow;
    }
    return newExtent.scaleBy(this.getScale());
  }, {category: ['layout']});

  add.method('rejiggerTheLayout', function (availableSpace) {
    if (this._layout && this._layout.rejigger) {
      return this._layout.rejigger(this, availableSpace);
    } else {
      this.rejiggerTheLayoutOfMySubmorphs();
      return this.rejiggerJustMyLayout(availableSpace);
    }
  }, {category: ['layout']});

  add.method('hasMinimumExtentActuallyChanged', function () {
    var old_cachedMinimumExtent = this._cachedMinimumExtent;
    this._cachedMinimumExtent = null;
    this.minimumExtent();
    var newMinimumExtent = this._cachedMinimumExtent;
    return ! (old_cachedMinimumExtent && old_cachedMinimumExtent.eqPt(newMinimumExtent));
  }, {category: ['layout']});

  add.method('minimumExtentMayHaveChanged', function () {
    if (! this.hasMinimumExtentActuallyChanged()) { return false; }
    this.forceLayoutRejiggering(true);
    return true;
  }, {category: ['layout']});

  add.method('possiblyDoSomethingBecauseASubmorphMinimumExtentHasChanged', function () {
    // can be overridden by morphs that want to trigger a higher-level rejiggering;
    // return true to tell the caller not to bother with the lower-level rejiggering

    if (this._layout && this._layout.possiblyDoSomethingBecauseASubmorphMinimumExtentHasChanged) {
      return this._layout.possiblyDoSomethingBecauseASubmorphMinimumExtentHasChanged(this);
    }
    
    return false;
  }, {category: ['layout']});

  add.method('layoutRejiggeringBatcherUpper', function () {
    if (! this._layoutRejiggeringBatcherUpper) {
      this._layoutRejiggeringBatcherUpper = avocado.batcherUpper.create(this, function() {
        this._context.forceLayoutRejiggering(this._isMinimumExtentKnownToHaveChangedWhileBatching);
      }, function(isMinimumExtentKnownToHaveChanged) {
        if (isMinimumExtentKnownToHaveChanged) { this._isMinimumExtentKnownToHaveChangedWhileBatching = true; }
      }, function() {
        delete this._isMinimumExtentKnownToHaveChangedWhileBatching;
      });
    }
    return this._layoutRejiggeringBatcherUpper;
  }, {category: ['layout']});

  add.method('forceLayoutRejiggering', function (isMinimumExtentKnownToHaveChanged) {
    if (this._layoutRejiggeringBatcherUpper && this._layoutRejiggeringBatcherUpper.isRunning()) {
      this._layoutRejiggeringBatcherUpper.batchUp(isMinimumExtentKnownToHaveChanged);
      return;
    }

    this._layoutIsStillValid = false;

    var doesMyOwnerNeedToKnow = isMinimumExtentKnownToHaveChanged || this.hasMinimumExtentActuallyChanged();
    var o = this.getOwner();
    if (!o || o.isWorld || o.isHand) {
      this.rejiggerTheLayout(pt(100000, 100000));
      return;
    }
    if (doesMyOwnerNeedToKnow) { 
      var layoutRejiggeringHasBeenTriggeredHigherUp = o.possiblyDoSomethingBecauseASubmorphMinimumExtentHasChanged();
      if (layoutRejiggeringHasBeenTriggeredHigherUp) { return; }
    }
    if (this._spaceUsedLastTime) {
      var scaledSpaceToUse = this._spaceUsedLastTime.scaleBy(this.getScale());
      this.rejiggerTheLayout(scaledSpaceToUse);
    } else {
      o.forceLayoutRejiggering();
    }
  }, {category: ['layout']});

  add.method('forceLayoutRejiggeringIfNecessaryAfter', function (operation, m) {
    if (this._layout) {
      if (this._layout.isAffectedBy(operation, m)) {
        this.forceLayoutRejiggering();
      }
    }
  }, {category: ['layout']});

  add.method('layout', function () {
    return this._layout;
  }, {category: ['layout']});

  add.method('setLayout', function (layout) {
    this._layout = layout;
    if (this._debugMode) { layout._debugMode = true; }
    if (layout.initializeLayoutOf) { layout.initializeLayoutOf(this); }
    return this;
  }, {category: ['layout']});

  add.method('submorphsParticipatingInLayout', function () {
    var layout = this._layout;
    return this.submorphEnumerator().select(function(m) { return !layout || layout.isAffectedBy(null, m); });
  }, {category: ['iterating']});

  add.method('addMorphs', function (morphsToAdd, shouldNotForceLayoutRejiggering) {
    var thisMorph = this;
    morphsToAdd.forEach(function(m) { thisMorph.addMorph(m, true); });
    if (! shouldNotForceLayoutRejiggering) { this.forceLayoutRejiggering(); }
  }, {category: ['adding and removing']});

  add.method('removeMorphs', function (morphsToRemove, shouldNotForceLayoutRejiggering) {
    var thisMorph = this;
    morphsToRemove.toArray().forEach(function(m) { thisMorph.removeMorph(m, true); });
    if (! shouldNotForceLayoutRejiggering) { this.forceLayoutRejiggering(); }
  }, {category: ['adding and removing']});

  add.method('replaceMorphs', function (morphsToRemove, morphsToAdd, shouldNotForceLayoutRejiggering) {
    this.removeMorphs(morphsToRemove, true);
    this.addMorphs(morphsToAdd, true);
    if (! shouldNotForceLayoutRejiggering) { this.forceLayoutRejiggering(); }
  }, {category: ['adding and removing']});

  add.method('beSpaceFilling', function () {
    this.horizontalLayoutMode = avocado.LayoutModes.SpaceFill;
    this.  verticalLayoutMode = avocado.LayoutModes.SpaceFill;
    return this;
  }, {category: ['layout']});

  add.method('beShrinkWrapping', function () {
    this.horizontalLayoutMode = avocado.LayoutModes.ShrinkWrap;
    this.  verticalLayoutMode = avocado.LayoutModes.ShrinkWrap;
    return this;
  }, {category: ['layout']});

  add.method('beRigid', function () {
    this.horizontalLayoutMode = avocado.LayoutModes.Rigid;
    this.  verticalLayoutMode = avocado.LayoutModes.Rigid;
    return this;
  }, {category: ['layout']});

  add.method('layoutModes', function () {
    // aaa make the morph itself store them as a Point?
    return pt(this.horizontalLayoutMode, this.verticalLayoutMode);
  }, {category: ['layout']});

  add.method('setLayoutModes', function (layoutModes) {
    if (layoutModes.horizontalLayoutMode) { this.horizontalLayoutMode = layoutModes.horizontalLayoutMode; }
    if (layoutModes.  verticalLayoutMode) { this.  verticalLayoutMode = layoutModes.  verticalLayoutMode; }
    
    // This just seems cleaner. Maybe get rid of the old big wordy way.
    if (layoutModes.x)                    { this.horizontalLayoutMode = layoutModes.x;                    }
    if (layoutModes.y)                    { this.  verticalLayoutMode = layoutModes.y;                    }
    
    if (this._layout && this._layout.justSetLayoutModes) { this._layout.justSetLayoutModes(this); }
    return this;
  }, {category: ['layout']});

});


thisModule.addSlots(avocado.LayoutModes, function(add) {

  add.creator('Abstract', {});

});


thisModule.addSlots(avocado.LayoutModes.Abstract, function(add) {

  add.method('toString', function () {
    return this.name;
  });

});


thisModule.addSlots(avocado.LayoutModes, function(add) {

  add.creator('Rigid', Object.create(avocado.LayoutModes.Abstract));

});


thisModule.addSlots(avocado.LayoutModes.Rigid, function(add) {

  add.data('name', 'rigid');

});


thisModule.addSlots(avocado.LayoutModes, function(add) {

  add.creator('SpaceFill', Object.create(avocado.LayoutModes.Abstract));

});


thisModule.addSlots(avocado.LayoutModes.SpaceFill, function(add) {

  add.data('name', 'space-fill');

});


thisModule.addSlots(avocado.LayoutModes, function(add) {

  add.creator('ShrinkWrap', Object.create(avocado.LayoutModes.Abstract));

});


thisModule.addSlots(avocado.LayoutModes.ShrinkWrap, function(add) {

  add.data('name', 'shrink-wrap');

});


});

avocado.transporter.module.onLoadCallbacks["lk_ext/layout"] = function() {};
avocado.transporter.module.create('lk_ext/layout', function(requires) {

requires('general_ui/layout');

}, function(thisModule) {


thisModule.addSlots(TextMorph.prototype, function(add) {

  add.method('layoutChanged', function ($super) {
    var r = $super();
    this.adjustForNewBounds();          // make the focus halo look right
    this.minimumExtentMayHaveChanged(); // play nicely with my new layout system
    return r;
  });

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/active_sentence"] = function() {};
avocado.transporter.module.create('general_ui/active_sentence', function(requires) {

requires('general_ui/layout');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('activeSentence', {}, {category: ['user interface']});

});


thisModule.addSlots(avocado.activeSentence, function(add) {

  add.method('create', function () {
    var s = Object.create(this);
    s.initialize.apply(s, arguments);
    return s;
  }, {category: ['creating']});

  add.method('initialize', function (parts) {
    this.setParts(parts);
  }, {category: ['creating']});

  add.method('parts', function () {
    if (typeof(this._parts) === 'function') {
      return this._parts();
    } else {
      return this._parts;
    }
  }, {category: ['accessing']});

  add.method('setParts', function (parts) {
    this._parts = parts;
    return this;
  }, {category: ['accessing']});

  add.method('content', function () {
    return this._content;
  }, {category: ['accessing']});

  add.method('setContent', function (content) {
    this._content = content;
    return this;
  }, {category: ['accessing']});

  add.method('createHTMLNodesIn', function (parentNode) {
    this.parts().forEach(function(part, i) {
      var t = typeof(part);
      var partString;
      var isActive = false;
      if (t === 'function') {
        partString = part.call(this);
      } else if (t === 'string') {
        partString = part;
      } else {
        isActive = true;
        partString = "" + part.getValue();
      }
      
      if (! isActive) {
        parentNode.appendChild(document.createTextNode(partString));
      } else {
        var partTextNode = document.createTextNode(partString);
        if (typeof(part.doAction) === 'function') {
          var link = document.createElement("a");
          if (this._aaa_hack_linkStyleClass) { link.setAttribute("class", this._aaa_hack_linkStyleClass); }
          link.appendChild(partTextNode);
          link.onclick = function(evt) {
            part.doAction(new Event(evt).setHand(avocado.ui.currentWorld().firstHand()), link);
          };
          link.href = "#";
          parentNode.appendChild(link);
        } else {
          parentNode.appendChild(partTextNode);
        }
      }
    }.bind(this));
  }, {category: ['HTML']});

  add.method('newMorph', function () {
    var htmlMorph = avocado.html.newMorphWithBounds(new Rectangle(0, 0, this._aaa_hack_desiredWidth || 450, 23)).setModel(this).applyStyle(this.htmlMorphStyle);
    this.setContentsOfHTMLMorph(htmlMorph);
    if (this._aaa_hack_desiredScale) { htmlMorph.setScale(this._aaa_hack_desiredScale); }
    htmlMorph.beRigid(); // aaa - blecch, this is wrong, but for now I don't have any sentences that need to be more than one line high
    return htmlMorph;
  }, {category: ['user interface']});

  add.method('setContentsOfHTMLMorph', function (htmlMorph) {
    var div = document.createElement("div");
    if (this._aaa_hack_style) { div.style.cssText = this._aaa_hack_style; }
    this.createHTMLNodesIn(div);
    
    var bodyNode = htmlMorph.layout().bodyNode();
    while (bodyNode.hasChildNodes()) { bodyNode.removeChild(bodyNode.firstChild); }
    bodyNode.appendChild(div);
    
    if (false && this._aaa_hack_desiredSpace) {
      if (this._aaa_hack_desiredSpace.x) { htmlMorph.setScale(this._aaa_hack_desiredSpace.x / htmlMorph.getExtent().x); }
      if (this._aaa_hack_desiredSpace.y) { htmlMorph.setScale(this._aaa_hack_desiredSpace.y / htmlMorph.getExtent().y); }
    }
  }, {category: ['user interface']});

  add.creator('htmlMorphStyle', {}, {category: ['user interface']});

});


thisModule.addSlots(avocado.activeSentence.htmlMorphStyle, function(add) {

  add.data('fill', null);

  add.data('suppressGrabbing', true);

  add.data('openForDragAndDrop', false);

  add.data('horizontalLayoutMode', avocado.LayoutModes.SpaceFill);

  add.data('verticalLayoutMode', avocado.LayoutModes.ShrinkWrap);

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/similar_objects"] = function() {};
avocado.transporter.module.create('general_ui/similar_objects', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('groupOfSimilarObjects', {}, {category: ['user interface']});

});


thisModule.addSlots(avocado.groupOfSimilarObjects, function(add) {

  add.method('create', function () {
    var g = Object.create(this);
    g.initialize.apply(g, arguments);
    return g;
  }, {category: ['creating']});

  add.method('initialize', function (objects, commonProperties) {
    this._objects = objects;
    this._commonProperties = commonProperties;
  }, {category: ['creating']});

  add.method('toString', function () {
    return "Group of somethings";
  }, {category: ['printing']});

  add.method('eachObject', function (f) {
    this._objects.forEach(f);
  }, {category: ['iterating']});

  add.method('disableHeader', function () {
    this._disableHeader = true;
    return this;
  }, {category: ['header']});

  add.method('enableHeader', function () {
    this._disableHeader = false;
    return this;
  }, {category: ['header']});

  add.method('disableObjectNames', function () {
    this._disableObjectNames = true;
    return this;
  }, {category: ['header']});

  add.method('enableObjectNames', function () {
    this._disableObjectNames = false;
    return this;
  }, {category: ['header']});

  add.method('beVertical', function () {
    this._shouldTableBeVertical = true;
    return this;
  }, {category: ['direction']});

  add.method('beHorizontal', function () {
    this._shouldTableBeVertical = false;
    return this;
  }, {category: ['direction']});

  add.method('newMorph', function () {
    var morph = avocado.ui.newMorph().useTableLayout(this._shouldTableBeVertical ? avocado.table.contents.columnPrototype : avocado.table.contents.rowPrototype);
    morph.setModel(this).applyStyle(this.defaultMorphStyle);
    morph.setPotentialContentMorphsFunction(function() {
      var commonProperties = this._commonProperties;
      if (!commonProperties) {
        var setOfCommonProperties = avocado.set.copyRemoveAll();
        // aaa - this'll be slow for big lists of objects; maybe allow the option of just using the first one?
        this._objects.forEach(function(o) {
          o.propertiesToShow().forEach(function(p) { setOfCommonProperties.add(p); });
        });
        commonProperties = setOfCommonProperties.toArray().sort();
      }
      
      var cells = [];
      if (! this._disableHeader) {
        var header = [];
        if (! this._disableObjectNames) { header.push(avocado.label.newMorphFor("")); }
        commonProperties.forEach(function(p) { header.push(avocado.label.create(p).setEmphasis(avocado.label.emphasiseses.bold).newMorph()); }); 
        cells.push(header);
      }
      var world = avocado.ui.currentWorld();
      this._objects.forEach(function(o) {
        var line = [];
        var objectName = o && o.namingScheme ? o.namingScheme.nameInContext(o, morph) : "" + o;
        if (! this._disableObjectNames) { line.push(avocado.label.create(objectName).setEmphasis(avocado.label.emphasiseses.bold).newMorph()); }
        commonProperties.forEach(function(p) {
          var v;
          if (typeof(o.valueOfProperty) === 'function') {
            v = o.valueOfProperty(p);
          } else {
            v = o[p].call(o);
          }
          
          var valueMorph;
          if (typeof(v) === 'string') {
            valueMorph = avocado.label.newMorphFor(v);
          } else if (v && v.isMorph) {
            valueMorph = v;
          } else {
            valueMorph = world.morphFor(v);
          }
          // aaa - I like the idea, but this doesn't end up looking quite right.
          // if (typeof(o.updateStyleOfMorph) === 'function') { o.updateStyleOfMorph(valueMorph); }
          line.push(valueMorph);
        });
        cells.push(line);
      }.bind(this));
      return avocado.table.contents.create(cells, this._shouldTableBeVertical ? avocado.directions.vertical : avocado.directions.horizontal);
    }.bind(this));
    morph.refreshContentOfMeAndSubmorphs();
    return morph;
  }, {category: ['user interface']});

  add.creator('defaultMorphStyle', {}, {category: ['user interface']});

});


thisModule.addSlots(avocado.groupOfSimilarObjects.defaultMorphStyle, function(add) {

  add.data('fill', null);

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/styles"] = function() {};
avocado.transporter.module.create('general_ui/styles', function(requires) {

requires('general_ui/basic_morph_mixins');

}, function(thisModule) {


thisModule.addSlots(avocado.morphMixins.Morph, function(add) {

  add.method('setStylist', function (stylist) {
	  this._stylist = stylist;
	  return this;
	}, {category: ['styles']});

  add.method('nonNullFillInMeOrOwners', function () {
    var m = this;
    while (m) {
      var fill = m.getFill();
      if (fill) { return fill; }
      m = m.getOwner();
    }
    return null;
  }, {category: ['drag and drop']});

  add.method('styleForWhenNotEmbeddedInAnythingElse', function () {
    return {
      horizontalLayoutMode: avocado.LayoutModes.ShrinkWrap,
        verticalLayoutMode: avocado.LayoutModes.ShrinkWrap,
                      fill: this.nonNullFillInMeOrOwners()
    };
  }, {category: ['drag and drop']});

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/refreshing_content"] = function() {};
avocado.transporter.module.create('general_ui/refreshing_content', function(requires) {

requires('general_ui/basic_morph_mixins');

}, function(thisModule) {


thisModule.addSlots(avocado.morphMixins.Morph, function(add) {

  add.method('refreshContentOfMeAndSubmorphs', function () {
    this._hasBeenRefreshedAtLeastOnce = true;
    this.refreshContent();
    this.eachSubmorph(function(m) { m.refreshContentOfMeAndSubmorphs(); });
    return this;
  });

  add.method('refreshContentIfOnScreenOfMeAndSubmorphs', function () {
    if (! this.isOnScreen()) { return this; }
    // var s = this.toString() || this.inspect();
    // if (s) { console.log("refreshContentIfOnScreenOfMeAndSubmorphs: refreshing " + s); }

    this._hasBeenRefreshedAtLeastOnce = true;
    this.refreshContent();
    this.eachSubmorph(function(m) { m.refreshContentIfOnScreenOfMeAndSubmorphs(); });
    return this;
  });

  add.method('refreshContent', function () {
    // children can override
    this.updateStyle();
    
    if (this._layout && typeof(this._layout.refreshContent) === 'function') {
      this._layout.refreshContent(this);
    }
    
    var recalculatedActualContent = this.recalculateActualContent();
    if (recalculatedActualContent) {
      this.replaceContentWith(recalculatedActualContent);
    }
  });

  add.method('refreshContentOfMeAndSubmorphsIfNeverRefreshedBefore', function () {
    if (! this._hasBeenRefreshedAtLeastOnce) {
      this.refreshContentOfMeAndSubmorphs();
    }
  });

  add.method('recalculateActualContent', function () {
    var potentialContentMorphs = this.potentialContentMorphs();
    if (potentialContentMorphs) {
      var context = this;
      var layoutModesForContentMorphs = this._layoutModesForContentMorphs;
      var actualContentMorphs = potentialContentMorphs.selectThenMap(function(morphOrToggler) {
        return !!morphOrToggler.actualMorphToShow(context);
      }, function(morphOrToggler) {
        var actualMorph = morphOrToggler.actualMorphToShow(context);
        if (layoutModesForContentMorphs) { actualMorph.setLayoutModes(layoutModesForContentMorphs); }
        return actualMorph;
      });
      return actualContentMorphs;
    } else {
      return null;
    }
  }, {category: ['potential content']});

  add.method('replaceContentWith', function (newContent) {
    if (this._layout && this._layout.replaceContentWith) {
      this.layout().replaceContentWith(newContent);
      return this;
    }
    
    throw new Error("To use the potentialContentMorphs mechanism, the morph or the layout must override replaceContentWith.");
  }, {category: ['potential content']});

  add.method('makeContentMorphsHaveLayoutModes', function (layoutModes) {
    // aaa - kind of a hack, but better than having it directly in the TreeNodeMorph code
    this._layoutModesForContentMorphs = layoutModes;
    return this;
  }, {category: ['layout']});

  add.method('potentialContentMorphs', function () {
    // children can override, or specify a _potentialContentCreator, or call setPotentialContentMorphs or setPotentialContentMorphsFunction
    
    if (this._potentialContentMorphs) { return this._potentialContentMorphs; }
    
    if (this._potentialContentCreator) { return this._potentialContentCreator.potentialContentMorphsForMorph(this); }
    
    return null;
  }, {category: ['potential content']});

  add.method('setPotentialContentMorphs', function (content) {
    this._potentialContentMorphs = content;
  }, {category: ['potential content']});

  add.method('setPotentialContentMorphsFunction', function (contentFunction) {
    this.potentialContentMorphs = contentFunction;
  }, {category: ['potential content']});

  add.method('updateStyle', function () {
    // children can override
    if (this._model && typeof(this._model.updateStyleOfMorph) === 'function') {
      this._model.updateStyleOfMorph(this);
    }
  });

  add.method('startPeriodicallyUpdating', function (frequency) {
    this._updater = new PeriodicalExecuter(function(pe) {
      if (window.shouldNotDoAnyPeriodicalMorphUpdating) { pe.stop(); return; }
      this.refreshContentIfOnScreenOfMeAndSubmorphs();
    }.bind(this), frequency || 8);
    return this;
  });

  add.method('isPeriodicallyUpdating', function () {
    return this._updater && this._updater.timer;
  });

  add.method('justChangedContent', function () {
    // children can override
    if (this._layout && typeof(this._layout.justChangedContent) === 'function') {
      this._layout.justChangedContent(this);
    }
  }, {category: ['updating']});

  add.method('ensureVisible', function () {
    this.morphsThatNeedToBeVisibleBeforeICanBeVisible().forEach(function(morph) { morph.ensureVisibleForJustMe(); });
    this.ensureVisibleForJustMe();
    this.topmostOwnerBesidesTheWorldAndTheHand().refreshContentIfOnScreenOfMeAndSubmorphs();
  }, {category: ['updating']});

  add.method('morphsThatNeedToBeVisibleBeforeICanBeVisible', function () {
    // children can override
    return [];
  }, {category: ['updating']});

  add.method('ensureVisibleForJustMe', function () {
    // children can override;
  }, {category: ['updating']});

  add.method('wasJustAdded', function (evt) {
    // aaa - not sure this really belongs here, used to be on TreeNodeMorph
    this.ensureVisible();

    var uiState = this.desiredUIStateAfterBeingAdded;
    if (typeof(uiState) === 'function') { uiState = uiState.call(this); }
    this.assumeUIState(uiState, null, evt);
    
    var titleLabel = this.findTitleLabel();
    if (titleLabel) { titleLabel.wasJustAdded(evt); }
  }, {category: ['events']});

});


thisModule.addSlots(avocado.morphMixins.TextMorph, function(add) {

  add.method('refreshContent', function () {
    avocado.morphMixins.Morph.refreshContent.call(this);
    if (this.refreshText) { this.refreshText(); }
  });

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/animation"] = function() {};
avocado.transporter.module.create('general_ui/animation', function(requires) {

requires('general_ui/animation_math');
requires('general_ui/basic_morph_mixins');

}, function(thisModule) {


thisModule.addSlots(avocado.morphMixins.Morph, function(add) {

  add.method('startWhooshingTo', function (loc, shouldAnticipateAtStart, shouldWiggleAtEnd, callback) {
    return this.startAnimating(avocado.animation.newMovement(this, avocado.ui.aaa_isArcPathBroken ? avocado.animation.straightPath : avocado.animation.arcPath, loc, 3 / avocado.ui.currentWorld().getScale(), shouldAnticipateAtStart, shouldWiggleAtEnd, !shouldWiggleAtEnd), callback);
  }, {category: ['whooshing around']});

  add.method('startWhooshingInAStraightLineTo', function (loc, shouldAnticipateAtStart, shouldWiggleAtEnd, shouldDecelerateAtEnd, callback) {
    return this.startAnimating(avocado.animation.newMovement(this, avocado.animation.straightPath, loc, 2 / avocado.ui.currentWorld().getScale(), shouldAnticipateAtStart, shouldWiggleAtEnd, shouldDecelerateAtEnd), callback);
  }, {category: ['whooshing around']});

  add.method('whooshAwayAfter', function (ms) {
    this.whooshOuttaHereTimer = window.setTimeout(function() {
      this.startWhooshingOuttaHere();
    }.bind(this), ms || 5000);
  }, {category: ['whooshing around']});

  add.method('showTemporarilyInCenterOfUsersFieldOfVision', function (w) {
    this.showInCenterOfUsersFieldOfVision(w, function() {this.whooshAwayAfter(5000);}.bind(this));
  }, {category: ['whooshing around']});

  add.method('showInWorldAt', function (w, p, callWhenDone) {
    this.ensureIsInWorld(w, p, true, false, true, callWhenDone);
  }, {category: ['whooshing around']});

  add.method('ensureIsInWorld', function (w, desiredLoc, shouldMoveToDesiredLocEvenIfAlreadyInWorld, shouldAnticipateAtStart, shouldWiggleAtEnd, callback) {
    var originalOwner = this.getOwner();
    this.becomeDirectSubmorphOfWorld(w);
    
    avocado.callbackWaiter.on(function(generateIntermediateCallback) {
      if (typeof(desiredLoc.desiredScale) !== 'undefined') { // aaa hack
        var scalingCallback = generateIntermediateCallback();
        this.smoothlyScaleTo(desiredLoc.desiredScale, function() { this.refreshContentOfMeAndSubmorphs(); scalingCallback(); }.bind(this));
      }
      
      if (originalOwner !== w || shouldMoveToDesiredLocEvenIfAlreadyInWorld) {
        this.startWhooshingTo(desiredLoc, shouldAnticipateAtStart, shouldWiggleAtEnd, generateIntermediateCallback());
      }
    }.bind(this), callback, "whooshing animation");
  }, {category: ['adding and removing']});

  add.method('becomeDirectSubmorphOfWorld', function (w) {
    var owner = this.getOwner();
    if (w) {
      if (owner !== w) {
        var initialLoc = (!owner || this.world() !== w.world()) ? this.getExtent().scaleBy(-1.1).addXY(-200,-200) : this.getPosition().matrixTransform(owner.transformToMorph(w));
        var initialScale = this.overallScale(w);
        
        if (owner && this.doIOrMyOwnersWantToLeaveAPlaceholderWhenRemovingMe()) { owner.placeholderForMorph(this).setScale(this.getScale()).layout().putInPlaceOfOriginalMorph(); }
        
        this.refreshContentOfMeAndSubmorphsIfNeverRefreshedBefore(); // aaa - not sure this is a good idea, but maybe; it makes sure that a mirror will be updated as soon as it's visible, for one thing.
        
        if (this._previousLayoutModes) {
          this.remove();
          this.setLayoutModes(this._previousLayoutModes);
          this.forceLayoutRejiggering();
        }
        
        w.addMorphAt(this, initialLoc);
        this.setScale(initialScale);
        
      }
    } else {
      if (owner && this.doIOrMyOwnersWantToLeaveAPlaceholderWhenRemovingMe()) { owner.placeholderForMorph(this).layout().putInPlaceOfOriginalMorph(); }
    }
  }, {category: ['adding and removing']});

  add.method('putBackOrDismiss', function (callWhenDone) {
    var placeholder = this._placeholderMorphIJustCameFrom;
    if (placeholder) {
      placeholder.layout().putOriginalMorphBack(callWhenDone);
    } else {
      this.startWhooshingOuttaHere(callWhenDone);
    }
  }, {category: ['adding and removing']});

  add.method('startAnimating', function (animator, callback) {
    animator.stopAnimating();
    animator.whenDoneCall(callback);
    animator.startAnimating(this);
    return animator;
  }, {category: ['whooshing around']});

  add.method('wiggle', function (duration) {
    return this.startAnimating(avocado.animation.newWiggler(this, null, duration));
  }, {category: ['wiggling']});

  add.method('ensureIsNotInWorld', function () {
    if (this.world()) {this.startWhooshingOuttaHere();}
  }, {category: ['adding and removing']});

  add.method('smoothlyAnimate', function (accessor, desiredValue, callback) {
    this.startAnimating(avocado.animation.newSpeedStepper(this, desiredValue, accessor, accessor.defaultDuration || 200), callback);
  }, {category: ['animating']});

  add.method('smoothlyFadeTo', function (desiredAlpha, callback) {
    this.smoothlyAnimate(avocado.animation.accessors.fillOpacity, desiredAlpha, callback);
  }, {category: ['animating']});

  add.method('smoothlyResizeTo', function (desiredSize, callback) {
    this.smoothlyAnimate(avocado.animation.accessors.extent, desiredSize, callback);
  }, {category: ['animating']});

  add.method('smoothlyScaleTo', function (desiredScale, callback) {
    this.smoothlyAnimate(avocado.animation.accessors.scale, desiredScale, callback);
  }, {category: ['animating']});

  add.method('smoothlyScaleHorizontallyTo', function (desiredScale, callback) {
    this.smoothlyAnimate(avocado.animation.accessors.horizontalScale, desiredScale, callback);
  }, {category: ['animating']});

  add.method('smoothlyScaleVerticallyTo', function (desiredScale, callback) {
    this.smoothlyAnimate(avocado.animation.accessors.verticalScale, desiredScale, callback);
  }, {category: ['animating']});

  add.method('startTinyAndSmoothlyGrowTo', function (desiredScale, callback) {
    this.setScale(desiredScale * 0.01);
    this.smoothlyScaleTo(desiredScale, callback);
  }, {category: ['animating']});

  add.method('smoothlyShrinkDownToNothing', function (callback) {
    this.smoothlyScaleTo(0.01, callback);
  }, {category: ['animating']});

});


thisModule.addSlots(avocado.animation, function(add) {

  add.creator('accessors', {});

});


thisModule.addSlots(avocado.animation.accessors, function(add) {

  add.creator('general', {});

  add.creator('fillOpacity', Object.create(avocado.animation.accessors.general));

});


thisModule.addSlots(avocado.animation.accessors.fillOpacity, function(add) {

  add.data('defaultDuration', 1000);

  add.method('getValue', function (m) { return m.getFillOpacity(); });

  add.method('setValue', function (m, a) { m.setFillOpacity(a); });

});


thisModule.addSlots(avocado.animation.accessors, function(add) {

  add.creator('extent', Object.create(avocado.animation.accessors.general));

});


thisModule.addSlots(avocado.animation.accessors.extent, function(add) {

  add.data('defaultDuration', 100);

  add.method('getValue', function (m) { return m.getExtent(); });

  add.method('setValue', function (m, e) { m.setExtent(e); });

});


thisModule.addSlots(avocado.animation.accessors, function(add) {

  add.creator('scale', Object.create(avocado.animation.accessors.general));

});


thisModule.addSlots(avocado.animation.accessors.scale, function(add) {

  add.data('defaultDuration', 200);

  add.method('getValue', function (m) { return m.getScale(); });

  add.method('setValue', function (m, s) { m.setScale(s); });

});


thisModule.addSlots(avocado.animation.accessors, function(add) {

  add.creator('horizontalScale', Object.create(avocado.animation.accessors.general));

});


thisModule.addSlots(avocado.animation.accessors.horizontalScale, function(add) {

  add.data('defaultDuration', 200);

  add.method('getValue', function (m) { return m.getHorizontalScale(); });

  add.method('setValue', function (m, v) { m.setHorizontalScale(v); });

});


thisModule.addSlots(avocado.animation.accessors, function(add) {

  add.creator('verticalScale', Object.create(avocado.animation.accessors.general));

});


thisModule.addSlots(avocado.animation.accessors.verticalScale, function(add) {

  add.data('defaultDuration', 200);

  add.method('getValue', function (m) { return m.getVerticalScale(); });

  add.method('setValue', function (m, v) { m.setVerticalScale(v); });

});


});

avocado.transporter.module.onLoadCallbacks["lk_ext/animation"] = function() {};
avocado.transporter.module.create('lk_ext/animation', function(requires) {

requires('general_ui/animation');

}, function(thisModule) {


thisModule.addSlots(Morph.prototype, function(add) {

  add.method('isOnScreen', function () {
    var w = this.world();
    if (!w) { return false; }
    if (w === this) { return true; }
    // var wTransform = w.getTransform();
    var wBounds = w.visibleBoundsCachingIfPossible();
    var thisBounds = this.shape.bounds();
    var transformedBounds = thisBounds.matrixTransform(this.transformToMorph(w));
    var intersects = wBounds.intersects(transformedBounds);
    // console.log("For " + this + ", intersects is " + intersects + "; wBounds is " + wBounds + ", transformedBounds is " + transformedBounds);
    return intersects;
  }, {category: ['testing']});

  add.method('visibleBoundsCachingIfPossible', function () {
    // Calling world.visibleBounds() from isOnScreen turned out to be a performance problem, so let's
    // try a simple cache. -- Adam
    
    if (!this._cachedVisibleBounds) {
      this._cachedVisibleBounds = this.visibleBounds();
    }
    return this._cachedVisibleBounds;
  }, {category: ['accessing']});

  add.method('startWhooshingOuttaHere', function (functionToCallWhenDone) {
      var w = this.world();
      if (w) {
        this.becomeDirectSubmorphOfWorld(w);
        var howFarOutside = 300 / w.getScale();
        this.startWhooshingTo(pt(w.getExtent().x + howFarOutside, -howFarOutside), true, false, function() {
          this.remove();
          if (functionToCallWhenDone) { functionToCallWhenDone(); }
        }.bind(this));
      } else {
        if (functionToCallWhenDone) { functionToCallWhenDone(); }
      }
    }, {category: ['whooshing around']});

  add.method('positionToCenterIn', function (m) {
      return m.getExtent().scaleBy(m.getScale() * 0.5).subPt(this.getExtent().scaleBy(this.getScale() * 0.5));
    });

  add.method('setCenterPosition', function (p) {
    return this.setPosition(p.addPt(this.getExtent().scaleBy(this.getScale() * -0.5)));
  });

  add.method('showInCenterOfUsersFieldOfVision', function (w, callback) {
      this.scaleBy(1 / w.getScale());
      // Can't use positionToCenterIn because that finds the actual center of the morph, whereas we
      // want the center of the *visible* part of the world.
      var p = w.getExtent().scaleBy(0.5).subPt(this.getExtent().scaleBy(this.getScale() * 0.5));
      this.showInWorldAt(w, p, callback);
    });

  add.method('showWithoutAnimationInTopRightCornerOfUsersFieldOfVision', function (w) {
    var wScale = w.getScale();
    this.setScale(1 / wScale);
    var padding = 10 / wScale;
    w.addMorphAt(this, pt(w.getExtent().x - this.getExtent().scaleBy(this.getScale()).x - padding, padding));
  });

  add.method('showAsLabelOnTopOf', function (morphToBeLabelled, world) {
    this.setScale(2.0 / world.getScale());
    var p = morphToBeLabelled.worldPoint(this.positionToCenterIn(morphToBeLabelled));
    this.setPosition(p);
    world.addMorphFront(this);
  });

  add.method('setPositionAndDoMotionBlurIfNecessary', function (newPos, blurTime) {
      var world = this.world();
      if (world) {
  			var scaledExtent = this.getExtent().scaleBy(this.overallScale(world));
        var oldPos = this.getPosition();
        var difference = newPos.subPt(oldPos);
        var ratio = Math.max(Math.abs(difference.x) / scaledExtent.x, Math.abs(difference.y) / scaledExtent.y);
        // console.log("Do we want motion blur? difference is " + difference + ", scaledExtent is " + scaledExtent + ", so ratio is " + ratio);
        if (ratio > 0.5) {
          // aaa - I am sure that there's a more elegant way to get the globalBounds.
          // aaa - And I don't even think this works right.
    			var topLeft = this.getOwner().worldPoint(this.getPosition());
    			var globalBounds = topLeft.extent(scaledExtent);
    			
          var allVertices = globalBounds.vertices().concat(globalBounds.translatedBy(difference).vertices());
          var convexVertices = avocado.geometry.quickhull.getConvexHull(allVertices).map(function(a) {return a.pointA;});
          var motionBlurMorph = Morph.makePolygon(convexVertices, 0, Color.black, this.getFill());
          motionBlurMorph.doesNotNeedACreatorSlot = true; // aaa HACK to fix performance bug
          // could try adjusting the opacity based on the distance, but I tried that and
          // couldn't figure out how to make it look non-weird
          motionBlurMorph.setFillOpacity(0.3);
          motionBlurMorph.setBorderColor(null);
          motionBlurMorph.closeDnD();
          motionBlurMorph.ignoreEvents();
          world.addMorphBack(motionBlurMorph);
          setTimeout(function() {motionBlurMorph.remove();}, blurTime);
        }
      }
      this.setPosition(newPos);
      if (this._layout && this._layout.justDidAnimatedPositionChange) { this._layout.justDidAnimatedPositionChange(); }
    }, {category: ['motion blur']});

  add.method('animatedAddMorphAt', function (m, p, callWhenDone) {
    this.summonMorphToPosition(m, p, m.getScale(), function() {
      this.addMorphAt(m, p);
    }.bind(this));
  }, {category: ['adding and removing']});

  add.method('animatedReplaceMorph', function (currentSubmorph, newSubmorph, callWhenDone) {
    this.summonMorphToPosition(newSubmorph, currentSubmorph.getPosition(), currentSubmorph.overallScale(currentSubmorph.world()), function() {
      this.replaceMorph(currentSubmorph, newSubmorph);
      if (callWhenDone) { callWhenDone(); }
    }.bind(this));
  }, {category: ['adding and removing']});

  add.method('summonMorphToPosition', function (m, pos, scale, callWhenDone) {
    var w = this.world();
    m.becomeDirectSubmorphOfWorld(w);
    if (w) {
      var desiredWorldPos = this.worldPoint(pos);
      desiredWorldPos.desiredScale = scale;
      m.ensureIsInWorld(w, desiredWorldPos, true, true, false, function() {
        if (callWhenDone) { callWhenDone(); }
      }.bind(this));
    } else {
      if (callWhenDone) { callWhenDone(); }
    }
  }, {category: ['adding and removing']});

  add.method('createDismissButton', function () {
    var size = 22 * (Config.fatFingers ? 2 : 1);
    var b = new WindowControlMorph(new Rectangle(0, 0, size, size), 3, Color.primary.orange);
    b.relayToModel(this, {Trigger: "=ensureIsNotInWorld"});
    b.setHelpText('Dismiss me');
    return b;
  }, {category: ['adding and removing']});

  add.method('createDismissButtonThatOnlyAppearsIfTopLevel', function () {
    return avocado.table.createOptionalMorph(this.createDismissButton.bind(this).memoize(), function() {
      return (! this.owner) || (this.owner instanceof WorldMorph) || (this.owner instanceof HandMorph) || (this.owner instanceof avocado.CarryingHandMorph);
    }.bind(this));
  }, {category: ['adding and removing']});

  add.method('setFillOpacityRecursively', function (a) {
    // console.log("setFillOpacityRecursively: " + a);
    this.setFillOpacity(a);
    for (var i = 0, n = this.submorphs.length; i < n; ++i) {
      this.submorphs[i].setFillOpacityRecursively(a);
    }
  }, {category: ['fading']});

  add.method('stayCenteredAndSmoothlyScaleTo', function (desiredScale, centerPos, functionToCallWhenDone) {
      var center = this.innerBounds().center();
      this.moveOriginBy(center);
      this.translateBy(center.negated());

      this.smoothlyScaleTo(desiredScale, function() {
        this.moveOriginBy(center.negated());
        if (functionToCallWhenDone) { functionToCallWhenDone(); }
      }.bind(this));
    }, {category: ['scaling']});

});


thisModule.addSlots(SelectionMorph.prototype, function(add) {

  add.method('startWhooshingOuttaHere', function ($super, callWhenDone) {
      // Alternate way that I don't think looks quite as good: this.selectedMorphs.invoke('startWhooshingOuttaHere');

      this.selectedMorphs.each(function(m) {
        this.addMorphAt(m, this.relativize(m.owner.worldPoint(m.getPosition())));
      }.bind(this));
      $super(callWhenDone);
    }, {category: ['whooshing around']});

});


});

avocado.transporter.module.onLoadCallbacks["lk_ext/scatter"] = function() {};
avocado.transporter.module.create('lk_ext/scatter', function(requires) {

requires('lk_ext/animation');

}, function(thisModule) {


thisModule.addSlots(Morph.prototype, function(add) {

  add.method('scatterNearMe', function (morphs) {
    var world = this.world();
    var rectToScatterIn = this.bounds().insetBy(-200).intersection(world.bounds().insetBy(50));
    var rectToAvoid = this.bounds().insetBy(-50);
    world.scatter(morphs, rectToScatterIn, rectToAvoid);
  });

});


thisModule.addSlots(WorldMorph.prototype, function(add) {

  add.method('scatter', function (morphs, rectToScatterIn, rectToAvoid) {
    if (!rectToScatterIn) { rectToScatterIn = this.bounds().insetBy(50); }
    morphs.each(function(m) {
      while (true) {
        var p = rectToScatterIn.randomPoint();
        if (!rectToAvoid || !rectToAvoid.containsPoint(p)) {
          m.ensureIsInWorld(this, p, true, true, false);
          return p;
        }
      }
    }.bind(this));
  });

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/commands"] = function() {};
avocado.transporter.module.create('general_ui/commands', function(requires) {

requires('core/commands');
requires('general_ui/basic_morph_mixins');

}, function(thisModule) {


thisModule.addSlots(avocado.command, function(add) {

  add.method('wrapForMorph', function (morph) {
    var modelCommand = this;
    
    var morphCommand = Object.create(modelCommand);
    morphCommand.setContext(morph); // aaa - not sure this won't break stuff
    
    if (modelCommand._argumentSpecs) {
      morphCommand.setArgumentSpecs(modelCommand._argumentSpecs.map(function(spec) { return spec.wrapForMorph(morph); }))
    }
    
    var oldFunctionToRun = modelCommand.functionToRun();
    if (oldFunctionToRun) {
      morphCommand.setFunction(function() {
        var rcvr = modelCommand.contextOrDefault();
        var args = $A(arguments);
        // first arg is the event
        var result = modelCommand.functionToRun().apply(rcvr, args.map(function(o, i) { return i === 0 ? o : o._model; }));
        args.each(function(arg, i) {
          if (i > 0) {
            if ((arg.getOwner() instanceof HandMorph || arg.getOwner() instanceof avocado.CarryingHandMorph) && arg._placeholderMorphIJustCameFrom && arg._placeholderMorphIJustCameFrom.world()) {
              var hand = arg.getOwner();
              arg._placeholderMorphIJustCameFrom.layout().putOriginalMorphBack(function() {
                if (typeof(hand.hideIfEmpty) === 'function') { hand.hideIfEmpty(); }
              });
            } else if (arg._shouldDisappearAfterCommandIsFinished) {
              arg.remove();
            } else {
              // I guess just leave it there.
            }
          }
        });
        return result;
      });
    }

    return morphCommand;
  }, {category: ['user interface']});

  add.method('immediateContents', function () {
    return this.argumentSpecs();
  }, {category: ['user interface']});

});


thisModule.addSlots(avocado.command.argumentSpec, function(add) {

  add.method('wrapForMorph', function (morph) {
    var argSpecForModelCommand = this;
    var argSpecForMorphCommand = avocado.command.argumentSpec.create(this._name);
    
    argSpecForMorphCommand.onlyAccepts(function(arg) {
      return (typeof(arg) === 'object') &&
             (! arg._shouldOnlyBeDroppedOnThisParticularMorph ||
                arg._shouldOnlyBeDroppedOnThisParticularMorph === morph) &&
             argSpecForModelCommand.canAccept(arg._model);
    });
    
    var modelPrompter = argSpecForModelCommand.prompter();
    if (modelPrompter) {
      argSpecForMorphCommand.setPrompter({
        prompt: function(caption, context, evt, callback) {
          modelPrompter.prompt(caption, context._model, evt, function(arg) { callback({ _model: arg }); });
        }
      });
    }
    
    argSpecForMorphCommand.useMorphicContextualArgFinder();
    
    return argSpecForMorphCommand;
  }, {category: ['user interface']});

  add.method('useMorphicContextualArgFinder', function () {
    var thisArgSpec = this;
    return this.setArgFinder(function(context, evt) {
      var tryMorphs = function(availableMorphs) {
        var possibleArgMorphs = [];
        availableMorphs.forEach(function(morph) {
          var morphAndRelatedMorphs = [morph];
          if (morph.layout() && typeof(morph.layout().relatedMorphs) === 'function') {
            morphAndRelatedMorphs = morphAndRelatedMorphs.concat(morph.layout().relatedMorphs());
          }
          morphAndRelatedMorphs.forEach(function(morphOrRelatedMorph) {
            if (thisArgSpec.canAccept(morphOrRelatedMorph)) {
              // console.log("Found an argument: " + morphOrRelatedMorph);
              possibleArgMorphs.push(morphOrRelatedMorph);
            } else {
              // console.log("Can't use as argument: " + morphOrRelatedMorph);
            }
          });
        });
        return possibleArgMorphs;
      };
      
      var world = evt.hand.world();
      var contextsInOrderFromMostToLeastRelevant = [
        evt.hand.submorphs,
        avocado.CarryingHandMorph.forWorld(world).submorphs,
        avocado.compositeCollection.create([context.ownersRecursively(), context.submorphsRecursively()]),
        avocado.compositeCollection.create([world.submorphsRecursively()])   // I hope this isn't too slow. Or too unintuitive.
      ];
      
      for (var i = 0; i < contextsInOrderFromMostToLeastRelevant.length; ++i) {
        var possibleArgMorphs = tryMorphs(contextsInOrderFromMostToLeastRelevant[i]);
        if (possibleArgMorphs.length === 1) {
          return possibleArgMorphs[0];
        } else if (possibleArgMorphs.length > 1) {
          return undefined;
        }
      }
      
      return undefined;
    });
  }, {category: ['user interface']});

});


thisModule.addSlots(avocado.command.list, function(add) {

  add.method('wrapForMorph', function (morph) {
    return avocado.command.list.create(morph, this._commands.map(function(c) { return c ? c.wrapForMorph(morph) : null; }));
  }, {category: ['user interface']});

  add.method('createMenu', function (target, menuClass) {
    menuClass = menuClass || this.defaultMenuClass();
    var commands = this.commandsForMenu(target);
    var menuItems = menuClass.itemsForCommands(commands);
    if (typeof(menuClass.maximumNumberOfCommands) === 'number' && menuItems.length > menuClass.maximumNumberOfCommands) {
      // Can't have a wheel menu with more than 9 commands.
      return this.createMenu(target, this.menuClassThatCanHandleAnUnlimitedNumberOfItems());
    }
    return menuClass.createMenuMorph(menuItems, target);
  }, {category: ['converting']});

  add.method('commandsForMenu', function (target) {
    var commands = [];
    var i = 0;
    var n = this._commands.length;
    this._commands.each(function(c) {
      if (c) {
        c = c.wrapWithPromptersForArguments();
        
        if (typeof(c.isApplicable) !== 'function' || c.isApplicable()) {
          commands.push(c);
        }
      } else {
        if (i !== n - 1) { // no point if it's the last one
          commands.push(c);
        }
      }
      i += 1;
    }.bind(this));
    return commands;
  }, {category: ['converting']});

});


thisModule.addSlots(avocado.morphMixins.Morph, function(add) {

  add.method('eachAssociatedObject', function (f) {
    // Children can override.
    var model = this._model;
    if (typeof(model) !== 'undefined') {
      f(model);
      if (model !== null && typeof(model.eachAssociatedObject) === 'function') {
        model.eachAssociatedObject(f);
      }
    }
  }, {category: ['associated objects']});

  add.method('associatedObjectSatisfying', function (criterion) {
    return exitValueOf(function(exit) {
      this.eachAssociatedObject(function(o) {
        if (!criterion || criterion(o)) { exit(o); }
      });
      return null;
    }.bind(this));
  }, {category: ['associated objects']});

  add.method('addModelSpecificUICommandsTo', function (cmdList) {
    if (this._model && typeof(this._model.addUICommandsTo) === 'function') {
      this._model.addUICommandsTo(cmdList);
    }
  }, {category: ['commands']});

  add.method('dragAndDropCommands', function () {
    if (this._model) {
      var cmdList = avocado.command.list.create(this);

      if (typeof(this._model.dragAndDropCommands) === 'function') {
        var modelCmdList = this._model.dragAndDropCommands();
        if (modelCmdList) { cmdList.addAllCommands(modelCmdList.wrapForMorph(this)); }
      }
      
      this.addArrowDroppingCommandTo(cmdList);
      
      return cmdList;
    } else {
      return null;
    }
  }, {category: ['commands']});

  add.method('addArrowDroppingCommandTo', function (cmdList) {
    cmdList.addItem(avocado.command.create("make arrow point to me", function(evt, arrowEndpoint) {
      arrowEndpoint.wasJustDroppedOn(this);
    }, this).setArgumentSpecs([avocado.command.argumentSpec.create('arrowEndpoint').onlyAccepts(function(m) {
      if (!m.isArrowEndpoint) { return false; }
      return avocado.types.checkToSeeIfTypeMatches(m._layout._association.arrowTargetType(), this._model);
    }.bind(this))]));
  }, {category: ['commands']});

});


thisModule.addSlots(avocado.morphMixins.MorphOrWorld, function(add) {

  add.method('isMorphMenuEnabled', function () {
    var b = false;
    avocado.ui.currentWorld().applicationList().applications().each(function(app) { if (app.isMorphMenuEnabled) { b = true; }; });
    return b;
  }, {category: ['menus']});

  add.method('showMorphMenu', function (evt) {
    // Disable the reflective stuff in deployed apps. -- Adam
    if (!this.isMorphMenuEnabled()) { return false; }

    var menu = this.morphMenu(evt);
    var world = this.world();
    menu.openIn(world, world.worldPointCorrespondingToScreenPoint(evt.point(), 100), false, (Object.inspect(this) || "").truncate()); // added || "" -- Adam
    return true;
  }, {category: ['menus']});

  add.method('showContextMenu', function (evt) {
    var menu = this.contextMenu(evt);
    if (!menu) { return false; }
    
    // should be a clear difference between a morph menu and a context menu
    var baseColor = Color.black;
    if (menu.listStyle) {
      menu.listStyle = Object.create(menu.listStyle);
      menu.listStyle.borderColor = baseColor;
      menu.listStyle.fill        = baseColor.lighter(5);
    }
    if (menu.textStyle) {
      menu.textStyle = Object.create(menu.textStyle);
      menu.textStyle.textColor   = baseColor;
    }
    
    var world = this.world();
    menu.openIn(world, world.worldPointCorrespondingToScreenPoint(evt.point(), 100), false, (Object.inspect(this) || "").truncate()); // added || "" -- Adam
    return true;
  }, {category: ['menus']});

  add.method('contextMenu', function (evt) {
    var cs = this.commands();
    if (!cs || cs.size() === 0) { return null; }
    return cs.createMenu(this);
  }, {category: ['menus']});

  add.method('commands', function () {
    var cmdList;
    if (this._model && typeof(this._model.commands) === 'function') {
      var modelCommands = this._model.commands();
      if (modelCommands) { cmdList = modelCommands.wrapForMorph(this); }
    }
    if (!cmdList) { cmdList = avocado.command.list.create(); }
    
    this.addTitleEditingCommandsTo(cmdList);
    this.addModelSpecificUICommandsTo(cmdList);
    return cmdList;
  }, {category: ['menus']});

  add.method('addExtraMorphMenuItemsTo', function (cmdList) {
    // children can override
    
    if (this.layout() && typeof(this.layout().addExtraMorphMenuItemsTo) === 'function') {
      this.layout().addExtraMorphMenuItemsTo(cmdList);
    }
  }, {category: ['menus']});

  add.method('morphMenu', function (evt) {
    var cmdList = avocado.command.list.create(this);
    
    if (this._placeholderMorphIJustCameFrom) {
      cmdList.addItem(avocado.command.create("put back", function() { this._placeholderMorphIJustCameFrom.layout().putOriginalMorphBack(); }));
    } else if (this.shouldBeEasilyGrabbable()) {
      cmdList.addItem(avocado.command.create("grab and pull", function() { this.grabAndPullMe(evt); }));
    } else {
      cmdList.addItem(avocado.command.create("", function() {}));
    }
    
    cmdList.addItem(avocado.command.create("remove", function() { this.startWhooshingOuttaHere(); }));
    
    var disablePickUpAndDropExperiment = true;
    if (disablePickUpAndDropExperiment) {
      cmdList.addItem(avocado.command.create("grab", function() { this.pickMeUpLeavingPlaceholderIfNecessary(evt); }));
    } else {
      var carryingHand = avocado.CarryingHandMorph.forWorld(this.world());
      var dropCmd = carryingHand.applicableCommandForDroppingOn(this);
      var handEmpty = !carryingHand.carriedMorph();
      if (dropCmd) {
        cmdList.addItem(avocado.command.create("drop", function() { carryingHand.dropOn(this, evt); }));
      } else if (handEmpty) {
        cmdList.addItem(avocado.command.create("pick up", function() { carryingHand.pickUp(this, evt); }));
      } else {
        cmdList.addItem(null);
      }
    }
    
    cmdList.addItem(avocado.command.create("zoom to me", function(evt) { this.navigateToMe(evt); }));
    
    // aaa not really usable yet -- Adam: cmdList.addItem(["tagging...", this.taggingCommands()]);
    
    this.addExtraMorphMenuItemsTo(cmdList);
    
    // aaa - Not really sure what to do with this stuff, but if we leave it in the UI, users end up thinking
    // that the morph menu is for scary stuff that they shouldn't touch.
    if (avocado.isReflectionEnabled) {
      cmdList.addItem(this.okToDuplicate() ? avocado.command.create("duplicate", function(evt) { this.copyToHand(evt.hand); }) : null);
    
      cmdList.addItem(this.isInEditMode() ? avocado.command.create("turn off edit mode", function() { this.switchEditModeOff(); })
                                          : avocado.command.create("turn on edit mode" , function() { this.switchEditModeOn (); }));
      cmdList.addItem(avocado.command.create("inspect...", [
         this._model ? ["object", function(evt) { this.world().morphFor(reflect(this._model)).grabMe(evt); }] : ["", function() {}],
                       ["morph",  function(evt) { this.world().morphFor(reflect(this       )).grabMe(evt); }],
      ]));
      cmdList.addItem(avocado.command.create("script me", function(evt) {
        var mir = reflect(avocado.morphScripter.create(this));
        var mirMorph = this.world().morphFor(mir);
        mirMorph.openEvaluator(evt);
        mirMorph.grabMe(evt);
      })); // simple scripting interface -- Adam

      cmdList.addLine();
      cmdList.addItems(this.subMenuItems(evt));
    }
    
    cmdList.addItem(avocado.command.create("edit style", function() { new StylePanel(this).open(); }));
    
    var menu = cmdList.createMenu(this);
		menu.commandStyle = menu.morphCommandStyle;
    return menu;
  }, {category: ['menus']});

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/events"] = function() {};
avocado.transporter.module.create('general_ui/events', function(requires) {

requires('general_ui/basic_morph_mixins');

}, function(thisModule) {


thisModule.addSlots(avocado.morphMixins.MorphOrWorld, function(add) {

  add.method('runAvocadoEventHandler', function (handlerMethodName, evt) {
    if (this._eventHandler) {
      if (typeof(this._eventHandler.isEnabled) !== 'function' || this._eventHandler.isEnabled(this, evt)) {
        var handlerMethod = this._eventHandler[handlerMethodName];
        if (typeof(handlerMethod) === 'function') {
          return handlerMethod.call(this._eventHandler, this, evt);
        }
      }
    }
    return false;
  }, {category: ['events']});

  add.method('setEventHandler', function (h) {
    this._eventHandler = h;
    return this;
  }, {category: ['events']});

});


thisModule.addSlots(avocado, function(add) {

  add.creator('eventHandlers', {}, {category: ['user interface']});

});


thisModule.addSlots(avocado.eventHandlers, function(add) {

  add.creator('general', {});

  add.creator('composite', Object.create(avocado.eventHandlers.general));

  add.creator('default', Object.create(avocado.eventHandlers.general));

  add.method('grabAndPullOrPutBackIfPossible', function (morph, evt) {
    if (morph.hasPlaceholderToGoBackTo()) {
      morph.goBackToPlaceholder();
      return true;
    } else if (morph.shouldBeEasilyGrabbable()) {
      morph.grabAndPullMe(evt);
      return true;
    } else {
      return false;
    }
  }, {category: ['miscellaneous functions']});

});


thisModule.addSlots(avocado.eventHandlers.general, function(add) {

  add.method('create', function () {
    var c = Object.create(this);
    c.initialize.apply(c, arguments);
    return c;
  }, {category: ['creating']});
  
});


thisModule.addSlots(avocado.eventHandlers.composite, function(add) {

  add.method('initialize', function (handlers) {
    this._eventHandlers = handlers;
  }, {category: ['creating']});

  add.method('handleEvent', function (handlerMethodName, morph, evt) {
    this._eventHandlers.forEach(function(h) {
      if (typeof(h.isEnabled) !== 'function' || h.isEnabled(morph, evt)) {
        var handlerMethod = h[handlerMethodName];
        if (typeof(handlerMethod) === 'function') { handlerMethod.call(h, morph, evt); }
      }
    });
  });

  add.method('onMouseDown', function (morph, evt) {
    return this.handleEvent('onMouseDown', morph, evt);
  });

  add.method('onMouseUp', function (morph, evt) {
    return this.handleEvent('onMouseUp', morph, evt);
  });

  add.method('onMouseMove', function (morph, evt) {
    return this.handleEvent('onMouseMove', morph, evt);
  });

  add.method('onMouseOver', function (morph, evt) {
    return this.handleEvent('onMouseOver', morph, evt);
  });

  add.method('onMouseOut', function (morph, evt) {
    return this.handleEvent('onMouseOut', morph, evt);
  });

  add.method('onTouchStart', function (morph, evt) {
    return this.handleEvent('onTouchStart', morph, evt);
  });

  add.method('onTouchEnd', function (morph, evt) {
    return this.handleEvent('onTouchEnd', morph, evt);
  });

  add.method('onTouchMove', function (morph, evt) {
    return this.handleEvent('onTouchMove', morph, evt);
  });

  add.method('onTouchCancel', function (morph, evt) {
    return this.handleEvent('onTouchCancel', morph, evt);
  });

  add.method('onTouchOver', function (morph, evt) {
    return this.handleEvent('onTouchOver', morph, evt);
  });

  add.method('onTouchOut', function (morph, evt) {
    return this.handleEvent('onTouchOut', morph, evt);
  });

  add.method('onKeyDown', function (morph, evt) {
    return this.handleEvent('onKeyDown', morph, evt);
  });

  add.method('onKeyUp', function (morph, evt) {
    return this.handleEvent('onKeyUp', morph, evt);
  });

  add.method('onKeyPress', function (morph, evt) {
    return this.handleEvent('onKeyPress', morph, evt);
  });

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/placeholder_morph"] = function() {};
avocado.transporter.module.create('general_ui/placeholder_morph', function(requires) {

requires('general_ui/basic_morph_mixins');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('placeholder', {});

});


thisModule.addSlots(avocado.placeholder, function(add) {

  add.method('newPlaceholderMorphForMorph', function (originalMorphOrFn) {
    var placeholderMorph = avocado.ui.newMorph(avocado.ui.shapeFactory.newRectangle(pt(0,0).extent(avocado.treeNode.defaultExtent())));
    placeholderMorph.setLayout(Object.newChildOf(avocado.placeholder.layout, placeholderMorph, originalMorphOrFn));
    placeholderMorph.setEventHandler(avocado.placeholder.eventHandler);
    return placeholderMorph;
  }, {category: ['user interface']});

  add.method('newPlaceholderMorphForSlot', function (slot) {
    var m = avocado.placeholder.newPlaceholderMorphForMorph(function() { return avocado.ui.currentWorld().morphFor(slot.contents()); });
    m._arrow = avocado.arrow.newMorphFor(slot, m, null);
    return m;
  }, {category: ['user interface']});

  add.creator('defaultStyle', {}, {category: ['styles']});

  add.creator('layout', {}, {category: ['user interface']}, {comment: 'This doesn\'t really seem like a "layout", but I\'m not sure what it is.'});

  add.creator('eventHandler', {}, {category: ['user interface']});

});


thisModule.addSlots(avocado.placeholder.defaultStyle, function(add) {

  add.data('fillOpacity', 0.2);

  add.data('openForDragAndDrop', false);

  add.data('suppressGrabbing', true);

  add.data('suppressHandles', true);

  add.data('grabsShouldFallThrough', false, {comment: 'Otherwise clicking on it doesn\'t work.'});

  add.data('textColor', new Color(0.5, 0.5, 0.5));

});


thisModule.addSlots(avocado.placeholder.layout, function(add) {

  add.method('initialize', function (placeholderMorph, originalMorphOrFn) {
    this._placeholderMorph = placeholderMorph;
    this._originalMorphOrFn = originalMorphOrFn;
    this._labelMorph = avocado.label.newMorphFor("").setTextColor(avocado.placeholder.defaultStyle.textColor);
    this.refreshContent();
  }, {category: ['creating']});

  add.method('refreshContent', function () {
    var originalMorph = this.originalMorph();
    this._placeholderMorph.setShape(originalMorph.getShape().copy());
		this._placeholderMorph.applyStyle(originalMorph.makeStyleSpec());
    this._placeholderMorph.applyStyle(avocado.placeholder.defaultStyle);
    this._labelMorph.setText(originalMorph.nameUsingContextualInfoIfPossible(this._placeholderMorph));
    this._labelMorph.updateStyle();
    this._placeholderMorph.addMorphCentered(this._labelMorph);
    this._placeholderMorph.minimumExtentMayHaveChanged();
  }, {category: ['updating']});

  add.method('applyStyle', function () {
  }, {category: ['styles']});

  add.method('isAffectedBy', function (operation, morph) {
    return true;
  }, {category: ['styles']});

  add.method('morphDescription', function (morph) {
    return "a placeholder";
  }, {category: ['printing']});

  add.method('minimumExtent', function () {
    var h = this._placeholderMorph.horizontalLayoutMode;
    var v = this._placeholderMorph.  verticalLayoutMode;
    var e = this._placeholderMorph.getExtent();
    if (/* h === avocado.LayoutModes.ShrinkWrap || */ h === avocado.LayoutModes.SpaceFill) { e = e.withX(this._labelMorph.getExtent().x + 10); }
    if (/* v === avocado.LayoutModes.ShrinkWrap || */ v === avocado.LayoutModes.SpaceFill) { e = e.withY(this._labelMorph.getExtent().y + 10); }
    this._placeholderMorph._cachedMinimumExtent = e;
    return e.scaleBy(this._placeholderMorph.getScale());
  }, {category: ['layout']});

  add.method('originalMorph', function () {
    var m = typeof(this._originalMorphOrFn) === 'function' ? this._originalMorphOrFn() : this._originalMorphOrFn;
    m.refreshContentOfMeAndSubmorphsIfNeverRefreshedBefore();
    return m;
  }, {category: ['accessing']});

  add.method('relatedMorphs', function () { return [this.originalMorph()]; }, {category: ['related morphs']});

  add.data('isPlaceholder', true, {category: ['testing']});

  add.method('putOriginalMorphBack', function (callWhenDone) {
    if (this._puttingOriginalMorphBack) { return; }
	  this._puttingOriginalMorphBack = true;
	  var originalMorph = this.originalMorph();
    this._placeholderMorph.getOwner().animatedReplaceMorph(this._placeholderMorph, originalMorph, function() {
      delete originalMorph._placeholderMorphIJustCameFrom;
      originalMorph.refreshContentOfMeAndSubmorphs();
      delete this._puttingOriginalMorphBack;
      if (callWhenDone) { callWhenDone(this._placeholderMorph); }
    }.bind(this));
  }, {category: ['putting in place']});

  add.method('putOriginalMorphBackWithoutAnimation', function () {
	  var originalMorph = this.originalMorph();
    this._placeholderMorph.getOwner().replaceMorph(this._placeholderMorph, originalMorph);
    delete originalMorph._placeholderMorphIJustCameFrom;
    originalMorph.refreshContentOfMeAndSubmorphs();
  }, {category: ['putting in place']});

  add.method('putInPlaceOfOriginalMorph', function () {
	  var originalMorph = this.originalMorph();
    originalMorph.getOwner().replaceMorph(originalMorph, this._placeholderMorph);
    originalMorph._placeholderMorphIJustCameFrom = this._placeholderMorph;
  }, {category: ['putting in place']});

  add.method('addExtraMorphMenuItemsTo', function (cmdList) {
    if (this._placeholderMorph._arrow) { this._placeholderMorph._arrow._layout.addArrowGrabbingCommandTo(cmdList); }
    cmdList.addItem(avocado.command.create('bring it here', function(evt) { this.putOriginalMorphBack(); }, this));
    cmdList.addItem(avocado.command.create('take me there', function(evt) { this.originalMorph().navigateToMe(evt); }, this));
  }, {category: ['commands']});

});


thisModule.addSlots(avocado.placeholder.eventHandler, function(add) {

  add.method('onMouseDown', function (morph, evt) {
	  if (morph._arrow) {
		  morph._arrow.layout().toggleVisibility();
	  }
	});

  add.method('onDoubleClick', function (morph, evt) {
	  morph.layout().originalMorph().navigateToMe(evt);
	  return true;
	});

});


thisModule.addSlots(avocado.morphMixins.Morph, function(add) {

  add.method('doIOrMyOwnersWantToLeaveAPlaceholderWhenRemovingMe', function () {
    return this.doIOrMyOwnersWantToLeaveAPlaceholderWhenRemoving(this);
  }, {category: ['placeholders']});

  add.method('doIOrMyOwnersWantToLeaveAPlaceholderWhenRemoving', function (m) {
    if (this.doIWantToLeaveAPlaceholderWhenRemoving(m)) { return this; }
    return this.getOwner() && this.getOwner().doIOrMyOwnersWantToLeaveAPlaceholderWhenRemoving(m);
  }, {category: ['placeholders']});

  add.method('doIWantToLeaveAPlaceholderWhenRemoving', function (m) {
    // can override in children
    return null;
  }, {category: ['placeholders']});

  add.method('hasPlaceholderToGoBackTo', function () {
    return !!this._placeholderMorphIJustCameFrom;
  }, {category: ['placeholders']});

  add.method('goBackToPlaceholder', function (callWhenDone) {
    this._placeholderMorphIJustCameFrom.layout().putOriginalMorphBack(callWhenDone);
  }, {category: ['placeholders']});

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/input_focus"] = function() {};
avocado.transporter.module.create('general_ui/input_focus', function(requires) {

requires('general_ui/basic_morph_mixins');

}, function(thisModule) {


thisModule.addSlots(avocado.morphMixins.Morph, function(add) {

  add.method('takeInputFocus', function (hand, shouldGoBackwards) {
    var m = shouldGoBackwards ? this._firstSubmorphToReceiveInputFocusBackwards : this._firstSubmorphToReceiveInputFocusForwards;
    if (m) {
      if (typeof(m) === 'function') { m = m(); }
      if (m) { m.takeInputFocus(hand, shouldGoBackwards); }
    } else {
      var evt = Event.createFake(hand);
      if (typeof(this.prepareForUserInput) === 'function') { this.prepareForUserInput(evt); }
      evt.hand.setKeyboardFocus(this);
    }
  }, {category: ['input focus']});

  add.method('passOnInputFocus', function (hand, shouldGoBackwards) {
    var m = shouldGoBackwards ? this._nextMorphToReceiveInputFocusBackwards : this._nextMorphToReceiveInputFocusForwards;
    if (m) {
      if (typeof(m) === 'function') { m = m(); }
      if (m) { m.takeInputFocus(hand, shouldGoBackwards); }
    } else {
      m = shouldGoBackwards ? this._isFirstMorphInInputFocusOrderFor : this._isLastMorphInInputFocusOrderFor;
      if (m) {
        if (typeof(m) === 'function') { m = m(); }
        if (m) { m.passOnInputFocus(hand, shouldGoBackwards); }
      } else {
        // Actually, maybe it's better to just leave this morph with the input focus if it doesn't know where to pass it on to.
        // this.releaseInputFocus(hand);
      }
    }
  }, {category: ['input focus']});

  add.method('releaseInputFocus', function (hand) {
    hand = hand || avocado.ui.currentWorld().firstHand();
    if (hand.getMouseFocus()    === this) { hand.setMouseFocus(null); }
    if (hand.getKeyboardFocus() === this) { hand.setKeyboardFocus(null); }
  }, {category: ['input focus']});

  add.method('setOrderForInputFocus', function (morphs) {
    var first, last;
    morphs.forEach(function(m) {
      if (last) {
        last._nextMorphToReceiveInputFocusForwards = m;
        m._nextMorphToReceiveInputFocusBackwards = last;
      }
      if (! first) { first = m; }
      last = m;
    });
    
    if (first) { first._isFirstMorphInInputFocusOrderFor = this; this._firstSubmorphToReceiveInputFocusForwards  = first; }
    if (last ) {  last._isLastMorphInInputFocusOrderFor  = this; this._firstSubmorphToReceiveInputFocusBackwards = last;  }
    
    return this;
  }, {category: ['input focus']});

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/grabbing"] = function() {};
avocado.transporter.module.create('general_ui/grabbing', function(requires) {

requires('general_ui/basic_morph_mixins');

}, function(thisModule) {


thisModule.addSlots(avocado.morphMixins.Morph, function(add) {

  add.method('grabCopy', function (evt) {
    var newMorph = avocado.ui.worldFor(evt).morphFor(this._model.copyForGrabbing());
    newMorph.applyStyle(this.styleForWhenNotEmbeddedInAnythingElse());
    newMorph.refreshContentOfMeAndSubmorphs();
    newMorph.forceLayoutRejiggering();
    newMorph._shouldDisappearAfterCommandIsFinished = true;
    evt.hand.grabMorphWithoutAskingPermission(newMorph, evt);
    return newMorph;
  }, {category: ['drag and drop']});

  add.method('copyToNewHolderAndDropOnWorld', function (world) {
    var newModel = this._model.copyToNewHolder();
    var newHolder = newModel.holder();
    if (newHolder) {
      var newHolderMorph = world.morphFor(newHolder);
      world.addMorphAt(newHolderMorph, this.position());
      avocado.ui.ensureVisible(newModel);
      newHolderMorph.refreshContentOfMeAndSubmorphs();
    } else {
      var newMorph = world.morphFor(newModel);
      world.addMorphAt(newMorph, this.position());
      newMorph.refreshContentOfMeAndSubmorphs();
    }
  }, {category: ['drag and drop']});

  add.method('wasJustDroppedOnWorld', function (world) {
    if (this._model && this._model.shouldCopyToNewHolderWhenDroppedOnWorld) {
      this.copyToNewHolderAndDropOnWorld(world);
    } else {
      // doing nothing is fine, I think...
    }
    if (this._shouldDisappearAfterCommandIsFinished) { this.remove(); }
  }, {category: ['drag and drop']});

  add.method('pullMorphsCloser', function (morphsToPull, titleContent, callWhenDone) {
    var detailsMorph = this._morphForViewingThingsInMoreDetail || this.world() || avocado.ui.currentWorld();
    var detailsMorphLayout = detailsMorph.layout();
    if (detailsMorphLayout && typeof(detailsMorphLayout.showMorphs) === 'function') {
      detailsMorphLayout.showMorphs(detailsMorph, morphsToPull, titleContent, null, callWhenDone);
    } else {
      var pm = detailsMorph.poseManager();
      pm.assumePose(pm.cleaningUpPose(morphsToPull), null, callWhenDone);
    }
  }, {category: ['pulling']});

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/morph_titles"] = function() {};
avocado.transporter.module.create('general_ui/morph_titles', function(requires) {

requires('general_ui/basic_morph_mixins');

}, function(thisModule) {


thisModule.addSlots(avocado.morphMixins.Morph, function(add) {

  add.method('createNameLabel', function () {
    // can't use "bind" because we can't transport closures, so instead use ownerWithAModel
    var label = avocado.label.newMorphFor({
      initialText: this.nameUsingContextualInfoIfPossible(),
      calculateNewText: function() {
        var o = this.ownerWithAModel();
        return o ? o.nameUsingContextualInfoIfPossible() : "";
      }
    });
    
    var emph = this.titleEmphasis();
    if (emph) { label.setEmphasis(emph); }
    
    return label;
  }, {category: ['title']});

  add.method('nameUsingContextualInfoIfPossible', function (optionalContext) {
		try {
		  var context = optionalContext || this;
      if (this._model && this._model.namingScheme) {
        return this._model.namingScheme.nameInContext(this._model, context);
      }
      return this.inspect();
		} catch (err) {
			return "#<naming error: " + err + ">";
		}
	}, {category: ['title']});

  add.method('createTitleLabel', function () {
    var a = this.titleAccessors();
    if (a) {
      this._titleLabelMorph = avocado.infrequentlyEditedText.newMorphFor(a, "rename", this.titleEmphasis());
    } else {
      var m = this.titleModel();
      if (m) {
        this._titleLabelMorph = avocado.ui.currentWorld().morphFor(m);
      } else {
       this._titleLabelMorph = this.createNameLabel();
      }
    }
    return this._titleLabelMorph;
  }, {category: ['title']});

  add.method('titleEmphasis', function () {
    if (this._model && typeof(this._model.titleEmphasis) === 'function') { return this._model.titleEmphasis(); }
    return null;
  }, {category: ['title']});

  add.method('titleAccessors', function () {
    if (this._model && typeof(this._model.titleAccessors) === 'function') { return this._model.titleAccessors(); }
    return null;
  }, {category: ['title']});

  add.method('titleModel', function () {
    if (this._model && typeof(this._model.titleModel) === 'function') { return this._model.titleModel(); }
    return null;
  }, {category: ['title']});

  add.method('findTitleLabel', function () {
    return this._titleLabelMorph;
  }, {category: ['title']});

  add.method('findOrCreateTitleLabel', function () {
    return this.findTitleLabel() || this.createTitleLabel();
  }, {category: ['title']});

  add.method('addTitleEditingCommandsTo', function (cmdList) {
    var titleLabel = this.findTitleLabel();
    if (titleLabel && typeof(titleLabel.editingCommands) === 'function') {
      cmdList.addAllCommands(titleLabel.editingCommands());
    }
  }, {category: ['title']});

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/highlighting"] = function() {};
avocado.transporter.module.create('general_ui/highlighting', function(requires) {

requires('general_ui/basic_morph_mixins');

}, function(thisModule) {


thisModule.addSlots(avocado.morphMixins.Morph, function(add) {

  add.method('styleWhenHighlighted', function () {
    if (this._stylist) { return this._stylist.styleWhenHighlighted(this); }
    
    if (! this._styleBeforeHighlighting.fill) {
      return {
        fill: Color.white,
        fillOpacity: 0.7
      };
    } else {
      return {
        fill: this._styleBeforeHighlighting.fill.mixedWith(Color.white, 0.7)
      };
    }
  }, {category: ['highlighting']});

  add.method('beHighlighted', function () {
    if (!this._styleBeforeHighlighting) {
      this._styleBeforeHighlighting = this.makeStyleSpec();
      var newStyle = this.styleWhenHighlighted();
      this.applyStyle(newStyle);
    }
  }, {category: ['highlighting']});

  add.method('beUnhighlighted', function () {
    if (this._styleBeforeHighlighting) {
      this.applyStyle(this._styleBeforeHighlighting);
      delete this._styleBeforeHighlighting;
    }
  }, {category: ['highlighting']});

  add.method('isHighlighted', function () {
    return !! this._styleBeforeHighlighting;
  }, {category: ['highlighting']});

  add.method('setHighlighting', function (shouldBeOn) {
    if (shouldBeOn) {
      this.beHighlighted();
    } else {
      this.beUnhighlighted();
    }
  }, {category: ['highlighting']});

});


thisModule.addSlots(avocado.morphMixins.WorldMorph, function(add) {

  add.method('beHighlighted', function () {
    // Don't highlight the world.;
  }, {category: ['highlighting']});

  add.method('beUnhighlighted', function () {
    // Don't highlight the world.;
  }, {category: ['highlighting']});

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/invisibility"] = function() {};
avocado.transporter.module.create('general_ui/invisibility', function(requires) {

requires('general_ui/basic_morph_mixins');

}, function(thisModule) {


thisModule.addSlots(avocado.morphMixins.Morph, function(add) {

  add.method('beInvisible', function () {
    return this.applyStyle(this.invisibleStyle);
  }, {category: ['shortcuts']});

  add.creator('invisibleStyle', {}, {category: ['styles']});

});


thisModule.addSlots(avocado.morphMixins.Morph.invisibleStyle, function(add) {

  add.data('padding', 0);

  add.data('borderWidth', 0);

  add.data('fill', null);

  add.data('suppressGrabbing', true);

  add.data('shouldIgnoreEvents', true);

  add.data('openForDragAndDrop', false);

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/morph_structure"] = function() {};
avocado.transporter.module.create('general_ui/morph_structure', function(requires) {

requires('general_ui/basic_morph_mixins');

}, function(thisModule) {


thisModule.addSlots(avocado.morphMixins.Morph, function(add) {

  add.method('isSameTypeAs', function (m) {
    return m && m['__proto__'] === this['__proto__'];
  }, {category: ['morph structure']});

  add.method('ownerSatisfying', function (condition) {
    var o = this.getOwner();
    if (!o) { return null; }
    if (condition(o)) { return o; }
    return o.ownerSatisfying(condition);
  }, {category: ['morph structure']});

  add.method('ownerWithAModel', function () {
    if (typeof(this._model) !== 'undefined') { return this; }
    return this.ownerSatisfying(function(m) { return typeof(m._model) !== 'undefined'; });
  }, {category: ['morph structure']});

  add.method('outermostOwner', function () {
    var m = this;
    while (m) {
      var o = m.getOwner();
      if (!o || o.isWorld) { return m; }
      m = o;
    }
    throw new Error("Should never get here.");
  }, {category: ['morph structure']});

  add.method('submorphEnumerator', function () {
    return avocado.enumerator.create(this, 'eachSubmorph');
  }, {category: ['morph structure']});

  add.method('eachSubmorphRecursively', function (f) {
    this.eachSubmorph(function(m) {
      f(m);
      m.eachSubmorphRecursively(f);
    });
  }, {category: ['morph structure']});

  add.method('submorphsRecursively', function () {
    return avocado.enumerator.create(this, 'eachSubmorphRecursively');
  }, {category: ['morph structure']});

  add.method('ownerChainIncludes', function (m) {
    var o = this.getOwner();
    while (o) {
      if (o === m) { return true; }
      o = o.getOwner();
    }
    return false;
  }, {category: ['morph structure']});

  add.method('eachOwnerRecursively', function (f) {
    var o = this.getOwner();
    while (o) {
      f(o);
      o = o.getOwner();
    }
  }, {category: ['morph structure']});

  add.method('ownersRecursively', function () {
    return avocado.enumerator.create(this, 'eachOwnerRecursively');
  }, {category: ['morph structure']});

  add.method('detachSubmorphsSatisfying', function (criterion) {
    var world = this.world();
    if (world) {
      this.eachSubmorph(function(m) {
        if (criterion(m)) {
          world.addMorphAt(m, this.worldPoint(m.getPosition()));
        }
      }.bind(this));
    }
  }, {category: ['morph structure']});

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/arrows"] = function() {};
avocado.transporter.module.create('general_ui/arrows', function(requires) {

requires('core/commands');
requires('general_ui/basic_morph_mixins');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('arrow', {}, {category: ['ui']});

});


thisModule.addSlots(avocado.arrow, function(add) {

  add.creator('layout', {});

  add.creator('endpointLayout', {});

  add.creator('defaultStyle', {}, {category: ['styles']});

  add.method('createButtonForToggling', function (slot) {
    var shouldUsePlaceholdersAsArrowTogglingButtons = true; // aaa get rid of the old way after the new placeholder way is working.
    if (shouldUsePlaceholdersAsArrowTogglingButtons && avocado.ui.shouldMirrorsUseZooming) {
      var m = avocado.placeholder.newPlaceholderMorphForSlot(slot).setScale(0.25);
    } else {
      var m = avocado.command.create("Toggle arrow", function() { m._arrow._layout.toggleVisibility(); }).newMorph(avocado.arrow.createArrowIconLabelMorph(), 0, pt(2,2));

      m.commands = function() {
        var cmdList = avocado.command.list.create();
        this._arrow._layout.addArrowGrabbingCommandTo(cmdList);
        return cmdList;
      };

      m.inspect = function() { return slot.inspect() + " contents"; };
      m.getHelpText = function() { return this._arrow._layout.noLongerNeedsToBeUpdated ? "Show arrow" : "Hide arrow"; };

      m._arrow = avocado.arrow.newMorphFor(slot, m, null);
    }

    return m;
  }, {category: ['toggling buttons']});

  add.method('createArrowIconLabelMorph', function () {
		var morph = avocado.ui.newMorph(avocado.ui.shapeFactory.newPolyLine([pt(0,5), pt(10,5), pt(5,0), pt(10,5), pt(5,10), pt(10,5)]));
    return morph.applyStyle({fill: Color.black, borderWidth: 1, borderColor: Color.black, suppressHandles: true, shouldIgnoreEvents: true});
  }, {category: ['creating morphs']});

  add.method('newMorphFor', function (slot, optionalEndpoint1, optionalEndpoint2) {
    var arrow = avocado.ui.newMorph(avocado.ui.shapeFactory.newPolyLine([pt(0,0), pt(0,0)]));
    arrow.applyStyle(avocado.arrow.defaultStyle);
    arrow.setLayout(Object.newChildOf(avocado.arrow.layout, arrow, slot, optionalEndpoint1, optionalEndpoint2));

    arrow._layout.noLongerNeedsToBeUpdated = true;

    arrow._layout.endpoint2.wasJustDroppedOn = function(targetMorph) {
      slot.explicitlySetContents(targetMorph._model);
    };

    // aaa - Wait a sec, do I really want the holder's morph? What if it's embedded in something else? Maybe I want the topmostOwnerBesidesTheWorldAndTheHand.
    var holder = slot.holder();
    if (holder) {
      var holderMorph = avocado.ui.currentWorld().existingMorphFor(holder);
      if (holderMorph) {
        holderMorph.changeNotifier().addObserver(arrow._layout.notificationFunction);
      }
    }
    
    return arrow;
  }, {category: ['creating morphs']});

});


thisModule.addSlots(avocado.arrow.layout, function(add) {

  add.method('initialize', function (arrowMorph, assoc, ep1, ep2) {
    this._arrowMorph = arrowMorph;
    this._association = assoc;
    
    this._arrowMorph.shouldNotMoveWhenSlidingTheWorld = true; // Hack, not sure what exactly is going on.
    
    // Optimization: create this notificationFunction once, rather than needing to bind a new function every time it's called.
    this.notificationFunction = function() {setTimeout(this.putVerticesInTheRightPlace.bind(this), 0);}.bind(this);
    
    this.endpoint1 = ep1 || this.createArrowEndpoint(assoc, this._arrowMorph);
    this.endpoint2 = ep2 || this.createArrowEndpoint(assoc, this._arrowMorph);
    if (!ep1) { this.endpoint1._layout._otherEndpoint = this.endpoint2; }
    if (!ep2) { this.endpoint2._layout._otherEndpoint = this.endpoint1; }
    this.needsToBeVisible();
  }, {category: ['creating']});

  add.method('createArrowEndpoint', function (assoc, arrowMorph) {
    var m = avocado.ui.newMorph();
    m.setLayout(Object.newChildOf(avocado.arrow.endpointLayout, m, assoc, arrowMorph));
    m.isArrowEndpoint = true;
    m.shouldNotBePartOfRowOrColumn = true;
    m.suppressHandles = true;
    m.setFill(Color.black);
    m._cachedRelativeLineEndpoint = pt(0,0);

    m.okToDuplicate = function () { return false; };
    m.okToBeGrabbedBy = function (evt) { return this; };
    
    return m;
  }, {category: ['creating']});

  add.method('shouldIgnorePoses', function () { return true; }, {category: ['poses']});

  add.method('stopUpdating', function () {
    if (this._updateProcess) {
      this._updateProcess.stop();
      delete this._updateProcess;
    }
  }, {category: ['updating']});

  add.method('changeUpdateFrequency', function (newFrequency) {
    if (this._updateProcess && this._updateProcess.frequency === newFrequency) { return; }
    // Optimization suggested by Dan Ingalls: slow down ticking when things are pretty quiet.
    this.stopUpdating();
    this._updateProcess = new PeriodicalExecuter(function(pe) {
      this.putVerticesInTheRightPlace();
    }.bind(this), newFrequency);
  }, {category: ['updating']});

  add.method('tickQuickly', function () { this.changeUpdateFrequency(0.05); }, {category: ['updating']});

  add.method('tickSlowly', function () { this.changeUpdateFrequency(0.5); }, {category: ['updating']});

  add.method('toggleVisibility', function () {
    this.setVisibility(this.noLongerNeedsToBeUpdated);
  }, {category: ['showing and hiding']});

  add.method('setVisibility', function (b, callWhenDone) {
    if (b) {
      this.showMe(callWhenDone);
    } else {
      this.noLongerNeedsToBeVisible(callWhenDone);
    }
  }, {category: ['showing and hiding']});

  add.method('prepareToBeShown', function (callWhenDone) {
    var w = this.endpoint1.world() || avocado.ui.currentWorld();
    var contents = this._association.contents();
    var contentsMorph = w.morphFor(contents);
    if (contentsMorph.world() === w) {
      if (callWhenDone) { callWhenDone(); }
    } else {
      contentsMorph.smoothlyScaleTo(1 / w.getScale()); // aaa - not sure this is a good idea, but maybe
      contentsMorph.ensureIsInWorld(w, this.endpoint1.worldPoint(pt(this.endpoint1.getExtent().x + 125, 0)), false, true, true, callWhenDone);
    }
  }, {category: ['showing and hiding']});

  add.method('showMe', function (callWhenDone) {
    if (this.noLongerNeedsToBeUpdated) {
      this.prepareToBeShown(function() {
        this.needsToBeVisible();
        if (callWhenDone) { callWhenDone(); }
      }.bind(this));
    }
  }, {category: ['showing and hiding']});

  add.method('noLongerNeedsToBeVisible', function (callWhenDone) {
    this.noLongerNeedsToBeUpdated = true;
    this.disappear(function() {
      this.stopUpdating();
      if (callWhenDone) { callWhenDone(); }
    }.bind(this));
  }, {category: ['showing and hiding']});

  add.method('needsToBeVisible', function () {
    this.noLongerNeedsToBeUpdated = false;
    this.tickQuickly();
  }, {category: ['showing and hiding']});

  add.method('putVerticesInTheRightPlace', function () {
    if (this.shouldBeShown()) {
      if (this.endpoint1._layout && this.endpoint1._layout.attachToTheRightPlace) { this.endpoint1._layout.attachToTheRightPlace(); }
      if (this.endpoint2._layout && this.endpoint2._layout.attachToTheRightPlace) { this.endpoint2._layout.attachToTheRightPlace(); }
      if (! this._arrowMorph.getOwner()) {
        var w = avocado.ui.currentWorld();
        this.adjustScaleBasedOnWorldScale(w.getScale());
        w.addMorph(this._arrowMorph);
      }
      this.changeVerticesIfNecessary();
    } else {
      if (this._arrowMorph.getOwner()) {
        this.disappear();
      }
    }
  }, {category: ['vertices']});

  add.method('changeVerticesIfNecessary', function () {
    var oldVertices = this._arrowMorph.shape.vertices();
    var newVertices = [this.endpoint1.lineEndpoint(), this.endpoint2.lineEndpoint()];
    if (oldVertices[0].approximatelyEqualsPt(newVertices[0], 1) && oldVertices[1].approximatelyEqualsPt(newVertices[1], 1)) {
      this.changeVertices(newVertices);
      this.tickSlowly();
    } else {
      this.changeVertices(newVertices);
      this.tickQuickly();
    }
  }, {category: ['vertices']});

  add.method('changeVertices', function (newVertices) {
    this._arrowMorph.setVertices(newVertices);

    if (! newVertices[0].eqPt(newVertices[1])) {
      var arrowDirection = newVertices[1].subPt(newVertices[0]);
      if (arrowDirection.rSquared() >= 225) {
        //console.log("endpoint1: " + newVertices[0] + ", endpoint2: " + newVertices[1] + ", arrowDirection: " + arrowDirection + ", arrowDirection.theta(): " + arrowDirection.theta());
        if (this.endpoint1._layout && this.endpoint1._layout.setShapeToLookLikeACircle) { this.endpoint1._layout.setShapeToLookLikeACircle(arrowDirection          .theta()); }
        if (this.endpoint2._layout && this.endpoint2._layout.setShapeToLookLikeAnArrow) { this.endpoint2._layout.setShapeToLookLikeAnArrow(arrowDirection.negated().theta()); }
      } else {
        // Workaround: the endpoint keeps being in weird places when it's very near the source,
        // and so the arrow head kept pointing in weird directions. Until I figure out the cause,
        // let's just not show the arrow head until it gets a bit further away.
        this.endpoint2._layout.setShapeToLookLikeNothing();
      }
    }
  }, {category: ['vertices']});

  add.method('adjustScaleBasedOnWorldScale', function (worldScale) {
    var inverse = 1 / worldScale;
    this._arrowMorph.setBorderWidth(inverse);
    if (this.endpoint1.isArrowEndpoint) { this.endpoint1.setOverallScale(1); }
    if (this.endpoint2.isArrowEndpoint) { this.endpoint2.setOverallScale(1); }
  }, {category: ['scaling']});

  add.method('justScaledWorld', function (worldScale) {
    this.adjustScaleBasedOnWorldScale(worldScale);
    this.putVerticesInTheRightPlace();
  }, {category: ['scaling']});

  add.method('disappear', function (callWhenDone) {
    avocado.callbackWaiter.on(function(finalCallback) {
      if (this.endpoint1._layout && this.endpoint1._layout.noLongerNeedsToBeVisibleAsArrowEndpoint) { this.endpoint1._layout.noLongerNeedsToBeVisibleAsArrowEndpoint(finalCallback()); }
      if (this.endpoint2._layout && this.endpoint2._layout.noLongerNeedsToBeVisibleAsArrowEndpoint) { this.endpoint2._layout.noLongerNeedsToBeVisibleAsArrowEndpoint(finalCallback()); }
    }.bind(this), function() {
      this.noLongerNeedsToBeUpdated = true;
      if (this._arrowMorph.getOwner()) {
        this._arrowMorph.remove();
        this.tickSlowly();
      }
      if (callWhenDone) { callWhenDone(); }
    }.bind(this), "making the arrow disappear");
  }, {category: ['showing and hiding']});

  add.method('shouldBeShown', function () {
    if (this.noLongerNeedsToBeUpdated) { return false; }
    var m1 = this.endpoint1._layout && this.endpoint1._layout.determineWhichMorphToAttachTo ? this.endpoint1._layout.determineWhichMorphToAttachTo() : !!this.endpoint1.world();
    var m2 = this.endpoint2._layout && this.endpoint2._layout.determineWhichMorphToAttachTo ? this.endpoint2._layout.determineWhichMorphToAttachTo() : !!this.endpoint2.world();
    var w  = avocado.ui.currentWorld();
    return m1 && m2 && (m1 !== w || m2 !== w);
  }, {category: ['showing and hiding']});

  add.method('constructUIStateMemento', function (morph) {
    return ! this.noLongerNeedsToBeUpdated;
  }, {category: ['UI state']});

  add.method('assumeUIState', function (morph, uiState, callWhenDone, evt) {
    this.setVisibility(uiState, callWhenDone);
  }, {category: ['UI state']});

  add.method('addArrowGrabbingCommandTo', function (cmdList) {
    // aaa - To do "grab arrow" properly I think I need to do a more general drag-and-drop thing. Right
    // now nothing will get called if I drop the endpoint on something invalid (like the world or some
    // other morph), so the visibility will need to be toggled an extra time to get it back to normal.
    cmdList.addItem(avocado.command.create("grab arrow", function(evt) {
      this.needsToBeVisible();
      this.endpoint2.grabMeWithoutZoomingAroundFirst(evt);
    }, this));
  }, {category: ['commands']});

});


thisModule.addSlots(avocado.arrow.endpointLayout, function(add) {

  add.method('initialize', function (arrowEndpointMorph, assoc, arrowMorph) {
    this._arrowEndpointMorph = arrowEndpointMorph;
    this._association = assoc;
    this._arrowMorph = arrowMorph;
  }, {category: ['creating']});

  add.method('determineWhichMorphToAttachTo', function () {
    var m = this._arrowEndpointMorph.getOwner() instanceof HandMorph ? this._arrowEndpointMorph.getOwner() : this.whichMorphToAttachTo();
    this._morphToAttachTo = m;
    return m;
  }, {category: ['attaching']});

  add.method('whichMorphToAttachTo', function () {
    var slotContents = this._association.contents();
    var morph = avocado.ui.currentWorld().existingMorphFor(slotContents);
    return morph ? (morph.world() ? morph : null) : null;
  }, {category: ['attaching']});

  add.method('stopCurrentAnimationIfAny', function () {
    if (this._animator) { this._animator.stopAnimating(); }
  }, {category: ['animating']});

  add.method('isZoomingTo', function () {
    return this._animator ? this._animator.isZoomingTo : undefined;
  }, {category: ['animating']});

  add.method('attachToTheRightPlace', function () {
    var morphToAttachTo = this._morphToAttachTo;
    var isZoomingTo = this.isZoomingTo();
    if (isZoomingTo === morphToAttachTo) {return;}
    this.stopCurrentAnimationIfAny();
    var oldOwner = this._arrowEndpointMorph.getOwner();
    if (! (morphToAttachTo instanceof HandMorph)) {
      if (morphToAttachTo === oldOwner && this.doesNotNeedToBeRepositionedIfItStaysWithTheSameOwner) {return;}
      
      if (morphToAttachTo !== WorldMorph.current()) {
        var otherEndpointLoc = this._otherEndpoint.worldPoint(this._otherEndpoint.relativeLineEndpoint());
        var localCenterOfMorphToAttachTo = morphToAttachTo.relativeCenterpoint();
        var globalCenterOfMorphToAttachTo = morphToAttachTo.worldPoint(localCenterOfMorphToAttachTo);
        var vectorFromCenterToOtherEndpoint = otherEndpointLoc.subPt(globalCenterOfMorphToAttachTo);
        var localPositionOfOtherEndpoint = localCenterOfMorphToAttachTo.addPt(vectorFromCenterToOtherEndpoint);
        var localNewLoc = this.localPositionClosestTo(localPositionOfOtherEndpoint, localCenterOfMorphToAttachTo);
        var globalNewLoc = morphToAttachTo.worldPoint(localNewLoc);
        
        var world = this._arrowEndpointMorph.world();
        var globalCurLoc;
        if (world) {
          globalCurLoc = this._arrowEndpointMorph.getOwner().worldPoint(this._arrowEndpointMorph.getPosition());
        } else {
          globalCurLoc = otherEndpointLoc;
          world = this._otherEndpoint.world();
        }
        world.addMorphAt(this._arrowEndpointMorph, globalCurLoc);
        this.stopCurrentAnimationIfAny();
        // aaa console.log("Now zooming from " + globalCurLoc + " to " + globalNewLoc + "; morphToAttachTo is " + Object.inspect(morphToAttachTo) + "; noLongerNeedsToBeUpdated is " + this._arrowMorph._layout.noLongerNeedsToBeUpdated);
        this._animator = this._arrowEndpointMorph.startWhooshingInAStraightLineTo(globalNewLoc, false, false, false, function() {
          var wasAlreadyAttachedToThisMorph = morphToAttachTo === this._arrowEndpointMorph.getOwner();
          morphToAttachTo.addMorphAt(this._arrowEndpointMorph, localNewLoc);
          if (!wasAlreadyAttachedToThisMorph) {
            morphToAttachTo.bringToFront();
            morphToAttachTo.wiggle(100);
          }
          delete this._animator;
        }.bind(this));
        this._animator.isZoomingTo = morphToAttachTo;
        
        this.doesNotNeedToBeRepositionedIfItStaysWithTheSameOwner = true;
      } else {
        if (! this._vectorFromOtherEndpoint) { this._vectorFromOtherEndpoint = this.calculateDefaultVectorFromOtherEndpoint().scaleToLength(50); }
        var newLoc = this._otherEndpoint.world() ? this._otherEndpoint.worldPoint(pt(0,0)).addPt(this._vectorFromOtherEndpoint) : pt(0,0);
        morphToAttachTo.addMorphAt(this._arrowEndpointMorph, newLoc);
      }
    }

    this.registerForChangeNotification(oldOwner, morphToAttachTo);
  }, {category: ['attaching']});

  add.method('registerForChangeNotification', function (oldOwner, newOwner) {
    // Not really necessary because we have the update process, but it makes the UI look smoother
    // if we register to be notified whenever the owner changes position.
    if (newOwner !== oldOwner) {
      this.unregisterFromChangeNotification(oldOwner);
      newOwner.topmostOwnerBesidesTheWorldAndTheHand().changeNotifier().addObserver(this._arrowMorph._layout.notificationFunction);
    }
  }, {category: ['updating']});

  add.method('unregisterFromChangeNotification', function (oldOwner) {
    if (oldOwner) { oldOwner.topmostOwnerBesidesTheWorldAndTheHand().changeNotifier().removeObserver(this._arrowMorph._layout.notificationFunction); }
  }, {category: ['updating']});

  add.method('noLongerNeedsToBeVisibleAsArrowEndpoint', function (callWhenDone) {
    var isZoomingTo = this.isZoomingTo();
    if (isZoomingTo === null) {return;}
    this.unregisterFromChangeNotification(this._arrowEndpointMorph.getOwner());
    this.stopCurrentAnimationIfAny();
    var world = this._arrowEndpointMorph.world();
    if (world && this._otherEndpoint.world()) {
      var globalCurLoc = this._arrowEndpointMorph.getOwner().worldPoint(this._arrowEndpointMorph.getPosition());
      var globalNewLoc = this._otherEndpoint.worldPoint(this._otherEndpoint.relativeLineEndpoint());
      // aaa console.log("OK, zooming from " + globalCurLoc + " to " + globalNewLoc + "; noLongerNeedsToBeUpdated is " + this._arrowMorph._layout.noLongerNeedsToBeUpdated);
      world.addMorphAt(this._arrowEndpointMorph, globalCurLoc);
      this._animator = this._arrowEndpointMorph.startWhooshingInAStraightLineTo(globalNewLoc, false, false, false, function() {
        delete this._animator;
        this._arrowEndpointMorph.remove();
        callWhenDone();
      }.bind(this));
      this._animator.isZoomingTo = null;
    } else {
      this._arrowEndpointMorph.remove();
      callWhenDone();
    }
  }, {category: ['showing and hiding']});

  add.method('justDidAnimatedPositionChange', function () {
    this._arrowMorph._layout.changeVerticesIfNecessary();
  }, {category: ['animating']});

  add.method('localPositionClosestTo', function (localPositionToBeClosestTo, localCenter) {
    var vectorFromCenterToPositionToBeClosestTo = localPositionToBeClosestTo.subPt(localCenter);
    var s1 = vectorFromCenterToPositionToBeClosestTo.x !== 0 ? Math.abs(localCenter.x / vectorFromCenterToPositionToBeClosestTo.x) : null;
    var s2 = vectorFromCenterToPositionToBeClosestTo.y !== 0 ? Math.abs(localCenter.y / vectorFromCenterToPositionToBeClosestTo.y) : null;
    var positonToBeClosestToIsAlongAVerticalEdge = s2 === null || s1 < s2;
    var s = positonToBeClosestToIsAlongAVerticalEdge ? s1 : s2;
    return localCenter.addPt(vectorFromCenterToPositionToBeClosestTo.scaleBy(s));
  }, {category: ['attaching']});

  add.method('setShapeToLookLikeACircle', function (arrowTheta) {
    if (! this.wasAlreadySetToLookLikeACircle) {
      this._arrowEndpointMorph.setShape(new lively.scene.Ellipse(pt(0,0).extent(pt(10,10))));
      this.wasAlreadySetToLookLikeACircle = true;
      this.wasAlreadySetToLookLikeAnArrow = false;
    }
    this._arrowEndpointMorph.setRotation(arrowTheta);
  }, {category: ['shape']});

  add.method('setShapeToLookLikeNothing', function (arrowTheta) {
    this._arrowEndpointMorph.setShape(new lively.scene.Rectangle(pt(0,0).extent(pt(0,0))));
    this.wasAlreadySetToLookLikeACircle = false;
    this.wasAlreadySetToLookLikeAnArrow = false;
  }, {category: ['shape']});

  add.method('setShapeToLookLikeAnArrow', function (arrowTheta) {
    if (! this.wasAlreadySetToLookLikeAnArrow) {
      var parallelVector = pt(1,0);
      var pointOnTipOfArrow = this._arrowEndpointMorph.relativeLineEndpoint();
      var middleOfBaseOfArrow = pointOnTipOfArrow.addPt(parallelVector.scaleBy(15.0));
      var vectorToPointOnBaseOfArrow = parallelVector.perpendicularVector().scaleBy(6.0);
      var verticesOfArrow = [pointOnTipOfArrow, middleOfBaseOfArrow.addPt(vectorToPointOnBaseOfArrow), middleOfBaseOfArrow.subPt(vectorToPointOnBaseOfArrow)];
      this._arrowEndpointMorph.setShape(new lively.scene.Polygon(verticesOfArrow, Color.black, 1, Color.black));
      this.wasAlreadySetToLookLikeAnArrow = true;
      this.wasAlreadySetToLookLikeACircle = false;
    }
    this._arrowEndpointMorph.setRotation(arrowTheta);
  }, {category: ['shape']});

  add.method('calculateDefaultVectorFromOtherEndpoint', function () {
    return this._otherEndpoint.lineEndpoint().subPt(this._otherEndpoint.ownerCenterpoint());
  }, {category: ['attaching']});

});


thisModule.addSlots(avocado.arrow.defaultStyle, function(add) {

  add.data('borderColor', new Color(0, 0, 0));

  add.data('borderWidth', 1);

  add.data('fill', null);

  add.data('suppressGrabbing', true);

  add.data('openForDragAndDrop', false);

  add.data('shouldIgnoreEvents', true);

});


thisModule.addSlots(avocado.morphMixins.Morph, function(add) {

  add.method('detachArrowEndpoints', function () {
    this.detachSubmorphsSatisfying(function(m) { return m.isArrowEndpoint; });
  }, {category: ['arrows']});

  add.method('relativeLineEndpoint', function () {
    return this._cachedRelativeLineEndpoint || (this._cachedRelativeLineEndpoint = this.getExtent().scaleBy(0.5));
  }, {category: ['arrows']});

  add.method('ownerCenterpoint', function () {
    var o = this.getOwner();
    if (!o || !o.world()) {return pt(0, 0);}
    return o.worldPoint(o.shape.bounds().center());
  }, {category: ['geometry']});

  add.method('relativeCenterpoint', function () {
    return this.getExtent().scaleBy(0.5);
  }, {category: ['geometry']});

  add.method('lineEndpoint', function () {
    if (! this.world()) {return pt(0,0);}
    var relative = this.relativeLineEndpoint();
    return this.worldPoint(relative);
  }, {category: ['arrows']});

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/auto_scaling_morph"] = function() {};
avocado.transporter.module.create('general_ui/auto_scaling_morph', function(requires) {

requires('general_ui/basic_morph_mixins');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('autoScaling', {}, {category: ['ui']});

});


thisModule.addSlots(avocado.autoScaling, function(add) {

  add.creator('layout', {});

  add.method('newAutoScalingMorph', function (shape, shouldAutoOrganize) {
    return avocado.ui.newMorph(shape).useAutoScalingLayout(shouldAutoOrganize);
  });

});


thisModule.addSlots(avocado.autoScaling.layout, function(add) {

  add.method('initialize', function (morph, shouldAutoOrganize) {
    this._morph = morph;
    this._shouldAutoOrganize = shouldAutoOrganize;
  });

  add.method('applyStyle', function (spec) {
  });

  add.method('isAffectedBy', function (operation, morph) {
    return false;
  });

  add.method('justChangedContent', function (evt) {
    if (this._shouldAutoOrganize) {
      // aaa - Not sure this is what we want in the long run - it might be better to just add the new content in an empty area
      this.cleanUp();
    }
  }, {category: ['updating']});

  add.method('replaceContentWith', function (newContentMorphs) {
    this.removeMorphsNotIncludedIn(newContentMorphs);
    this.invalidateLayoutIfIDoNotContainMorphsIncludedIn(newContentMorphs);
    this.refreshLayoutIfNecessary(newContentMorphs);
  });

  add.method('removeMorphsNotIncludedIn', function (contentMorphs) {
    // aaa - find a more efficient way to do this

    var notIncluded = [];
    
    this._morph.eachSubmorph(function(m) {
      if (! contentMorphs.include(m)) {
        notIncluded.push(m);
      }
    });
    
    notIncluded.forEach(function(m) {
      this._morph.removeMorph(m);
      this.invalidateLayout();
    }.bind(this));
  });

  add.method('invalidateLayoutIfIDoNotContainMorphsIncludedIn', function (contentMorphs) {
    if (! this._hasAlreadyBeenLaidOutAtLeastOnce) { return; } // already invalidated, no point in checking
    
    // aaa - find a more efficient way to do this
    contentMorphs.forEach(function(m) {
      if (m.getOwner() !== this._morph) {
        this.invalidateLayout();
      }
    }.bind(this));
  });

  add.method('invalidateLayout', function () {
    this._hasAlreadyBeenLaidOutAtLeastOnce = false;
  });

  add.method('refreshLayoutIfNecessary', function (contentMorphs) {
    if (!this._hasAlreadyBeenLaidOutAtLeastOnce) {
      this.cleanUp(contentMorphs);
    }
  });

  add.method('cleanUp', function (contentMorphsOrNull) {
    this._hasAlreadyBeenLaidOutAtLeastOnce = true;
    var contentMorphs = contentMorphsOrNull || this._morph.recalculateActualContent() || this._morph.submorphs;
    var pose = this.cleaningUpPoseFor(contentMorphs).beUnobtrusive().whenDoneScaleToFitWithinCurrentSpace().aaa_addExtraZHack(0);
    this._morph.poseManager().assumePose(pose);
  }, {category: ['organizing']});

  add.method('cleaningUpPoseFor', function (contentMorphs) {
    return this._morph.poseManager().cleaningUpPose(contentMorphs).beSquarish();
  }, {category: ['organizing']});

  add.method('aboutToReceiveDrop', function (m) {
    var tfm = m.transformForNewOwner(this._morph);
		m.scaleBy(1 / tfm.getScale());
  }, {category: ['drag and drop']});

  add.method('justReceivedDrop', function (m) {
    if (this._shouldAutoOrganize) {
      this.cleanUp();
    }
  }, {category: ['drag and drop']});

  add.method('possiblyDoSomethingBecauseASubmorphMinimumExtentHasChanged', function (morph) {
    this.invalidateLayout();
    // aaa Can't just do the refreshLayoutIfNecessary() right now because the submorph's *actual* size
    // hasn't changed yet. But ideally I guess we would have the cleanUp pose account for minimum size
    // rather than actual size.
    setTimeout(this.refreshLayoutIfNecessary.bind(this), 0);
    return false;
  }, {category: ['layout']});

});


thisModule.addSlots(avocado.morphMixins.Morph, function(add) {

  add.method('useAutoScalingLayout', function (shouldAutoOrganize) {
    this.doIWantToLeaveAPlaceholderWhenRemoving = function (m) {
      // aaa - probably need to actually determine whether the submorph is part of
      // this morph's potential content (rather than just some transient thing)
      return this;
    };
    
    this.setLayout(Object.newChildOf(avocado.autoScaling.layout, this, shouldAutoOrganize));
    return this;
  }, {category: ['layout']});

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/wheel_layout"] = function() {};
avocado.transporter.module.create('general_ui/wheel_layout', function(requires) {

requires('general_ui/basic_morph_mixins');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('wheelLayout', {}, {category: ['user interface']});

});


thisModule.addSlots(avocado.wheelLayout, function(add) {

  add.data('displayName', 'wheelLayout');

  add.method('initialize', function (morph) {
    this._morph = morph;
  }, {category: ['creating']});

  add.data('_innerRadius', 30, {category: ['geometry']});

  add.data('_outerRadius', 100, {category: ['geometry']});

  add.method('innerRadius', function () {
    return this._innerRadius;
  }, {category: ['accessing']});

  add.method('outerRadius', function () {
    return this._outerRadius;
  }, {category: ['accessing']});

  add.method('eachPosition', function (f) {
		var r = (this.innerRadius() + this.outerRadius()) * 0.575;
		var n = avocado.wheelMenu.maximumNumberOfCommands;
		for (var i = 0; i < n; ++i) {
      var p = pt(0,0);
	    if (i !== 0) {
		    var theta = ((i - 3) / (n - 1)) * (2 * Math.PI);
	      p = p.addPt(Point.polar(r * ((i % 2 === 0) ? 1 : 0.84), theta));
	    }
      f(p, i);
		}
  }, {category: ['geometry']});

  add.method('applyStyle', function (spec) {
  }, {category: ['styles']});

  add.method('adjustStyleSpec', function (spec) {
  }, {category: ['styles']});

  add.method('isAffectedBy', function (operation, morph) {
    return true;
  }, {category: ['layout']});

  add.method('createPieceShape', function (commandIndex) {
    if (commandIndex === 0) {
      // aaa LK-specific
  		return avocado.ui.shapeFactory.newCircle(pt(0, 0), this.innerRadius());
    } else {
      var thetaA = ((commandIndex - 3.5) / 8) * (2 * Math.PI);
      var thetaC = ((commandIndex - 2.5) / 8) * (2 * Math.PI);
  		return avocado.ui.shapeFactory.newPieWedge(thetaA, thetaC, this.innerRadius(), this.outerRadius() * 0.95);
    }
  }, {category: ['layout']});

  add.method('centerOfPiece', function (commandIndex) {
    if (commandIndex === 0) { return pt(0, 0); }
    return Point.polar((this.innerRadius() + this.outerRadius()) / 2, ((commandIndex - 3) / 8) * (2 * Math.PI));
  }, {category: ['layout']});

});


thisModule.addSlots(avocado.morphMixins.Morph, function(add) {

  add.method('useWheelLayout', function () {
    this.setLayout(Object.newChildOf(avocado.wheelLayout, this));
    return this;
  }, {category: ['layout']});

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/wheel_menus"] = function() {};
avocado.transporter.module.create('general_ui/wheel_menus', function(requires) {

requires('general_ui/basic_morph_mixins');
requires('general_ui/wheel_layout');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('wheelMenu', {}, {category: ['user interface']});

});


thisModule.addSlots(avocado.wheelMenu, function(add) {

  add.data('maximumNumberOfCommands', 9);

  add.creator('eventHandlerForMenu', {}, {category: ['user interface', 'events']});

  add.creator('eventHandlerForHighlighting', {}, {category: ['user interface', 'events']});

  add.creator('eventHandlerForShowingPartialCommandMorph', {}, {category: ['user interface', 'events']});

  add.creator('eventHandlerForRunningTheCommand', {}, {category: ['user interface', 'events']});

  add.creator('stylistToMatchTextColorWithMenuColor', {}, {category: ['user interface', 'events']});

  add.creator('defaultCommandStyle', {}, {category: ['user interface', 'styles']});

  add.data('keyboardShortcuts', 'swedcxzaq', {category: ['user interface', 'events']});

  add.creator('defaultStyle', {}, {category: ['styles']});

  add.creator('contextCommandStyle', {}, {category: ['styles']});

  add.creator('morphCommandStyle', {}, {category: ['styles']});

  add.creator('modes', {}, {category: ['user interface', 'modes']});

  add.method('createMenuMorph', function (commands, targetMorph) {
		var menuMorph = avocado.ui.newMorph(avocado.ui.shapeFactory.newCircle(pt(0,0), avocado.wheelLayout.outerRadius()));
		menuMorph._commands = commands;
		menuMorph._targetMorph = targetMorph;
		menuMorph._mode = avocado.wheelMenu.modes.transientInactive;
		menuMorph.useWheelLayout();
		menuMorph.applyStyle(this.defaultStyle);
		var targetMorphFill = targetMorph && targetMorph.getFill();
		if (targetMorphFill && targetMorphFill.isVeryLight()) { menuMorph.setFill(this.defaultStyle.fillToUseWhenTargetIsVeryLight); }
		menuMorph.setEventHandler(avocado.wheelMenu.eventHandlerForMenu);
		menuMorph.openIn = function(parentMorph, loc, remainOnScreen, captionIfAny) { avocado.wheelMenu.openMenu(menuMorph, parentMorph, loc, remainOnScreen, captionIfAny); };
    menuMorph.focusHaloBorderWidth = 0;
    menuMorph.morphCommandStyle   = this.morphCommandStyle;
    menuMorph.contextCommandStyle = this.contextCommandStyle;
    menuMorph.commandStyle        = this.contextCommandStyle;
    menuMorph.handlesMouseDown   = function (evt) { return true; };
    menuMorph.takesKeyboardFocus = function (evt) { return true; };
    if (avocado.wheelMenu.morphMixin) { Object.extend(menuMorph, avocado.wheelMenu.morphMixin); }
    return menuMorph;
  }, {category: ['creating']});

  add.method('itemsForCommands', function (commands) {
    return commands.compact();
  }, {category: ['converting']});

  add.method('waitForABitAndThenBecomeActive', function (menuMorph) {
    setTimeout(function() {
      if (menuMorph._mode === this.modes.transientInactive) {
        menuMorph._mode = this.modes.transientActive;
        menuMorph.onMouseMove(Event.createFake());
      }
    }.bind(this), 250);
  }, {category: ['user interface', 'modes']});

  add.method('areCommandsEnabled', function (menuMorph) {
    return ! menuMorph._mode.areCommandsDisabled;
  }, {category: ['user interface', 'running commands']});

  add.method('commandMorphForIndex', function (menuMorph, commandIndex) {
    for (var i = 0, n = menuMorph.submorphs.length; i < n; ++i) {
      var cm = menuMorph.submorphs[i];
      if (cm._commandIndex === commandIndex) { return cm; }
    }
    return null;
  }, {category: ['user interface', 'events']});

  add.method('highlightAppropriateCommandMorphs', function (menuMorph, evt) {
    menuMorph.eachSubmorph(function(cm) {
      if (avocado.wheelMenu.keyboardShortcuts[cm._commandIndex] === menuMorph._mostRecentKeyCharDown || (!menuMorph._mostRecentKeyCharDown && cm.handIsOverMe(evt.hand))) {
        cm.onMouseOver(evt);
      } else {
        cm.onMouseOut(evt);
      }
    });
  }, {category: ['user interface', 'highlighting']});

  add.method('openMenu', function (menuMorph, parentMorph, loc, remainOnScreen, captionIfAny) {
		this.createCommandMorphsIfNecessary(menuMorph);
    menuMorph.rotateToFaceTheCamera();
    menuMorph.setCenterPosition(loc);
    parentMorph.addMorph(menuMorph);
    var hand = parentMorph.world().firstHand();
    menuMorph.takeInputFocus(hand);
    hand.setMouseFocus(menuMorph);
    this.waitForABitAndThenBecomeActive(menuMorph);
    this.startOpeningAnimation(menuMorph);
  }, {category: ['user interface', 'opening']});

  add.method('startOpeningAnimation', function (menuMorph, callWhenDone) {
    var desiredScale = (window.Config && Config.fatFingers ? 1.5 : 1) * (this._normalScale || 1) / menuMorph.world().getScale();
    menuMorph.startTinyAndSmoothlyGrowTo(desiredScale, function() {
      // aaa - Make sure the text is visible. Not sure why this is necessary - why isn't it already visible?
      menuMorph.eachSubmorph(function(cm) { cm.beHighlighted(); cm.beUnhighlighted(); });
      if (callWhenDone) { callWhenDone(); }
    });
  }, {category: ['user interface', 'opening']});

  add.method('startClosingAnimation', function (menuMorph, callback) {
    menuMorph.smoothlyShrinkDownToNothing(function() {
      menuMorph.remove();
      if (callback) { callback(); }
    });
  }, {category: ['user interface', 'closing']});

  add.method('close', function (menuMorph, evt, callback) {
    menuMorph.releaseInputFocus(evt.hand);
    this.startClosingAnimation(menuMorph, callback);
  }, {category: ['user interface', 'closing']});

  add.method('createCommandMorphsIfNecessary', function (menuMorph) {
    if (menuMorph._hasCreatedCommandMorphs) { return; }
    menuMorph._hasCreatedCommandMorphs = true;
    menuMorph.layout().eachPosition(function(p, i) {
		  var c = menuMorph._commands[i];
		  if (c) { menuMorph.addMorphCenteredAt(this.createCommandMorph(menuMorph, c, i), p); }
    }.bind(this));
  }, {category: ['user interface', 'creating']});

  add.method('createCommandMorph', function (menuMorph, command, commandIndex) {
    var commandMorph = avocado.ui.newMorph(menuMorph.layout().createPieceShape(commandIndex));
    commandMorph.setModel(command);
		commandMorph._commandIndex = commandIndex;
		commandMorph._menuMorph = menuMorph;

		commandMorph.setEventHandler(avocado.eventHandlers.composite.create([
		  avocado.wheelMenu.eventHandlerForHighlighting,
		  avocado.wheelMenu.eventHandlerForRunningTheCommand,
		  avocado.wheelMenu.eventHandlerForShowingPartialCommandMorph
		]));
    commandMorph.handlesMouseDown = function (evt) { return true; };

		commandMorph.setStylist(avocado.wheelMenu.stylistToMatchTextColorWithMenuColor);
		commandMorph._labelMorph = avocado.label.create(command.labelString().attemptToInsertALineBreak()).newMorph().fitText();
		var p = menuMorph.layout().centerOfPiece(commandIndex);
		commandMorph.addMorphCenteredAt(commandMorph._labelMorph, p);
		commandMorph.applyStyle(avocado.wheelMenu.defaultCommandStyle);
		commandMorph.applyStyle(menuMorph.commandStyle);
		var targetMorphFill = menuMorph._targetMorph && menuMorph._targetMorph.getFill();
		if (targetMorphFill && targetMorphFill.isVeryLight()) { commandMorph.setFill(avocado.wheelMenu.defaultCommandStyle.fillToUseWhenTargetIsVeryLight); }
		
		return commandMorph;
  }, {category: ['user interface', 'constructing the morph']});

  add.method('runCommand', function (menuMorph, command, evt) {
	  this.close(menuMorph, evt, function() {
  	  command.go(evt);
	  });
  }, {category: ['user interface', 'running commands']});

  add.creator('morphMixin', {}, {category: ['user interface']});

});


thisModule.addSlots(avocado.wheelMenu.eventHandlerForMenu, function(add) {

  add.method('onMouseDown', function (morph, evt) {
    if (morph.handIsOverMe(evt.hand)) {
      var selectedCommandMorph = morph.submorphThatHandIsOver(evt.hand);
      if (selectedCommandMorph) { selectedCommandMorph.onMouseDown(evt); }
    } else {
      avocado.wheelMenu.close(morph, evt);
    }
    return true;
  });

  add.method('onMouseUp', function (morph, evt) {
    var selectedCommandMorph = morph.submorphThatHandIsOver(evt.hand);
    if (selectedCommandMorph) { selectedCommandMorph.onMouseUp(evt); }
    return true;
  });

  add.method('onMouseMove', function (morph, evt) {
    var hand = evt.hand || avocado.ui.currentWorld().firstHand();
    morph.takeInputFocus(hand);
    hand.setMouseFocus(morph);
    avocado.wheelMenu.highlightAppropriateCommandMorphs(morph, evt);
  });

  add.method('onTouchStart', function (morph, evt) {
    return this.onMouseDown(morph, evt);
  });

  add.method('onTouchEnd', function (morph, evt) {
    return this.onMouseUp(morph, evt);
  });

  add.method('onTouchMove', function (morph, evt) {
    return this.onMouseMove(morph, evt);
  });

  add.method('onKeyDown', function (morph, evt) {
    switch (evt.getKeyCode()) {
    	case Event.KEY_ESC: {
        avocado.wheelMenu.close(morph, evt);
        avocado.ui.worldFor(evt).removeAllPartialCommandMorphs();
  			evt.stop();
  			return true;
      }
  	}
  	
  	morph._mostRecentKeyCharDown = evt.getKeyChar().toLowerCase();
    avocado.wheelMenu.highlightAppropriateCommandMorphs(morph, evt);
  	return true;
  });

  add.method('onKeyUp', function (morph, evt) {
  	var keyChar = evt.getKeyChar().toLowerCase();
  	if (keyChar === morph._mostRecentKeyCharDown) {
    	morph._mostRecentKeyCharDown = undefined;
    	var i = avocado.wheelMenu.keyboardShortcuts.indexOf(keyChar);
    	if (i >= 0) {
    	  var cmdMorph = avocado.wheelMenu.commandMorphForIndex(morph, i);
    	  if (cmdMorph) {
          avocado.wheelMenu.runCommand(morph, cmdMorph._model, evt);
          avocado.ui.worldFor(evt).removeAllPartialCommandMorphs();
          evt.stop();
          return true;
    	  }
    	}
  	}
  	
  	return false;
  });

});


thisModule.addSlots(avocado.wheelMenu.eventHandlerForHighlighting, function(add) {

  add.method('isEnabled', function (morph, evt) {
    return avocado.wheelMenu.areCommandsEnabled(morph._menuMorph);
  });

  add.method('onMouseOver', function (morph, evt) {
    morph.beHighlighted();
  });

  add.method('onMouseOut', function (morph, evt) {
    morph.beUnhighlighted();
  });

  add.method('onTouchOver', function (morph, evt) {
    morph.beHighlighted();
  });

  add.method('onTouchOut', function (morph, evt) {
    morph.beUnhighlighted();
  });

  add.method('onTouchEnd', function (morph, evt) {
    morph.beUnhighlighted();
  });

});


thisModule.addSlots(avocado.wheelMenu.eventHandlerForShowingPartialCommandMorph, function(add) {

  add.method('onMouseDown', function (morph, evt) {
    var world = avocado.ui.worldFor(evt);
    var pcm = world._partialCommandMorph;
    if (pcm) {
      if (pcm._model.command() === morph._model) {
        var menuMorph = morph._menuMorph;
        setTimeout(function() {
          pcm.smoothlyFadeTo(1);
          world.grabPartialCommandMorphIfItIsStillThisOne(pcm);
          avocado.wheelMenu.close(menuMorph, evt);
        }, 750);
        return true;
      } else {
        throw new Error("Why is the world's _partialCommandMorph not the one we expected?");
      }
    }
  }, {category: ['events']});

  add.method('onMouseUp', function (morph, evt) {
    var world = avocado.ui.worldFor(evt);
    world.hideWhatWillHappenIfThisCommandRuns(evt, morph);
  }, {category: ['events']});

  add.method('onMouseOver', function (morph, evt) {
    var world = avocado.ui.worldFor(evt);
    world.showWhatWillHappenIfThisCommandRuns(evt, morph);
  }, {category: ['events']});

  add.method('onMouseOut', function (morph, evt) {
    var world = avocado.ui.worldFor(evt);
    world.hideWhatWillHappenIfThisCommandRuns(evt, morph);
  }, {category: ['events']});

});


thisModule.addSlots(avocado.wheelMenu.eventHandlerForRunningTheCommand, function(add) {

  add.method('isEnabled', function (morph, evt) {
    return avocado.wheelMenu.areCommandsEnabled(morph._menuMorph);
  });

  add.method('onMouseUp', function (morph, evt) {
    avocado.wheelMenu.runCommand(morph._menuMorph, morph._model, evt);
  });

  add.method('onTouchEnd', function (morph, evt) {
    return this.onMouseUp(morph, evt);
  });

});


thisModule.addSlots(avocado.wheelMenu.stylistToMatchTextColorWithMenuColor, function(add) {

  add.method('applyStyle', function (morph, spec) {
		if (spec.textColor !== undefined) {
			morph._labelMorph.setTextColor(spec.textColor);
		}
  });

  add.method('adjustStyleSpec', function (morph, spec) {
    spec.textColor = morph._labelMorph.getTextColor();
  });

  add.method('styleWhenHighlighted', function (morph) {
    return {
      fillBase: Color.blue,
      borderWidth: 0,
      borderRadius: 1,
      textColor: Color.white
    };
  }, {category: ['styles']});

});


thisModule.addSlots(avocado.wheelMenu.defaultCommandStyle, function(add) {

  add.data('borderWidth', 0);

  add.data('fill', new Color(1, 1, 1));

  add.data('fillToUseWhenTargetIsVeryLight', new Color(0.75, 0.75, 0.75));

  add.data('fillOpacity', 0.6);

  add.data('openForDragAndDrop', false);

  add.data('suppressHandles', true);

  add.data('textColor', new Color(0, 0, 0));

});


thisModule.addSlots(avocado.wheelMenu.defaultStyle, function(add) {

  add.data('borderWidth', 0);

  add.data('fill', new Color(1, 1, 1));

  add.data('fillToUseWhenTargetIsVeryLight', new Color(0.75, 0.75, 0.75));

  add.data('fillOpacity', 0.4);

  add.data('openForDragAndDrop', false);

  add.data('suppressHandles', true);

});


thisModule.addSlots(avocado.wheelMenu.contextCommandStyle, function(add) {

  add.data('textColor', new Color(0, 0, 0));

});


thisModule.addSlots(avocado.wheelMenu.morphCommandStyle, function(add) {

  add.data('textColor', new Color(0, 0, 0.8));

});


thisModule.addSlots(avocado.wheelMenu.modes, function(add) {

  add.creator('transientInactive', {});

  add.creator('transientActive', {});

  add.creator('semiTransient', {});

  add.creator('nonTransient', {});

});


thisModule.addSlots(avocado.wheelMenu.modes.transientInactive, function(add) {

  add.data('areCommandsDisabled', true);

});


thisModule.addSlots(avocado.wheelMenu.morphMixin, function(add) {

  add.method('keepOnlyItemsNamed', function (nameList) {
    for (var i = 0; i < this._commands.length; ++i) {
      var c = this._commands[i];
      if (c) {
        var n = c.labelString();
        if (nameList.indexOf(n) < 0) {
          this._commands[i] = null;
        }
      }
    }
    return this;
  }, {category: ['compatibility']});

  add.method('removeItemNamed', function (name) {
    for (var i = 0; i < this._commands.length; ++i) {
      var c = this._commands[i];
      if (c) {
        var n = c.labelString();
        if (name === n) {
          this._commands[i] = null;
        }
      }
    }
    return this;
  }, {category: ['compatibility']});

  add.method('addLine', function () {
    // No such thing, just here for compatibility with normal MenuMorphs.;
  }, {category: ['compatibility']});

  add.method('addItem', function (item) {
    if (!item[0] || !item[1]) { return this; }
    var newCmd = avocado.command.create(item[0], item[1]);
    for (var i = 0; i < this._commands.length; ++i) {
      var c = this._commands[i];
      if (! c) {
        this._commands[i] = newCmd;
        return this;
      }
    }
    throw new Error("Cannot add " + item[0] + " to wheel menu; no more room.");
  }, {category: ['compatibility']});

});


thisModule.addSlots(avocado.morphMixins.WorldMorph, function(add) {

  add.method('showPartialCommandMorph', function (pcm) {
    this._partialCommandMorph = pcm;
    pcm.showWithoutAnimationInTopRightCornerOfUsersFieldOfVision(this);
  }, {category: ['commands']});

  add.method('removeAllPartialCommandMorphsExceptFor', function (command) {
    var pcm = this._partialCommandMorph;
    if (pcm && pcm._model.command() === command) {
      pcm.remove();
      delete this._partialCommandMorph;
    }
  }, {category: ['commands']});

  add.method('removeAllPartialCommandMorphs', function () {
    var pcm = this._partialCommandMorph;
    if (pcm) {
      pcm.remove();
      delete this._partialCommandMorph;
    }
  }, {category: ['commands']});

  add.method('grabPartialCommandMorphIfItIsStillThisOne', function (pcm, evt) {
    if (this._partialCommandMorph === pcm && pcm.getOwner() === this) {
      delete this._partialCommandMorph;
      pcm.grabMe(evt);
    }
  }, {category: ['commands']});

  add.method('argumentMorphLabelsFor', function (commandMorph) {
    if (! commandMorph._cachedArgumentMorphLabels) {
      commandMorph._cachedArgumentMorphLabels = (commandMorph._model._argumentSpecsThatWillBeFoundOrPromptedFor || []).map(function(argSpec, i) {
        var tm = avocado.label.create(argSpec.name() || i.toString()).newMorph().ignoreEvents();
        tm._argSpec = argSpec;
        return tm;
      });
    }
    return commandMorph._cachedArgumentMorphLabels;
  }, {category: ['commands', 'feedback']});

  add.method('findArgumentMorphsAndShowLabels', function (argMorphLabels, partialCommand) {
    var context = partialCommand.command().contextOrDefault();
    argMorphLabels.each(function(m, i) {
      var argHolder = partialCommand.argumentHolders()[i];
      var arg = m._argSpec.findArg(context, evt);
      if (arg !== null && typeof(arg) !== 'undefined') {
        if (arg.isMorph) {
          argHolder.setValue(arg);
          var world = arg.world();
          if (world) { m.showAsLabelOnTopOf(arg, world); }
        }
      }
    });
  }, {category: ['commands', 'feedback']});

  add.method('showWhatWillHappenIfThisCommandRuns', function (evt, commandMorph) {
    var pc = commandMorph._model.createPartialCommand();
    this.findArgumentMorphsAndShowLabels(this.argumentMorphLabelsFor(commandMorph), pc);
    var world = avocado.ui.worldFor(evt);
    world.removeAllPartialCommandMorphs();
    world.showPartialCommandMorph(world.morphFor(pc).setFillOpacity(0.5));
  }, {category: ['commands', 'feedback']});

  add.method('hideWhatWillHappenIfThisCommandRuns', function (evt, commandMorph) {
    this.argumentMorphLabelsFor(commandMorph).each(function(m) { m.remove(); });
    avocado.ui.worldFor(evt).removeAllPartialCommandMorphsExceptFor(commandMorph._model);
  }, {category: ['commands', 'feedback']});

});


});

avocado.transporter.module.onLoadCallbacks["lk_ext/commands"] = function() {};
avocado.transporter.module.create('lk_ext/commands', function(requires) {

requires('general_ui/commands');
requires('general_ui/wheel_menus');

}, function(thisModule) {


thisModule.addSlots(avocado.command, function(add) {

  add.method('newMorph', function (optionalLabelMorph, optionalPadding, optionalLabelPos) {
    var m = ButtonMorph.createButton(optionalLabelMorph || this.label, this.go.bind(this), typeof(optionalPadding) === 'number' ? optionalPadding : 2, optionalLabelPos);
    
    var ht = this.helpText();
    if (typeof(ht) === 'function') {
      m.getHelpText = ht;
    } else if (typeof(ht) === 'string') {
      m.setHelpText(ht);
    }
    
    var af = this.applicabilityFunction();
    if (af) {
      m = avocado.table.createOptionalMorph(m, af);
      m.refreshContent();
    }
    
    return m;
  }, {category: ['user interface']});

});


thisModule.addSlots(avocado.command.list, function(add) {

  add.data('shouldUseWheelMenus', true);

  add.method('defaultMenuClass', function () {
    return this.shouldUseWheelMenus ? avocado.wheelMenu : MenuMorph;
  }, {category: ['converting']});

  add.method('menuClassThatCanHandleAnUnlimitedNumberOfItems', function () {
    return MenuMorph;
  }, {category: ['converting']});

});


thisModule.addSlots(MenuMorph, function(add) {

  add.method('createMenuMorph', function (items, target) {
    return new this(items, target);
  }, {category: ['creating']});

  add.method('itemsForCommands', function (commands) {
    return commands.map(function(c) {
      if (!c) {
        return null;
      } else if (c instanceof Array) {
        return c;
      } else if (c.subcommands()) {
        return [c.labelString(), MenuMorph.itemsForCommands(c.subcommands())];
      } else {
        return [c.labelString(), function() { c.go.apply(c, arguments); }];
      }
    });
  }, {category: ['converting']});

});


thisModule.addSlots(avocado.command.partial, function(add) {

  add.method('newMorph', function () {
    return avocado.treeNode.newMorphFor(this, undefined, 0.1);
  }, {category: ['user interface']});

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/morph_hider"] = function() {};
avocado.transporter.module.create('general_ui/morph_hider', function(requires) {

requires('general_ui/basic_morph_mixins');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('morphHider', {}, {category: ['ui']});

});


thisModule.addSlots(avocado.morphHider, function(add) {

  add.method('create', function () {
    var c = Object.create(this);
    c.initialize.apply(c, arguments);
    return c;
  }, {category: ['creating']});

  add.method('initialize', function (morphToUpdate, possibleMorphsToShow, criterionForShowing) {
    this._morphToUpdate = morphToUpdate;
    this._possibleMorphsToShow = possibleMorphsToShow;
    if (criterionForShowing) { this.whichMorphShouldBeShown = criterionForShowing; }
  });

  add.method('update', function (evt) {
    if (this._morphToUpdate) { this._morphToUpdate.refreshContentIfOnScreenOfMeAndSubmorphs(); }
  });

  add.method('morphOrFunctionToShow', function () {
    var i = this.whichMorphShouldBeShown();
    if (i === null || typeof(i) === 'undefined') { return null; }
    return this._possibleMorphsToShow[i];
  });

  add.method('actualMorphToShow', function (context) {
    var m = this.morphOrFunctionToShow();
    if (typeof(m) === 'function') { m = m(); }
    return m && m.actualMorphToShow(context);
  });

  add.method('constructUIStateMemento', function () {
    return undefined;
  }, {category: ['UI state']});

  add.method('assumeUIState', function (uiState, callWhenDone, evt) {
    // no UI state
    if (callWhenDone) { callWhenDone(); }
  }, {category: ['UI state']});

});


thisModule.addSlots(avocado.morphMixins.TextMorph, function(add) {

  add.method('wasJustAdded', function (evt) { this.requestKeyboardFocus(evt.hand); });

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/scaling"] = function() {};
avocado.transporter.module.create('general_ui/scaling', function(requires) {

requires('general_ui/basic_morph_mixins');
requires('general_ui/morph_hider');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('scaleBasedMorphHider', Object.create(avocado.morphHider), {category: ['ui']});

});


thisModule.addSlots(avocado.scaleBasedMorphHider, function(add) {

  add.method('initialize', function ($super, morphToUpdate, morph1, owner, thresholdNumberOrFunction, sizeOfSpaceHolder, styleOfSpaceHolder) {
    $super(morphToUpdate, [morph1, this.spaceHolder.bind(this)]);
    this._owner = owner;
    if (typeof(thresholdNumberOrFunction) === 'function') {
      this.currentThreshold = thresholdNumberOrFunction;
    } else {
      this._thresholdNumber = thresholdNumberOrFunction;
    }
    this._sizeOfSpaceHolder = sizeOfSpaceHolder;
    this._styleOfSpaceHolder = styleOfSpaceHolder || {fill: null};
  });

  add.method('spaceHolder', function () {
    var h = this._spaceHolder;
    if (!h) {
      if (!this._sizeOfSpaceHolder) { return null; }
      var h = avocado.ui.newMorph(avocado.ui.shapeFactory.newRectangle(pt(0,0).extent(this._sizeOfSpaceHolder)));
      h._spaceHolderMinimumExtent = this._sizeOfSpaceHolder;
      h.setLayout(avocado.scaleBasedMorphHider.spaceHolderLayout);
      h.applyStyle(this._styleOfSpaceHolder);
      h.ignoreEvents();
      h._isSpaceHolderForScaleBasedMorphHider = this;
      this._spaceHolder = h;
    }
    return h;
  });

  add.method('currentThreshold', function () {
    return this._thresholdNumber;
  });

  add.method('whichMorphShouldBeShown', function () {
    if (avocado.shouldAlwaysShowVerySmallMorphs) { return 0; }
    var b = false;
    var onScreen = this._owner.isOnScreen();
    if (onScreen) {
      var s = this._owner.overallScaleTakingUsersPositionIntoAccount();
      var t = this.currentThreshold();
      b = s >= t;
    }
    var i = b ? 0 : 1;
    // console.log("whichMorphShouldBeShown is " + i + " for " + this._owner + ", scale is " + s + ", threshold is " + t + ", onScreen is " + onScreen);
    return i;
  });

  add.creator('spaceHolderLayout', {});

});


thisModule.addSlots(avocado.scaleBasedMorphHider.spaceHolderLayout, function(add) {

  add.method('minimumExtent', function (spaceHolderMorph) {
    return spaceHolderMorph._spaceHolderMinimumExtent;
  });

});


thisModule.addSlots(avocado.morphMixins.Morph, function(add) {

  add.method('overallScale', function (optionalAncestorToStopAt) {
    var s = 1.0;
    var m = this;
    while (m && m !== optionalAncestorToStopAt) {
      s = s * m.getScale();
      m = m.getOwner();
    }
    return s;
  }, {category: ['zooming interface']});

  add.method('setOverallScale', function (desiredOverallScale, optionalAncestorToStopAt) {
    var ownerOverallScale = this.getOwner() ? this.getOwner().overallScale(optionalAncestorToStopAt) : 1;
    this.setScale(desiredOverallScale / ownerOverallScale);
    return this;
  }, {category: ['zooming interface']});

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/toggler"] = function() {};
avocado.transporter.module.create('general_ui/toggler', function(requires) {

requires('general_ui/morph_hider');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('morphToggler', Object.create(avocado.morphHider), {category: ['ui']});

});


thisModule.addSlots(avocado.morphToggler, function(add) {

  add.method('initialize', function ($super, morphToUpdate, morph1, morph2) {
    $super(morphToUpdate, [morph1, morph2]);
    this._valueHolder = avocado.booleanHolder.containing(false);
    this._valueHolder.addObserver(this.valueChanged.bind(this));
  });

  add.method('whichMorphShouldBeShown', function () { return this.isOn() ? 0 : 1; });

  add.method('isOn', function () { return this._valueHolder.getValue(); });

  add.method('toggle', function (evt) { this._valueHolder.toggle(evt); });

  add.method('setValue', function (b, evt) { this._valueHolder.setValue(b, evt); });

  add.method('beOn', function (evt) { this.setValue(true, evt); });

  add.method('beOff', function (evt) { this.setValue(false, evt); });

  add.method('valueChanged', function (valueHolder, evt) {
    this.update(evt);
  });

  add.method('update', function ($super, evt) {
    $super(evt);
    var m = this.actualMorphToShow();
    if (m) { m.wasJustAdded(evt); } // aaa this seems wrong, it wasn't just added;
  });

  add.method('constructUIStateMemento', function () {
    return this.isOn();
  }, {category: ['UI state']});

  add.method('assumeUIState', function (uiState, callWhenDone, evt) {
    this.setValue(uiState, evt || Event.createFake());
    if (callWhenDone) { callWhenDone(); }
  }, {category: ['UI state']});

  add.method('commandForToggling', function (name, label) {
    var c = avocado.command.create(label || (this.isOn() ? "hide " : "show ") + name, function(evt) { this.toggle(evt); }.bind(this));
    c.setHelpText(function() { return (this.isOn() ? 'Hide ' : 'Show ') + name; }.bind(this));
    return c;
  }, {category: ['commands']});

});


});

avocado.transporter.module.onLoadCallbacks["core/history"] = function() {};
avocado.transporter.module.create('core/history', function(requires) {

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('history', {}, {category: ['core']});

});


thisModule.addSlots(avocado.history, function(add) {

  add.method('create', function () {
    var h = Object.create(this);
    h.initialize.apply(h, arguments);
    return h;
  }, {category: ['creating']});

  add.method('initialize', function (name) {
    this._name = name;
    this._versions = [];
  }, {category: ['creating']});

  add.method('toString', function () {
    return this._name;
  }, {category: ['printing']});

  add.method('inspect', function () {
    return this.toString();
  }, {category: ['printing']});

  add.method('latest', function () {
    if (this._versions.length === 0) { return null; }
    return this._versions[this._versions.length - 1];
  }, {category: ['accessing']});

  add.method('addLatest', function (v) {
    if (this._versions.length > 0 && this.latest() === null) {
      this._versions[this._versions.length - 1] = v;
    } else {
      this._versions.push(v);
    }
  }, {category: ['accessing']});

  add.method('clearLatest', function () {
    if (this.latest() !== null) {
      this.addLatest(null);
    }
  }, {category: ['accessing']});

});


});

avocado.transporter.module.onLoadCallbacks["core/table"] = function() {};
avocado.transporter.module.create('core/table', function(requires) {

requires('core/directions');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('table', {}, {category: ['collections', 'tables']});

});


thisModule.addSlots(avocado.table, function(add) {

  add.creator('contents', {});

});


thisModule.addSlots(avocado.table.contents, function(add) {

  add.method('createWithRows', function (a) {
    return this.create(a, avocado.directions.vertical);
  }, {category: ['creating']});

  add.method('createWithColumns', function (a) {
    return this.create(a, avocado.directions.horizontal);
  }, {category: ['creating']});

  add.method('createWithRow', function (elements) {
    return this.createWithRows([elements]);
  }, {category: ['creating']});

  add.method('createWithColumn', function (elements) {
    return this.createWithColumns([elements]);
  }, {category: ['creating']});

  add.method('create', function (a, dir1) {
    return Object.newChildOf(this, a, dir1);
  }, {category: ['creating']});

  add.data('_direction1', avocado.directions.vertical);

  add.data('_direction2', avocado.directions.horizontal);

  add.data('_data', [], {initializeTo: '[]'});

  add.method('initialize', function (a, dir1) {
    this._data = a;
    if (! avocado.shouldBreakCreatorSlotsInOrderToImprovePerformance) {
      reflect(this).slotAt('_data').beCreator();
      this._data.makeAllCreatorSlots();
      this._data.forEach(function(line) { line.makeAllCreatorSlots(); });
    }
    this._direction1 = dir1;
    this._direction2 = dir1.sideways;
  }, {category: ['creating']});

  add.method('copyRemoveAll', function () {
    return avocado.table.contents.create([], this._direction1);
  }, {category: ['creating']});

  add.method('copyWithLines', function (primaryLines) {
    return avocado.table.contents.create(primaryLines, this._direction1);
  }, {category: ['creating']});

  add.method('copyWithSoleLine', function (solePrimaryLine) {
    return avocado.table.contents.create([solePrimaryLine], this._direction1);
  }, {category: ['creating']});

  add.method('copy', function () {
    return this.copyWithLines(this._data.map(function(line) { return line.map(function(elem) { return elem; }); }));
  }, {category: ['copying']});

  add.method('duplicate', function (copier) {
    return this.copy(copier);
  }, {category: ['copying']});

  add.method('copyAndAddElement', function (extraElement) {
    var c = this.copy();
    c.addElement(extraElement);
    return c;
  }, {category: ['creating']});

  add.method('copyAndRemoveElement', function (e) {
    var newData = this._data.map(function(primaryLine) { return primaryLine.reject(function(ee) { return e === ee; }); });
    return this.copyWithLines(newData);
  }, {category: ['creating']});

  add.method('equals', function (other) {
    if (this._direction1 !== other._direction1) { return false; }
    if (this._data.length !== other._data.length) { return false; }
    for (var i = 0, n = this._data.length; i < n; ++i) {
      if (! this.areArraysEqual(this._data[i], other._data[i])) {
        return false;
      }
    }
    return true;
  }, {category: ['comparing']});

  add.method('areArraysEqual', function (a1, a2) {
    if (a1.length !== a2.length) { return false; }
    for (var i = 0, n = a1.length; i < n; ++i) {
      if (a1[i] !== a2[i]) { return false; }
    }
    return true;
  }, {category: ['comparing']});

  add.method('hashCode', function (other) {
    var h = [this._direction1];
    // aaa - maybe just loop over the first few, not all of them
    this.eachElement(function(x) { h.push(avocado.hashTable.identityComparator.hashCodeForKey(x)); })
    return h.join("");
  }, {category: ['comparing']});

  add.method('elements', function () {
    return avocado.enumerator.create(this, 'eachElement');
  }, {category: ['iterating']});

  add.method('eachElement', function (f) {
    this._data.each(function(rowOrCol) {
      rowOrCol.each(f);
    });
  }, {category: ['iterating']});

  add.method('eachRow', function (f) {
    this.eachLineInDirection(avocado.directions.horizontal, f);
  }, {category: ['iterating']});

  add.method('eachColumn', function (f) {
    this.eachLineInDirection(avocado.directions.vertical, f);
  }, {category: ['iterating']});

  add.method('eachLineInDirection', function (dir, f) {
    if (dir === this._direction2) {
      this.eachPrimaryLine(f);
    } else if (dir === this._direction1) {
      this.eachSecondaryLine(f);
    } else {
      throw new Error("eachLineInDirection(" + dir + ")???");
    }
  }, {category: ['iterating']});

  add.method('eachPrimaryLine', function (f) {
    this._data.each(f);
  }, {category: ['iterating']});

  add.method('primaryLines', function () {
    return this._data;
  }, {category: ['accessing']});

  add.method('primaryLine', function (i) {
    return this._data[i];
  }, {category: ['iterating']});

  add.method('setData', function (d) {
    this._data = d;
    return this;
  }, {category: ['accessing']});

  add.method('setPrimaryLines', function (d) {
    return this.setData(d);
  }, {category: ['accessing']});

  add.method('setSoleLine', function (line) {
    return this.setPrimaryLines([line]);
  }, {category: ['accessing']});

  add.method('eachSecondaryLine', function (f) {
    for (var i = 0, n = this.lengthOfLongestPrimaryLine(); i < n; ++i) {
      f(this.secondaryLine(i));
    }
  }, {category: ['iterating']});

  add.method('secondaryLine', function (i) {
    return avocado.enumerator.create(this, 'eachElementInSecondaryLine', i);
  }, {category: ['iterating']});

  add.method('secondaryLines', function () {
    return avocado.enumerator.create(this, 'eachSecondaryLine');
  }, {category: ['accessing']});

  add.method('eachElementInSecondaryLine', function (i, f) {
    this.primaryLines().each(function(line) {
      f(line.length > i ? line[i] : null);
    });
  }, {category: ['iterating']});

  add.method('lengthOfLongestPrimaryLine', function () {
    var n = 0;
    this.primaryLines().each(function(line) {
      n = Math.max(n, line.length);
    });
    return n;
  }, {category: ['accessing']});

  add.method('insertPrimaryLine', function (line, i) {
    if (! avocado.shouldBreakCreatorSlotsInOrderToImprovePerformance) {
      line.makeAllCreatorSlots();
      this._data.spliceAndAdjustCreatorSlots(i, 0, line);
    } else {
      this._data.splice(i, 0, line);
    }
  }, {category: ['inserting']});

  add.method('selectThenMap', function (selectFn, mapFn) {
    var c = this.copyRemoveAll();
    this._data.each(function(rowOrCol) {
      var rowOrColArray = rowOrCol.toArray();
      var newRowOrCol = [];
      // using a for loop because sometimes I have sparse arrays and forEach skips over the "missing" elements
      for (var i = 0; i < rowOrColArray.length; ++i) {
        var x = rowOrColArray[i];
        if (selectFn(x)) {
          newRowOrCol.push(mapFn(x));
        }
      }
      if (! avocado.shouldBreakCreatorSlotsInOrderToImprovePerformance) {
        newRowOrCol.makeAllCreatorSlots();
        c._data.pushAndAdjustCreatorSlots(newRowOrCol);
      } else {
        c._data.push(newRowOrCol);
      }
    });
    return c;
  }, {category: ['transforming']});

  add.method('map', function (mapFn) {
    return this.selectThenMap(function() { return true; }, mapFn);
  }, {category: ['transforming']});

  add.method('replaceElement', function (currentElement, newElement) {
    this._data.each(function(rowOrCol) {
      for (var i = 0, n = rowOrCol.length; i < n; ++i) {
        var e = rowOrCol[i];
        if (e === currentElement) { rowOrCol[i] = newElement; }
      }
    });
  }, {category: ['transforming']});

  add.method('addElement', function (e) {
    if (! this.primaryLines().last()) { this.primaryLines().push([]); }
    this.primaryLines().last().push(e);
    return this;
  }, {category: ['transforming']});

  add.method('removeElement', function (e) {
    this._data = this._data.map(function(primaryLine) { return primaryLine.reject(function(ee) { return e === ee; }); });
    return this;
  }, {category: ['transforming']});

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/table_layout"] = function() {};
avocado.transporter.module.create('general_ui/table_layout', function(requires) {

requires('reflection/reflection');
requires('core/table');
requires('general_ui/basic_morph_mixins');
requires('general_ui/layout');

}, function(thisModule) {


thisModule.addSlots(avocado.table, function(add) {

  add.creator('layout', {}, {category: ['user interface']});

  add.method('newColumnMorph', function () {
    return avocado.ui.newMorph().useTableLayout(avocado.table.contents.columnPrototype);
  }, {category: ['user interface']});

  add.method('newRowMorph', function () {
    return avocado.ui.newMorph().useTableLayout(avocado.table.contents.rowPrototype);
  }, {category: ['user interface']});

  add.method('newTableMorph', function () {
    return this.newColumnMorph();
  }, {category: ['user interface']});

  add.method('createSpaceFillingRowMorph', function (content, padding) {
    var m = this.newRowMorph().beInvisible();
    var direction = avocado.directions.horizontal;
    if (padding !== undefined) { m.layout().setPadding(padding); }
    direction.setLayoutModeOf(m, avocado.LayoutModes.SpaceFill);
    
    if (typeof(content) === 'function') {
      m.setPotentialContentMorphsFunction(function() { return avocado.table.contents.create([content()], direction.sideways); });
      m.refreshContent();
    } else {
      // default to left-justifying the contents
      if (content.all(function(c) {return direction.layoutModeOf(c) !== avocado.LayoutModes.SpaceFill;})) {
        content = content.concat([avocado.ui.createSpacer()]);
      }
      m.replaceContentWith(avocado.table.contents.create([content], direction.sideways));
    }
    
    return m;
  }, {category: ['user interface']});

  add.creator('boxStyle', {}, {category: ['user interface']});

  add.method('createEitherOrMorph', function (morphs, functionReturningTheIndexOfTheOneToShow) {
    // aaa - callers that are TableMorphs already and just need two choices should just use the new enhanced morphToggler, don't need to wrap it in this RowMorph anymore
    var r = avocado.table.newRowMorph().beInvisible();
    r.typeName = 'either-or morph';
    var togglers = morphs.map(function(m) { return avocado.morphToggler.create(null, m); });
    r.layout().setPotentialCells(togglers);
    r.refreshContent = avocado.makeSuperWork(r, "refreshContent", function($super) {
      var i = functionReturningTheIndexOfTheOneToShow();
      var evt = Event.createFake();
      togglers.each(function(t, ti) {
        t.setValue(i === ti, evt);
      });
      return $super();
    });
    return r;
  }, {category: ['shortcuts']});

  add.method('createOptionalMorph', function (m, condition, layoutModes) {
    var om = this.createEitherOrMorph([m, avocado.table.newRowMorph().beInvisible()], function() { return condition() ? 0 : 1; });
    om.typeName = 'optional morph';
    om.horizontalLayoutMode = (layoutModes || m).horizontalLayoutMode;
    om.verticalLayoutMode   = (layoutModes || m).verticalLayoutMode;
    return om;
  }, {category: ['shortcuts']});

  add.method('wrapToTakeUpConstantWidth', function (width, morph) {
    return this.wrapToTakeUpConstantSpace(pt(width, null), morph);
  }, {category: ['shortcuts']});

  add.method('wrapToTakeUpConstantHeight', function (height, morph) {
    return this.wrapToTakeUpConstantSpace(pt(null, height), morph);
  }, {category: ['shortcuts']});

  add.method('wrapToTakeUpConstantSpace', function (space, morph) {
    var wrapper = avocado.table.newRowMorph().beInvisible();
    wrapper.layout().setDesiredSpace(space);
    wrapper.layout().setCells([morph]);
    return wrapper;
  }, {category: ['shortcuts']});

});


thisModule.addSlots(avocado.table.layout, function(add) {

  add.method('initialize', function (tableMorph) {
    this._tableMorph = tableMorph;
  }, {category: ['creating']});

  add.method('getExtent', function () {
    return this._tableMorph.getExtent();
  }, {category: ['accessing the table morph']});

  add.method('getScale', function () {
    return this._tableMorph.getScale();
  }, {category: ['accessing the table morph']});

  add.method('setScale', function (s) {
    this._tableMorph.setScale(s);
  }, {category: ['accessing the table morph']});

  add.method('tableContent', function () {
    return this._tableContent;
  }, {category: ['accessing']});

  add.method('setTableContent', function (c) {
    this._tableContent = c;
    // aaa - several hacks piled on top of each other
    if (!avocado.shouldBreakCreatorSlotsInOrderToImprovePerformance && c !== avocado.table.contents.rowPrototype && c !== avocado.table.contents.columnPrototype && !reflect(c).explicitlySpecifiedCreatorSlot()) {
      reflect(this).slotAt('_tableContent').beCreator();
    }
    return this;
  }, {category: ['accessing']});

  add.method('shouldPrintDebugInfo', function () {
    return this._tableMorph._debugMyLayout;
  }, {category: ['accessing the table morph']});

  add.method('layoutModes', function () {
    // aaa make the TableMorph itself store them as a Point?
    return pt(this._tableMorph.horizontalLayoutMode, this._tableMorph.verticalLayoutMode);
  }, {category: ['accessing the table morph']});

  add.method('replaceContentWith', function (newContent) {
    if (this.tableContent() && this.tableContent().equals(newContent)) { return; }
    this.setTableContent(newContent);
    this.setSubmorphsFromTableContent();
  }, {category: ['adding and removing']});

  add.method('replaceMorph', function (m, newSubmorph) {
		// Gotta make sure to leave the replaced morph at the right scale, so that if we then add it back to the world it'll look right. -- Adam
		var mScale = m.overallScale(this._tableMorph.world());
		
    this.tableContent().replaceElement(m, newSubmorph);
    this.setSubmorphsFromTableContent();
    
		m.setScale(mScale);
  }, {category: ['adding and removing']});

  add.method('setCells', function (ms) {
    this.replaceContentWith(this.tableContent().copyWithSoleLine(ms));
  }, {category: ['adding and removing']});

  add.method('setPotentialCells', function (ms) {
    this._tableMorph.setPotentialContentMorphs(this.tableContent().copyWithSoleLine(ms));
  }, {category: ['adding and removing']});

  add.method('addCell', function (m) {
    this.replaceContentWith(this.tableContent().copyAndAddElement(m));
  }, {category: ['adding and removing']});

  add.method('removeCell', function (m) {
    this.replaceContentWith(this.tableContent().copyAndRemoveElement(m));
  }, {category: ['adding and removing']});

  add.method('setSubmorphsFromTableContent', function () {
    if (this._submorphReplacementBatcherUpper && this._submorphReplacementBatcherUpper.isRunning()) {
      this._submorphReplacementBatcherUpper.batchUp();
      return;
    }
    
    // console.log("Running setSubmorphsFromTableContent on " + (this._tableMorph.toString() || avocado.identityHashFor(this._tableMorph)));
    this._tableMorph.replaceMorphs(this._tableMorph.submorphsParticipatingInLayout(), this.tableContent().elements());
  }, {category: ['adding and removing']});

  add.method('submorphReplacementBatcherUpper', function () {
    if (! this._submorphReplacementBatcherUpper) {
      this._submorphReplacementBatcherUpper = avocado.batcherUpper.create(this, function() {
        this._context.setSubmorphsFromTableContent();
      });
    }
    return this._submorphReplacementBatcherUpper;
  }, {category: ['layout']});

  add.method('getPadding', function () {
    return this._padding;
  }, {category: ['padding']});

  add.method('setPadding', function (p) {
    if (typeof p === 'number') {
      this._padding = {left: p, right: p, top: p, bottom: p, between: {x: p, y: p}};
    } else {
      this._padding = p;
    }
    return this;
  }, {category: ['padding']});

  add.data('_padding', {left: 10, right: 10, top: 10, bottom: 10, between: {x: 10, y: 10}}, {category: ['padding'], initializeTo: '{left: 10, right: 10, top: 10, bottom: 10, between: {x: 10, y: 10}}'});

  add.method('applyStyle', function (spec) {
	  if (typeof(spec.padding) !== 'undefined') { this.setPadding(spec.padding); }
  }, {category: ['styles']});

  add.method('adjustStyleSpec', function (spec) {
    if (typeof(this._padding) !== 'undefined') { spec.padding = this._padding; }
  }, {category: ['styles']});

  add.method('eachDirection', function (f) {
    f(avocado.directions.horizontal);
    f(avocado.directions.vertical);
  }, {category: ['directions']});

  add.method('isAffectedBy', function (operation, morph) {
    return ! morph.shouldNotBePartOfRowOrColumn;
  }, {category: ['layout']});

  add.method('possiblyDoSomethingBecauseASubmorphMinimumExtentHasChanged', function (tableMorph) {
    return tableMorph.minimumExtentMayHaveChanged();
  }, {category: ['layout']});

  add.method('minimumExtent', function () {
    return this.adjustForRigidityAndScale(this.internalMinimumExtent());
  }, {category: ['layout', 'minimum extent']});

  add.method('adjustForRigidityAndScale', function (e) {
    var e2 = this.adjustForRigidity(e);
    return e2.scaleBy(this.currentOrDesiredScaleGivenExtent(e2));
  }, {category: ['layout']});

  add.method('adjustForRigidity', function (e) {
    // Code uglified just a bit to avoid creating unnecessary Point objects; it's turning out to be significant. -- Adam
    var rigidX = this._tableMorph.horizontalLayoutMode === avocado.LayoutModes.Rigid;
    var rigidY = this._tableMorph.  verticalLayoutMode === avocado.LayoutModes.Rigid;
    if (rigidX || rigidY) {
      var currentExtent = this.getExtent();
      return pt(rigidX ? Math.max(e.x, currentExtent.x) : e.x,
                rigidY ? Math.max(e.y, currentExtent.y) : e.y);
    } else {
      return e;
    }
  }, {category: ['layout']});

  add.method('setDesiredSpace', function (space) {
    this._desiredSpaceToScaleTo = space;
    return this;
  }, {category: ['layout']});

  add.method('doNotCenter', function () {
    this._shouldNotCenterSideways = true;
    return this;
  }, {category: ['layout']});

  add.method('currentOrDesiredScaleGivenExtent', function (e) {
    var desiredSpace = this._desiredSpaceToScaleTo;
    if (desiredSpace) {
      var hs = null;
      var vs = null;
      if (desiredSpace.x && e.x) { hs = desiredSpace.x / e.x; }
      if (desiredSpace.y && e.y) { vs = desiredSpace.y / e.y; }
      if (hs !== null && vs !== null) { return Math.min(hs, vs); }
      if (hs === null && vs !== null) { return vs; }
      if (hs !== null && vs === null) { return hs; }
    }
    return this.getScale();
  }, {category: ['layout']});

  add.method('internalMinimumExtent', function () {
    if (! this._tableMorph._cachedMinimumExtent) {
      var layoutInfoForRowsAndColumns = this.calculateMinimumExtentsForRowsAndColumns();
      this._tableMorph._cachedMinimumExtent = this.calculateOverallMinimumExtent(layoutInfoForRowsAndColumns);
    }
    return this._tableMorph._cachedMinimumExtent;
  }, {category: ['layout', 'minimum extent']});

  add.method('calculateMinimumExtentsForRowsAndColumns', function () {
    var layoutInfo = pt([], []);
    this.eachDirection(function(dir) {
      var rs = dir.coord(layoutInfo);
      rs.spaceFillingCount = 0;
      this.tableContent().eachLineInDirection(dir, function(line) {
        var r = this.calculateMinimumExtentFor(line, dir);
        rs.push(r);
        if (r.canFillSpace) { rs.spaceFillingCount += 1; }
      }.bind(this));
    }.bind(this));
    return layoutInfo;
  }, {category: ['layout']});

  add.method('calculateMinimumExtentFor', function (morphs, direction) {
    var r = { biggestSideways: 0, canFillSpace: false };
    
    if (this.shouldPrintDebugInfo()) { console.log("calculateMinimumExtentFor " + morphs.size() + " morphs in direction " + direction); }
    morphs.each(function(m) {
      if (m) {
        var mMinExt = m.minimumExtent();
        var mMinSideways = direction.sideways.coord(mMinExt);
        if (this.shouldPrintDebugInfo()) { console.log("minimumExtent() for " + m.inspect() + " in direction " + direction.sideways + " is " + mMinSideways); }
        r.biggestSideways = Math.max(r.biggestSideways, mMinSideways);

        // How should we do this? Should the row be space-filling if *any* morph in it
        // is space-filling, or if *all* of them are, or what? Try any for now. -- Adam
        if (direction.sideways.layoutModeOf(m) === avocado.LayoutModes.SpaceFill) { r.canFillSpace = true; }
      }
    }.bind(this));
    
    return r;
  }, {category: ['layout', 'minimum extent']});

  add.method('calculateOverallMinimumExtent', function (layoutInfoForRowsAndColumns) {
    var overallMinExt = pt(0, 0);
    
    this.eachDirection(function(dir) {
      var infoForThisDirection = dir.coord(layoutInfoForRowsAndColumns);
      
      var totalLineSizes = infoForThisDirection.inject(0, function(sum, r) {
        return sum + r.biggestSideways;
      });
      
      var padding = this.getPadding();
      var totalPadding = dir.sideways.padding1(padding) +
                         dir.sideways.padding2(padding) +
                         (dir.sideways.coord(padding.between) * (infoForThisDirection.length - 1));

      if (this.shouldPrintDebugInfo()) { console.log("In calculateOverallMinimumExtent, direction " + dir + ", totalLineSizes is " + totalLineSizes + " and totalPadding is " + totalPadding + " for a total of " + (totalLineSizes + totalPadding)); }
      dir.sideways.setCoord(overallMinExt, totalLineSizes + totalPadding);
    }.bind(this));
    
    // keep it around, we'll need it when rejiggering the layout
    overallMinExt.layoutInfoForRowsAndColumns = layoutInfoForRowsAndColumns;
    if (this.shouldPrintDebugInfo()) { console.log("overallMinExt: " + overallMinExt); }
    
    return overallMinExt;
  }, {category: ['layout', 'minimum extent']});

  add.method('calculateSpaceToUseOutOf', function (availableSpace, thisExtent) {
    var availableSpaceToUse = pt(null, null);
    
    var layoutModes = this.layoutModes()
    if (layoutModes.x === avocado.LayoutModes.ShrinkWrap) { availableSpaceToUse.x =          this.internalMinimumExtent().x;                }
    if (layoutModes.x === avocado.LayoutModes.Rigid     ) { availableSpaceToUse.x = Math.max(this.internalMinimumExtent().x, thisExtent.x); }
    if (layoutModes.y === avocado.LayoutModes.ShrinkWrap) { availableSpaceToUse.y =          this.internalMinimumExtent().y;                }
    if (layoutModes.y === avocado.LayoutModes.Rigid     ) { availableSpaceToUse.y = Math.max(this.internalMinimumExtent().y, thisExtent.y); }
    
    var scale = this.currentOrDesiredScaleGivenExtent(availableSpaceToUse);
    if (scale !== this.getScale()) { this.setScale(scale); }
    
    if (availableSpaceToUse.x === null) { availableSpaceToUse.x = availableSpace.x / scale; }
    if (availableSpaceToUse.y === null) { availableSpaceToUse.y = availableSpace.y / scale; }
    
    if (this.shouldPrintDebugInfo()) { console.log(this._tableMorph.inspect() + ": availableSpace: " + availableSpace + ", availableSpaceToUse: " + availableSpaceToUse + ", this.getScale(): " + this.getScale() + ", this.internalMinimumExtent(): " + this.internalMinimumExtent() + ", thisExtent: " + thisExtent); }
    return availableSpaceToUse;
  }, {category: ['layout']});

  add.method('rejigger', function (tableMorph, availableSpace) {
    if (this.shouldPrintDebugInfo()) { console.log("About to rejigger the layout, availableSpace is " + availableSpace); }
    var thisExtent = this.getExtent();
    var availableSpaceToUse = this.calculateSpaceToUseOutOf(availableSpace, thisExtent);
    if (this.shouldPrintDebugInfo()) { console.log("availableSpaceToUse is " + availableSpaceToUse); }
    if (this.isAlreadyLaidOutInSpace(availableSpaceToUse)) {
      availableSpaceToUse = thisExtent;
    } else {
      this._tableMorph._spaceUsedLastTime = availableSpaceToUse;

      var extraSpaceUsage = this.decideWhatToDoWithExtraSpace(availableSpaceToUse);
      var actualCoordsAndSizes = this.calculateActualCoordinatesAndSizes(extraSpaceUsage);
      
      // aaa - Just reversed these two lines, because in 3D-land setMorphPositionsAndSizes needs to have the extent set already. Will that cause grief?
      this._tableMorph.setExtentIfChanged(availableSpaceToUse);
      this.setMorphPositionsAndSizes(actualCoordsAndSizes);

      this._tableMorph._layoutIsStillValid = true;
    }
    return availableSpaceToUse.scaleBy(this.getScale());
  }, {category: ['layout']});

  add.method('isAlreadyLaidOutInSpace', function (s) {
    if (this._tableMorph._layoutIsStillValid && this._tableMorph._spaceUsedLastTime && this._tableMorph._spaceUsedLastTime.eqPt(s)) {
      if (this.shouldPrintDebugInfo()) {
        console.log("No need to lay out " + this._tableMorph.inspect() + ", since it's already laid out in the appropriate amount of space: " + s);
      }
      return true;
    } else {
      if (this.shouldPrintDebugInfo()) {
        console.log("Gonna have to lay out " + this._tableMorph.inspect() + ", since _spaceUsedLastTime is " + this._tableMorph._spaceUsedLastTime + " but s is " + s);
      }
      return false;
    }
  }, {category: ['layout']});

  add.method('decideWhatToDoWithExtraSpace', function (availableSpaceToUse) {
    var r = { padding: this.getPadding(), extraSpacePerSpaceFillingChild: pt(0,0) };
    var extraSpace = availableSpaceToUse.subPt(this._tableMorph._cachedMinimumExtent);
    this.eachDirection(function(dir) {
      var info = dir.coord(this._tableMorph._cachedMinimumExtent.layoutInfoForRowsAndColumns);
      var extra = dir.sideways.coord(extraSpace);
      if (info.spaceFillingCount === 0) {
        // Nobody wants it; just put in extra padding.
        var numberOfBetweenPads = info.size() - 1;
        if (numberOfBetweenPads > 0) {
          if (r.padding === this.getPadding()) { r.padding = Object.clone(r.padding); r.padding.between = Object.clone(r.padding.between); }
          dir.sideways.setCoord(r.padding.between, dir.sideways.coord(r.padding.between) + (extra / numberOfBetweenPads));
        }
      } else {
        // Divvy it up among those who want it.
        dir.sideways.setCoord(r.extraSpacePerSpaceFillingChild, extra / info.spaceFillingCount);
      }
    }.bind(this));
    return r;
  }, {category: ['layout']});

  add.method('calculateActualCoordinatesAndSizes', function (extraSpaceUsage) {
    var actualCoordsAndSizes = pt([], []);
    this.eachDirection(function(dir) {
      var info = dir.coord(this._tableMorph._cachedMinimumExtent.layoutInfoForRowsAndColumns);
      var paddingBeforeNextLine = dir.sideways.padding1(extraSpaceUsage.padding);
      var actuals = dir.coord(actualCoordsAndSizes);
      var f = 0;
      info.each(function(x) {
        f += paddingBeforeNextLine;
        var availableSidewaysSpaceToPassOnToThisLine = x.biggestSideways;
        if (x.canFillSpace) {
          availableSidewaysSpaceToPassOnToThisLine += dir.sideways.coord(extraSpaceUsage.extraSpacePerSpaceFillingChild);
        }
        actuals.push({ coordinate: f, space: availableSidewaysSpaceToPassOnToThisLine });
        f += availableSidewaysSpaceToPassOnToThisLine;
        paddingBeforeNextLine = dir.sideways.coord(extraSpaceUsage.padding.between);
      }.bind(this));
    }.bind(this));
    return actualCoordsAndSizes;
  }, {category: ['layout']});

  add.method('setMorphPositionsAndSizes', function (actualCoordsAndSizes) {
    this._actualCoordsAndSizes = actualCoordsAndSizes;
    var direction = this.tableContent()._direction2;
    var origin = this._tableMorph.getOriginAAAHack(); // necessary because in 3D-land the origin is in the centre, but I don't understand why it's not working in LK-land
    this.tableContent().primaryLines().each(function(line, i) {
      line.each(function(m, j) {
        var actualsForThisMorph = direction.point(direction.sideways.coord(actualCoordsAndSizes)[j], direction.coord(actualCoordsAndSizes)[i]);
        var availableSpaceToPassOnToThisChild = pt(actualsForThisMorph.x.space, actualsForThisMorph.y.space);
        
        if (this._overrideSubmorphLayoutModes) {
          if (!m._previousLayoutModes) { m._previousLayoutModes = m.layoutModes(); }
          m.setLayoutModes(this._overrideSubmorphLayoutModes);
        }
        
        var mScaledExtent = m.rejiggerTheLayout(availableSpaceToPassOnToThisChild);
        if (this.shouldPrintDebugInfo()) { console.log("mScaledExtent is " + mScaledExtent); }
        
        // Uglified slightly to avoid creating the Point object; it's actually getting significant. -- Adam
        var f = direction         .coord(actualsForThisMorph).coordinate;
        var s = direction.sideways.coord(actualsForThisMorph).coordinate;
        
        if (!this._shouldNotCenterSideways) {
          var unusedSidewaysSpace = direction.sideways.coord(availableSpaceToPassOnToThisChild) - direction.sideways.coord(mScaledExtent);
          s = s + (unusedSidewaysSpace / 2);
        }
        
        var x, y;
        if (direction === avocado.directions.horizontal) {
          x = f; y = s;
        } else {
          x = s; y = f;
        }
        m.setTopLeftPosition(origin.moveDownAndRightBy(x, y));
        if (this.shouldPrintDebugInfo()) { console.log("Added " + m.inspect() + " at " + x + ", " + y); }
      }.bind(this));
    }.bind(this));
  }, {category: ['layout']});

  add.method('positionOfPrimaryLine', function (i) {
    var direction = this.tableContent()._direction2;
    var actualsForThisMorph = direction.point(direction.sideways.coord(this._actualCoordsAndSizes)[0], direction.coord(this._actualCoordsAndSizes)[i]);
    var p = pt(actualsForThisMorph.x.coordinate, actualsForThisMorph.y.coordinate);
    return p;
  }, {category: ['layout']});

});


thisModule.addSlots(avocado.table.boxStyle, function(add) {

  add.data('padding', {top: 2, bottom: 2, left: 4, right: 4, between: {x: 3, y: 3}}, {initializeTo: '{top: 2, bottom: 2, left: 4, right: 4, between: {x: 3, y: 3}}'});

  add.data('borderRadius', 10);

  add.data('openForDragAndDrop', false);

});


thisModule.addSlots(avocado.directions.vertical, function(add) {

  add.method('externallySpecifiedFreeSpaceSideways', function (m) {return m.externallySpecifiedFreeWidth;});

  add.method('specifyFreeSpaceSideways', function (m, s) {m.externallySpecifiedFreeWidth = s;});

  add.method('dimensionOfRect', function (r) {return r.height;});

  add.method('padding1', function (padding) {return padding.top;});

  add.method('padding2', function (padding) {return padding.bottom;});

  add.method('layoutModeOf', function (m) {return m.verticalLayoutMode;});

  add.method('setLayoutModeOf', function (m, mode) {m.verticalLayoutMode = mode;});

});


thisModule.addSlots(avocado.directions.horizontal, function(add) {

  add.method('externallySpecifiedFreeSpaceSideways', function (m) {return m.externallySpecifiedFreeHeight;});

  add.method('specifyFreeSpaceSideways', function (m, s) {m.externallySpecifiedFreeHeight = s;});

  add.method('dimensionOfRect', function (r) {return r.width;});

  add.method('padding1', function (padding) {return padding.left;});

  add.method('padding2', function (padding) {return padding.right;});

  add.method('layoutModeOf', function (m) {return m.horizontalLayoutMode;});

  add.method('setLayoutModeOf', function (m, mode) {m.horizontalLayoutMode = mode;});

});


thisModule.addSlots(avocado.table.contents, function(add) {

  add.data('rowPrototype', avocado.table.contents.create([], avocado.directions.vertical), {initializeTo: 'avocado.table.contents.create([], avocado.directions.vertical)'});

  add.data('columnPrototype', avocado.table.contents.create([], avocado.directions.horizontal), {initializeTo: 'avocado.table.contents.create([], avocado.directions.horizontal)'});

  add.method('newMorph', function () {
    var world = avocado.ui.currentWorld();
    var morphsTable = this.map(function(model) { return world.morphFor(model); });
    var m = avocado.table.newTableMorph();
    if (this._desiredSpaceToScaleTo) { m.layout().setDesiredSpace(this._desiredSpaceToScaleTo); } // aaa hack, the model shouldn't know about this UI stuff
    m.replaceContentWith(morphsTable);
    m.applyStyle(avocado.table.boxStyle);
    return m;
  }, {category: ['user interface']});

});


thisModule.addSlots(avocado.morphMixins.Morph, function(add) {

  add.method('useTableLayout', function (tableContent) {
    this.horizontalLayoutMode = avocado.LayoutModes.ShrinkWrap;
    this.  verticalLayoutMode = avocado.LayoutModes.ShrinkWrap;
    this.suppressHandles = true; // aaa - handles don't work right with tables yet
    this.setLayout(Object.newChildOf(avocado.table.layout, this).setTableContent(tableContent));
    return this;
  }, {category: ['layout']});

});


});

avocado.transporter.module.onLoadCallbacks["lk_ext/core_sampler"] = function() {};
avocado.transporter.module.create('lk_ext/core_sampler', function(requires) {

requires('general_ui/table_layout');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.method('CoreSamplerMorph', function CoreSamplerMorph() { Class.initializer.apply(this, arguments); }, {category: ['ui']});

});


thisModule.addSlots(avocado.CoreSamplerMorph, function(add) {

  add.data('displayName', 'CoreSamplerMorph');

  add.data('superclass', Morph);

  add.data('type', 'avocado.CoreSamplerMorph');

  add.creator('prototype', Object.create(Morph.prototype));

});


thisModule.addSlots(avocado.CoreSamplerMorph.prototype, function(add) {

  add.data('constructor', avocado.CoreSamplerMorph);

  add.method('initialize', function ($super) {
    $super(lively.scene.Rectangle.createWithIrrelevantExtent());
    
    this.useTableLayout(avocado.table.contents.columnPrototype);
    this.applyStyle(this.defaultStyle);

    var crosshairCenter = pt(-40,-40);
    var radius = 10;
    var connectorLength = 40 - (radius / Math.sqrt(2));
    this._connector = Morph.makeLine([pt(0,0), pt(-connectorLength, -connectorLength)], 4, Color.black).ignoreEvents();
    this._connector.shouldNotBePartOfRowOrColumn = true;
    this.addMorph(this._connector);

    this._circle = Morph.makeCircle(crosshairCenter.copy(), 10, 1, Color.black).ignoreEvents();
    this._circle.setFill(null);
    this._circle.shouldNotBePartOfRowOrColumn = true;
    this.addMorph(this._circle);

    this._crosshairLine1 = Morph.makeLine([pt(-radius, 0), pt(radius, 0)], 1, Color.black).ignoreEvents();
    this._crosshairLine2 = Morph.makeLine([pt(0, -radius), pt(0, radius)], 1, Color.black).ignoreEvents();
    this._crosshairLine1.shouldNotBePartOfRowOrColumn = true;
    this._crosshairLine2.shouldNotBePartOfRowOrColumn = true;
    this.addMorphAt(this._crosshairLine1, crosshairCenter.addXY(-radius, 0));
    this.addMorphAt(this._crosshairLine2, crosshairCenter.addXY(0, -radius));

    this._crosshairMorphs = [this._circle, this._crosshairLine1, this._crosshairLine2];

    this._placeholderForWhenEmpty = new Morph(new lively.scene.Rectangle(pt(0,0).extent(pt(40,30))));
    this._placeholderForWhenEmpty.setFill(null);
    this._placeholderForWhenEmpty.ignoreEvents();

    this.refreshContent();
    this.startPeriodicallyUpdating();
  }, {category: ['creating']});

  add.creator('defaultStyle', {}, {category: ['styles']});

  add.method('refreshContent', function () {
    var w = this.world();
    if (w) {
      var p = this.worldPoint(this._circle.bounds().center());
      var evt = Event.createFake();
      evt.mousePoint = p;
      var topmostMorph = w.morphToReceiveEvent(evt);
      if (topmostMorph) {
        //console.log("Core sampler found morph " + reflect(topmostMorph).name());
        var morphs = topmostMorph.ownerChain().reverse(); // topmostMorph should be first
        var morphSummaries = [];
        w.eachMorphAt(p, function(m) {
          if (! this._crosshairMorphs.include(m)) {
            var summary = avocado.table.createSpaceFillingRowMorph([avocado.label.newMorphFor(reflect(m).name())]).enableEvents();
            summary.grabsShouldFallThrough = true;
            summary.contextMenu = m.morphMenu.bind(m);
            morphSummaries.push(summary);
          }
        }.bind(this));
        if (morphSummaries.size() > 0) {
          this.layout().setCells(morphSummaries);
        } else {
          this.layout().setCells([this._placeholderForWhenEmpty]);
        }
      } else {
        this.layout().setCells([this._placeholderForWhenEmpty]);
      }
    } else {
      this.layout().setCells([this._placeholderForWhenEmpty]);
    }
  }, {category: ['updating']});

  add.method('dropMeOnMorph', function ($super, receiver) {
    $super(receiver);
    this.refreshContentOfMeAndSubmorphs(); // because I'm impatient;
  }, {category: ['drag and drop']});

  add.data('suppressHandles', true, {category: ['handles']});

});


thisModule.addSlots(avocado.CoreSamplerMorph.prototype.defaultStyle, function(add) {

  add.data('openForDragAndDrop', false);

  add.data('padding', 10);

  add.data('fillBase', new Color(0.4, 0.4, 0.4));

});


thisModule.addSlots(Morph.prototype, function(add) {

  add.method('eachMorphAt', function (p, iterator) {
    if (!this.fullContainsWorldPoint(p)) return;
    
    for (var i = this.submorphs.length - 1; i >= 0; --i) {
      this.submorphs[i].eachMorphAt(p, iterator);
    }
    
    // Check if it's really in this morph (not just fullBounds)
    if (this.containsWorldPoint(p)) {
      iterator(this);
    }
  }, {category: ['drilling']});

});


});

avocado.transporter.module.onLoadCallbacks["lk_ext/morph_factories"] = function() {};
avocado.transporter.module.create('lk_ext/morph_factories', function(requires) {

requires('lk_ext/core_sampler');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('morphFactories', {}, {category: ['ui']});

});


thisModule.addSlots(avocado.morphFactories, function(add) {

  add.creator('simpleMorphs', {}, {category: ['simple morphs']});

  add.creator('tools', {}, {category: ['tools']});

  add.data('globalFactories', [], {category: ['registering'], initializeTo: '[]'});

  add.method('addGlobalCommandsTo', function (menu) {
    menu.addLine();
    
    menu.addItem(["morph factory", avocado.morphFactories.globalFactories.map(function(factory) {
      return [factory.factoryName(), function(evt) { factory.createFactoryMorph().grabMe(evt); }]
    })]);
  }, {category: ['menu']});

  add.creator('defaultStyle', {}, {category: ['styles']});

});


thisModule.addSlots(avocado.morphFactories.simpleMorphs, function(add) {

  add.method('factoryName', function () { return 'simple morphs'; });

  add.method('createFactoryMorph', function () {
    var line     = Morph.makeLine([pt(0,0), pt(60, 30)], 2, Color.black).closeDnD();
    var rect     = Morph.makeRectangle(pt(0,0), pt(60, 30)).closeDnD();
    var ellipse  = Morph.makeCircle(pt(0,0), 25).closeDnD();
    var text     = new TextMorph(pt(0,0).extent(pt(120, 10)), "This is a TextMorph").closeDnD();
    var star     = Morph.makeStar(pt(0,0)).closeDnD();
    var heart    = Morph.makeHeart(pt(0,0)).closeDnD();
    var triangle = Morph.makePolygon([pt(-30,0), pt(30,0), pt(0,-50)], 1, Color.black, Color.green.darker());
    
    var buttonLabel = new avocado.TwoModeTextMorph();
    buttonLabel.setText("Button");
    buttonLabel.acceptChanges();
    buttonLabel.suppressHandles = true;
    buttonLabel.ignoreEvents();
    buttonLabel.backgroundColorWhenWritable = Color.white;
    var button  = ButtonMorph.createButton(buttonLabel, function(event) {
  this.world().showMessage("Inspect the button and edit its 'run' method.");
}).closeDnD();

    var container = avocado.container.newContainerMorph();

    var dbMorph = new avocado.db.Morph(null);

    ellipse.setFill(new Color(0.8, 0.5, 0.5)); // make it a different color than the rectangle
    
    var factory = Morph.makeRectangle(pt(0,0), pt(300, 560));
    factory.applyStyle(avocado.morphFactories.defaultStyle);
    factory.addMorphAt(line,      pt( 20,  20));
    factory.addMorphAt(rect,      pt(120,  20));
    factory.addMorphAt(ellipse,   pt( 20, 120));
    factory.addMorphAt(text,      pt(120, 120));
    factory.addMorphAt(star,      pt( 20, 220));
    factory.addMorphAt(heart,     pt(200, 300));
    factory.addMorphAt(button,    pt( 20, 340));
    factory.addMorphAt(triangle,  pt(150, 340));
    factory.addMorphAt(container, pt( 20, 410));
    factory.addMorphAt(dbMorph,   pt(190, 435));
    return factory;
  });

  add.method('postFileIn', function () {
    avocado.morphFactories.globalFactories.push(this);
  });

});


thisModule.addSlots(avocado.morphFactories.tools, function(add) {

  add.method('factoryName', function () { return 'tools'; });

  add.method('createFactoryMorph', function () {
    var coreSampler = new avocado.CoreSamplerMorph();
    
    var factory = Morph.makeRectangle(pt(0,0), pt(300, 200));
    factory.applyStyle(avocado.morphFactories.defaultStyle);
    factory.addMorphAt(coreSampler, pt( 70,  70));
    
    return factory;
  });

  add.method('postFileIn', function () {
    avocado.morphFactories.globalFactories.push(this);
  });

});


thisModule.addSlots(avocado.morphFactories.defaultStyle, function(add) {

  add.data('fill', new Color(0.1, 0.6, 0.7));

  add.data('borderWidth', 1);

  add.data('borderColor', new Color(0, 0, 0));

  add.data('openForDragAndDrop', false);

});


});

avocado.transporter.module.onLoadCallbacks["lk_programming_environment/vocabulary_morph"] = function() {};
avocado.transporter.module.create('lk_programming_environment/vocabulary_morph', function(requires) {

requires('general_ui/table_layout');
requires('reflection/vocabulary');

}, function(thisModule) {


thisModule.addSlots(avocado.vocabulary, function(add) {

  add.method('Morph', function Morph() { Class.initializer.apply(this, arguments); }, {category: ['user interface']});

  add.method('newMorph', function () {
    return new this.Morph(this);
  }, {category: ['user interface']});

  add.data('isImmutableForMorphIdentity', true, {category: ['user interface']});

});


thisModule.addSlots(avocado.vocabulary.Morph, function(add) {

  add.data('displayName', 'Morph');

  add.data('superclass', Morph);

  add.data('type', 'avocado.vocabulary.Morph');

  add.creator('prototype', Object.create(Morph.prototype));

});


thisModule.addSlots(avocado.vocabulary.Morph.prototype, function(add) {

  add.data('constructor', avocado.vocabulary.Morph);

  add.method('initialize', function ($super, v) {
    $super(lively.scene.Rectangle.createWithIrrelevantExtent());
    this.useTableLayout(avocado.table.contents.columnPrototype);
    this._model = v;
    this.applyStyle(this.defaultStyle);

    this._evaluatorsPanel = avocado.table.newColumnMorph().beInvisible().applyStyle({horizontalLayoutMode: avocado.LayoutModes.SpaceFill});
    this._mirrorsPanel    = avocado.table.newColumnMorph().beInvisible().applyStyle({horizontalLayoutMode: avocado.LayoutModes.SpaceFill});
    
    
    var mirs = this.mirror().meAndAncestors().toArray();
    var mirrorsPanel = this._mirrorsPanel;
    var world = avocado.ui.currentWorld();
    this._mirrorsPanel.layout().setCells(mirs.map(function(mir) { return mirrorsPanel.placeholderForMorph(world.morphFor(mir)); }));
    
    this._expander = new avocado.ExpanderMorph(this);
    this._titleLabel = this.createNameLabel();
    
    if (window.avocado && avocado.evaluator) {
      this._evaluatorButton = avocado.command.create("E", function(evt) { this.openEvaluator(evt); }.bind(this)).setHelpText('Show an evaluator box').newMorph();
    }

    this.dismissButton = this.createDismissButton();
    
    this._headerRow = avocado.table.createSpaceFillingRowMorph([this._expander, this._titleLabel, avocado.ui.createSpacer(), this._evaluatorButton, this.dismissButton].compact(), this.defaultStyle.headerRowPadding);
    this._headerRow.refreshContentOfMeAndSubmorphs();
    
    this.refreshContent();
  }, {category: ['creating']});

  add.creator('defaultStyle', {}, {category: ['styles']});

  add.method('mirror', function () { return this._model.mirror(); }, {category: ['accessing']});

  add.method('potentialContentMorphs', function () {
    var rows = [this._headerRow];
    if (this._expander.isExpanded()) { rows.push(this._mirrorsPanel); }
    rows.push(this._evaluatorsPanel);
    return avocado.table.contents.createWithColumns([rows]);
  }, {category: ['updating']});

  add.method('getAllMirrors', function () {
    this._mirrorsPanel.submorphsParticipatingInLayout().forEach(function(m) {
      if (m.layout() && m.layout().putOriginalMorphBack) {
        m.layout().putOriginalMorphBack();
      }
    });
  }, {category: ['evaluators']});

  add.method('openEvaluator', function (evt) {
    evt = evt || Event.createFake();
    var e = avocado.ui.currentWorld().morphFor(avocado.evaluator.create(this._model));
    this._evaluatorsPanel.layout().addCell(e);
    e.wasJustAdded(evt);
    return e;
  }, {category: ['evaluators']});

  add.method('closeEvaluator', function (evaluatorMorph) {
    this._evaluatorsPanel.layout().removeCell(evaluatorMorph);
  }, {category: ['evaluators']});

  add.method('grabResult', function (resultMirMorph, evt) {
    if (resultMirMorph === avocado.ui.worldFor(evt).morphFor(this.mirror())) {
      this.wiggle();
    } else {
      resultMirMorph.grabMe(evt);
    }
  }, {category: ['evaluators']});

  add.method('doIWantToLeaveAPlaceholderWhenRemoving', function (m) {
    return m.owner === this._mirrorsPanel && m.isMirrorMorph;
  }, {category: ['placeholders']});

  add.method('placeholderForMirror', function (mir) {
    return this.placeholderMorphs().find(function(placeholderMorph) { return mir.equals(placeholderMorph.layout().originalMorph().mirror()); });
  }, {category: ['placeholders']});

  add.method('placeholderMorphs', function () {
    return this._mirrorsPanel.submorphsParticipatingInLayout().select(function(m) { return m.layout() && m.layout().isPlaceholder; });
  }, {category: ['placeholders']});

});


thisModule.addSlots(avocado.vocabulary.Morph.prototype.defaultStyle, function(add) {

  add.data('borderColor', new Color(0.6, 0.6, 0.6));

  add.data('borderWidth', 1);

  add.data('borderRadius', 10);

  add.data('openForDragAndDrop', false);

  add.data('fillBase', new Color(0.8, 0.8, 0.5));

  add.data('padding', {top: 2, bottom: 2, left: 4, right: 4, between: {x: 2, y: 2}}, {initializeTo: '{top: 2, bottom: 2, left: 4, right: 4, between: {x: 2, y: 2}}'});

  add.data('internalPadding', {left: 15, right: 2, top: 2, bottom: 2, between: {x: 0, y: 0}}, {initializeTo: '{left: 15, right: 2, top: 2, bottom: 2, between: {x: 0, y: 0}}'});

  add.data('headerRowPadding', {top: 0, bottom: 0, left: 0, right: 0, between: {x: 3, y: 3}}, {initializeTo: '{top: 0, bottom: 0, left: 0, right: 0, between: {x: 3, y: 3}}'});

});


});

avocado.transporter.module.onLoadCallbacks["lk_programming_environment/project_morph"] = function() {};
avocado.transporter.module.create('lk_programming_environment/project_morph', function(requires) {

requires('general_ui/table_layout');
requires('lk_ext/check_box');
requires('projects/projects');

}, function(thisModule) {


thisModule.addSlots(avocado.project, function(add) {

  add.method('newMorph', function () {
    var m = avocado.table.newColumnMorph().setModel(this).applyStyle(this.defaultMorphStyle);
    m.typeName = 'project';
    var headerRow = avocado.table.newRowMorph().beInvisible().applyStyle({padding: 3});
    
    var changeIndicator = avocado.label.newMorphFor(function() {
      var project = this.ownerWithAModel()._model;
      return project.modificationFlag().hasThisOneOrChildrenChanged() ? ' has changed ' : '';
    });
    changeIndicator.setTextColor(Color.green.darker());

    var columns = [m.createNameLabel()];
    // columns.push(changeIndicator); // aaa just leave this out for now because it's not working right
    headerRow.layout().setCells(columns);
    
    /* Why isn't this working?
    var privacyRow = avocado.table.newRowMorph().beInvisible().applyStyle({padding: {between: {x: 3}}});
    var privacyLabel = avocado.label.newMorphFor("Private: ");
    var privacyCheckbox = new avocado.CheckBoxMorph();
    privacyRow.layout().setCells([privacyLabel, privacyCheckbox]);
    privacyCheckbox.notifier().addObserver(function(a, b, c) {
      console.log("Clicked the checkbox: " + a + ", " + b + ", " + c);
    });
    */
    
    m.layout().setCells([headerRow]);

    this.module().whenChangedNotify(m.refreshContentIfOnScreenOfMeAndSubmorphs.bind(m));
    m.startPeriodicallyUpdating();
    return m;
  }, {category: ['user interface']});

  add.creator('defaultMorphStyle', Object.create(avocado.table.boxStyle), {category: ['user interface']});

});


thisModule.addSlots(avocado.project.defaultMorphStyle, function(add) {

  add.data('fillBase', new Color(0.7, 0.6, 0.7));

});


});

avocado.transporter.module.onLoadCallbacks["programming_environment/evaluator_morph"] = function() {};
avocado.transporter.module.create('programming_environment/evaluator_morph', function(requires) {

requires('general_ui/table_layout');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('evaluator', {}, {category: ['ui']});

});


thisModule.addSlots(avocado.evaluator, function(add) {

  add.method('create', function (context) {
    return Object.newChildOf(this, context);
  }, {category: ['creating']});

  add.method('initialize', function (context) {
    this._context = context;
  }, {category: ['creating']});

  add.method('mirror', function () {
    if (typeof(this._context.mirror) === 'function') { return this._context.mirror(); }
    return this._context;
  }, {category: ['accessing']});

  add.method('mirrorMorph', function () {
    // aaa - HACK
    return avocado.ui.currentWorld().morphFor(this.mirror());
  }, {category: ['user interface']});

  add.method('textMorph', function () {
    // aaa - HACK
    return avocado.ui.currentWorld().morphFor(this)._textMorph;
  }, {category: ['user interface']});

  add.creator('defaultStyle', {}, {category: ['styles']});

  add.creator('textStyle', {}, {category: ['styles']});

  add.method('newMorph', function () {
    var m = avocado.ui.newMorph().setModel(this).useTableLayout(avocado.table.contents.columnPrototype);
    
    m.applyStyle(avocado.evaluator.defaultStyle);

    var tm = m._textMorph = TextMorph.createInputBox("", pt(150, 60)).applyStyle(avocado.evaluator.textStyle);
    
    var thisEvaluator = this;
    tm.onKeyDown = function(evt) {
      if (evt.getKeyCode() == Event.KEY_RETURN && (evt.isMetaDown() || evt.isAltDown() || evt.isCtrlDown())) {
        thisEvaluator.getIt(evt);
        evt.stop();
        return;
      }
      return TextMorph.prototype.onKeyDown.call(tm, evt);
    };
    
    var buttons = this.buttonCommands().map(function(c) { return c.newMorph(); });

    m.layout().setCells([tm, avocado.table.createSpaceFillingRowMorph(buttons)]);
    
    m.wasJustAdded = function (evt) { m._textMorph.wasJustAdded(evt); };
    
    return m;
  }, {category: ['user interface']});

  add.method('buttonCommands', function () {
    return [avocado.command.create("Do it",  function(evt) {this. doIt(evt);}.bind(this)).setHelpText('Run the code in the box'),
            avocado.command.create("Get it", function(evt) {this.getIt(evt);}.bind(this)).setHelpText('Run the code in the box and get the result'),
            avocado.command.create("Close",  function(evt) {this.mirrorMorph().closeEvaluator(this);}.bind(this))];
  }, {category: ['user interface']});

  add.method('commands', function () {
    var cmdList = avocado.command.list.create(this);
    cmdList.addItem(avocado.command.create("Get it", function(evt) {this.getIt(evt);}.bind(this)).setHelpText('Run the code in the box and get the result'));
    cmdList.addItem(avocado.command.create("Do it",  function(evt) {this. doIt(evt);}.bind(this)).setHelpText('Run the code in the box'));
    if (this.isTicking()) {
      cmdList.addItem(avocado.command.create("Stop ticking", function(evt) {this.stopTicking(evt);}.bind(this)));
    } else {
      cmdList.addItem(avocado.command.create("Start ticking", function(evt) {this.startTicking(evt);}.bind(this)));
    }
    return cmdList;
  }, {category: ['creating']});

  add.method('runTheCode', function () {
    return this.mirror().evalCodeString(this.textMorph().getText());
  }, {category: ['running the code']});

  add.method('doIt', function (evt) {
    avocado.ui.showMessageIfErrorDuring(function() { this.runTheCode(); }.bind(this), evt);
  }, {category: ['running the code']});

  add.method('getIt', function (evt) {
    avocado.ui.showMessageIfErrorDuring(function() {
      var resultMirMorph = avocado.ui.worldFor(evt).morphFor(reflect(this.runTheCode()));
      this.mirrorMorph().grabResult(resultMirMorph, evt);
    }.bind(this), evt);
  }, {category: ['running the code']});

  add.method('startTicking', function (evt) {
    var mir = this.mirror();
    var f = mir.functionFromCodeString(this._textMorph.getText());
    this._ticker = new PeriodicalExecuter(function(pe) {
      avocado.ui.showMessageIfErrorDuring(function() {
        try {
          mir.callFunction(f);
        } catch (ex) {
          this.stopTicking();
          throw ex;
        }
      }.bind(this), evt);
    }.bind(this), 0.1);
  }, {category: ['running the code']});

  add.method('stopTicking', function (evt) {
    if (! this._ticker) { return; }
    this._ticker.stop();
    this._ticker = null;
  }, {category: ['running the code']});

  add.method('isTicking', function (evt) {
    return !!this._ticker;
  }, {category: ['running the code']});

});


thisModule.addSlots(avocado.evaluator.defaultStyle, function(add) {

  add.data('padding', 10);

  add.data('borderWidth', 0);

  add.data('fill', null);

  add.data('suppressGrabbing', true);

  add.data('suppressHandles', true);

  add.data('grabsShouldFallThrough', true);

  add.data('openForDragAndDrop', false);

});


thisModule.addSlots(avocado.evaluator.textStyle, function(add) {

  add.data('fill', new Color(1, 1, 1));

  add.data('fontFamily', 'monospace');

});


});

avocado.transporter.module.onLoadCallbacks["programming_environment/module_morph"] = function() {};
avocado.transporter.module.create('programming_environment/module_morph', function(requires) {

requires('general_ui/table_layout');
requires('transporter/transporter');

}, function(thisModule) {


thisModule.addSlots(avocado.transporter.module, function(add) {

  add.method('newMorph', function () {
    var m = avocado.table.newRowMorph().setModel(this).applyStyle(this.defaultMorphStyle);
    m.typeName = 'module';

    var changeIndicator = avocado.label.newMorphFor(function() {
      var module = this.ownerWithAModel()._model;
      if (module.modificationFlag().hasJustThisOneChanged()) { return ' has changed '; }
      // aaa - maybe it's fine to just say 'has changed' here too?
      if (module.modificationFlag().hasThisOneOrChildrenChanged()) { return ' dependencies have changed '; }
      return '';
    });
    changeIndicator.setTextColor(Color.green.darker());

    var columns = [m.createNameLabel()];
    columns.push(changeIndicator);
    this.buttonCommands().commands().each(function(c) { columns.push(c.newMorph()); });
    columns.push(m.createDismissButton());
    m.layout().setCells(columns);

    m.commands = function() {
      var module = this.ownerWithAModel()._model;
      var cmdList = module.commands().wrapForMorph(m);
      var saveCmd = cmdList.itemWith("id", "save");
      if (saveCmd) {
        saveCmd.pluralLabel = 'save modules as .js files';
        saveCmd.pluralGo = avocado.transporter.fileOutPluralMorphs.bind(avocado.transporter);
      }
      return cmdList;
    };

    this.whenChangedNotify(m.refreshContentIfOnScreenOfMeAndSubmorphs.bind(m));
    m.startPeriodicallyUpdating();
    return m;
  }, {category: ['user interface']});

  add.creator('defaultMorphStyle', Object.create(avocado.table.boxStyle), {category: ['user interface']});

});


thisModule.addSlots(avocado.transporter.module.defaultMorphStyle, function(add) {

  add.data('fillBase', new Color(0.9, 0.5, 0.5));

});


thisModule.addSlots(avocado.transporter, function(add) {

  add.method('fileOutPluralMorphs', function (morphsAndCommands, evt) {
    // aaa - This is a hack. Come up with a more general, cleaner way of doing
    // plural commands that can handle both SelectionMorph and other mechanisms.
    morphsAndCommands.each(function(x) { x.moduleVersion = x.morph._model.currentVersion(); });
    avocado.transporter.fileOutPlural(morphsAndCommands, evt);
  }, {category: ['user interface', 'commands', 'filing out']});

});


});

avocado.transporter.module.onLoadCallbacks["programming_environment/test_case_morph"] = function() {};
avocado.transporter.module.create('programming_environment/test_case_morph', function(requires) {

requires('general_ui/table_layout');
requires('core/testFramework');

}, function(thisModule) {


thisModule.addSlots(avocado.testCase, function(add) {

  add.method('newMorph', function () {
    var m = avocado.treeNode.newMorphFor(this, this.defaultMorphStyle);
    m.typeName = 'test case';
    m.refreshContentOfMeAndSubmorphs();
    m.startPeriodicallyUpdating();
    return m;
  }, {category: ['user interface']});

  add.creator('defaultMorphStyle', Object.create(avocado.table.boxStyle), {category: ['user interface']});

  add.method('updateStyleOfMorph', function (m, result) {
    result = result || m._model.result(); // allow the result to be passed in, so we can use this to update related morphs that don't actually have a _model
    if (result && result.hasFinished()) {
      if (result.anyFailed()) {
        m.setFillBase(avocado.testCase.singleResult.failedMorphStyle.fillBase);
      } else {
        m.setFillBase(avocado.testCase.singleResult.defaultMorphStyle.fillBase);
      }
    } else {
      m.setFillBase(avocado.testCase.defaultMorphStyle.fillBase);
    }
  }, {category: ['user interface']});

  add.method('shouldPutHeaderOnLeftInsteadOfTop', function () {
    // just for fun, to see if this works OK
    return false;
  }, {category: ['user interface']});

  add.method('contentsPanelExtent', function () {
    if (this.shouldPutHeaderOnLeftInsteadOfTop()) {
      return pt(30, 20);
    } else {
      return avocado.treeNode.defaultExtent();
    }
  }, {category: ['user interface']});

});


thisModule.addSlots(avocado.testCase.defaultMorphStyle, function(add) {

  add.data('fillBase', new Color(0.5, 0.5, 0.5));

});


thisModule.addSlots(avocado.testCase.suite, function(add) {

  add.method('newMorph', function () {
    var m = avocado.treeNode.newMorphFor(this, this.defaultMorphStyle);
    m.typeName = 'test suite';
    
    
    // aaa - just an experiment
    if (this._shouldBeDisplayedAsOneLongRow) {
      var cp = avocado.treeNode.actualContentsPanelForMorph(m);
      cp.layout().cleaningUpPoseFor = function (contentMorphs) {
        return this._morph.poseManager().rowPose(contentMorphs);
      };
    }
    
    
    m.refreshContentOfMeAndSubmorphs();
    m.startPeriodicallyUpdating();
    return m;
  }, {category: ['user interface']});

  add.creator('defaultMorphStyle', Object.create(avocado.table.boxStyle), {category: ['user interface']});

  add.method('contentsPanelExtent', function () {
    if (this._shouldBeDisplayedAsOneLongRow) {
      return pt(200, 6);
    } else {
      return avocado.treeNode.defaultExtent();
    }
  }, {category: ['user interface']});

  add.method('updateStyleOfMorph', function (m) {
    avocado.testCase.updateStyleOfMorph(m);
  }, {category: ['user interface']});

});


thisModule.addSlots(avocado.testCase.suite.defaultMorphStyle, function(add) {

  add.data('fillBase', new Color(0.5, 0.5, 0.5));

});


thisModule.addSlots(avocado.testCase.resultHistory, function(add) {

  add.method('newMorph', function () {
    var m = avocado.table.newColumnMorph().setModel(this);
    m.applyStyle(this.defaultMorphStyle);
    
    m._headerRow = avocado.table.createSpaceFillingRowMorph([m.findOrCreateTitleLabel()], avocado.treeNode.headerRowPadding).enableEvents(); // aaa DO NOT enableEvents(), not sure what to do, but needed to make links work
    //m._immediateContentsMorph = avocado.ui.currentWorld().morphFor(this.immediateContents()).setFill(null);
    m._immediateContentsMorph = avocado.table.newTableMorph().setFill(null);
    m._immediateContentsMorph.setPotentialContentMorphsFunction(function () {
      return this.immediateContents().map(function(t) { return t ? avocado.ui.currentWorld().morphFor(t) : avocado.ui.newMorph().beInvisible(); });
    }.bind(this));
    m._immediateContentsMorph.layout().setDesiredSpace(pt(800, null));
    m._immediateContentsMorph.doIWantToLeaveAPlaceholderWhenRemoving = function (m) { return true; };
    m._immediateContentsMorph.layout()._overrideSubmorphLayoutModes = pt(null, avocado.LayoutModes.SpaceFill);
    
    this._interestingTestsModel  = this.createInterestingEntriesList();
    var interestingTestsContainer = m._morphForViewingThingsInMoreDetail = avocado.ui.currentWorld().morphFor(this._interestingTestsModel);
    var interestingTestsHeaderRow = avocado.table.createSpaceFillingRowMorph([interestingTestsContainer.findOrCreateTitleLabel()], Object.extend(Object.create(avocado.treeNode.headerRowPadding), {top: 15})).enableEvents(); // aaa DO NOT enableEvents(), not sure what to do, but needed to make links work
    
    var selectedTests = avocado.groupOfSimilarObjects.create([]); // .beVertical();
    this._reallyInterestingTestsModel = this.createInterestingEntriesList();
    this._reallyInterestingTestsModel.titleModel().setContent(avocado.testCase.subset.create(this, null, "selected", avocado.enumerator.create(selectedTests, 'eachObject')));
    m._reallyInterestingTestsContainer = interestingTestsContainer._morphForViewingThingsInMoreDetail = avocado.ui.currentWorld().morphFor(selectedTests);
    m._reallyInterestingTestsContainer.layout().doNotCenter();
    //m._reallyInterestingTestsContainer.layout()._overrideSubmorphLayoutModes = pt(avocado.LayoutModes.SpaceFill, avocado.LayoutModes.SpaceFill);
    m._reallyInterestingTestsTitleLabel = this._reallyInterestingTestsModel.titleModel().newMorph();
    m._reallyInterestingTestsHeaderRow  = avocado.table.createSpaceFillingRowMorph([m._reallyInterestingTestsTitleLabel], Object.extend(Object.create(avocado.treeNode.headerRowPadding), {top: 15})).enableEvents(); // aaa DO NOT enableEvents(), not sure what to do, but needed to make links work
    
    m._layout.setCells([m._headerRow, m._immediateContentsMorph, interestingTestsHeaderRow, ScrollPane.containing(interestingTestsContainer, pt(800, 400)), /* doesn't actually say anything useful yet: m._reallyInterestingTestsHeaderRow, */ ScrollPane.containing(m._reallyInterestingTestsContainer, pt(800, 400))]);
    
    return m;
  }, {category: ['user interface']});

  add.creator('defaultMorphStyle', Object.create(avocado.table.boxStyle), {category: ['user interface']});

  add.method('showInterestingSubset', function (evt, subset, linkNode) {
    var world = avocado.ui.worldFor(evt);
    var historyMorph = world.morphFor(this);
    
    if (historyMorph._selectedSummaryLinkNode) { historyMorph._selectedSummaryLinkNode.setAttribute("class", "summaryLink"); }
    historyMorph._selectedSummaryLinkNode = linkNode;
    historyMorph._selectedSummaryLinkNode.setAttribute("class", "highlightedSummaryLink");
    
    var morphsToShow = subset.tests().toArray().map(function(entry) { return world.morphFor(entry); });
    historyMorph.pullMorphsCloser(morphsToShow, subset);
  }, {category: ['user interface']});

});


thisModule.addSlots(avocado.testCase.resultHistory.defaultMorphStyle, function(add) {

  add.data('fillBase', new Color(0.8, 0.8, 0.8));

});


thisModule.addSlots(avocado.testCase.resultHistory.interestingEntriesProto, function(add) {

  add.method('newMorph', function () {
    var m = avocado.ui.newMorph(avocado.ui.shapeFactory.newRectangle(new Rectangle(0, 0, 600, 400))).beInvisible().beShrinkWrapping();
    m.setModel(this);

    /*
    Let's try a tree pose instead.
    var pose = avocado.poses.list.create("interesting entries").setPadding(pt(10, 10)).setDesiredPoserScale(1);
    pose.setDirection(avocado.directions.horizontal).setMaxExtent(function() { return m.getExtent().withY(null); });
    */
    var parentOf = function(m) { var p = m._model.parent && m._model.parent(); return p ? avocado.ui.currentWorld().morphFor(p) : null; };
    var childrenOf = function(m) { return m._model.children ? m._model.children().map(function(childTest) { return avocado.ui.currentWorld().morphFor(childTest); }) : []; };
    var pose = avocado.poses.tree.create("interesting entries", [], parentOf, childrenOf).setPadding(pt(10, 10)).setDesiredPoserScale(1);
    
    pose.doNotAnticipateAtStart().doNotWiggleAtEnd().whenDoneSetExtentToEncompassWholePose();
    m.setLayout(Object.newChildOf(avocado.poses.layout, pose));
    
    m.doIWantToLeaveAPlaceholderWhenRemoving = function (sm) { return false; };
    return m;
  }, {category: ['user interface']});

});


thisModule.addSlots(avocado.testCase.singleResult, function(add) {

  add.method('newMorph', function () {
    return avocado.messageNotifier.create(this.toString(), Color.gray).newMorph().setModel(this);
  }, {category: ['user interface']});

  add.method('updateStyleOfMorph', function (m) {
    avocado.testCase.updateStyleOfMorph(m);
  }, {category: ['user interface']});

  add.creator('defaultMorphStyle', {}, {category: ['user interface']});

  add.creator('failedMorphStyle', {}, {category: ['user interface']});

});


thisModule.addSlots(avocado.testCase.singleResult.defaultMorphStyle, function(add) {

  add.data('fillBase', new Color(0, 0.8, 0.6));

});


thisModule.addSlots(avocado.testCase.singleResult.failedMorphStyle, function(add) {

  add.data('fillBase', new Color(0.8, 0.3, 0));

});


});

avocado.transporter.module.onLoadCallbacks["lk_ext/combo_box"] = function() {};
avocado.transporter.module.create('lk_ext/combo_box', function(requires) {

requires('general_ui/table_layout');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.method('ComboBoxMorph', function ComboBoxMorph() { Class.initializer.apply(this, arguments); }, {category: ['ui']});

});


thisModule.addSlots(avocado.ComboBoxMorph, function(add) {

  add.data('displayName', 'ComboBoxMorph');

  add.data('superclass', Morph);

  add.data('type', 'avocado.ComboBoxMorph');

  add.method('prompt', function (msg, okButtonText, cancelButtonText, values, defaultValue, onAccept, onCancel) {
    var promptBox = avocado.table.newColumnMorph();
    promptBox.setFill(Color.blue.lighter().lighter());
    var messageLabel = avocado.label.newMorphFor(msg);
    var     okButton = ButtonMorph.createButton(    okButtonText, function(evt) { comboBox.relinquishKeyboardFocus(Event.createFake()); promptBox.remove(); if (onAccept) { onAccept(comboBox.value()); } });
    var cancelButton = ButtonMorph.createButton(cancelButtonText, function(evt) { comboBox.relinquishKeyboardFocus(Event.createFake()); promptBox.remove(); if (onCancel) { onCancel();                 } });
    var comboBox = new this(values, defaultValue, function() {okButton.simulatePress(Event.createFake());}, function() {cancelButton.simulatePress(Event.createFake());});
    comboBox.horizontalLayoutMode = avocado.LayoutModes.SpaceFill;
    var buttonRow = avocado.table.createSpaceFillingRowMorph([okButton, avocado.ui.createSpacer(), cancelButton]);
    promptBox.layout().setCells([messageLabel, comboBox, buttonRow]);
    var world = WorldMorph.current();
    world.addMorphAt(promptBox, promptBox.positionToCenterIn(world));
    comboBox.selectAll();
  });

  add.creator('prototype', Object.create(Morph.prototype));

});


thisModule.addSlots(avocado.ComboBoxMorph.prototype, function(add) {

  add.data('constructor', avocado.ComboBoxMorph);

  add.method('initialize', function ($super, values, defaultValue, onAccept, onCancel) {
    $super(lively.scene.Rectangle.createWithIrrelevantExtent());
    this.useTableLayout(avocado.table.contents.rowPrototype);
    this._values = values;
    this._defaultValue = defaultValue;
    this._onAccept = onAccept;
    this._onCancel = onCancel;

    this.applyStyle(this.defaultStyle);
    
    this._textMorph = new TextMorph(pt(0,0).extent(pt(120,20)), this._defaultValue);
    this._textMorph.suppressHandles = true;
    this._textMorph.setBorderWidth(0);
    this._textMorph.horizontalLayoutMode = avocado.LayoutModes.SpaceFill;
    this._textMorph.onKeyDown = function(evt) {
      var c = evt.getKeyCode();
      if (c === Event.KEY_RETURN) {
	      this.accept();
	      return true;
      }
      if (c === Event.KEY_ESC) {
	      this.cancel();
	      return true;
      }
      return TextMorph.prototype.onKeyDown.call(this._textMorph, evt);
    }.bind(this);

    var triangle = Morph.makePolygon([pt(-5,0), pt(5,0), pt(0,5)], 1, Color.black, Color.black);
    triangle.suppressHandles = true;
    this._button = ButtonMorph.createButton(triangle, function(evt) {this.toggleMenu();}.bind(this), 5);
    this._button.verticalLayoutMode = avocado.LayoutModes.SpaceFill;
    this._button.linkToStyles('comboBoxButton');

    this._menu = new MenuMorph([]);
    this._menu.shouldNotBePartOfRowOrColumn = true;
    this._menu.listStyle = Object.extend(Object.create(this._menu.listStyle), {fillOpacity: 1, borderColor: Color.black, borderRadius: 0});
    this._menu.textStyle = Object.extend(Object.create(this._menu.textStyle), {textColor: this._textMorph.textColor});
    this._menu.estimateListWidth = function(proto) { return this.getExtent().x; }.bind(this);
    this._menu.startOpeningAnimation = function() {
      this.setScalePoint(pt(1, 0.01));
      this.smoothlyScaleVerticallyTo(1);
    };

    values.each(function(v) {this._menu.addItem(["" + v, function() {this.setValue(v);}.bind(this)]);}.bind(this));

    this.setColumns([this._textMorph, avocado.ui.createSpacer(), this._button]);
  }, {category: ['creating']});

  add.creator('defaultStyle', {}, {category: ['styles']});

  add.method('value', function () {
    return this._textMorph.getText();
  }, {category: ['value']});

  add.method('setValue', function (v) {
    this._textMorph.setText("" + v);
    this.hideMenu();
  }, {category: ['value']});

  add.method('accept', function () {
    if (this._onAccept) { this._onAccept(this.value()); }
  }, {category: ['value']});

  add.method('cancel', function () {
    if (this._onCancel) { this._onCancel(); }
  }, {category: ['value']});

  add.method('toggleMenu', function () {
    if (this._menu.owner) { this.hideMenu(); } else { this.showMenu(); }
  }, {category: ['menu']});

  add.method('showMenu', function () {
    // I'd prefer to open the menu directly inside this morph, and leave it open, so that it would
    // move when you move the combo box around. But I don't know how to make the menu stay on
    // top (in z-order) if I do that. -- Adam
    //this._menu.openIn(this, this._textMorph.bounds().bottomLeft(), true);
    this._menu.openIn(this.world(), this.worldPoint(this._textMorph.bounds().bottomLeft()), false);
  }, {category: ['menu']});

  add.method('hideMenu', function () {
    this._menu.smoothlyScaleVerticallyTo(0.01, function() { this._menu.remove(); }.bind(this));
  }, {category: ['menu']});

  add.method('selectAll', function (evt) {
    this._textMorph.requestKeyboardFocus(evt ? evt.hand : WorldMorph.current().firstHand());
    this._textMorph.doSelectAll();
  }, {category: ['keyboard']});

  add.method('relinquishKeyboardFocus', function (evt) {
    this._textMorph.relinquishKeyboardFocus(evt ? evt.hand : WorldMorph.current().firstHand());
  }, {category: ['keyboard']});

});


thisModule.addSlots(avocado.ComboBoxMorph.prototype.defaultStyle, function(add) {

  add.data('padding', {left: 1, right: 1, top: 1, bottom: 1, between: {x: 0, y: 0}}, {initializeTo: '{left: 1, right: 1, top: 1, bottom: 1, between: {x: 0, y: 0}}'});

  add.data('fill', new Color(1, 1, 1));

  add.data('borderColor', new Color(0, 0, 0));

  add.data('borderWidth', 1);

  add.data('openForDragAndDrop', false);

});


thisModule.addSlots(DisplayThemes.lively, function(add) {

  add.creator('comboBoxButton', Object.create(DisplayThemes.lively.button));

});


thisModule.addSlots(DisplayThemes.lively.comboBoxButton, function(add) {

  add.data('fill', Color.white, {initializeTo: 'Color.white'});

  add.data('borderRadius', 1);

  add.data('borderWidth', 0);

});


});

avocado.transporter.module.onLoadCallbacks["lk_ext/collection_morph"] = function() {};
avocado.transporter.module.create('lk_ext/collection_morph', function(requires) {

requires('general_ui/table_layout');
requires('lk_ext/shortcuts');

}, function(thisModule) {


thisModule.addSlots(Array.prototype, function(add) {

  add.method('newMorph', function (columnsToShow, dropCriteria) {
    return new avocado.CollectionMorph(this, columnsToShow, dropCriteria);
  }, {category: ['user interface']});

});


thisModule.addSlots(avocado, function(add) {

  add.method('CollectionMorph', function CollectionMorph() { Class.initializer.apply(this, arguments); }, {category: ['ui']});

});


thisModule.addSlots(avocado.CollectionMorph, function(add) {

  add.data('displayName', 'CollectionMorph');

  add.data('superclass', Morph);

  add.data('type', 'avocado.CollectionMorph');

  add.creator('prototype', Object.create(Morph.prototype));

});


thisModule.addSlots(avocado.CollectionMorph.prototype, function(add) {

  add.data('constructor', avocado.CollectionMorph);

  add.method('initialize', function ($super, collection, columnsToShow, dropCriteria) {
    $super(lively.scene.Rectangle.createWithIrrelevantExtent());
    this._collection = collection;
    this._columnsToShow = (columnsToShow || [{name: 'Name', valueOf: function(o) { return Object.inspect(o); }}]).map(function(c) {
      if (typeof(c) === 'string') {
        return {
          name: c,
          valueOf: function(o) {
            var f = o[c];
            if (typeof(f) !== 'function') { throw "Unknown function: " + c; }
            return f.call(o);
          }
        };
      } else if (typeof(c.valueOf) === 'string') {
        return Object.extend(Object.shallowCopy(c), {
          valueOf: function(o) {
            var f = o[c.valueOf];
            if (typeof(f) !== 'function') { throw "Unknown function: " + c.valueOf; }
            return f.call(o);
          }
        });
      } else {
        return c;
      }
    });
    this._dropCriteria = dropCriteria;
    
    this.applyStyle(this.defaultStyle);
    
    this._headerRow = this._columnsToShow.map(function(c) { return this.headerMorphFor(c.name); }.bind(this));
    this.refreshContent();
  }, {category: ['creating']});

  add.creator('defaultStyle', {}, {category: ['styles']});

  add.method('headerMorphFor', function (name) {
    var m = ButtonMorph.createButton(name, function(evt) {}, 1);
    return m;
  }, {category: ['content']});

  add.method('cellMorphFor', function (o) {
    var s = "";
    if (o !== null && typeof(o) !== 'undefined') { s = o.toString(); }
    var m = avocado.label.newMorphFor(s);
    return m;
  }, {category: ['content']});

  add.method('rowOfCellMorphsFor', function (o) {
    return this._columnsToShow.map(function(col) {
      var v;
      try {
        v = col.valueOf(o);
      } catch (ex) {
        v = 'Error: ' + ex;
      }
      return this.cellMorphFor(v);
    }.bind(this));
  }, {category: ['content']});

  add.method('potentialContentMorphs', function () {
    return avocado.table.contents.createWithRows([this._headerRow].concat(this._collection.map(function(o) {
      return this.rowOfCellMorphsFor(o);
    }.bind(this))));
  }, {category: ['content']});

  add.method('acceptsDropping', function (m) {
    return m.associatedObjectSatisfying(this._dropCriteria) !== null;
  }, {category: ['drag and drop']});

  add.method('showPotentialDrops', function (potentialDrops, evt) {
    this._potentialDropInsertionIndex = this.determineIndexForPotentialDrops(evt);
    var content = this.potentialContentMorphs();
    for (var j = potentialDrops.length - 1; j >= 0; --j) {
      var o = potentialDrops[j].associatedObjectSatisfying(this._dropCriteria);
      var row = this.rowOfCellMorphsFor(o);
      row.each(function(m) { m.setFill(Color.neutral.gray); m.setFillOpacity(0.3); });
      content.insertPrimaryLine(row, this._potentialDropInsertionIndex + 1);
    }
    this.replaceContentWith(content);
  }, {category: ['drag and drop']});

  add.method('determineIndexForPotentialDrops', function (evt) {
    if (! this.insertionIndexMatters()) { return this._collection.size(); }
    
    var p = this.localize(evt.point());
    var morphs = this.submorphsParticipatingInLayout().toArray();
    var numCols = this._columnsToShow.size();
    for (var i = 1; i * numCols < morphs.length; i += 1) {
      var m = morphs[i * numCols];
      if (m && m.getPosition().y >= p.y) { break; }
    }
    return i - 1;
  }, {category: ['drag and drop']});

  add.method('hidePotentialDrops', function (evt) {
    delete this._potentialDropInsertionIndex;
    this.refreshContent();
  }, {category: ['drag and drop']});

  add.method('justReceivedDrop', function (m, hand) {
    var o = m.associatedObjectSatisfying(this._dropCriteria);
    if (o === null) { return; }
    if (this.insertionIndexMatters() && typeof(this._potentialDropInsertionIndex) === 'number') {
      this._collection.splice(this._potentialDropInsertionIndex, 0, o);
    } else {
      this._collection.add(o);
    }
    this.refreshContent();
    
    this.world().addMorphAt(m, hand.getPosition());
		var previousOwner    = hand.grabInfo[0];
		var previousPosition = hand.grabInfo[1];
		m.ensureIsInWorld(previousOwner.world(), previousPosition, true, false, false, function() {
			previousOwner.addMorph(m);
		});
  }, {category: ['drag and drop']});

  add.method('insertionIndexMatters', function () {
    return this._collection.canInsert || reflect(this._collection).isReflecteeArray();
  }, {category: ['testing']});

  add.data('padding', {top: 2, bottom: 2, left: 4, right: 4, between: {x: 3, y: 3}}, {initializeTo: '{top: 2, bottom: 2, left: 4, right: 4, between: {x: 3, y: 3}}'});

  add.data('fillBase', new Color(1, 0.8, 0.5));

  add.data('borderRadius', 10);

  add.data('openForDragAndDrop', false);

});


});

avocado.transporter.module.onLoadCallbacks["programming_environment/slot_morph"] = function() {};
avocado.transporter.module.create('programming_environment/slot_morph', function(requires) {

requires('reflection/reflection');
requires('general_ui/table_layout');

}, function(thisModule) {


thisModule.addSlots(avocado.slots, function(add) {

  add.creator('userInterface', {}, {category: ['user interface'], comment: 'This object seems like a hack, just using it as a place to store UI-related code for slots.'});

});


thisModule.addSlots(avocado.slots.userInterface, function(add) {

  add.creator('defaultStyle', {}, {category: ['styles']});

  add.creator('nonZoomingStyle', {}, {category: ['styles']});

  add.creator('zoomingStyle', {}, {category: ['styles']});

  add.creator('copyDownStyle', {}, {category: ['styles']});

  add.creator('annotationStyle', {}, {category: ['styles']});

  add.creator('sourceMorphStyle', {}, {category: ['styles']});

  add.creator('signatureRowStyle', {}, {category: ['styles']});

  add.creator('morphMixin_aaa_becauseIDoNotFeelLikeGeneralizingTheseMethodsRightNow', {}, {category: ['constructing morphs']});

  add.method('newMorphFor', function (slot) {
    var slotMorph = avocado.ui.newMorph();
    
    Object.extend(slotMorph, this.morphMixin_aaa_becauseIDoNotFeelLikeGeneralizingTheseMethodsRightNow);
    
    var shouldUseZooming = !!avocado.ui.shouldMirrorsUseZooming;
    slotMorph._shouldUseZooming = shouldUseZooming;
    slotMorph.useTableLayout(avocado.table.contents.columnPrototype);
    slotMorph.setModel(slot);

    slotMorph.applyStyle(avocado.slots.userInterface.defaultStyle);
    slotMorph.applyStyle(shouldUseZooming ? avocado.slots.userInterface.zoomingStyle : avocado.slots.userInterface.nonZoomingStyle);
    slotMorph.updateStyle();

    var optionalCommentButtonMorph;
    if (slot.annotationIfAny) {
      var annotationRow = avocado.slots.userInterface.createRow(function() { return avocado.slots.userInterface.createAnnotationMorphFor(slotMorph); }.memoize());
      if (shouldUseZooming) {
        slotMorph._annotationToggler = avocado.scaleBasedMorphHider.create(slotMorph, annotationRow, slotMorph, 4, pt(50,25)); // aaa made-up space-holder-size number
      } else {
        slotMorph._annotationToggler = avocado.morphToggler.create(slotMorph, annotationRow);

        var commentButton = slotMorph._annotationToggler.commandForToggling('my comment', "'...'").newMorph();
        optionalCommentButtonMorph = avocado.table.createOptionalMorph(commentButton, function() { return slotMorph._annotationToggler.isOn() || (slot.comment && slot.comment()); });
      }
    }
    
    var getOrCreateSourcePane = function() { return avocado.slots.userInterface.createSourceMorphFor(slotMorph); }.memoize();
    
    var descriptionMorph = slot.createDescriptionMorphFor(slotMorph);

    var signatureRowContent, contentsChooserMorph;
    if (shouldUseZooming) {
      /* aaa why does this produce weird shrinking behaviour?   avocado.scaleBasedMorphHider.create(slotMorph, function() { */
      contentsChooserMorph = avocado.table.createEitherOrMorph([
        function() { return avocado.slots.userInterface.createTypeSpecificInputMorphForSlot(slot); }.memoize(),
        function() { return avocado.table.wrapToTakeUpConstantSpace(pt(100, 50), getOrCreateSourcePane()); }.memoize(),
        function() {
          var contentsMorph = avocado.ui.currentWorld().morphFor(slot.contents());
          contentsMorph.setScale(0.65);
          contentsMorph.refreshContentOfMeAndSubmorphsIfNeverRefreshedBefore();
          return contentsMorph;
        },
        function() { return avocado.slots.userInterface.createContentsPointerPaneFor(slotMorph, getOrCreateSourcePane()); }.memoize()
      ], function() {
        return (slot.type() && slot.type().canCreateInputMorph && slot.type().canCreateInputMorph()) ? 0 : (slot.shouldBeShownAsJustSourceCode() ? 1 : (slot.shouldBeShownAsContainingItsContents() ? 2 : 3));
      }).applyStyle({horizontalLayoutMode: avocado.LayoutModes.SpaceFill});
      //}, slotMorph, 1.5, pt(10,10));
      signatureRowContent = [descriptionMorph, avocado.ui.createSpacer(), slotMorph._annotationToggler].compact();
    } else {
      slotMorph._sourceToggler = avocado.morphToggler.create(slotMorph, avocado.slots.userInterface.createRow(getOrCreateSourcePane));
      var buttonChooserMorph = avocado.table.createEitherOrMorph([
        slotMorph._sourceToggler.commandForToggling("code").newMorph(avocado.slots.userInterface.createSourceButtonIcon(), 1, pt(3,3)),
        slotMorph.contentsPointerButton()
      ], function() {
        return slotMorph._model.shouldBeShownAsJustSourceCode() ? 0 : 1;
      });
      signatureRowContent = [descriptionMorph, optionalCommentButtonMorph, avocado.ui.createSpacer(), buttonChooserMorph].compact();
    }

    var signatureRow = avocado.table.createSpaceFillingRowMorph(function () { return signatureRowContent; }, avocado.slots.userInterface.signatureRowStyle.padding);

    if (shouldUseZooming) {
      slotMorph.setPotentialContentMorphs(avocado.table.contents.createWithColumns([[signatureRow, contentsChooserMorph]]));
    } else {
      slotMorph.setPotentialContentMorphs(avocado.table.contents.createWithColumns([[signatureRow, slotMorph._annotationToggler, slotMorph._sourceToggler].compact()]));
    }
    
    slotMorph.refreshContentOfMeAndSubmorphs(); // wasn't needed back when slot morphs were always part of a table morph, but now that we have free-form layout we need it
    return slotMorph;
  }, {category: ['constructing morphs']});

  add.method('createSourceButtonIcon', function () {
    return Morph.makePolygon([pt(0,0), pt(8,0), pt(8,8), pt(0,8), pt(0,0), pt(0,2), pt(8,2), pt(0,2)], 1, Color.black, null).ignoreEvents();
  }, {category: ['constructing morphs']});

  add.method('createContentsPointerPaneFor', function (slotMorph, sourcePane) {
    var m = avocado.table.newRowMorph().beInvisible().applyStyle({horizontalLayoutMode: avocado.LayoutModes.SpaceFill});
    /* aaa delete this after the new placeholder way works
    m.layout().setCells([avocado.table.wrapToTakeUpConstantHeight(10, sourcePane), avocado.ui.createSpacer(), slotMorph.contentsPointerButton()]);
    */
    // aaa - why do I need to wrap it in this row morph? if I don't, the actualMorphToShow placeholder mechanism messes up, but maybe I can fix that.
    m.layout().setCells([avocado.ui.createSpacer(), slotMorph.contentsPointerButton(), avocado.ui.createSpacer()]);
    return m;
  }, {category: ['constructing morphs']});

  add.method('createSourceMorphFor', function (slotMorph) {
    var sm = avocado.frequentlyEditedText.newMorphFor(avocado.accessors.forMethods(slotMorph._model, 'sourceCode'));
    sm.applyStyle(avocado.slots.userInterface.sourceMorphStyle);
    sm.rememberThatSavedTextMightNotBeIdenticalToWhatWasTyped();
    slotMorph.findOrCreateTitleLabel()._nextMorphToReceiveInputFocusForwards = sm;
    if (slotMorph._shouldUseZooming) { sm._maxSpace = pt(200,200); }
    return sm.wrappedInScrollPaneIfNecessaryToFitWithin(pt(400,300));
  }, {category: ['constructing morphs']});

  add.method('createAnnotationMorphFor', function (slotMorph) {
    var m = slotMorph._model.newAnnotationMorph();
    if (slotMorph._shouldUseZooming) { m.setScale(0.2); }
    return m;
  }, {category: ['constructing morphs']});

  add.method('createRow', function (getOrCreateContent) {
    // Blecch, functions everywhere. But creating the row is expensive. Find a cleaner way to cache them.
    // Or even get rid of them, use the contents directly; the problem with that is that we can't make
    // TextMorphs SpaceFill yet.
    var p = avocado.slots.userInterface.defaultStyle.internalPadding;
    var row = null;
    return function() {
      if (row) { return row; }
      var spacer = avocado.ui.createSpacer();
      row = avocado.table.createSpaceFillingRowMorph(function() {return [getOrCreateContent(), spacer];}, p);
      row.wasJustAdded = function(evt) { getOrCreateContent().requestKeyboardFocus(evt.hand); };
      return row;
    };
  }, {category: ['constructing morphs']});

  add.method('createTypeSpecificInputMorphForSlot', function (slot) {
    var t = slot.type();
    return t ? t.createInputMorph(slot) : null;
  }, {category: ['constructing morphs']});

});


thisModule.addSlots(avocado.slots.userInterface.defaultStyle, function(add) {

  add.data('borderColor', new Color(0.6, 0.6, 0.6));

  add.data('borderWidth', 1);

  add.data('padding', 0);

  add.data('openForDragAndDrop', false);

  add.data('internalPadding', {left: 15, right: 2, top: 2, bottom: 2, between: {x: 0, y: 0}}, {initializeTo: '{left: 15, right: 2, top: 2, bottom: 2, between: {x: 0, y: 0}}'});

});


thisModule.addSlots(avocado.slots.userInterface.nonZoomingStyle, function(add) {

  add.data('fill', null);

  add.data('suppressGrabbing', true);

  add.data('grabsShouldFallThrough', true);

});


thisModule.addSlots(avocado.slots.userInterface.zoomingStyle, function(add) {

  add.data('fillBase', new Color(0.8, 0.8, 0.8));

  add.data('suppressGrabbing', false);

  add.data('grabsShouldFallThrough', false);

});


thisModule.addSlots(avocado.slots.userInterface.copyDownStyle, function(add) {

  add.data('fillBase', new Color(0.95, 0.75, 0.75));

});


thisModule.addSlots(avocado.slots.userInterface.annotationStyle, function(add) {

  add.data('horizontalLayoutMode', avocado.LayoutModes.SpaceFill);

  add.data('padding', {left: 0, right: 0, top: 0, bottom: 0, between: {x: 2, y: 2}}, {initializeTo: '{left: 0, right: 0, top: 0, bottom: 0, between: {x: 2, y: 2}}'});

});


thisModule.addSlots(avocado.slots.userInterface.sourceMorphStyle, function(add) {

  add.data('fontFamily', 'monospace');

  add.data('suppressHandles', true);

});


thisModule.addSlots(avocado.slots.userInterface.signatureRowStyle, function(add) {

  add.data('padding', {left: 0, right: 2, top: 0, bottom: 0, between: {x: 0, y: 0}}, {initializeTo: '{left: 0, right: 2, top: 0, bottom: 0, between: {x: 0, y: 0}}'});

});


thisModule.addSlots(avocado.slots.userInterface.morphMixin_aaa_becauseIDoNotFeelLikeGeneralizingTheseMethodsRightNow, function(add) {

  add.method('contentsPointerButton', function () {
    return this._contentsPointerButton || (this._contentsPointerButton = avocado.arrow.createButtonForToggling(this._model));
  }, {category: ['contents']});

  add.data('desiredUIStateAfterBeingAdded', {isSourceOpen: true}, {category: ['events'], initializeTo: '{isSourceOpen: true}'});

  add.method('partsOfUIState', function () {
    return {
      isSourceOpen:     this._sourceToggler,
      isAnnotationOpen: this._annotationToggler,
      isArrowVisible:   this._contentsPointerButton ? this._contentsPointerButton._arrow : null
    };
  }, {category: ['UI state']});

  add.method('updateStyle', function () {
    if (! this._model.isReallyPartOfHolder()) { this.applyStyle(avocado.slots.userInterface.copyDownStyle); }
  }, {category: ['updating']});

  add.method('morphsThatNeedToBeVisibleBeforeICanBeVisible', function () {
    var catMorph = avocado.ui.currentWorld().morphFor(this._model.category());
    return avocado.compositeCollection.create([catMorph.morphsThatNeedToBeVisibleBeforeICanBeVisible(), [catMorph]]);
  }, {category: ['updating']});

  add.method('grabCopyAndRemoveMe', function (evt) {
    this.grabCopy(evt);
    this._model.remove();
    var holder = this._model.holder();
    if (holder) { avocado.ui.justChanged(holder); }
  }, {category: ['drag and drop']});

  add.method('commands', function () {
    var cmdList = avocado.command.list.create(this);
    
    if (this._model.isReallyPartOfHolder()) {
      this.addTitleEditingCommandsTo(cmdList);
      
      var isModifiable = !window.isInCodeOrganizingMode;
      cmdList.addItem(avocado.command.create(isModifiable ? "copy" : "move", function(evt) { this.grabCopy(evt); }).onlyApplicableIf(function() { return this._model.copyTo; }.bind(this)));
      cmdList.addItem(avocado.command.create("move", function(evt) { this.grabCopyAndRemoveMe(evt); }).onlyApplicableIf(function() { return isModifiable && this._model.remove; }.bind(this)));
      if (! this._shouldUseZooming) {
        if (this._sourceToggler) { cmdList.addItem(this._sourceToggler.commandForToggling("contents")); }
        if (this._annotationToggler) { cmdList.addItem(this._annotationToggler.commandForToggling("annotation").onlyApplicableIf(function() {return this._model.annotationIfAny; }.bind(this))); }
      }
    }
    
    cmdList.addAllCommands(this._model.commands().wrapWithPromptersForArguments().wrapForMorph(this));
    
    return cmdList;
  }, {category: ['menu']});

});


thisModule.addSlots(avocado.slots['abstract'], function(add) {

  add.method('newMorph', function () {
    return avocado.slots.userInterface.newMorphFor(this);
  }, {category: ['user interface']});

  add.method('newAnnotationMorph', function () {
    // aaa - It'd be nice if we could just as the annotation for its own morph, but for now we
    // still have to ask the slot for its annotation-related info (because, for one thing, there's
    // that organization object in between).
    var m = avocado.table.newTableMorph().beInvisible().applyStyle(avocado.slots.userInterface.annotationStyle);
    m.replaceContentWith(avocado.table.contents.createWithRows([
      [avocado.label.newMorphFor("Comment:"      ), avocado.frequentlyEditedText.newMorphFor(avocado.accessors.forMethods(this, 'comment'))],
      [avocado.label.newMorphFor("Module:"       ), avocado.frequentlyEditedText.newMorphFor(avocado.accessors.forMethods(this, 'moduleName'))],
      [avocado.label.newMorphFor("Initialize to:"), avocado.frequentlyEditedText.newMorphFor(avocado.accessors.forMethods(this, 'initializationExpression'))]
    ]));
    return m;
  }, {category: ['user interface']});

  add.method('createDescriptionMorphFor', function (slotMorph) {
    // override for kinds of slots that have more to describe (like process contexts)
    return slotMorph.findOrCreateTitleLabel();
  }, {category: ['user interface']});

  add.data('isImmutableForMorphIdentity', true, {category: ['user interface']});

  add.method('arrowTargetType', function () {
    return avocado.types.mirror;
  }, {category: ['user interface']});

  add.method('titleAccessors', function () {
    if (!window.isInCodeOrganizingMode) {
      return avocado.accessors.forMethods(this, 'title');
    } else {
      return null;
    }
  }, {category: ['signature']});

  add.method('title', function () { return this.readableName(); }, {category: ['signature']});

  add.method('setTitle', function (newName, evt) {
    evt = evt || Event.createFake();
    avocado.ui.showMessageIfErrorDuring(function() {
      var newSlot = this.rename(newName);
      var holder = this.holder();
      if (holder) {
        var world = avocado.ui.worldFor(evt);
        var holderMorph = world.existingMorphFor(holder);
        if (holderMorph) {
          holderMorph.refreshContentOfMeAndSubmorphs();

          // it's actually a whole nother slot and slotMorph but we want it to feel like the same one
          var newSlotMorph = avocado.ui.transferUIState(this, newSlot, evt);
          
          newSlotMorph._titleLabelMorph.passOnInputFocus(evt.hand); // aaa shouldn't reference _titleLabelMorph

          avocado.ui.justChangedContent(newSlot.category(), evt);
        }
      }
    }.bind(this), evt);
  }, {category: ['signature']});

  add.method('explicitlySetContents', function (c, evt) {
    this.setContents(c);
    this.justExplicitlySetContents(evt);
    
    // Not sure this is really what I want, but I think I don't like it when the
    // source keeps taking up space after I edit it, at least if it's data rather
    // than a method. (The method I'm likely to be editing again. But editing the
    // source of a data slot is usually just done when initially creating the
    // slot.)
    if (! this.shouldBeShownAsJustSourceCode()) {
      var m = avocado.ui.worldFor(evt).existingMorphFor(this);
      if (m) { m.assumeUIState({isSourceOpen: false}, null, evt); }
    }

    avocado.ui.justChanged(this);
  }, {category: ['user interface']});

  add.method('setSourceCode', function (s) {
    this.explicitlySetContents(this.newContentsForSourceCode(s));
  }, {category: ['accessing']});

  add.method('showInSitu', function (inSituCommand) {
    avocado.ui.showNextTo(inSituCommand, this.holder(), function() {
      avocado.ui.ensureVisible(this);
    }.bind(this));
  }, {category: ['user interface', 'slices']});

  add.method('createMorphsForSearchResults', function () {
    var inSituCommand = avocado.command.create("in situ", function() { this.showInSitu(inSituCommand); }.bind(this));
    return [avocado.label.newMorphFor(this.holder().name()), this.newMorph(), avocado.ui.currentWorld().morphFor(inSituCommand)];
  }, {category: ['user interface', 'slices']});

  add.method('copyForGrabbing', function () {
    return this.copyToNewHolder();
  }, {category: ['user interface']});

  add.data('shouldCopyToNewHolderWhenDroppedOnWorld', true, {category: ['user interface']});

});


thisModule.addSlots(avocado.valueHolder, function(add) {

  add.method('newMorph', function () {
    // Let's try this. A valueHolder is like a slot.
    return avocado.slots.userInterface.newMorphFor(this);
  }, {category: ['user interface']});

  add.method('holder', function () {
    return null;
  }, {category: ['pretending to be a slot']});

  add.method('isReallyPartOfHolder', function () {
    return true;
  }, {category: ['pretending to be a slot']});

  add.method('shouldBeShownAsJustSourceCode', function () {
    return false;
  }, {category: ['pretending to be a slot']});

  add.method('contents', function () {
    return this.getValue();
  }, {category: ['pretending to be a slot']});

  add.method('setContents', function (c) {
    this.setValue(c);
  }, {category: ['pretending to be a slot']});

  add.method('explicitlySetContents', function (c, evt) {
    // aaa - blecch, maybe I should just make valueHolders have a common parent with slots.
    avocado.slots['abstract'].explicitlySetContents.call(this, c, evt);
  }, {category: ['pretending to be a slot']});

  add.method('justExplicitlySetContents', function (evt) {
    // nothing necessary here;
  }, {category: ['pretending to be a slot']});

  add.method('shouldBeShownAsContainingItsContents', function () {
    return false;
  }, {category: ['pretending to be a slot']});

  add.method('sourceCode', function () {
    return '' + this.contents();
  }, {category: ['pretending to be a slot']});

  add.method('setSourceCode', function (s) {
    this.explicitlySetContents(this.newContentsForSourceCode(s));
  }, {category: ['pretending to be a slot']});

  add.method('canSetContentsFromSourceCode', function () {
    var type = this.type();
    return type && typeof(type.objectForString) === 'function';
  }, {category: ['pretending to be a slot']});

  add.method('newContentsForSourceCode', function (s) {
    if (this.canSetContentsFromSourceCode()) {
      return this.type().objectForString(s);
    }
    throw new Error("Don't know how to set the contents of " + this + " from a string.");
  }, {category: ['pretending to be a slot']});

  add.method('createDescriptionMorphFor', function (slotMorph) {
    return slotMorph.findOrCreateTitleLabel();
  }, {category: ['pretending to be a slot']});

  add.method('titleAccessors', function () {
    return avocado.accessors.forMethods(this, 'title');
  }, {category: ['pretending to be a slot']});

  add.method('arrowTargetType', function () {
    return this.type();
  }, {category: ['pretending to be a slot']});

});


});

avocado.transporter.module.onLoadCallbacks["lk_programming_environment/process_morph"] = function() {};
avocado.transporter.module.create('lk_programming_environment/process_morph', function(requires) {

requires('general_ui/table_layout');
requires('reflection/process');
requires('programming_environment/slot_morph');

}, function(thisModule) {


thisModule.addSlots(avocado.process, function(add) {

  add.method('newMorph', function () {
    var m = avocado.table.newColumnMorph().setModel(this).applyStyle(this.defaultMorphStyle);
    m._numberToShow = 0;
    m._hasMore = true;

    var headerRow = avocado.table.createSpaceFillingRowMorph([m.createNameLabel(), avocado.ui.createSpacer(), m.createDismissButton()]);
    
    var world = WorldMorph.current();
    var contentColumn = avocado.table.newColumnMorph().beInvisible();
    contentColumn.setPotentialContentMorphsFunction(function () {
      var rows = [];
      var c = m._model.leafContext();
      for (var i = 0, n = m._numberToShow; c && i < n; ++i) {
        rows.push(world.morphFor(c));
        c = c.callerContext();
      }
      m._hasMore = !!c;
      moreOrLessRow.refreshContentOfMeAndSubmorphs();
      return avocado.table.contents.createWithColumns([rows]);
    });
    
    var moreButton = avocado.command.create('More', function(evt) { m._numberToShow += 10; contentColumn.refreshContent(); }).newMorph();
    var moreOrLessRow = avocado.table.createSpaceFillingRowMorph([
      avocado.ui.createSpacer(),
      avocado.table.createOptionalMorph(moreButton, function() { return m._hasMore; }),
      avocado.ui.createSpacer()
    ]).applyStyle({padding: 3});
    
    m.layout().setCells([headerRow, contentColumn, moreOrLessRow]);
    
    m._numberToShow = 10;
    m.refreshContentOfMeAndSubmorphs();
    return m;
  }, {category: ['user interface']});

  add.creator('defaultMorphStyle', Object.create(avocado.table.boxStyle), {category: ['user interface']});

});


thisModule.addSlots(avocado.process.defaultMorphStyle, function(add) {

  add.data('fillBase', new Color(0.5, 0.9, 0.5));

});


thisModule.addSlots(avocado.process.context, function(add) {

  add.method('newMorph', function () {
    var slot = this.functionMirror().probableCreatorSlot();
    if (! slot) { slot = reflect({ unknownFunction: this.rawFunction() }).slotAt('unknownFunction'); }
    var contextSlot = Object.create(slot);
    contextSlot._processContext = this;
    var slotMorph = avocado.slots.userInterface.newMorphFor(contextSlot);
    slotMorph.applyStyle(this.defaultMorphStyle);
    var m = avocado.table.createSpaceFillingRowMorph([slotMorph]);
    m._model = this;
    return m;
  }, {category: ['user interface']});

  add.method('createDescriptionMorphFor', function (slotMorph) {
    var m = avocado.table.newRowMorph().beInvisible();
    var columns = [slotMorph.findOrCreateTitleLabel()];
    var context = this._processContext;
    var args = context.args();
    var argNames = context.argNames();
    if (args.length > argNames.length) {
      columns.push(context.commandToGrabAllArgs().newMorph());
    } else {
      for (var i = 0, n = args.length; i < n; ++i) {
        columns.push(context.commandToGrabArg(i).newMorph());
      }
    }
    m.layout().setCells(columns);
    return m;
  }, {category: ['user interface']});

  add.creator('defaultMorphStyle', {}, {category: ['user interface']});

});


thisModule.addSlots(avocado.process.context.defaultMorphStyle, function(add) {

  add.data('horizontalLayoutMode', avocado.LayoutModes.SpaceFill);

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/tree_node"] = function() {};
avocado.transporter.module.create('general_ui/tree_node', function(requires) {

requires('core/tree_node');
requires('general_ui/layout');
requires('general_ui/table_layout');
requires('general_ui/auto_scaling_morph');

}, function(thisModule) {


thisModule.addSlots(avocado.treeNode, function(add) {

  add.method('newMorph', function () {
    return this.newMorphFor(this);
  }, {category: ['user interface']});

  add.method('newMorphFor', function (treeNode, style, contentsThreshold, shouldOmitHeaderRow, shouldPutHeaderOnLeftInsteadOfTop) {
    var morph = avocado.ui.newMorph(avocado.ui.shapeFactory.newRectangle());

    if (typeof(treeNode.shouldPutHeaderOnLeftInsteadOfTop) === 'function') { shouldPutHeaderOnLeftInsteadOfTop = treeNode.shouldPutHeaderOnLeftInsteadOfTop(); }
    morph.useTableLayout(shouldPutHeaderOnLeftInsteadOfTop ? avocado.table.contents.rowPrototype : avocado.table.contents.columnPrototype);
    morph._model = treeNode;
    morph._potentialContentCreator = avocado.treeNode;
    morph._contentsThreshold = contentsThreshold;
    morph._shouldOmitHeaderRow = shouldOmitHeaderRow;
    var shouldUseZooming = avocado.ui.isZoomingEnabled && (typeof(treeNode.shouldUseZooming) !== 'function' || treeNode.shouldUseZooming());
    morph._morphFactory = shouldUseZooming ? avocado.treeNode.morphFactories.scalingBased : avocado.treeNode.morphFactories.expanderBased;
    morph.applyStyle(morph._morphFactory.styleForTreeNode(treeNode));
    morph._morphFactory.initializeMorph(morph);
    
    Object.extend(morph, avocado.treeNode.morphMixin_aaa_becauseIDoNotFeelLikeGeneralizingTheseMethodsRightNow);

    morph.refreshContentOfMeAndSubmorphs();
    morph.applyStyle(style || {borderRadius: 10});
    return morph;
  }, {category: ['user interface']});

  add.method('defaultExtent', function () {
    return pt(150, 100);
  }, {category: ['user interface']});

  add.method('createContentsPanelMorphFor', function (model) {
    var contents = model.immediateContents(); // aaa - is this an unnecessary calculation of immediateContents? Is it gonna be slow?
    if (Object.isArray(contents) || Object.inheritsFrom(avocado.compositeCollection, contents) || Object.inheritsFrom(avocado.typedCollection, contents)) { // aaa - hack, I'm just not quite sure yet that I want an array's newMorph to return one of these autoScaling.Morphs or whatever
      var m = avocado.treeNode.createTreeContentsPanelMorph(model)
      m.setModel(contents);
      avocado.ui.currentWorld().rememberMorphFor(contents, m);
      return m;
    } else {
      return avocado.ui.currentWorld().morphFor(contents);
    }
  }, {category: ['user interface', 'contents panel']});

  add.method('createTreeContentsPanelMorph', function (treeNode) {
    // aaa - This whole thing is a bit of a hack, and too function-y. There's an object missing here or something.
    
    var shouldUseZooming = typeof(treeNode.shouldContentsPanelUseZooming) === 'function' ? treeNode.shouldContentsPanelUseZooming() : treeNode.shouldContentsPanelUseZooming;
    if (typeof(shouldUseZooming) === 'undefined') { shouldUseZooming = avocado.ui.isZoomingEnabled; }
    var contentsPanelSize = typeof(treeNode.contentsPanelExtent) === 'function' ? treeNode.contentsPanelExtent() : this.defaultExtent();
    var shouldAutoOrganize = treeNode.shouldContentsPanelAutoOrganize;

    var cp;
    if (shouldUseZooming) {
      cp = avocado.autoScaling.newAutoScalingMorph(avocado.ui.shapeFactory.newRectangle(pt(0,0).extent(contentsPanelSize)), shouldAutoOrganize).applyStyle(avocado.treeNode.zoomingContentsPanelStyle);
      cp.typeName = 'tree node contents panel'; // just for debugging purposes

      // aaa - eventually should only need one of these, probably recalculateContentModels, and it shouldn't have anything to do with TreeNodeMorph
      cp.setPotentialContentMorphsFunction(function() { return this.recalculateAndRememberContentMorphsInOrder(); });

      cp.dragAndDropCommands = function() {
        return this.getOwner().dragAndDropCommandsForTreeContents();
      };
    } else {
      cp = avocado.table.newTableMorph().beInvisible().applyStyle(avocado.treeNode.nonZoomingContentsPanelStyle);
      cp.makeContentMorphsHaveLayoutModes({horizontalLayoutMode: avocado.LayoutModes.SpaceFill});
      cp.setPotentialContentMorphsFunction(function () {
        return avocado.table.contents.createWithColumns([this.recalculateAndRememberContentMorphsInOrder()]);
      });
      // cp.refreshContent(); // aaa - leaving this line in breaks the "don't show if the scale is too small" functionality, but does taking it out break something else?
    }

    cp.recalculateContentModels = function() { return treeNode.immediateContents(); };
    cp.recalculateAndRememberContentMorphsInOrder = function () {
      var world = avocado.ui.currentWorld();
      var models = this.recalculateContentModels();
      var morphs;
      if (models.mapElementsAndType) {
        morphs = models.mapElementsAndType(function(c) { return world.morphFor(c); }, function(t) { return avocado.types.morph.onModelOfType(t); });
      } else {
        morphs = models.map(function(c) { return world.morphFor(c); });
      }
      this._contentMorphs = morphs.toArray().sortBy(function(m) { return m._model && m._model.sortOrder ? m._model.sortOrder() : ''; });
      return this._contentMorphs;
    };

    cp.partsOfUIState = function () {
      return {
        treeNodeContents: {
          collection: this._contentMorphs || [],
          keyOf: function(cm) { return cm._model; },
          getPartWithKey: function(morph, c) { return avocado.ui.currentWorld().morphFor(c); }
        }
      };
    };

    return cp;
  }, {category: ['user interface', 'creating']});

  add.method('thresholdMultiplierFor', function (treeNode) {
    if (treeNode.thresholdMultiplier) { return treeNode.thresholdMultiplier; }
    if (typeof(treeNode.immediateContents) === 'function') {
      var contents = treeNode.immediateContents();
      if (typeof(contents.size) === 'function') {
        return Math.sqrt(contents.size());
      }
    }
    return 1;
  }, {category: ['user interface', 'contents panel']});

  add.method('actualContentsPanelForMorph', function (morph) {
    return morph._contentsPanel || (morph._contentsPanel = avocado.treeNode.createContentsPanelMorphFor(morph._model));
  }, {category: ['user interface', 'contents panel']});

  add.method('potentialContentMorphsForMorph', function (morph) {
    if (! morph._potentialContentMorphs) {
      var rows = [];
      if (! morph._shouldOmitHeaderRow)  { rows.push(avocado.treeNode.headerRowForMorph(morph)); }
      rows.push(morph._morphFactory.createContentsPanelOrHider(morph, function() { return avocado.treeNode.actualContentsPanelForMorph(morph); }));
      morph._potentialContentMorphs = avocado.table.contents.create([rows], morph.layout().tableContent()._direction1);
    }
    return morph._potentialContentMorphs;
  }, {category: ['user interface', 'creating']});

  add.method('headerRowForMorph', function (morph) {
    if (avocado.ui.is3D) { avocado.treeNode.headerRowPadding.bottom = 25; } // aaa HACK, just wanna see what it looks like
    return avocado.table.createSpaceFillingRowMorph(morph._morphFactory.headerRowContentsForMorph(morph), avocado.treeNode.headerRowPadding);
  }, {category: ['user interface', 'creating']});

  add.method('ownerObjectChainStartingFromRoot', function (leaf) {
    var treeNodeChain = [];
    var treeNode = leaf;
    while (true) {
      treeNode = treeNode.ownerObject && treeNode.ownerObject();
      if (! treeNode) { break; }
      treeNodeChain.unshift(treeNode);
    }
    return treeNodeChain;
  }, {category: ['updating']});

  add.creator('nonZoomingStyle', {}, {category: ['user interface', 'styles']});

  add.creator('nonZoomingContentsPanelStyle', {}, {category: ['user interface', 'styles']});

  add.creator('zoomingStyle', {}, {category: ['user interface', 'styles']});

  add.creator('zoomingContentsPanelStyle', {}, {category: ['user interface', 'styles']});

  add.data('headerRowPadding', {top: 0, bottom: 0, left: 0, right: 0, between: {x: 3, y: 3}}, {category: ['user interface', 'styles'], initializeTo: '{top: 0, bottom: 0, left: 0, right: 0, between: {x: 3, y: 3}}'});

  add.creator('morphFactories', {}, {category: ['user interface', 'creating']});

  add.creator('morphMixin_aaa_becauseIDoNotFeelLikeGeneralizingTheseMethodsRightNow', {}, {category: ['user interface', 'creating']});

});


thisModule.addSlots(avocado.treeNode.nonZoomingStyle, function(add) {

  add.data('fillBase', new Color(1, 0.8, 0.5));

  add.data('padding', {top: 0, bottom: 0, left: 2, right: 2, between: {x: 2, y: 2}}, {initializeTo: '{top: 0, bottom: 0, left: 2, right: 2, between: {x: 2, y: 2}}'});

  add.data('openForDragAndDrop', false);

});


thisModule.addSlots(avocado.treeNode.nonZoomingContentsPanelStyle, function(add) {

  add.data('padding', {top: 0, bottom: 0, left: 10, right: 0, between: {x: 0, y: 0}}, {initializeTo: '{top: 0, bottom: 0, left: 10, right: 0, between: {x: 0, y: 0}}'});

  add.data('horizontalLayoutMode', avocado.LayoutModes.SpaceFill);

});


thisModule.addSlots(avocado.treeNode.zoomingStyle, function(add) {

  add.data('fillBase', new Color(0.8, 0.8, 0.8));

  add.data('padding', {top: 3, bottom: 3, left: 3, right: 3, between: {x: 1, y: 1}}, {initializeTo: '{top: 3, bottom: 3, left: 3, right: 3, between: {x: 1, y: 1}}'});

  add.data('horizontalLayoutMode', avocado.LayoutModes.ShrinkWrap);

  add.data('verticalLayoutMode', avocado.LayoutModes.ShrinkWrap);

  add.data('openForDragAndDrop', false);

});


thisModule.addSlots(avocado.treeNode.zoomingContentsPanelStyle, function(add) {

  add.data('padding', 0);

  add.data('fill', new Color(1, 1, 1));

  add.data('fillOpacity', 0.65);

  add.data('borderRadius', 10);

  add.data('horizontalLayoutMode', avocado.LayoutModes.SpaceFill);

  add.data('verticalLayoutMode', avocado.LayoutModes.SpaceFill);

  add.data('shouldIgnoreEvents', true, {comment: 'Otherwise it\'s just too easy to accidentally mess up an object. Also we want menus to work.'});

  add.data('openForDragAndDrop', false);

});


thisModule.addSlots(avocado.treeNode.morphFactories, function(add) {

  add.creator('expanderBased', {});

  add.creator('scalingBased', {});

});


thisModule.addSlots(avocado.treeNode.morphFactories.expanderBased, function(add) {

  add.method('initializeMorph', function (morph) {
    morph._expander = new avocado.ExpanderMorph(morph);
  });

  add.method('styleForTreeNode', function (n) {
    return n.nonZoomingStyle || avocado.treeNode.nonZoomingStyle;
  });

  add.method('createContentsPanelOrHider', function (ownerMorph, getOrCreateActualMorph) {
    return avocado.morphHider.create(ownerMorph, [getOrCreateActualMorph], function() {
      return ownerMorph._expander.isExpanded() ? 0 : null;
    });
  });

  add.method('headerRowContentsForMorph', function (morph) {
    return [morph._expander, morph.createTitleLabel(), avocado.ui.createSpacer()];
  });

  add.method('dragAndDropCommandsForMorph', function (morph) {
    return morph.dragAndDropCommandsForTreeContents();
  });

});


thisModule.addSlots(avocado.treeNode.morphFactories.scalingBased, function(add) {

  add.method('initializeMorph', function (morph) {
  });

  add.method('styleForTreeNode', function (n) {
    return n.zoomingStyle || avocado.treeNode.zoomingStyle;
  });

  add.method('createContentsPanelOrHider', function (ownerMorph, getOrCreateActualMorph) {
    var contentsThreshold = ownerMorph._contentsThreshold || 0.25;
    var thresholdMultiplierForHeader = ownerMorph._shouldOmitHeaderRow ? 0.25 : 0.7;
    
    var treeNode = ownerMorph._model;
    var contentsPanelSize = typeof(treeNode.contentsPanelExtent) === 'function' ? treeNode.contentsPanelExtent() : avocado.treeNode.defaultExtent();
    
    return avocado.scaleBasedMorphHider.create(ownerMorph, getOrCreateActualMorph, ownerMorph, function() {
      return contentsThreshold * thresholdMultiplierForHeader * avocado.treeNode.thresholdMultiplierFor(ownerMorph._model);
    }, contentsPanelSize, avocado.treeNode.zoomingContentsPanelStyle);
  });

  add.method('headerRowContentsForMorph', function (morph) {
    return [morph.createTitleLabel()];
  });

  add.method('dragAndDropCommandsForMorph', function (morph) {
    // Let the content panel be the drop target. Except for making arrows point at me.
    // aaa - Seriously, is this complication really necessary? Why not just let stuff be dropped on the whole tree-node morph? I forget the motivation for this.
    var cmdList = avocado.command.list.create(morph);
    morph.addArrowDroppingCommandTo(cmdList);
    return cmdList;
  });

});


thisModule.addSlots(avocado.treeNode.morphMixin_aaa_becauseIDoNotFeelLikeGeneralizingTheseMethodsRightNow, function(add) {

  add.method('expander', function () { return this._expander; }, {category: ['expanding and collapsing']});

  add.method('ensureVisibleForJustMe', function () {
    if (this._expander) {
      this.assumeUIState({isExpanded: true});
    } else {
      this.refreshContent(); // aaa - is this the right thing do? is it a performance bug?
    }
  }, {category: ['contents panel']});

  add.method('justChangedContent', function () {
    if (this._contentsPanel) { this._contentsPanel.justChangedContent(); }
  }, {category: ['updating']});

  add.method('morphsThatNeedToBeVisibleBeforeICanBeVisible', function () {
    return avocado.treeNode.ownerObjectChainStartingFromRoot(this._model).map(function(n) { return avocado.ui.currentWorld().morphFor(n); });
  }, {category: ['updating']});

  add.method('partsOfUIState', function () {
    var s = this._expander ? { isExpanded: this._expander } : {};
    if (this._contentsPanel) { s.contents = this._contentsPanel; }
    return s;
  }, {category: ['UI state']});

  add.method('dragAndDropCommands', function () {
    return this._morphFactory.dragAndDropCommandsForMorph(this);
  }, {category: ['drag and drop']});

  add.method('dragAndDropCommandsForTreeContents', function () {
    return avocado.morphMixins.Morph.dragAndDropCommands.call(this);
  }, {category: ['drag and drop']});

});


});

avocado.transporter.module.onLoadCallbacks["lk_ext/container_morph"] = function() {};
avocado.transporter.module.create('lk_ext/container_morph', function(requires) {

requires('general_ui/tree_node');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('container', {}, {category: ['user interface']});

});


thisModule.addSlots(avocado.container, function(add) {

  add.creator('modelUsingWhicheverMorphsHappenToBeThere', {});

  add.creator('defaultStyle', {}, {category: ['styles']});

  add.method('newContainerMorph', function () {
    var model = Object.newChildOf(this.modelUsingWhicheverMorphsHappenToBeThere);
    var morph = avocado.treeNode.newMorphFor(model);
    model._morph = morph;
    reflect(morph).slotAt('_model').beCreator();
    return morph;
  });

});


thisModule.addSlots(avocado.container.modelUsingWhicheverMorphsHappenToBeThere, function(add) {

  add.method('initialize', function (morph) {
    this._morph = morph;
    this._containerName = 'a container';
    this._titleAccessors = avocado.accessors.forAttribute(this, '_containerName');
  }, {category: ['creating']});

  add.method('toString', function () { return "morphs of " + this._morph; });

  add.method('immediateContents', function () {
    var models = [];
    if (this._morph._contentsPanel) {
      this._morph._contentsPanel.eachSubmorph(function(m) {
        models.push(typeof(m._model) !== 'undefined' ? m._model : { newMorph: function() { return m; }});
      });
    }
    return models;
  }, {category: ['accessing']});

  add.method('titleAccessors', function () {
    return this._titleAccessors;
  }, {category: ['accessing']});

  add.data('shouldContentsPanelAutoOrganize', true);

});


thisModule.addSlots(avocado.container.defaultStyle, function(add) {

  add.data('fillBase', new Color(1, 0.8, 0.5));

  add.data('openForDragAndDrop', false);

  add.data('borderRadius', 10);

});


});

avocado.transporter.module.onLoadCallbacks["lk_programming_environment/db_morph"] = function() {};
avocado.transporter.module.create('lk_programming_environment/db_morph', function(requires) {

requires('lk_ext/container_morph');
requires('db/abstract');
requires('db/couch');

}, function(thisModule) {


thisModule.addSlots(avocado.db, function(add) {

  add.method('Morph', function Morph() { Class.initializer.apply(this, arguments); }, {category: ['user interface']});

  add.method('newMorph', function () {
    return new this.Morph(this);
  }, {category: ['user interface']});

  add.creator('morphFactory', {}, {category: ['user interface']});

});


thisModule.addSlots(avocado.db.Morph, function(add) {

  add.data('displayName', 'Morph');

  add.data('superclass', Morph);

  add.data('type', 'avocado.db.Morph');

  add.creator('prototype', Object.create(Morph.prototype));

});


thisModule.addSlots(avocado.db.Morph.prototype, function(add) {

  add.data('constructor', avocado.db.Morph);

  add.method('initialize', function ($super, db) {
    $super(new lively.scene.Ellipse(pt(0,0), 40));
    this.setDB(db);
  });

  add.creator('style', {}, {category: ['styles']});

  add.method('db', function () { return this._model; }, {category: ['accessing']});

  add.method('setDB', function (db) {
    this._model = db;
    if (this._labelMorph) { this._labelMorph.remove(); }
		this._labelMorph = avocado.label.newMorphFor(this.labelString()).fitText();
		this.addMorphAt(this._labelMorph, this._labelMorph.getExtent().scaleBy(-0.5));
  }, {category: ['accessing']});

  add.method('labelString', function () { return this.db() ? this.db().labelString() : 'CouchDB'; }, {category: ['accessing']});

  add.method('commands', function ($super) {
    if (this._model) {
      return $super();
    } else {
      var cmdList = avocado.command.list.create(this);
      cmdList.addItem(avocado.command.create('connect to', function(evt, db) {
        this.setDB(db);
      }.bind(this)).setArgumentSpecs([
        avocado.command.argumentSpec.create('db').onlyAcceptsType(avocado.couch.db)
      ]));

      return cmdList;
    }
  }, {category: ['commands']});

});


thisModule.addSlots(avocado.db.Morph.prototype.style, function(add) {

  add.data('fill', new Color(1, 0, 1));

  add.data('borderWidth', 1);

  add.data('borderColor', new Color(0, 0, 0));

  add.data('openForDragAndDrop', false);

});


thisModule.addSlots(avocado.db.morphFactory, function(add) {

  add.method('factoryName', function () { return 'database morphs'; });

  add.method('createFactoryMorph', function () {
    var dbMorph = new avocado.db.Morph(null);
    
    var factory = avocado.table.newTableMorph();
    factory.applyStyle(avocado.morphFactories.defaultStyle);
    factory.replaceContentWith(avocado.table.contents.createWithRow([dbMorph]));
    return factory;
  });

  add.data('enableDBExperiment', true);

  add.method('postFileIn', function () {
    // Not really much point in having a whole factory just for one morph.
    // For now I've added a DB morph to the simple morphs factory.
    if (false && this.enableDBExperiment && avocado.morphFactories) {
      avocado.morphFactories.globalFactories.push(this);
    }
  });

});


thisModule.addSlots(avocado.couch.db.containerTypesOrganizerProto, function(add) {

  add.method('newMorph', function () {
    return avocado.treeNode.newMorphFor(this, {fillBase: new Color(1, 0.8, 0.5), borderRadius: 10});
  }, {category: ['user interface']});

});


thisModule.addSlots(avocado.couch.db.container, function(add) {

  add.method('newMorph', function () {
    var m = avocado.treeNode.newMorphFor(this, this.defaultStyle);

    // aaa - this is a hack, but for now I just want a custom copy; in the
    // long run make this work with the general copying mechanism
    m.copyAttributesFrom = function (copier, other) {
      Morph.prototype.copyAttributesFrom.call(this, copier, other);

      // Make a new container object, don't try to copy all the contents yet.
      this._model = this._model.copyRemoveAll();
    };
  
    m.updateContents = function (callback) {
      this._model.updateContents(function(contents) {
        contents.forEach(function(c) { WorldMorph.current().morphFor(c).refreshContentOfMeAndSubmorphs(); }.bind(this));
        avocado.ui.justChangedContent(this._model, evt);
        if (callback) { callback(contents); }
      }.bind(this));
      return this;
    };
  
    m.storeString = function () {
      // aaa - hack, in the long run the transporter should be smart enough to handle this
      return ["WorldMorph.current().morphFor(", this._model.storeString(), ").setBasicMorphProperties(", this.basicMorphPropertiesStoreString(), ").updateContents()"].join("");
    };

    return m;
  }, {category: ['user interface']});

  add.creator('defaultStyle', {}, {category: ['user interface', 'styles']});

});


thisModule.addSlots(avocado.couch.db.container.defaultStyle, function(add) {

  add.data('fillBase', new Color(0.7, 1, 0.6));

  add.data('openForDragAndDrop', false);

  add.data('borderRadius', 10);

});


});

avocado.transporter.module.onLoadCallbacks["programming_environment/category_morph"] = function() {};
avocado.transporter.module.create('programming_environment/category_morph', function(requires) {

requires('reflection/reflection');
requires('general_ui/tree_node');

}, function(thisModule) {


thisModule.addSlots(avocado.category.ofAParticularMirror, function(add) {

  add.method('newMorph', function () {
    return new avocado.treeNode.newMorphFor(this, undefined, 1, this.isRoot());
  }, {category: ['user interface']});

  add.method('existingMorph', function () {
    return avocado.ui.currentWorld().existingMorphFor(this);
  }, {category: ['user interface']});

  add.creator('nonZoomingStyle', Object.create(avocado.treeNode.nonZoomingStyle), {category: ['user interface', 'styles']});

  add.creator('zoomingStyle', Object.create(avocado.treeNode.zoomingStyle), {category: ['user interface', 'styles']});

  add.data('isImmutableForMorphIdentity', true, {category: ['user interface']});

  add.method('shouldContentsPanelUseZooming', function () { return !!avocado.ui.shouldMirrorsUseZooming; }, {category: ['user interface']});

  add.method('shouldUseZooming', function () { return !!avocado.ui.shouldMirrorsUseZooming; }, {category: ['user interface']});

  add.method('copyForGrabbing', function () {
    return this.copyToNewHolder();
  }, {category: ['user interface']});

  add.data('shouldCopyToNewHolderWhenDroppedOnWorld', true, {category: ['user interface']});

  add.method('titleAccessors', function () {
    return avocado.accessors.forMethods(this, 'lastPart');
  }, {category: ['user interface', 'title']});

  add.method('titleEmphasis', function () {
    return avocado.label.emphasiseses.italic;
  }, {category: ['user interface', 'title']});

  add.method('aaa_unused_createContentsSummaryMorph', function () {
    var summaryLabel = avocado.label.newMorphFor(function() {return this.ownerWithAModel()._model.contentsSummaryString();});
    // summaryLabel.setFontSize(summaryLabel.getFontSize() - 1); // aaa - why does this create a little space at the beginning of the label?
    
    // aaa - I get weird 100000-wide behaviour when I try to use just the label instead of wrapping it with a row. I'd like to know why.
    // summaryLabel.setLayoutModes({horizontalLayoutMode: avocado.LayoutModes.SpaceFill});
    // return summaryLabel;
    
    return avocado.table.createSpaceFillingRowMorph([summaryLabel], {left: 0, right: 0, top: 0, bottom: 2, between: {x: 0, y: 0}}).setScale(this.shouldUseZooming() ? 0.5 : 1.0);
  }, {category: ['user interface', 'creating']});

  add.method('addUICommandsTo', function (cmdList, morph) {
    if (this.mirror().canHaveSlots()) {
      if (!this.isRoot()) {
        var isModifiable = ! window.isInCodeOrganizingMode;

        cmdList.addItem(avocado.command.create(isModifiable ? "copy" : "move", function(evt) { this.grabCopy(evt); }, morph));

        if (isModifiable) {
          cmdList.addItem(avocado.command.create("move", function(evt) {
            this.grabCopy(evt);
            this._model.removeSlots();
            avocado.ui.justChanged(this._model.mirror());
          }, morph));
        }
      }
    }
  }, {category: ['user interface', 'commands']});

});


thisModule.addSlots(avocado.category.ofAParticularMirror.nonZoomingStyle, function(add) {

  add.data('horizontalLayoutMode', avocado.LayoutModes.SpaceFill);

  add.data('openForDragAndDrop', false);

  add.data('suppressGrabbing', false);

  add.data('grabsShouldFallThrough', true);

  add.data('fillBase', null);

});


thisModule.addSlots(avocado.category.ofAParticularMirror.zoomingStyle, function(add) {

  add.data('openForDragAndDrop', false);

  add.data('suppressGrabbing', false);

  add.data('grabsShouldFallThrough', true, {comment: 'Otherwise it\'s just too easy to accidentally mess up an object.'});

  add.data('fillBase', new Color(0.8, 0.8, 0.8));

});


});

avocado.transporter.module.onLoadCallbacks["programming_environment/mirror_morph"] = function() {};
avocado.transporter.module.create('programming_environment/mirror_morph', function(requires) {

requires('reflection/reflection');
requires('programming_environment/category_morph');
requires('programming_environment/slot_morph');

}, function(thisModule) {


thisModule.addSlots(avocado.mirror, function(add) {

  add.creator('morphMixin_aaa_becauseIDoNotFeelLikeGeneralizingTheseMethodsRightNow', {}, {category: ['user interface']});

  add.method('newMorph', function () {
    var mirMorph = avocado.ui.newMorph().setModel(this).useTableLayout(avocado.table.contents.columnPrototype);
    Object.extend(mirMorph, this.morphMixin_aaa_becauseIDoNotFeelLikeGeneralizingTheseMethodsRightNow);

    var shouldUseZooming = mirMorph._shouldUseZooming = !!avocado.ui.shouldMirrorsUseZooming;

    mirMorph.applyStyle(avocado.mirror.defaultStyle);

    mirMorph._nameMorph = mirMorph.createNameLabel();
    mirMorph._nameMorph.setEmphasis(avocado.label.emphasiseses.bold);
    
    var descLabel = avocado.label.newMorphFor('');
    descLabel.setScale(0.9);
    mirMorph._descMorph = avocado.morphHider.create(mirMorph, [descLabel], function() {
      var s = this.shortDescription();
      descLabel.setText(s);
      return s === '' ? null : 0;
    }.bind(this));

    if (this.canHaveAnnotation() || this.hasAccessibleParent()) {
      var getOrCreateAnnotationRow = function() { return avocado.mirror.morphBuilder.annotationRowFor(this); }.bind(mirMorph);
      
      if (shouldUseZooming) {
        mirMorph._annotationToggler = avocado.scaleBasedMorphHider.create(mirMorph, getOrCreateAnnotationRow, mirMorph, 1, pt(50,10)); // aaa made-up space-holder-size number
      } else {
        mirMorph._annotationToggler = avocado.morphToggler.create(mirMorph, getOrCreateAnnotationRow);
        if (this.canHaveAnnotation()) {
          mirMorph._commentToggler  = avocado.morphToggler.create(mirMorph, function() { return avocado.mirror.morphBuilder.commentRowFor(this); }.bind(mirMorph));
        }
      }
    }

    // mirMorph.refreshContent();   // this used to be here, but I took it out as an optimization; still not quite sure that it isn't needed -- Adam, Apr. 2011

    mirMorph.startPeriodicallyUpdating();
    
    return mirMorph;
  }, {category: ['user interface']});

  add.data('isImmutableForMorphIdentity', true, {category: ['user interface']});

  add.creator('defaultStyle', {}, {category: ['styles']});

  add.creator('annotationStyle', {}, {category: ['styles']});

  add.creator('commentStyle', {}, {category: ['styles']});

  add.creator('copyDownParentsStyle', {}, {category: ['styles']});

  add.method('justRenamedCategory', function (oldCat, newCat, isEmpty) {
    // aaa - I don't think this code could ever have really worked right. When we
    // rename a category, it's going to break all the subcategories - they *all*
    // have different names now. What can we do about this?
    var world = avocado.ui.currentWorld();
    var oldCatMorph = world.existingMorphFor(oldCat);
    if (oldCatMorph) {
      world.forgetAboutExistingMorphFor(oldCat, oldCatMorph);
    }
    avocado.ui.justChanged(this, function() {
      if (!isEmpty) {
        var newCatMorph = world.morphFor(newCat);
        if (oldCatMorph) { oldCatMorph.transferUIStateTo(newCatMorph, Event.createFake()); }
      }
    });
  }, {category: ['categories']});

  add.creator('morphBuilder', {}, {category: ['user interface']});

  add.method('copyDownParentsString', function () {
    return reflect(this.copyDownParents()).expressionEvaluatingToMe();
  }, {category: ['annotation']});

  add.method('setCopyDownParentsString', function (str) {
    avocado.ui.showMessageIfErrorDuring(function() {
      this.setCopyDownParents(eval(str));
    }.bind(this));
    avocado.ui.justChanged(this); // to make the copied-down slots appear;
  }, {category: ['annotation']});

});


thisModule.addSlots(avocado.mirror.morphMixin_aaa_becauseIDoNotFeelLikeGeneralizingTheseMethodsRightNow, function(add) {

  add.method('mirror', function () { return this._model; }, {category: ['accessing']});

  add.data('isMirrorMorph', true, {category: ['testing']});

  add.method('refreshContent', function () {
    this.mirror().updateCategoryCacheIfOlderThan(8000);
    return avocado.morphMixins.Morph.refreshContent.call(this);
  }, {category: ['updating']});

  add.method('potentialContentMorphs', function () {
    if (! this._potentialContentMorphs) {
      var potentialRows = [
        avocado.mirror.morphBuilder.createHeaderRowFor(this),
        this._shouldUseZooming ? this._descMorph : null,
        this._annotationToggler,
        this._commentToggler,
        this.rootCategoryMorph(),
        this.evaluatorsPanel()
      ].compact();
      this._potentialContentMorphs = avocado.table.contents.createWithColumns([potentialRows]);
    }
    return this._potentialContentMorphs;
  }, {category: ['updating']});

  add.method('rootCategoryMorph', function () {
    if (! this._rootCategoryMorph) {
      this._rootCategoryMorph = avocado.ui.currentWorld().morphFor(this._model.rootCategory());
    }
    return this._rootCategoryMorph;
  }, {category: ['root category']});

  add.method('storeString', function () {
    // aaa - This is not the right long-term solution for saving mirror morphs.
    //       The transporter should be able to handle them. But for now it's
    //       choking for some reason, so let's do this for now. -- Adam, Mar. 2011
    return [
      "avocado.ui.currentWorld().morphFor(",
      this.mirror().storeString(),
      ").setBasicMorphProperties(",
      this.basicMorphPropertiesStoreString(),
      ")"
      /* aaa - not working because the UI state contains references to the actual reflectee of the mirror,
               which means it needs to respect object identity
      "m.assumeUIState(",
      reflect(this.constructUIStateMemento()).expressionEvaluatingToMe(),
      ");"
      */
    ].join("");
  }, {category: ['transporting']});

  add.method('shouldNotBeTransported', function () {
    // aaa - Actually, for now, let's just not have mirrors get saved at all, because they
    // don't really come back right (what with the object identity problems).
    return true;
  }, {category: ['transporting']});

  add.method('expander', function () {
    if (this._shouldUseZooming) { return null; }
    if (! this._expander) {
      this._expander = this.rootCategoryMorph().expander();
    }
    return this._expander;
  }, {category: ['expanding']});

  add.method('evaluatorsPanel', function () {
    if (! this._evaluatorsPanel) {
      this._evaluatorsPanel = avocado.table.newColumnMorph().beInvisible().applyStyle({horizontalLayoutMode: avocado.LayoutModes.SpaceFill});
    }
    return this._evaluatorsPanel;
  }, {category: ['creating']});

  add.method('openEvaluator', function (evt) {
    evt = evt || Event.createFake();
    
    // Experimenting with using vocabulary morphs for evaluators, instead of putting the evaluators
    // directly inside the mirror.
    var enableNewVocabularyMorphExperiment = false;
    if (enableNewVocabularyMorphExperiment) {
      var m = avocad.ui.worldFor(evt).morphFor(avocado.vocabulary.create(this.mirror()));
      m.openEvaluator(evt);
      if (! this.ownerSatisfying(function(o) { return o === m; })) {
        m.assumeUIState({isExpanded: true}, function() {
          m.grabMeWithoutZoomingAroundFirst(evt);
        }, evt);
      }
      m.getAllMirrors();
      return ;
    }
    
    
    var e = avocado.ui.currentWorld().morphFor(avocado.evaluator.create(this.mirror()));
    this.evaluatorsPanel().layout().addCell(e);
    e.wasJustAdded(evt);
    return e;
  }, {category: ['evaluators']});

  add.method('closeEvaluator', function (evaluatorMorph) {
    this.evaluatorsPanel().layout().removeCell(evaluatorMorph);
  }, {category: ['evaluators']});

  add.method('grabResult', function (resultMirMorph, evt) {
    if (resultMirMorph === this) {
      this.wiggle();
    } else {
      resultMirMorph.grabMe(evt);
    }
  }, {category: ['evaluators']});

  add.method('scriptMe', function (evt) {
    /*
    Meh, vocabulary morphs aren't quite feeling right yet. For now, go back to regular evaluators.
    
    var m = avocado.ui.worldFor(evt).morphFor(avocado.vocabulary.create(this.mirror()));
    m.assumeUIState({isExpanded: true}, null, evt);
    m.grabMeWithoutZoomingAroundFirst(evt);
    m.getAllMirrors();
    return m;
    */
    
    return this.openEvaluator(evt);
  }, {category: ['evaluators']});

  add.method('shouldAllowModification', function () {
    return !window.isInCodeOrganizingMode;
  });

  add.method('commands', function () {
    var cmdList = avocado.command.list.create(this);
    cmdList.addAllCommands(this.rootCategoryMorph().commands());
    cmdList.addLine();
    cmdList.addAllCommands(this.mirror().commands().wrapForMorph(this));
    cmdList.addLine();

    cmdList.addItem(avocado.command.create("script me", this.scriptMe));
    cmdList.addLine();
    
    if (!this._shouldUseZooming && this.mirror().canHaveAnnotation()) {
      cmdList.addLine();

      var annotationCommands = [];
      
      if (this.mirror().comment) {
        annotationCommands.push(this._commentToggler.commandForToggling("comment"));
      }

      annotationCommands.push(this._annotationToggler.commandForToggling("annotation"));
      
      cmdList.addItem(avocado.command.create("annotation", annotationCommands));
    }
    
    return cmdList;
  }, {category: ['menu']});

  add.method('dragAndDropCommands', function () {
    var cmdList = avocado.morphMixins.Morph.dragAndDropCommands.call(this);
    
    var rootCatCmdList = this.rootCategoryMorph().dragAndDropCommands();
    if (rootCatCmdList) { cmdList.addAllCommands(rootCatCmdList); }
    
    return cmdList;
  }, {category: ['drag and drop']});

  add.method('partsOfUIState', function () {
    return {
      isExpanded:       this.expander(),  // the root category already has this, but we want it at the top level so "clean up" can set it
      isCommentOpen:    this._commentToggler,
      isAnnotationOpen: this._annotationToggler,
      rootCategory:     this.rootCategoryMorph()
    };
  }, {category: ['UI state']});

});


thisModule.addSlots(avocado.mirror.defaultStyle, function(add) {

  add.data('borderColor', new Color(0.6, 0.6, 0.6));

  add.data('borderWidth', 1);

  add.data('borderRadius', 10);

  add.data('openForDragAndDrop', false);

  add.data('fillBase', new Color(0.8, 0.8, 0.8));

  add.data('padding', {top: 2, bottom: 2, left: 4, right: 4, between: {x: 2, y: 2}}, {initializeTo: '{top: 2, bottom: 2, left: 4, right: 4, between: {x: 2, y: 2}}'});

  add.data('internalPadding', {left: 15, right: 2, top: 2, bottom: 2, between: {x: 0, y: 0}}, {initializeTo: '{left: 15, right: 2, top: 2, bottom: 2, between: {x: 0, y: 0}}'});

  add.data('headerRowPadding', {top: 0, bottom: 0, left: 0, right: 0, between: {x: 3, y: 3}}, {initializeTo: '{top: 0, bottom: 0, left: 0, right: 0, between: {x: 3, y: 3}}'});

});


thisModule.addSlots(avocado.mirror.annotationStyle, function(add) {

  add.data('horizontalLayoutMode', avocado.LayoutModes.SpaceFill);

});


thisModule.addSlots(avocado.mirror.commentStyle, function(add) {

  add.data('suppressHandles', true);

});


thisModule.addSlots(avocado.mirror.copyDownParentsStyle, function(add) {

  add.data('suppressHandles', true);

});


thisModule.addSlots(avocado.mirror.morphBuilder, function(add) {

  add.method('createHeaderRowFor', function (mirMorph) {
    if (mirMorph._commentToggler) {
      var optionalCommentButtonMorph = avocado.morphHider.create(mirMorph, [function() {
        return mirMorph._commentToggler.commandForToggling('my comment', "'...'").newMorph();
      }.memoize()], function() {
        return (mirMorph._commentToggler.isOn() || (mirMorph.mirror().comment && mirMorph.mirror().comment())) ? 0 : null;
      });
    }
    
    if (! mirMorph._shouldUseZooming) {
      // With zooming, these buttons clutter up the object. Plus the parent button isn't really necessary and doesn't make sense
      // now that the __proto__ slot is always visible (rather than hidden because the object isn't expanded). And the E button
      // is less interesting now that we have the "script me" command, plus it's kinda weird because evaluators belong to vocab
      // morphs instead of mirror morphs.

      if (mirMorph.mirror().hasAccessibleParent()) {
        var parentButton = avocado.command.create("^", function(evt) { mirMorph.mirror().getParent(evt); }).setHelpText('Get my parent').newMorph();
      }

      if (window.avocado && avocado.evaluator) {
        var evaluatorButton = avocado.command.create("E", function(evt) { mirMorph.openEvaluator(evt); }).setHelpText('Show an evaluator box').newMorph();
      }
    }

    var optionalDismissButtonMorph = mirMorph._shouldUseZooming ? null : mirMorph.createDismissButtonThatOnlyAppearsIfTopLevel();
    
    var optionalAKAButtonMorph = avocado.morphHider.create(mirMorph, [function() {
      return avocado.command.create("AKA", function(evt) { mirMorph.mirror().chooseAmongPossibleCreatorSlotChains(function() {}, evt); }).newMorph();
    }.memoize()], function() {
      return mirMorph.mirror().hasMultiplePossibleNames() ? 0 : null;
    });

    var descInHeader = mirMorph._shouldUseZooming ? null : mirMorph._descMorph;
    
    var headerRowContents = [mirMorph._shouldUseZooming ? avocado.ui.createSpacer() : null, mirMorph.expander(), mirMorph._nameMorph, descInHeader, optionalAKAButtonMorph, optionalCommentButtonMorph, avocado.ui.createSpacer(), parentButton, evaluatorButton, optionalDismissButtonMorph].compact();
    var headerRow = avocado.table.createSpaceFillingRowMorph(function() { return headerRowContents; }, avocado.mirror.defaultStyle.headerRowPadding);
    headerRow.refreshContentOfMeAndSubmorphs();
    return headerRow;
  }, {category: ['header row']});

  add.method('commentRowFor', function (mirMorph) {
    var m = mirMorph._commentRow;
    if (m) { return m; }
    m = mirMorph._commentRow = avocado.mirror.morphBuilder.createRow(this.commentMorphFor(mirMorph), mirMorph._shouldUseZooming);
    return m;
  }, {category: ['comment']});

  add.method('commentMorphFor', function (mirMorph) {
    return mirMorph._commentMorph || (mirMorph._commentMorph = avocado.frequentlyEditedText.newMorphFor(avocado.accessors.forMethods(mirMorph.mirror(), 'comment')).applyStyle(avocado.mirror.commentStyle));
  }, {category: ['comment']});

  add.method('createRow', function (m, shouldCenter) {
    var content = shouldCenter ? [avocado.ui.createSpacer(), m, avocado.ui.createSpacer()] : [m, avocado.ui.createSpacer()];
    var r = avocado.table.createSpaceFillingRowMorph(content, avocado.mirror.defaultStyle.internalPadding);
    r.wasJustAdded = function(evt) { m.wasJustAdded(evt); };
    return r;
  }, {category: ['layout']});

  add.method('annotationRowFor', function (mirMorph) {
    var m = mirMorph._annotationRow;
    if (m) { return m; }

    var annoMorph = mirMorph.mirror().canHaveAnnotation() ? avocado.mirror.morphBuilder.annotationMorphFor(mirMorph) : null;
    var parentSlotMorph = mirMorph.mirror().hasAccessibleParent() ? avocado.ui.currentWorld().morphFor(mirMorph.mirror().parentSlot()) : null;
    if (parentSlotMorph) { parentSlotMorph.setScale(mirMorph._shouldUseZooming ? 0.5 : 1.0); }
    var content = mirMorph._shouldUseZooming ? [parentSlotMorph, avocado.ui.createSpacer(), annoMorph].compact() : [parentSlotMorph, annoMorph, avocado.ui.createSpacer()].compact();
    m = mirMorph._annotationRow = avocado.table.createSpaceFillingRowMorph(content, avocado.mirror.defaultStyle.internalPadding);
    m.wasJustAdded = function(evt) { annoMorph.wasJustAdded(evt); };
    
    return m;
  }, {category: ['annotation']});

  add.method('annotationMorphFor', function (mirMorph) {
    var m = mirMorph._annotationMorph;
    if (m) { return m; }
    m = mirMorph._annotationMorph = avocado.table.newColumnMorph().beInvisible().applyStyle(avocado.mirror.annotationStyle);
    if (mirMorph._shouldUseZooming) { m.setScale(0.25); }

    // aaa - shouldn't really be a string; do something nicer, some way of specifying a list
    mirMorph._copyDownParentsLabel = avocado.frequentlyEditedText.newMorphFor(avocado.accessors.forMethods(mirMorph._model, 'copyDownParentsString'));
    mirMorph._copyDownParentsLabel.applyStyle(avocado.mirror.copyDownParentsStyle);
    mirMorph._copyDownParentsLabel.rememberThatSavedTextMightNotBeIdenticalToWhatWasTyped();

    var rows = [];
    if (mirMorph._shouldUseZooming) { rows.push(avocado.table.createSpaceFillingRowMorph([avocado.label.newMorphFor("Comment:"), this.commentMorphFor(mirMorph)])); }
    rows.push(avocado.table.createSpaceFillingRowMorph([avocado.label.newMorphFor("Copy-down parents:"), mirMorph._copyDownParentsLabel]).setScale(mirMorph._shouldUseZooming ? 0.5 : 1.0));
    m.layout().setCells(rows);
    return m;
  }, {category: ['annotation']});

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/message_notifier"] = function() {};
avocado.transporter.module.create('general_ui/message_notifier', function(requires) {

requires('general_ui/basic_morph_mixins');
requires('general_ui/one_morph_per_object');
requires('general_ui/table_layout');

}, function(thisModule) {


thisModule.addSlots(avocado.morphMixins.WorldMorph, function(add) {

  add.method('showMessage', function (msg, color, heading) {
    avocado.messageNotifier.create(msg, color || Color.green, heading).showInWorld(this);
  }, {category: ['showing messages']});

});


thisModule.addSlots(Error, function(add) {

  add.method('create', function (err) {
    if (err instanceof Error) { return err; }
    return new Error(err);
  }, {category: ['creating']});

});


thisModule.addSlots(Error.prototype, function(add) {

  add.method('immediateContents', function () {
    var cs = this._immediateContents;
    if (! cs) {
      cs = this._immediateContents = [];
      if (typeof(this.sourceURL) !== 'undefined') { cs.push(avocado.messageNotifier.create(this.sourceURL, Color.red, "source URL")); }
      if (typeof(this.line     ) !== 'undefined') { cs.push(avocado.messageNotifier.create(this.line     , Color.red, "line"      )); }
    }
    return cs;
  }, {category: ['user interface']});

  add.method('setImmediateContents', function (cs) {
    this._immediateContents = cs;
    return this;
  }, {category: ['user interface']});

  add.creator('defaultMorphStyle', Object.create(avocado.table.boxStyle), {category: ['user interface']});

});


thisModule.addSlots(Error.prototype.defaultMorphStyle, function(add) {

  add.data('fillBase', new Color(1, 0, 0));

});


thisModule.addSlots(avocado, function(add) {

  add.creator('messageNotifier', {}, {category: ['ui']});

});


thisModule.addSlots(avocado.messageNotifier, function(add) {

  add.method('showError', function (err, evt, color) {
    var msg = "Error: " + err;
    if (err.line !== undefined) { msg += "[" + err.sourceURL + ":" + err.line + "]"; }
    console.log(msg);
    var world = avocado.ui.worldFor(evt);
    world.showMessage(err, color || Color.red);
  });

  add.method('showIfErrorDuring', function (f, evt, color) {
    try {
      return f();
    } catch (ex) {
      this.showError(ex, evt);
      return undefined;
    }
  });

  add.method('create', function (msg, color, heading) {
    return Object.newChildOf(this, msg, color, heading);
  }, {category: ['creating']});

  add.method('initialize', function (msg, color, heading) {
    this._message = msg;
    this._color = color;
    this._heading = heading;
  }, {category: ['creating']});

  add.method('showInWorld', function (world) {
    // By default, zoom away after a short while, unless the user touches it.
    var m = world.morphFor(this);
    m.showTemporarilyInCenterOfUsersFieldOfVision(world);
  }, {category: ['showing']});

  add.method('updateStyleOfMorph', function (m) {
    m.setFillBase(this._color || Color.red);
  }, {category: ['user interface']});

  add.method('newMorph', function () {
    var rows = [avocado.label.create(this._message.toString())];
    if (this._heading) { rows.unshift(avocado.label.create(this._heading).setEmphasis(avocado.label.emphasiseses.bold)); }
    var m = avocado.table.contents.createWithColumns([rows]).newMorph().setModel(this);
    this.updateStyleOfMorph(m);
    return m;
  }, {category: ['user interface']});

});


thisModule.addSlots(avocado, function(add) {

  add.creator('label', {}, {category: ['ui']});

});


thisModule.addSlots(avocado.label, function(add) {

  add.method('create', function (str) {
    return Object.newChildOf(this, str);
  }, {category: ['creating']});

  add.method('initialize', function (str) {
    this._stringSpecifier = str;
  }, {category: ['creating']});

  add.method('setEmphasis', function (e) {
    this._emphasis = e;
    return this;
  }, {category: ['accessing']});

  add.method('setDesiredScale', function (s) {
    // aaa - this is a hack, not sure what to do
    this._desiredScale = s;
    return this;
  }, {category: ['accessing']});

  add.method('newMorph', function () {
    var m = avocado.label.newMorphFor(this._stringSpecifier);
    if (this._emphasis) { m.setEmphasis(this._emphasis); }
    return m;
  }, {category: ['user interface']});

  add.method('newMorphFor', function (textOrFunctionOrObject, extent) {
    var initialText = "";
    var calculateNewText = null;
    if (textOrFunctionOrObject) {
      if (typeof textOrFunctionOrObject === 'string') {
        initialText = textOrFunctionOrObject;
      } else if (typeof textOrFunctionOrObject === 'function') {
        calculateNewText = textOrFunctionOrObject;
      } else if (typeof textOrFunctionOrObject === 'object') {
        if (typeof(textOrFunctionOrObject.get) === 'function') {
          initialText = textOrFunctionOrObject.get() || "";
          calculateNewText = textOrFunctionOrObject.get.bind(textOrFunctionOrObject);
        } else {
          initialText = textOrFunctionOrObject.initialText || "";
          calculateNewText = textOrFunctionOrObject.calculateNewText;
        }
      }
    }
    
    var m = this.newMorphWithInitialText(initialText, extent);
    
    if (calculateNewText) {
      m.calculateNewText = calculateNewText;
      m.refreshText = function() { this.setText(this.calculateNewText()); };
    }
    
    if (this._desiredScale) {
      m.setFontSize(this._desiredScale);
    }
    
    return m;
  });

  add.creator('emphasiseses', {}, {category: ['user interface']});

});


thisModule.addSlots(avocado.label.emphasiseses, function(add) {

  add.creator('bold', {});

  add.creator('italic', {});

});


thisModule.addSlots(avocado.label.emphasiseses.bold, function(add) {

  add.data('style', 'bold');

});


thisModule.addSlots(avocado.label.emphasiseses.italic, function(add) {

  add.data('style', 'italic');

});


thisModule.addSlots(avocado, function(add) {

  add.creator('editableText', Object.create(avocado.label), {category: ['ui']});

});


thisModule.addSlots(avocado.editableText, function(add) {

  add.method('setNameOfEditCommand', function (n) {
    this._nameOfEditCommand = n;
    return this;
  }, {category: ['accessing']});

  add.method('newMorph', function () {
    return this.newMorphFor(this._stringSpecifier, this._nameOfEditCommand, this._emphasis);
  }, {category: ['user interface']});

});


thisModule.addSlots(avocado, function(add) {

  add.creator('frequentlyEditedText', Object.create(avocado.editableText), {category: ['ui']});

  add.creator('infrequentlyEditedText', Object.create(avocado.editableText), {category: ['ui']});

});


});

avocado.transporter.module.onLoadCallbacks["lk_ext/message_notifier"] = function() {};
avocado.transporter.module.create('lk_ext/message_notifier', function(requires) {

requires('general_ui/message_notifier');
requires('general_ui/table_layout');

}, function(thisModule) {


thisModule.addSlots(avocado.label, function(add) {

  add.method('newMorphWithInitialText', function (initialText, extent) {
    var tf = new TextMorph(pt(0, 0).extent(extent || pt(0, 0)), initialText);
    tf.acceptInput = false;
    tf.closeDnD();
    tf.beLabel();
    return tf;
  }, {category: ['user interface']});

});


thisModule.addSlots(avocado.frequentlyEditedText, function(add) {

  add.method('newMorphFor', function (stringSpecifier, nameOfEditCommand, emphasis) {
    var m = new avocado.TextMorphRequiringExplicitAcceptance(stringSpecifier);
    if (emphasis) { m.setEmphasis(emphasis); }
    if (nameOfEditCommand) { m.setNameOfEditCommand(nameOfEditCommand); }
    return m;
  }, {category: ['user interface']});

});


thisModule.addSlots(avocado.infrequentlyEditedText, function(add) {

  add.method('newMorphFor', function (stringSpecifier, nameOfEditCommand, emphasis) {
    var m = new avocado.TwoModeTextMorph(stringSpecifier);
    if (emphasis) { m.setEmphasis(emphasis); }
    if (nameOfEditCommand) { m.setNameOfEditCommand(nameOfEditCommand); }
    m.backgroundColorWhenWritable = null;
    return m;
  }, {category: ['user interface']});

});


thisModule.addSlots(Error.prototype, function(add) {

  add.method('newMorph', function () {
    return avocado.treeNode.newMorphFor(this, this.defaultMorphStyle);
  }, {category: ['user interface']});

  add.creator('defaultMorphStyle', Object.create(avocado.table.boxStyle), {category: ['user interface']});

});


thisModule.addSlots(Error.prototype.defaultMorphStyle, function(add) {

  add.data('fillBase', new Color(1, 0, 0));

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/history_morph"] = function() {};
avocado.transporter.module.create('general_ui/history_morph', function(requires) {

requires('core/history');
requires('general_ui/table_layout');

}, function(thisModule) {


thisModule.addSlots(avocado.history, function(add) {

  add.method('newMorph', function () {
    var m = avocado.table.newColumnMorph().setModel(this);
    m.applyStyle(this.defaultMorphStyle);

    var nameLabel = m.createNameLabel();
    
    m.potentialContentMorphs = function() {
      var rows = [nameLabel];
      var latest = m._model.latest();
      if (latest !== null && typeof(latest) !== 'undefined') {
        rows.push(avocado.ui.currentWorld().morphFor(latest));
      } else {
        rows.push(avocado.messageNotifier.create("None", new Color(0.2, 0.5, 0.5)).newMorph());
      }
      return avocado.table.contents.createWithColumns([rows]);
    };
    
    m.refreshContentOfMeAndSubmorphs();
    return m;
  }, {category: ['user interface']});

  add.creator('defaultMorphStyle', Object.create(avocado.table.boxStyle), {category: ['user interface']});

});


thisModule.addSlots(avocado.history.defaultMorphStyle, function(add) {

  add.data('fillBase', new Color(0.2, 0.5, 0.5));

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/general_ui"] = function() {};
avocado.transporter.module.create('general_ui/general_ui', function(requires) {

requires('general_ui/models');
requires('general_ui/tree_node');
requires('general_ui/applications');
requires('general_ui/message_notifier');
requires('general_ui/one_morph_per_object');
requires('general_ui/layout');
requires('general_ui/styles');
requires('general_ui/refreshing_content');
requires('general_ui/table_layout');
requires('general_ui/animation');
requires('general_ui/commands');
requires('general_ui/events');
requires('general_ui/placeholder_morph');
requires('general_ui/input_focus');
requires('general_ui/wheel_menus');
requires('general_ui/grabbing');
requires('general_ui/morph_titles');
requires('general_ui/highlighting');
requires('general_ui/invisibility');
requires('general_ui/morph_structure');
requires('general_ui/scaling');
requires('general_ui/poses');
requires('general_ui/toggler');
requires('general_ui/arrows');
requires('general_ui/history_morph');
requires('general_ui/string_buffer_morph');
requires('general_ui/scripting');
requires('general_ui/active_sentence');
requires('general_ui/similar_objects');

}, function(thisModule) {


thisModule.addSlots(avocado.generalUI, function(add) {

  add.data('shouldEnableMouseFreeMenuExperiment', true);

  add.method('grab', function (obj, evt, callback) {
    var m = this.worldFor(evt).morphFor(obj);
    m.grabMe(evt, callback);
    return m;
  });

  add.method('growFromNothing', function (obj, evt) {
    var m = this.worldFor(evt).morphFor(obj);
    m.grabMe(evt);
    return m;
  });

  add.method('navigateTo', function (obj, callback, evt) {
    var m = this.worldFor(evt).morphFor(obj);
    m.navigateToMe(evt, callback);
    return m;
  });

  add.method('showCentered', function (obj, callback, evt) {
    var w = this.worldFor(evt);
    var m = w.morphFor(obj);
    m.showInCenterOfUsersFieldOfVision(w, function() {
      if (callback) { callback(m); }
    });
  });

  add.method('showCenteredAndNavigateTo', function (obj, callback, evt) {
    this.showCentered(obj, function () {
      this.justChanged(obj, function() {
        this.navigateTo(obj, function() {
          var world = this.worldFor(evt);
          world.firstHand().setKeyboardFocus(null); // aaa this is annoying, make it unnecessary
          if (callback) { setTimeout(callback, 0); }
        }.bind(this));
      }.bind(this));
    }.bind(this));
  });

  add.method('prompt', function (msg, callback, defaultValue, evtOrMorph) {
    return this.worldFor(evtOrMorph).prompt(msg, function(value) {
      if (value === null) { return null; }
      return callback(value);
    }, defaultValue);
  });

  add.method('confirm', function (message, callback, evtOrMorph) {
    return this.worldFor(evtOrMorph).confirm(message, callback);
  });

  add.method('poseManager', function (evt) {
    return this.worldFor(evt).poseManager();
  });

  add.method('showObjects', function (objs, name, evt) {
    var pm = this.poseManager(evt);
    pm.assumePose(pm.listPoseOfMorphsFor(objs, name));
  });

  add.method('showErrorsThatOccurDuring', function (f, evt) {
    var allErrors = [];
    var errorMessage = "";
    f(function(msg, errors) {
      errorMessage += msg + "\n";
      (errors || [msg]).each(function(e) { allErrors.push(e); });
    });
    if (allErrors.length > 0) {
      this.showErrors(errorMessage, allErrors, evt);
    }
    return allErrors;
  });

  add.method('showErrors', function (msg, errors, evt) {
    var objectsToShow = [];
    errors.each(function(err) {
      if (err.objectsToShow) {
        err.objectsToShow.each(function(o) {
          if (! objectsToShow.include(o)) {
            objectsToShow.push(o);
          }
        });
      } else {
        objectsToShow.push(err);
      }
    });
    this.showObjects(objectsToShow, "errors", evt);
    this.showError(msg, evt);
  });

  add.method('showMessage', function (msg, evt) {
    this.worldFor(evt).showMessage(msg);
  });

  add.method('ensureVisible', function (obj, evt) {
    var m = this.worldFor(evt).morphFor(obj);
    if (m.ensureVisible) { m.ensureVisible(); }
  });

  add.method('transferUIState', function (oldObj, newObj, evt) {
    var world = this.worldFor(evt);
    var oldMorph = world.existingMorphFor(oldObj);
    if (oldMorph) {
      var newMorph = world.morphFor(newObj);
      oldMorph.transferUIStateTo(newMorph);
      world.forgetAboutExistingMorphFor(oldObj, oldMorph);
      return newMorph;
    } else {
      return null;
    }
  });

  add.method('justChanged', function (obj, callback, evt) {
    var ui = this;
    setTimeout(function() {
      var m = ui.worldFor(evt).existingMorphFor(obj);
      if (m) { m.refreshContentIfOnScreenOfMeAndSubmorphs(); }
      if (callback) { callback(m); }
    }, 0);
  });

  add.method('justChangedContent', function (obj, evt) {
    // aaa - I don't like that this method and justChanged are different.
    var m = this.worldFor(evt).morphFor(obj);
    m.refreshContentOfMeAndSubmorphs();
    m.justChangedContent();
  });

  add.method('setInputFocus', function (obj, evt) {
    var w = this.worldFor(evt);
    var m = w.existingMorphFor(obj);
    var h = (evt ? evt.hand : null) || w.firstHand();
    if (m) { m.takeInputFocus(h); }
  });

  add.method('showMessageIfErrorDuring', function (f, evt) {
    return avocado.messageNotifier.showIfErrorDuring(f, evt);
  });

  add.method('showMessageIfWarningDuring', function (f, evt) {
    return avocado.messageNotifier.showIfErrorDuring(f, evt, new Color(1.0, 0.55, 0.0));
  });

  add.method('showError', function (err, evt) {
    avocado.messageNotifier.showError(err, evt);
  });

  add.method('showMenu', function (cmdList, target, caption, evt) {
    var world = this.worldFor(evt);
    var targetMorph = world.existingMorphFor(target) || world;
    var menu = cmdList.createMenu(targetMorph);
    menu.openIn(world, (evt || Event.createFake()).point(), false, caption);
  });

  add.method('createSpacer', function () {
    return avocado.table.newRowMorph().beInvisible().beSpaceFilling();
  });

});


});

avocado.transporter.module.onLoadCallbacks["lk_ext/lk_ext"] = function() {};
avocado.transporter.module.create('lk_ext/lk_ext', function(requires) {

requires('core/math');
requires('general_ui/general_ui');
requires('lk_ext/changes');
requires('lk_ext/menus');
requires('lk_ext/commands');
requires('lk_ext/grabbing');
requires('lk_ext/transporting_morphs');
requires('lk_ext/text_morph_variations');
requires('lk_ext/shortcuts');
requires('lk_ext/check_box');
requires('lk_ext/combo_box');
requires('lk_ext/layout');
requires('lk_ext/collection_morph');
requires('lk_ext/container_morph');
requires('lk_ext/animation');
requires('lk_ext/scatter');
requires('lk_ext/expander');
requires('lk_ext/message_notifier');
requires('lk_ext/poses');
requires('lk_ext/morph_factories');
requires('lk_ext/core_sampler');
requires('lk_ext/edit_mode');
requires('lk_ext/world_navigation');
requires('lk_ext/carrying_hand');
requires('lk_ext/types');
requires('lk_ext/morph_chooser');
requires('lk_ext/line_graph');
requires('lk_ext/html');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('livelyKernelUI', Object.create(avocado.generalUI), {category: ['user interface']});

});


thisModule.addSlots(avocado.livelyKernelUI, function(add) {

  add.method('worldFor', function (evtOrMorph) {
    if (evtOrMorph) {
      if (typeof(evtOrMorph.world) === 'function') {
        return evtOrMorph.world();
      } else if (typeof(evtOrMorph.hand) === 'object') {
        return evtOrMorph.hand.world();
      }
    }
    return WorldMorph.current();
  });

  add.method('showNextTo', function (objToBeNextTo, objToShow, callback, evt) {
    // This is maybe a bit too much abstraction. But let's try it for now. Un-abstract
    // it if this function starts needing a million arguments. -- Adam, Oct. 2010
    var w = this.worldFor(evt);
    var morphToBeNextTo = w.morphFor(objToBeNextTo);
    w.morphFor(objToShow).ensureIsInWorld(w, morphToBeNextTo.worldPoint(pt(morphToBeNextTo.getExtent().x + 50, 0)), true, true, true, callback);
  });

  add.method('defaultFillWithColor', function (c) {
    if (!c) { return null; }
    return new lively.paint.LinearGradient([new lively.paint.Stop(0, c),
                                            new lively.paint.Stop(1, c.lighter())],
                                           lively.paint.LinearGradient.SouthNorth);
  });

  add.method('newMorph', function (shape) {
    return new Morph(shape || lively.scene.Rectangle.createWithIrrelevantExtent());
  });

  add.method('currentWorld', function () {
    return WorldMorph.current();
  });

  add.creator('shapeFactory', {});

  add.data('isZoomingEnabled', true);

  add.data('shouldMirrorsUseZooming', true);

  add.data('debugMode', false);

});


thisModule.addSlots(avocado.livelyKernelUI.shapeFactory, function(add) {

  add.method('newRectangle', function (rectangle) {
    return new lively.scene.Rectangle(rectangle || new Rectangle(0, 0, 10, 10));
  });

  add.method('newCircle', function (centre, radius) {
    return new lively.scene.Ellipse(centre, radius);
  });

  add.method('newPieWedge', function (thetaA, thetaC, innerRadius, outerRadius) {
    var thetaB = (thetaA + thetaC) / 2;
    var p0    = Point.polar(innerRadius, thetaA);
    var p1    = Point.polar(innerRadius, thetaC);
    var ctrl1 = Point.polar(innerRadius * 1.05, thetaB);
    var p2    = Point.polar(outerRadius, thetaA);
    var p3    = Point.polar(outerRadius, thetaC);
    var ctrl2 = Point.polar(outerRadius * 1.05, thetaB);
		var g = lively.scene;
		var cmds = [];
		cmds.push(new g.MoveTo(true, p0.x,  p0.y));
		cmds.push(new g.QuadCurveTo(true, p1.x, p1.y, ctrl1.x, ctrl1.y));
		cmds.push(new g.LineTo(true, p3.x,  p3.y));
		cmds.push(new g.QuadCurveTo(true, p2.x, p2.y, ctrl2.x, ctrl2.y));
		cmds.push(new g.LineTo(true, p0.x,  p0.y));
		return new g.Path(cmds);
  }, {category: ['layout']});

  add.method('newPolygon', function (vertices) {
    return new lively.scene.Polygon(vertices);
  });

  add.method('newPolyLine', function (vertices) {
    return new lively.scene.Polyline(vertices);
  });

});


});

avocado.transporter.module.onLoadCallbacks["general_ui/search_results_morph"] = function() {};
avocado.transporter.module.create('general_ui/search_results_morph', function(requires) {

requires('general_ui/table_layout');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('searchResults', {}, {category: ['searching']});

});


thisModule.addSlots(avocado.searchResults, function(add) {

  add.creator('defaultStyle', {}, {category: ['styles']});

  add.creator('headerRowStyle', {}, {category: ['styles']});

  add.creator('resultsPanelStyle', {}, {category: ['styles']});

  add.method('newMorph', function (searcher) {
    var m = avocado.ui.newMorph().setModel(searcher);
    m.useTableLayout(avocado.table.contents.columnPrototype);
    
    m.applyStyle(avocado.searchResults.defaultStyle);

    m._resultsPanel = avocado.table.newTableMorph().beInvisible().applyStyle(avocado.searchResults.resultsPanelStyle);

    m._expander = new avocado.ExpanderMorph(m);
    m._titleLabel = m.createNameLabel();
    var redoButton = avocado.command.create("Redo", function(evt) { this.redo(); }.bind(m)).newMorph();
    var dismissButton = m.createDismissButton();

    m._headerRow = avocado.table.createSpaceFillingRowMorph([m._expander, m._titleLabel, avocado.ui.createSpacer(), redoButton, dismissButton], avocado.searchResults.headerRowStyle.padding);
    
    m.redo = function(callback) {
      this._resultsPanel.replaceContentWith(avocado.table.contents.createWithRows([[]])); // clear it first
      this._resultsPanel.replaceContentWith(avocado.searchResults.tableContainingMorphsForResultsFrom(this._model));
      this.assumeUIState({isExpanded: true}, callback);
      return this;
    };
    
    m.partsOfUIState = function() {
      return {
        isExpanded: this._expander
      };
    };

    m.layout().setPotentialCells([m._headerRow, avocado.table.createOptionalMorph(m._resultsPanel, function() {return this._expander.isExpanded();}.bind(m))]);
    m.refreshContent();
    
    return m;
  }, {category: ['user interface']});

  add.method('tableContainingMorphsForResultsFrom', function (searcher) {
    var results = searcher.goAndReturnSortedResults();
    var resultRows = results.map(function(o) { return o.createMorphsForSearchResults(); });
    return avocado.table.contents.createWithRows(resultRows);
  }, {category: ['user interface']});

});


thisModule.addSlots(avocado.searchResults.defaultStyle, function(add) {

  add.data('openForDragAndDrop', false);

  add.data('padding', 5);

  add.data('borderRadius', 10);

  add.data('fillBase', new Color(0.5, 0.5, 0.9));

});


thisModule.addSlots(avocado.searchResults.headerRowStyle, function(add) {

  add.data('padding', {top: 0, bottom: 0, left: 3, right: 3, between: {x: 3, y: 3}}, {initializeTo: '{top: 0, bottom: 0, left: 3, right: 3, between: {x: 3, y: 3}}'});

});


thisModule.addSlots(avocado.searchResults.resultsPanelStyle, function(add) {

  add.data('padding', {top: 3, bottom: 3, left: 3, right: 3, between: {x: 3, y: 3}}, {initializeTo: '{top: 3, bottom: 3, left: 3, right: 3, between: {x: 3, y: 3}}'});

});


});

avocado.transporter.module.onLoadCallbacks["programming_environment/searching"] = function() {};
avocado.transporter.module.create('programming_environment/searching', function(requires) {

requires('general_ui/search_results_morph');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('searchResultsPresenter', {}, {category: ['searching']});

});


thisModule.addSlots(avocado.searchResultsPresenter, function(add) {

  add.method('create', function (searcher) {
    return Object.newChildOf(this, searcher);
  }, {category: ['creating']});

  add.method('createForSlots', function (slots, description) {
    return this.create({
      inspect: function() { return description; },
      go: function() { return slots; },
      results: function() { return slots; },
      resultsAreSlots: function() { return true; }
    });
  }, {category: ['creating']});

  add.method('initialize', function (searcher) {
    this._searcher = searcher;
  }, {category: ['creating']});

  add.method('inspect', function () {
    return this._searcher.inspect();
  }, {category: ['printing']});

  add.method('go', function () {
    return this._searcher.go();
  }, {category: ['searching']});

  add.method('results', function () {
    return this._searcher.results();
  }, {category: ['accessing']});

  add.method('goAndReturnSortedResults', function () {
    var results = this.go();
    var sortCrit = this.sortingCriteriaForSearchResults();
    return sortCrit ? results.sortBy(sortCrit) : results;
  }, {category: ['accessing']});

  add.method('sortingCriteriaForSearchResults', function () {
    if (this._searcher.resultsAreSlots()) { // aaa hack
      return function(s) { return s.holder().name().toUpperCase(); };
    } else {
      console.log("Trying to sort " + this.inspect() + " but don't know how.");
      return null;
    }
  }, {category: ['sorting']});

  add.method('newMorph', function () {
    var shouldEnableTheTreeNodeSliceExperiment = false;
    if (shouldEnableTheTreeNodeSliceExperiment) {
      var m = avocado.treeNode.newMorphFor(this, avocado.searchResults.defaultStyle);
      m.redo = function() { this.redo(); }.bind(this); // just because the old-style slice morphs expect that method to be there
      return m;
    } else {
      // The new tree-node way isn't good enough yet for me to be willing to completely throw away the old way. -- Adam
      if (this._searcher.resultsAreSlots()) {
        return avocado.searchResults.newMorph(this);
      } else {
        throw new Error("What kind of morph should we make for " + this.inspect() + "?");
      }
    }
  }, {category: ['user interface']});

  add.method('immediateContents', function () {
    if (! this._immediateContents) {
      this._immediateContents = this.goAndReturnSortedResults();
    }
    return this._immediateContents;
  }, {category: ['user interface']});

  add.method('redo', function (evt) {
    this._immediateContents = this.goAndReturnSortedResults();
    avocado.ui.justChanged(this, null, evt);
  }, {category: ['user interface']});

  add.method('commands', function () {
    var cmdList = avocado.command.list.create(this);
    cmdList.addItem(avocado.command.create("redo", function(evt) { this.redo(evt); }));
    return cmdList;
  }, {category: ['user interface']});

});


});

avocado.transporter.module.onLoadCallbacks["programming_environment/programming_environment"] = function() {};
avocado.transporter.module.create('programming_environment/programming_environment', function(requires) {

requires('avocado_lib');
requires('general_ui/general_ui');
requires('programming_environment/mirror_morph');
requires('programming_environment/categorize_libraries');
requires('programming_environment/evaluator_morph');
requires('programming_environment/module_morph');
requires('programming_environment/pretty_printer');
requires('programming_environment/searching');
requires('programming_environment/test_case_morph');
requires('programming_environment/webdav');
requires('db/couch');
requires('demo/person');

}, function(thisModule) {


thisModule.addSlots(avocado, function(add) {

  add.creator('programmingEnvironment', {}, {category: ['loading']});

  add.creator('reflectionMenuContributor', {}, {category: ['menu']});

});


thisModule.addSlots(avocado.programmingEnvironment, function(add) {

  add.method('loadAsTopLevelEnvironment', function () {
    avocado.isReflectionEnabled = true;
    
    avocado.categorizeGlobals();

    // make the window's mirror morph less unwieldy, since people tend to keep lots of stuff there
    reflect(window).categorizeUncategorizedSlotsAlphabetically();
    
    avocado.applicationList.addApplication(this);
  });

  add.method('worldName', function () { return "Avocado"; }, {category: ['printing']});

  add.data('isMorphMenuEnabled', true, {category: ['enabling reflection']});

  add.method('addGlobalCommandsTo', function (cmdList) {
    if (avocado.ui.debugMode) {
      cmdList.addLine();
      avocado.ui.programmingEnvironment.addUISpecificDebugModeGlobalCommandsTo(cmdList);
    }

    this.menuItemContributors.each(function(c) {
      c.addGlobalCommandsTo(cmdList);
    });
  }, {category: ['menu']});

});


thisModule.addSlots(avocado.reflectionMenuContributor, function(add) {

  add.method('addGlobalCommandsTo', function (cmdList) {
    cmdList.addLine();
    
    cmdList.addItem(["create new object", function(evt) {
      avocado.ui.growFromNothing(reflect({}), evt);
    }]);

    cmdList.addItem(["get the window object", function(evt) {
      avocado.ui.grab(reflect(window), evt);
    }]);
  });

});


});

avocado.transporter.module.onLoadCallbacks["lk_programming_environment/programming_environment"] = function() {};
avocado.transporter.module.create('lk_programming_environment/programming_environment', function(requires) {

requires('programming_environment/programming_environment');
requires('lk_ext/lk_ext');
requires('lk_ext/core_sampler');
requires('lk_ext/poses');
requires('lk_ext/tags');
requires('lk_ext/morph_factories');
requires('lk_programming_environment/vocabulary_morph');
requires('lk_programming_environment/process_morph');
requires('lk_programming_environment/db_morph');
requires('lk_programming_environment/project_morph');
requires('projects/projects');

}, function(thisModule) {


thisModule.addSlots(avocado.livelyKernelUI, function(add) {

  add.creator('programmingEnvironment', Object.create(avocado.programmingEnvironment), {category: ['loading']});

});


thisModule.addSlots(avocado.livelyKernelUI.programmingEnvironment, function(add) {

  add.method('loadAsTopLevelEnvironment', function ($super) {
    $super();
    
    avocado.livelyKernelUI.isZoomingEnabled = true;
    avocado.livelyKernelUI.shouldMirrorsUseZooming = false;
    avocado.livelyKernelUI.debugMode = false;
    
    // aaa - figure out a way to do this creator-slot stuff without wrecking performance of the zooming UI
    avocado.shouldBreakCreatorSlotsInOrderToImprovePerformance = false;
    
    avocado.menuItemContributors = this.menuItemContributors;
  });

  add.creator('menuItemContributors', [], {category: ['menu']});

  add.method('addUISpecificDebugModeGlobalCommandsTo', function (cmdList) {

    cmdList.addItem(["get an HTML/Canvas morph", function(evt) {
      var m = new XenoMorph(new Rectangle(0, 0, 400, 600));

      var body = document.createElement("body");
      body.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
      var div = document.createElement("div");
      //div.appendChild(document.createTextNode("The quick brown fox jumps over the lazy dog."));






			var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
			canvas.width  = 475;
			canvas.height = 230;
    	div.appendChild(canvas);
			
			var ctx = canvas.getContext("2d");
			var x=0, y=20;
			var pix = [], dotCount = 50;
			
			//initialize array of dots
			(function init(){
			    for (var i = 0; i < dotCount; ++i) {
			        pix.push({x: canvas.width * Math.random(), y: 20 + Math.random() * canvas.height});
		      }
			}());
			
			//moving dots loop
			(function loop(){
		    if (m.world()) {
			    var mPos = m.worldPoint(pt(0,0));
			    console.log("mPos: " + mPos);
			    ctx.save();
			    ctx.globalCompositeOperation = 'source-in';
			    ctx.fillStyle = "rgba(0,0,0,0.4)";
			    ctx.fillRect(mPos.x, mPos.y, canvas.width, canvas.height);
			    ctx.restore();
			    for (var i = 0; i < dotCount; ++i) {
			        ctx.fillRect(mPos.x + ((pix[i].x += Math.random()) % canvas.width), mPos.y + ((pix[i].y += (Math.random())) % canvas.height), 2, 2);
			    }
		    }
		    setTimeout(loop, 1000 / 60)
			}());






      body.appendChild(div);
      m.foRawNode.appendChild(body);

      m.grabMe(evt);
    }]);

    cmdList.addItem(["get a textarea morph", function(evt) {
      var m = new XenoMorph(new Rectangle(0, 0, 400, 600));

      var ta = document.createElement("textarea");
      m.foRawNode.appendChild(ta);
      m.handlesMouseDown = Functions.True;
      m.handlesMouseUp = Functions.True;
      m.okToBeGrabbedBy = Functions.False;

      m.grabMe(evt);
    }]);

    cmdList.addItem(["get a line graph", function(evt) {
      var g = avocado.lineGraph.create([[1, 3, 2, 4, 3, 5, 2]]);
      avocado.ui.grab(g, evt).startPeriodicallyUpdating();
      setInterval(function() { g.lines().first().addValue(Math.random() * 10); }, 1000);
    }]);

    cmdList.addItem(["get a command object", function(evt) {
      var c = avocado.command.create('doStuff', function(evt) {
        evt.hand.world().showMessage("Doing stuff!");
      }).setArgumentSpecs([
        avocado.command.argumentSpec.create('bool').onlyAcceptsType(avocado.types.bool)
      ]);
      avocado.ui.grab(c.createPartialCommand(), evt);
    }]);

    cmdList.addItem({label: "make morph chooser", go: function(evt) {
      var w = evt.hand.world();
      var mc = new avocado.MorphChooser(avocado.types.morph.onModelOfType(avocado.types.string), function(m) { w.showMessage(m._model); });
      w.scatter(["argle", 1, true, "bargle"].map(function(o) { return w.morphFor(o); }));
      mc.grabMeWithoutZoomingAroundFirst(evt);
    }});

    cmdList.addItem({label: "get person object", go: function(evt) {
      var mir = reflect(avocado.person.example);
      avocado.ui.grab(mir, evt)
    }});

    cmdList.addItem({label: "scatter 1-50", go: function(evt) {
      var morphs = [];
      for (var i = 1; i <= 50; ++i) { morphs.push(evt.hand.world().morphFor(reflect(i))); }
      WorldMorph.current().scatter(morphs);
    }});

    cmdList.addItem({label: "group by remainders mod 5", go: function(evt) {
      var w = evt.hand.world();
      var posersByGroupID = avocado.dictionary.copyRemoveAll();
      w.eachSubmorph(function(m) {
        var poseName = "Other";
        if (m.isMirrorMorph && m.mirror().isReflecteeNumber()) {
          poseName = (m.mirror().primitiveReflectee() % 5).toString() + " mod 5";
        }
        var posers = posersByGroupID.getOrIfAbsentPut(poseName, function() { return []; });
        posers.push(m);
      });
      
      var poses = [];
      posersByGroupID.eachKeyAndValue(function(poseName, posers) {
        poses.push(w.poseManager().cleaningUpPose(posers, poseName.toString()));
      });
      poses.sort();
      
      var compositePose = w.poseManager().cleaningUpPose(poses).beSquarish();
      w.poseManager().assumePose(compositePose);
    }});

    cmdList.addItem({label: "tag mod 2,3,5", go: function(evt) {
      var cloud = avocado.tag.cloud.create("numbers mod 2, 3, 5", [2, 3, 5].map(function(modulus) {
        return avocado.tag.create("numbers divsible by " + modulus, function(model) {
          if (!model.reflectee) { return false; }
          if (!model.isReflecteeNumber()) { return false; }
          return model.reflectee() % modulus === 0;
        });
      }), avocado.range.create(1, 50).map(function(i) { return reflect(i); }));
      cloud.tagAllMorphsInWorld(evt.hand.world());
      // cloud.newMorph().grabMe(evt);
    }});

    cmdList.addItem({label: "walk annotations", go: function(evt) {
      var walker = avocado.objectGraphWalker.visitors.annotationWalker.create().createWalker();
      walker.go();
      evt.hand.world().morphFor(reflect(walker)).grabMe(evt);
    }});

    cmdList.addItem({label: "a collection morph", go: function(evt) {
      [1, 2, 3].newMorph(['toString', 'sqrt'], function(o) { return typeof(o) === 'number'; }).grabMe(evt);
    }});

    // useful for testing TableMorph
    cmdList.addItem({label: "senders of exitValueOf", go: function(evt) {
      avocado.ui.grab(avocado.searchResultsPresenter.create(avocado.senders.finder.create("exitValueOf"), evt)).redo();
    }});

    if (avocado.organization.current === avocado.organizationUsingAnnotations) {
      cmdList.addItem(["use JSQuiche organization", function(evt) {
        avocado.organization.setCurrent(avocado.organizationChain.create(avocado.organization.named(avocado.organization.name()), avocado.organizationUsingAnnotations));
      }]);
    } else {
      cmdList.addItem(["stop using JSQuiche organization", function(evt) {
        avocado.organization.setCurrent(avocado.organizationUsingAnnotations);
      }]);
    }

    var b = window.shouldNotDoAnyPeriodicalMorphUpdating;
    cmdList.addItem([(b ? "enable" : "disable") + " periodical updating", function(evt) {
      window.shouldNotDoAnyPeriodicalMorphUpdating = !b;
    }]);

  }, {category: ['menu']});

  add.method('initializeWorld', function (world) {
    // Just a place where I can keep some code that's useful for debugging whatever I'm working on.


    /* // Trying to fix that stupid moveOriginBy bug, the one where it doesn't work for images.
    var tn = avocado.treeNode.create("Stuff", ["Argle", "Bargle"]);
    var tnm = world.morphFor(tn);
    tnm.setScale(4);
    tnm.useBackgroundImage("images/cork_board.jpg");
    world.addMorphAt(tnm, pt(500, 300));
    tnm.refreshContentOfMeAndSubmorphs();
    tnm.moveOriginBy(pt(60, 30));
    */
    
    /*
    avocado.shouldHideTextSmallerThan = 7;
    //var suiteProto = avocado.testCase.suite.forTestingAvocado();
    var suiteProto = avocado.testCase.suite.createForAppropriatelyPrefixedMethodsOf(avocado.mirror.tests);
    var suite = suiteProto.copy().makeUpSomeRandomResults(0.1);
    var history = suite.makeUpARandomResultHistory(2, 0.05, 0.05);
    var historyMorph = world.morphFor(history).applyStyle({suppressGrabbing: true, fill: null});
    world.addMorphAt(historyMorph, pt(20, 20));
    historyMorph.refreshContentOfMeAndSubmorphs();
  
    setTimeout(function() {
      history.makeUpAnotherRowOfRandomResults(0.05, 0.05, 5000, function() {
        avocado.ui.justChanged(history);
      });
    }, 5000);
    */
    
    /*
    avocado.ui.enableHTMLTextMorphExperiment = true;
    var slot = avocado.valueHolder.containing("Noodle face").setName("Kumquat").setType(avocado.types.longString);
    var slotMorph = world.morphFor(slot); //avocado.slots.userInterface.createTypeSpecificInputMorphForSlot(slot);
    world.addMorphAt(slotMorph, pt(300, 50));
    */
    
    /*
    var p = document.createElement("p");
    p.innerHTML = "The quick brown fox jumps over the lazy friggin' dog.\nYeah!\nAwesome!\nI think it's doing the shrink-wrap layout stuff. Very cool.".replace(/\n/g, "<br/>");
    var html = avocado.html.create(p);
    var htmlMorph = world.morphFor(html);
    htmlMorph.setFill(new Color(0.9, 0.9, 0.9));
    htmlMorph.setExtent(pt(300, 300));
    world.addMorphAt(htmlMorph, pt(100, 100));
    htmlMorph.forceLayoutRejiggering();
    */
    
    // avocado.ui.grab(avocado.searchResultsPresenter.create(avocado.senders.finder.create("exitValueOf"))).redo();
  }, {category: ['world initialization']});
    
});


thisModule.addSlots(avocado.livelyKernelUI.programmingEnvironment.menuItemContributors, function(add) {

  add.data('0', avocado.reflectionMenuContributor);

  add.data('1', avocado.morphFactories);

  add.data('2', avocado.transporter);

  add.data('3', avocado.project);

  add.data('4', avocado.poses);

  add.data('5', avocado.testCase);

});


});

avocado.transporter.doneLoadingAllAvocadoCode();
